<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>A simple demo _Web page layout</title>
    <url>/2018/07/05/A-simple-demo-Web-page-layout/</url>
    <content><![CDATA[<h1 id="javaweb之网站布局demo"><a href="#javaweb之网站布局demo" class="headerlink" title="javaweb之网站布局demo"></a>javaweb之网站布局demo</h1><p>demo课程来源：<a href="https://class.imooc.com/lesson/430#mid=9040">慕课网javaweb课程</a><br>分析：实现了静态网页的展示效果。<br>效果图：<br><img src="/2018/07/05/A-simple-demo-Web-page-layout/1.png" alt="1"><br><img src="/2018/07/05/A-simple-demo-Web-page-layout/2.png" alt="2"><br><img src="/2018/07/05/A-simple-demo-Web-page-layout/3.png" alt="3"><br><img src="/2018/07/05/A-simple-demo-Web-page-layout/4.png" alt="4"><br><img src="/2018/07/05/A-simple-demo-Web-page-layout/add.png" alt="add"></p>
<h2 id="绘制概述："><a href="#绘制概述：" class="headerlink" title="绘制概述："></a>绘制概述：</h2><ol>
<li>将备用图片新建image文件夹，与html和css文件置于同一目录下<br><img src="/2018/07/05/A-simple-demo-Web-page-layout/5.png" alt="5"></li>
<li>将整个网页6个区域，找6个盒子对应<ul>
<li>标题及导航区</li>
<li>横幅栏</li>
<li>about区</li>
<li>picture-word区</li>
<li>gallery区</li>
<li>footer区</li>
</ul>
</li>
<li>按照不同区特点，设计css样式，主要涉及知识点：盒子模型、定位、浮动、遮罩、hover等</li>
</ol>
<h2 id="步骤详解"><a href="#步骤详解" class="headerlink" title="步骤详解"></a>步骤详解</h2><h3 id="一、标题及导航区"><a href="#一、标题及导航区" class="headerlink" title="一、标题及导航区"></a>一、标题及导航区</h3><p><img src="/2018/07/05/A-simple-demo-Web-page-layout/6.png" alt="6"></p>
<ul>
<li>html指向外部css文件</li>
<li>header由logo及nav两部分构成</li>
<li>nav细分出六个小导航</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Career Builder<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logo.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>HOME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>ABOUT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>GALLERY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>FACULTY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>EVENTS<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>CONTACT<span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<ul>
<li>消除浏览器默认边距,设置微软雅黑字体</li>
<li>logo设置左浮动</li>
<li>nav设置右浮动</li>
<li>nav-li设置左浮动，同时调整间距，垂直居中对齐</li>
<li>nav-li设置hover效果，悬浮时nav-li块出现黑色背景效果，鼠标变为“小手”效果</li>
</ul>
<span id="more"></span>



<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css</span>文件--&gt;</span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei UI&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标题及导航*/</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">260px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-li</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-li</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二、横幅栏"><a href="#二、横幅栏" class="headerlink" title="二、横幅栏"></a>二、横幅栏</h3><p><img src="/2018/07/05/A-simple-demo-Web-page-layout/7.png" alt="7"></p>
<ul>
<li>banner盒子，限定banner区尺寸及绝对定位</li>
<li>内部设计三层盒子，从底往上为：<ol>
<li>bannerP，放置图片</li>
<li>toplayer，黑色方形图片，为实现遮罩效果</li>
<li>toplayer-top，banner中央的表格</li>
</ol>
</li>
<li>toplayer-top上，分成3类Msg</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 横幅栏,图片、遮挡、表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bannerP&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/banner3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toplayer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toplayer-top&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;personMsg&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Phone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  Write Your Comment Here&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;Msg3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;summit&quot;</span>&gt;</span>SEND MESSAGE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bannerP与banner区尺寸重合</li>
<li>toplayer与banner区尺寸重合，黑色背景，透光0.5</li>
<li>toplayer-top表格在banner居中对齐</li>
<li>三个Msg实现透明背景，乳白色线条</li>
<li>按钮居中对齐</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css--</span>&gt;</span><br><span class="line"><span class="comment">/*横幅层*/</span></span><br><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.bannerP</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.toplayer</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.toplayer-top</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35%</span>;</span><br><span class="line">    <span class="comment">/*margin-left: -25%;</span></span><br><span class="line"><span class="comment">    margin-top: -25%;*/</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: normal;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg1</span>,<span class="selector-class">.Msg2</span>,<span class="selector-class">.Msg3</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#D3D3D3</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid grey; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg1</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg2</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg3</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三、about区"><a href="#三、about区" class="headerlink" title="三、about区"></a>三、about区</h3><p><img src="/2018/07/05/A-simple-demo-Web-page-layout/8.png" alt="8"></p>
<ul>
<li>about盒子，限制该区范围</li>
<li>分为about-title、title-line、about-desc、about-content四大块</li>
<li>前三块样式简单，但about-content复杂，再细分为content-explore、content-img、content-count三块</li>
<li>content-explore分为explore-title、explore-block两块</li>
<li>content-count分为count1和count2两块</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-title&quot;</span>&gt;</span>ABOUT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-desc&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the printing and typesetting <span class="tag">&lt;<span class="name">br</span>&gt;</span>industry.Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-explore&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;explore-title&quot;</span>&gt;</span>A WORD <span class="tag">&lt;<span class="name">br</span>&gt;</span>ABOUT US<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;explore-block&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block-word&quot;</span>&gt;</span>Praesent dignissim viverra est,sed<span class="tag">&lt;<span class="name">br</span>&gt;</span>bibendum ligula congue non.Sed ac nisl<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    et felis gravida commodo? Suspendisse <span class="tag">&lt;<span class="name">br</span>&gt;</span>eget ullamcorper ipsum.Suspendisse<span class="tag">&lt;<span class="name">br</span>&gt;</span>diam amet.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;block-button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-img&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/bb3.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-count&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count1&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>70000<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Students<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count2&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>600<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Faculty<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>about-title绝对定位，title-line相对于about-title定位，可使title-line代码实现复用</li>
<li>about-content中，content-img是中间块并且绝对定位，两边块相对于中间块定位，左边块的z-index设置为2，设置对应left偏移，实现块与块之间少量面积重叠</li>
<li>左块content-explore调整背景颜色rgba(255, 255, 255, 0.4)，形成毛玻璃效果</li>
<li>content-count的上下两块，可以实现样式复用</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css--</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*about区*/</span></span><br><span class="line"><span class="selector-class">.about</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">   <span class="comment">/* background-color: orange;*/</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">15%</span>;</span><br><span class="line"><span class="comment">/*    top:730px;*/</span></span><br><span class="line">    <span class="attribute">top</span>:<span class="number">90%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title-line</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">border-bottom-style</span>: solid ;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-desc</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">28%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-block</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#D3D3D3</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="comment">/*background-color: #ffffff;</span></span><br><span class="line"><span class="comment">    opacity: 0.5;*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-block</span> <span class="selector-class">.block-word</span>&#123;</span><br><span class="line">    <span class="comment">/*margin:5px;*/</span></span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.block-button</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-img</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">280px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span> <span class="selector-class">.count1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.num</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>  auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>  auto;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span> <span class="selector-class">.count2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、picture-word区"><a href="#四、picture-word区" class="headerlink" title="四、picture-word区"></a>四、picture-word区</h3><p><img src="/2018/07/05/A-simple-demo-Web-page-layout/9.png" alt="9"></p>
<ul>
<li>picture-word盒子，限定该区范围</li>
<li>分为layer1..8，图文间隔排布</li>
<li>文字区细分四部分（layerword_1、layerword_2、layerword_3、layerword_button），各文字区样式代码可以复用</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- picture-word区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picture-word&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b1.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Library<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b2.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Computer Lab<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>                 </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Conference Hall<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>                 </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b3.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer7&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Play Ground<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>               </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b4.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>picture-word限定尺寸定位</li>
<li><strong>关键：</strong>layer1..8各层均采用绝对定位，将全区等分为两层，每层等分4份</li>
<li><strong>关键：</strong>图或文字都采用相对定位，依次填坑，进而实现样式复用</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css--</span>&gt;</span><br><span class="line"><span class="comment">/*图文混排部分*/</span></span><br><span class="line"><span class="selector-class">.picture-word</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">720px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">1120px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer3</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer4</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer5</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer6</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer7</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer8</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer_word</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_2</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_3</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#D3D3D3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_button</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、gallery区"><a href="#五、gallery区" class="headerlink" title="五、gallery区"></a>五、gallery区</h3><p><img src="/2018/07/05/A-simple-demo-Web-page-layout/10.png" alt="10"></p>
<ul>
<li>gallery盒子限定该区尺寸定位</li>
<li>分为gallery-title、title-line、gallery-desc、gallery-picture_1..6几大部分</li>
<li>gallery-picture_1再次细分为img和gallery-word两部分</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- gallery区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-title&quot;</span>&gt;</span>GALLERY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-desc&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the printing and typesetting <span class="tag">&lt;<span class="name">br</span>&gt;</span>industry.Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-01.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>SCIENCE LAB<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-02.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>INDOOR STADIUM<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-03.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>TRANSPORTATION<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-04.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>KIDS ROOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-05.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>MEDITATION CLASSES<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-06.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>KIDS PLAY GROUND<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>gallery-title、title-line、gallery-desc部分与about区域样式雷同，本可以代码复用，本demo中仅复制修改代码，还有修改的空间</li>
<li>gallery-picture_1..6部分的思路与picture-word区的排布雷同，此处也不再赘述</li>
<li>排布不同之处在于，未将gallery宽度等分，各gallery-picture的width仅为32%，但是偏移位置仍然是33.3%及66.7%，由此实现了相邻图片之间的间隙，也是一种解决问题的思路</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css--</span>&gt;</span><br><span class="line"><span class="comment">/*gallery区*/</span></span><br><span class="line"><span class="selector-class">.gallery</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1830px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-desc</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_1</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_2</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">33.3%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_3</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">66.7%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_4</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_5</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">33.3%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_6</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">66.7%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-word</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、footer区"><a href="#六、footer区" class="headerlink" title="六、footer区"></a>六、footer区</h3><p>简单，此处不解释，看代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>© 2016 imooc.com 京ICP备13046642号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--css--</span>&gt;</span><br><span class="line"><span class="comment">/*footer层，效果垂直居中*/</span></span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">2490px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="完整项目源码："><a href="#完整项目源码：" class="headerlink" title="完整项目源码："></a>完整项目源码：</h2><h4 id="index-html文件："><a href="#index-html文件：" class="headerlink" title="index.html文件："></a>index.html文件：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html文件如下--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Career Builder<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标题及导航 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/logo.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>HOME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>ABOUT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>GALLERY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>FACULTY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>EVENTS<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav-li&quot;</span>&gt;</span>CONTACT<span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line">    <span class="comment">&lt;!-- 横幅栏,图片、遮挡、表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bannerP&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/banner3.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toplayer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toplayer-top&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;personMsg&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Phone&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  your Email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;Msg2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;  Write Your Comment Here&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;Msg3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;summit&quot;</span>&gt;</span>SEND MESSAGE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- about区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-title&quot;</span>&gt;</span>ABOUT<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-desc&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the printing and typesetting <span class="tag">&lt;<span class="name">br</span>&gt;</span>industry.Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-content&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-explore&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;explore-title&quot;</span>&gt;</span>A WORD <span class="tag">&lt;<span class="name">br</span>&gt;</span>ABOUT US<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;explore-block&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;block-word&quot;</span>&gt;</span>Praesent dignissim viverra est,sed<span class="tag">&lt;<span class="name">br</span>&gt;</span>bibendum ligula congue non.Sed ac nisl<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">                    et felis gravida commodo? Suspendisse <span class="tag">&lt;<span class="name">br</span>&gt;</span>eget ullamcorper ipsum.Suspendisse<span class="tag">&lt;<span class="name">br</span>&gt;</span>diam amet.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;block-button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-img&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/bb3.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-count&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count1&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>70000<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Students<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;count2&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;num&quot;</span>&gt;</span>600<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span>Faculty<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- picture-word区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;picture-word&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b1.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Library<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>            </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b2.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Computer Lab<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>                 </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Conference Hall<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>                 </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b3.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer7&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_word&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_1&quot;</span>&gt;</span>Play Ground<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_2&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the </span><br><span class="line">                    <span class="tag">&lt;<span class="name">br</span>&gt;</span>printing and typesetting industry.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layerword_3&quot;</span>&gt;</span>Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s,when an unknown printer took <span class="tag">&lt;<span class="name">br</span>&gt;</span> a galley of type and  scrambled it to make a type <span class="tag">&lt;<span class="name">br</span>&gt;</span> specimen book.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;layerword_button&quot;</span>&gt;</span>EXPLORE<span class="tag">&lt;/<span class="name">button</span>&gt;</span>               </span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer8&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;layer_picture&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/b4.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span>            </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- gallery区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-title&quot;</span>&gt;</span>GALLERY<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-line&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-desc&quot;</span>&gt;</span>Lorem Ipsum is simply dummy text of the printing and typesetting <span class="tag">&lt;<span class="name">br</span>&gt;</span>industry.Lorem</span><br><span class="line">        Ipsum has been the industry&#x27;s standard dummy <span class="tag">&lt;<span class="name">br</span>&gt;</span>text ever since the 1500s.<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_1&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-01.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>SCIENCE LAB<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-02.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>INDOOR STADIUM<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>      </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_3&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-03.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>TRANSPORTATION<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_4&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-04.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>KIDS ROOM<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_5&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-05.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>MEDITATION CLASSES<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-picture_6&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/03-06.jpg&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-word&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>KIDS PLAY GROUND<span class="tag">&lt;/<span class="name">div</span>&gt;</span>             </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- footer区 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>© 2016 imooc.com 京ICP备13046642号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>	</span><br></pre></td></tr></table></figure>

<h4 id="index-css文件如下："><a href="#index-css文件如下：" class="headerlink" title="index.css文件如下："></a>index.css文件如下：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;Microsoft YaHei UI&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标题及导航*/</span></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">260px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>:<span class="number">90px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-li</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.header</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-li</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*横幅层*/</span></span><br><span class="line"><span class="selector-class">.banner</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">48px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.bannerP</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.toplayer</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.toplayer-top</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35%</span>;</span><br><span class="line">    <span class="comment">/*margin-left: -25%;</span></span><br><span class="line"><span class="comment">    margin-top: -25%;*/</span></span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span>&#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: normal;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg1</span>,<span class="selector-class">.Msg2</span>,<span class="selector-class">.Msg3</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: transparent;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#D3D3D3</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid grey; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg1</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg2</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span> <span class="selector-class">.personMsg</span> <span class="selector-class">.Msg3</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">30%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*about区*/</span></span><br><span class="line"><span class="selector-class">.about</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70%</span>;</span><br><span class="line">   <span class="comment">/* background-color: orange;*/</span></span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">15%</span>;</span><br><span class="line"><span class="comment">/*    top:730px;*/</span></span><br><span class="line">    <span class="attribute">top</span>:<span class="number">90%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title-line</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1px</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">border-bottom-style</span>: solid ;</span><br><span class="line">    <span class="attribute">border-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-desc</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">13px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">28%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">10%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">2%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-block</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: left;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#D3D3D3</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="comment">/*background-color: #ffffff;</span></span><br><span class="line"><span class="comment">    opacity: 0.5;*/</span></span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.explore-block</span> <span class="selector-class">.block-word</span>&#123;</span><br><span class="line">    <span class="comment">/*margin:5px;*/</span></span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">5px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-explore</span> <span class="selector-class">.block-button</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-img</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">280px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">35%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span> <span class="selector-class">.count1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.num</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>  auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.name</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>  auto;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.about</span> <span class="selector-class">.about-content</span> <span class="selector-class">.content-count</span> <span class="selector-class">.count2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*图文混排部分*/</span></span><br><span class="line"><span class="selector-class">.picture-word</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">720px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">1120px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer1</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer2</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer3</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer4</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer5</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer6</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">25%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer7</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer8</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">25%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">75%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layer_word</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">40px</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_1</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_2</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_3</span>&#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#D3D3D3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.picture-word</span> <span class="selector-class">.layerword_button</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*gallery区*/</span></span><br><span class="line"><span class="selector-class">.gallery</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">1830px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-title</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">25px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: bolder;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-desc</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">color</span>: grey;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_1</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_2</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">33.3%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_3</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">130px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">66.7%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_4</span>&#123;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_5</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">33.3%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-picture_6</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">32%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">370px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">66.7%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.gallery</span> <span class="selector-class">.gallery-word</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span><span class="selector-pseudo">:left</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>:-<span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">35px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#07cbc9</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">55px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">2490px</span>;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本人原创，转载请注明出处，谢谢！</p>
]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(1)</title>
    <url>/2019/03/15/ARTS-1/</url>
    <content><![CDATA[<h1 id="ARTS-第一周分享"><a href="#ARTS-第一周分享" class="headerlink" title="ARTS 第一周分享"></a>ARTS 第一周分享</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.com/problems/majority-element-ii/">LeetCode 229. Majority Element II</a></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Time complexity：O(n).</span></span><br><span class="line"><span class="comment">// Space complexity: O(1).</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; majorityElement(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">	List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">int</span> major1 = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> major2 = nums[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> count1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> count2 = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 因为1/3的要求，所以最多有两个主元素，找出来 major1 和 major2</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == major1) &#123;</span><br><span class="line">			count1++;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(n == major2)</span> </span>&#123;</span><br><span class="line">			count2++;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(count1 == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">			major1 = n;</span><br><span class="line">			count1++;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(count2 == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">			major2 = n;</span><br><span class="line">			count2++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count1--;</span><br><span class="line">			count2--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	count1 = <span class="number">0</span>;</span><br><span class="line">	count2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n == major1) &#123;</span><br><span class="line">			count1++;</span><br><span class="line">		&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(n == major2)</span> </span>&#123;</span><br><span class="line">			count2++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count1 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">		list.add(major1);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (count2 &gt; nums.length / <span class="number">3</span>) &#123;</span><br><span class="line">		list.add(major2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://leetcode.com/problems/keys-and-rooms/">LeetCode 841. Keys and Rooms</a></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻接表版的图的 DFS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] vis;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span>;</span><br><span class="line"><span class="comment">// 是否能访问全部房间，返回true / false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> n = rooms.<span class="keyword">size</span>();</span><br><span class="line">	vis = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	DFS(rooms, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">count</span> + <span class="number">1</span> == n) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> DFS(List&lt;List&lt;Integer&gt;&gt; rooms, <span class="keyword">int</span> u) &#123;</span><br><span class="line">	List&lt;Integer&gt; room = rooms.get(u);</span><br><span class="line">	vis[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (Integer v : room) &#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[v] == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">count</span>++;</span><br><span class="line">			DFS(rooms, v);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读的英文文章是：<a href="https://medium.com/@KishoreKarunakaran/understanding-cpu-cache-friendliness-a970f142e889">Understanding CPU cache friendliness</a><br>文章主题：CPU 缓存的知识<br>主要内容：</p>
<ol>
<li>对于一个空序列，有一组乱序的数字要插入这个序列中，逐个插入时都要保证有序。满足上面情况的序列其实有两种实现：数组及链表。</li>
<li>起初两种实现的耗时表现基本一致，但随着元素数量的增加，数组实现明显比链表实现完成地更快（即便插入删除数据会造成数组元素的大量移动，数组仍然更快），这种差异其实是由 CPU 缓存造成的。</li>
<li>根据摩尔定律，我们知道处理器中晶体管的数量每 18 个月会翻一倍，但是最近的单核CPU表现却是十分平缓，为了增加处理速度只好增加更多的核。然而，RAM 的发展速度要远远地慢于CPU。</li>
<li>从缓存中取一个line可能需要 100ns，但是这100ns里，CPU甚至可以执行1200条指令。</li>
<li>回到上文数组和链表的问题。首先，数组存储一个整数需要4个字节，而链表需要16个字节，链表要访问更多的内存区域才能完成；其次，链表的物理存储位置分散，访问时相对“随机”，会导致 CPU 缓存失效（个人理解：CPU 会缓存物理区域相近的数据，随机访问时不容易命中缓存）。最后，硬件也更倾向于访问物理结构在一起的内存，例如数组结构。</li>
<li>结论：<ol>
<li>非必要时，不要存储数据；</li>
<li>尽量有规律地访问数据；</li>
<li>考虑算法复杂度时，也要考虑稳定性，众所周知，快排、归并、堆排的时间复杂度都是O(NlongN)，快排虽快，但它的稳定性最差。</li>
</ol>
</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p> 本周介绍两个效率工具，都是 chrome 浏览器的插件—— Stylus 和 Octotree。</p>
<ol>
<li>先说第一个：Stylus 插件，是一种网页外观样式管理器。像 CSDN 这类热点网站的布局实在难看即可，旁边的广告、琐碎信息太多容易分散精力，使用此插件之后，可以选自己舒服的样式，比如把正文框加宽等， 效果如下：</li>
</ol>
<p> <img src="/2019/03/15/ARTS-1/1.png"></p>
<ol start="2">
<li>然后说第二个：Octotree 插件，是专门用在 GitHub 网站上的，可以在浏览器一侧显示目录结构，爽到起飞，效果如下：</li>
</ol>
<p> <img src="/2019/03/15/ARTS-1/2.png"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周主要在准备 Java 实习生面试，Share 环节打算系统地整理一下有关 ConcurrentHashMap（JDK 1.8） 的面试知识点。<br>分为以下几个小节：</p>
<ol start="0">
<li>前置知识</li>
<li>什么是 ConcurrentHashMap？</li>
<li>它的线程安全的体现。</li>
</ol>
<h3 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h3><h4 id="1-首先我们需要知道-HashMap-这个基础类的存在。基础功能就不说了，直接看扩容操作："><a href="#1-首先我们需要知道-HashMap-这个基础类的存在。基础功能就不说了，直接看扩容操作：" class="headerlink" title="1. 首先我们需要知道 HashMap 这个基础类的存在。基础功能就不说了，直接看扩容操作："></a>1. 首先我们需要知道 HashMap 这个基础类的存在。基础功能就不说了，直接看扩容操作：</h4><ul>
<li><p>HashMap 的扩容：</p>
</li>
<li><p>先涉及两个参数：newCap 和 newThreshold，newCap 通常是原来的2倍，阈值（Threshold）也变为原来的2倍。</p>
</li>
<li><p>扩容后要将键值对Hash的重新计算，然后移动到合适的位置上去，如下：</p>
<ol>
<li>在链表中，如果<code>e.hash &amp; oldCap == 0</code>，则保持在原本的位置上，并且相同计算结果的结点按原来的相对位置接在后面。</li>
<li>如果<code>e.hash &amp; oldCap == 1</code>，则这些结点都要放在原位置j + oldCap 的位置上，这些结点相对位置不变。</li>
<li>在红黑树中，如果需要扩容操作，红黑树也需要拆分后重新映射。研究拆分之前，建议先阅读下边的扩展内容——红黑树的树化步骤。现在说一下拆分过程：因为红黑树中保留了原链表结点的 next 指针，所以分组方式跟原链表完全相同，将分成两种不同的链表。</li>
<li>红黑树拆分后变成两个链表，长度自然会变短，如果长度小于等于 6 ，那么此半个红黑树将保持链表状态；如果长度超过 6 ，那么将继续树化，成为一颗红黑树。</li>
</ol>
<p>  扩展：红黑树的树化步骤，如下：</p>
</li>
</ul>
<ol>
<li>将链表普通结点改造成 TreeNode 树形节点链表；</li>
<li>将得到的链表转化成红黑树。<ol>
<li>形成红黑树时需要比较结点间的大小：① 首先比较 hash 的大小；② 如果相等，则检查键类是否实现了 Comparable 接口，若是则调用 compareTo 方法进行比较；③ 若仍无法比较大小，则调用<code>tieBreakOrder()</code>方法进行仲裁，仲裁后就有大小的区别了。</li>
<li>链表转红黑树后，原链表的连接顺序依旧被保留了下来（next 指针来实现）。</li>
</ol>
</li>
</ol>
<h4 id="2-然后需要知道Unsafe-类"><a href="#2-然后需要知道Unsafe-类" class="headerlink" title="2. 然后需要知道Unsafe 类"></a>2. 然后需要知道Unsafe 类</h4><p>Unsafe 类能够对内存进行操作，详细功能如下：</p>
<ol>
<li><strong>内存的操作</strong>。以下主要讲解<strong>直接内存</strong>：通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收。</li>
<li><strong>CAS 操作</strong>。代码可参考上一题——Atomic 源码细节。其中调用的 <code>compareAndSwap*</code>才是真正的原子操作，<code>CAS#getAndAddInt()</code>是在原子操作的基础上增加了自旋的逻辑。</li>
<li><strong>线程调度</strong>。<blockquote>
<p>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p>
</blockquote>
</li>
<li><strong>内存屏障</strong>。其实是 CPU 或者 IDE 对内存随机访问的一个安全点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。体现在 Unsafe类中的<code>*Fence()</code>系列方法</li>
<li>Class 操作。不展开，直接看<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">原博客</a>。</li>
<li>对象操作。主要应用场景是：非常规的对象实例化方式（比如绕过类构造器，绕过安全检查等）。</li>
<li>数组相关。主要跟 AtomicIntegerArray中的数组操作中的元素定位有关。</li>
<li>系统相关。系统指针大小（32位指针大小是4B，64位是8B）；内存页大小（作者主机上内存页大小是4096B）。</li>
</ol>
<p>在 ConcurrentHashMap 中主要涉及三个操作：</p>
<ul>
<li><code>tabAt()</code> 用来返回节点数组的指定位置的节点的原子操作。</li>
<li><code>casTabAt()</code> cas原子操作，在指定位置设定值</li>
<li><code>setTabAt()</code> 原子操作，在指定位置设定值</li>
</ul>
<h3 id="2-什么是-ConcurrentHashMap？"><a href="#2-什么是-ConcurrentHashMap？" class="headerlink" title="2. 什么是 ConcurrentHashMap？"></a>2. 什么是 ConcurrentHashMap？</h3><p>ConcurrentHashMap 基础功能的实现原理跟 HashMap 相近，但 ConcurrentHashMap 是 HashMap 的线程安全的实现，内部使用了大量的 CAS、volatile、Synchronized 等并发技术，在 Spring 框架中被广泛应用。</p>
<h3 id="3-线程安全的操作"><a href="#3-线程安全的操作" class="headerlink" title="3. 线程安全的操作"></a>3. 线程安全的操作</h3><h4 id="3-0-关于sizeCtl-变量"><a href="#3-0-关于sizeCtl-变量" class="headerlink" title="3.0 关于sizeCtl 变量"></a>3.0 关于sizeCtl 变量</h4><p>sizeCtl 数值：</p>
<ul>
<li>-1 :代表table正在初始化,其他线程应该交出CPU时间片</li>
<li>-N: 表示正有N-1个线程执行扩容操作（高 16 位是 length 生成的标识符，低 16 位是扩容的线程数，最大 65535）</li>
<li>大于 0: 如果table已经初始化,代表table容量,默认为table大小的0.75,如果还未初始化,代表需要初始化的大小</li>
</ul>
<h4 id="3-1-初始化操作："><a href="#3-1-初始化操作：" class="headerlink" title="3.1. 初始化操作："></a>3.1. 初始化操作：</h4><p>首先有一个执行“初始化操作”的线程，然后观察 sizectl 参数，如果小于 0 ，此线程自旋等待；如果大于等于 0 ，则利用 CAS 操作将其设为 -1，此 CAS 操作保证以下操作的线程安全：① 为数组开辟内存，② 将 sizeCtl 设为数组长度的 3&#x2F;4（即sc &#x3D; n - (n &gt;&gt;&gt; 2)）。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化完整源码：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">private final Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] <span class="keyword">tab</span>; int <span class="keyword">sc</span>;</span><br><span class="line">    <span class="keyword">while</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">sc</span> = sizeCtl) &lt; 0)</span><br><span class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">U</span>.compareAndSwapInt(this, SIZECTL, <span class="keyword">sc</span>, -1)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">tab</span> = <span class="keyword">table</span>) == null || <span class="keyword">tab</span>.length == 0) &#123;</span><br><span class="line">                    int <span class="keyword">n</span> = (<span class="keyword">sc</span> &gt; 0) ? <span class="keyword">sc</span> : DEFAULT_CAPACITY;</span><br><span class="line">                    @SuppressWarnings(<span class="string">&quot;unchecked&quot;</span>)</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[<span class="keyword">n</span>];</span><br><span class="line">                    <span class="keyword">table</span> = <span class="keyword">tab</span> = nt;</span><br><span class="line">                    <span class="keyword">sc</span> = <span class="keyword">n</span> - (<span class="keyword">n</span> &gt;&gt;&gt; 2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                sizeCtl = <span class="keyword">sc</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">tab</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-put-操作"><a href="#3-2-put-操作" class="headerlink" title="3.2. put 操作"></a>3.2. put 操作</h4><ol>
<li>先拿到欲添加的 key 的 hash（执行<code>(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</code>）。</li>
<li>若 table 还没有申请到内存，则先执行初始化操作，即本题上一节。</li>
<li>若将要放置的位置没有元素，会执行<code>casTabAt()</code>方法尝试添加。</li>
<li>若检测到当前元素的hash为moved状态（说明正在执行<code>transfer()</code>操作，此操作会调用<code>ForwardingNode()</code>方法，此方法会将元素的hash设置为moved）。说明正处于数组扩张的数据复制阶段，则此线程也会参与去复制即<a href="https://www.jianshu.com/p/39b747c99d32">helpTransfer</a>，通过允许多线程复制的功能，以此来减少数组的复制所带来的性能损失。</li>
<li>若当前位置有元素，则使用 Synchronized 的方式加锁，对以下操作进行线程安全控制：① 若是链表，遍历链表，若同hash同key，则替换该value；不然，新建node加到链表末尾。② 若是红黑树，则添加到红黑树中。</li>
</ol>
<h4 id="3-3-get操作"><a href="#3-3-get操作" class="headerlink" title="3.3. get操作"></a>3.3. get操作</h4><p>get 操作无锁，支持并发</p>
<h4 id="3-4-链表转树操作"><a href="#3-4-链表转树操作" class="headerlink" title="3.4. 链表转树操作"></a>3.4. 链表转树操作</h4><ol>
<li>在执行<code>treeifyBin()</code>转树方法时，若桶的数量小于 64 时，优先触发扩容操作，细节参考本题下一节：3.5 扩容操作。</li>
<li>若桶数量多于 64 时，使用Synchronized 方式加锁，对以下操作进行线程安全控制：① 将普通结点转换为 TreeNode 结点；② 将 TreeNode 组成的链表构造出 Treebin 对象，在 Treebin 对象的构造方法中，链表被转换成了红黑树。</li>
</ol>
<h4 id="3-5-扩容操作"><a href="#3-5-扩容操作" class="headerlink" title="3.5. 扩容操作"></a>3.5. 扩容操作</h4><p>首先调用<code>tryPresize()</code>方法（支持并发），确定扩容的目标值（决定扩容的次数），以及根据<code>sizeCtl</code>参数选择进入不同的分支。<br>最终来到<code>transfer</code>方法处。</p>
<ol>
<li>首先如果多线程一起进行扩容操作，那么每个线程最少处理 16 个长度的数组元素，以避免此方法占用过多的 CPU 使用。</li>
<li>第一个进入扩容的线程负责初始化一个新的table，长度是旧的两倍。</li>
<li>然后分配一个区间的桶（一般是16 个）给此线程，完成下标的控制。<ol>
<li>如果扩容结束，可以尝试领取新的区间；如果无法领取，那么 sizeCtl 减一，扩容的线程减少一个。</li>
<li>如果数组i处桶是空的，就尝试用 CAS 占位，将占位符 fwd 插入。</li>
<li>如果桶不是空，而且已经有了占位符，说明已有其他线程处理过此操作，那么当前线程将跳过这个桶。</li>
<li>如果以上都不是，而且扩容操作没有完成，那么将开始同步处理这个桶。</li>
</ol>
</li>
<li>处理每个桶的行为是同步的，使用Synchronized关键词修饰，剩下的操作与HashMap基本一致，不再赘述。</li>
</ol>
<p>That’s all,thank you!</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(10)</title>
    <url>/2019/05/26/ARTS-10/</url>
    <content><![CDATA[<h1 id="ARTS-第十周"><a href="#ARTS-第十周" class="headerlink" title="ARTS 第十周"></a>ARTS 第十周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/number-of-matching-subsequences/">力扣 792. 匹配子序列的单词数</a></p>
<p>给定字符串 <code>S</code> 和单词字典 <code>words</code>, 求 <code>words[i]</code> 中是 <code>S</code> 的子序列的单词个数。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">示例:</span></span><br><span class="line"><span class="section">输入: </span></span><br><span class="line">S = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">words = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;acd&quot;</span>, <span class="string">&quot;ace&quot;</span>]</span><br><span class="line"><span class="section">输出: 3</span></span><br><span class="line"><span class="section">解释: 有三个是 S 的子序列的单词: &quot;a&quot;, &quot;acd&quot;, &quot;ace&quot;。</span></span><br></pre></td></tr></table></figure>



<p>思路：</p>
<ol>
<li><p>Sequece 跟 subSequence 采用双指针的方式进行逐位比较，其实时间复杂度只有 O(n)，但 words 数组也要逐个遍历，所以时间复杂度为 O(n2)。</p>
</li>
<li><p>因为 words 中可能存在重复元素，所以用 map 来保存之前的比较记录。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 匹配子序列的单词数 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">S</span> <span class="operator">=</span> <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">		String[] words = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;acd&quot;</span>, <span class="string">&quot;ace&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">actual</span> <span class="operator">=</span> numMatchingSubseq(S, words);</span><br><span class="line">		Assert.assertEquals(actual, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String S, String[] words)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; words.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (map.containsKey(words[i])) &#123;</span><br><span class="line">				count += map.get(words[i]);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (isSubSeq(S, words[i])) &#123;</span><br><span class="line">					num = <span class="number">1</span>;</span><br><span class="line">					++count;</span><br><span class="line">				&#125;</span><br><span class="line">				map.put(words[i], num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> count;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubSeq</span><span class="params">(String Str, String subStr)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; Str.length() &amp;&amp; j &lt; subStr.length()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Str.charAt(i) == subStr.charAt(j)) &#123;</span><br><span class="line">				++j;</span><br><span class="line">			&#125;</span><br><span class="line">			++i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (j == subStr.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>效率记录：</p>
<blockquote>
<p>执行用时 : 44 ms, 在Number of Matching Subsequences的Java提交中击败了100.00% 的用户</p>
<p>内存消耗 : 36.9 MB, 在Number of Matching Subsequences的Java提交中击败了100.00% 的用户</p>
</blockquote>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周继续第八周的 Review 未完成的内容进行解读，附在文末：<a href="http://likehui.fun/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">K8s 入门笔记</a></p>
<p>所参考的英文文章为：<a href="https://dev.to/softchris/weekend-read-serverless-docker-kubernetes-56co">Weekend read, Serverless, Docker, Kubernetes</a></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>chrome 中，<code>command + R</code>组合快捷键可以刷新页面，同样的组合键长按 5 秒，可以清除浏览器缓存。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>今天分享的是一篇关于 TopN 的搜索排序算法的文章，不是我写的，后续会增加我的理解，先看文章：</p>
<p><a href="https://mp.weixin.qq.com/s/k50L_3AWH0_FSuAitZVotg">劈开迷雾：蘑菇街搜索架构及搜索排序实践</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(11)</title>
    <url>/2019/06/01/ARTS-11/</url>
    <content><![CDATA[<h1 id="ARTS-第十一周"><a href="#ARTS-第十一周" class="headerlink" title="ARTS 第十一周"></a>ARTS 第十一周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/numbers-with-same-consecutive-differences/">力扣 967. 连续差相同的数字</a></p>
<p>返回所有长度为 <code>N</code> 且满足其每两个连续位上的数字之间的差的绝对值为 <code>K</code> 的<strong>非负整数</strong>。</p>
<p>请注意，<strong>除了</strong>数字 <code>0</code> 本身之外，答案中的每个数字都<strong>不能</strong>有前导零。例如，<code>01</code> 因为有一个前导零，所以是无效的；但 <code>0</code> 是有效的。</p>
<p>你可以按任何顺序返回答案。 </p>
<p><strong>示例 1：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：N = <span class="number">3</span>, K = <span class="number">7</span></span><br><span class="line">输出：[<span class="number">181,292</span>,<span class="number">707,818</span>,<span class="number">929</span>]</span><br><span class="line">解释：注意，<span class="number">070</span> 不是一个有效的数字，因为它有前导零。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">输入：N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">输出：[<span class="number">10,12,21,23</span>,<span class="number">32,34,43,45</span>,<span class="number">54,56,65,67</span>,<span class="number">76,78,87,89</span>,<span class="number">98</span>]</span><br></pre></td></tr></table></figure>

<p>思路：DFS 搜索的方式，然后使用 set 去重</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 连续差相同的数字 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] results = numsSameConsecDiff(<span class="number">3</span>, <span class="number">7</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; results.length; i++) &#123;</span><br><span class="line">			System.out.println(results[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] numsSameConsecDiff(<span class="type">int</span> N, <span class="type">int</span> K) &#123;</span><br><span class="line">		<span class="type">int</span>[] num0 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> num0;</span><br><span class="line">		&#125;</span><br><span class="line">		Set&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">			DFS(K, list, i, <span class="number">0</span>, N);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> K, Set&lt;Integer&gt; list, <span class="type">int</span> i, <span class="type">int</span> num, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">			list.add(num);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		num += i * (Math.pow(<span class="number">10</span>, N - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Math.abs(i - j) == K) &#123;</span><br><span class="line">				DFS(K, list, j, num, N - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享一篇介绍”蓝绿部署”和”金丝雀发行”(直男配直译)的文章：<a href="https://dev.to/koenighotze/serverless-blue-green-deployments-and-canary-releases-with-traffic-shifting-b55">Serverless blue green deployments and canary releases with traffic shifting</a></p>
<p>知识背景：AWS Lambda 是亚马逊提供的云计算平台，用户将代码上传到平台上，然后可以供用户从 aws、web 或者 app等多种渠道触发计算得出结果。</p>
<p>AWS 的 S3 是亚马逊提供的存储服务。</p>
<p>文章解读如下：</p>
<ol>
<li>Blue Green Deployments，我翻译成蓝绿部署，其实就是一种代码版本更替的方式。在现有 blue 版本的基础上，发布了 green 版本，用户是通过一个 load balancer 才能访问到这些代码。所以 load balancer 在用户不可知的前提下，将访问代码的 access 切换到 green 版本，而一旦 green 版本的代码 bug 甚至失效时，又能及时切换回 blue 版本，这就是所谓的蓝绿部署。</li>
<li>Canary Releases，我翻译成金丝雀发行，其实就是一种灰度发布的方式。将最近的版本仅发布到少量的用户那里，经过使用验证有效后，再逐步扩大到更多的用户那里。</li>
<li>AWS 的 Lambda 又是如何做的呢？<ol>
<li>新建一个 method，zip 打包，上传到AWS 的 S3，此方法属于为<code>lambda funciton</code>，此时版本号是 1；</li>
<li>再次发布时版本号是 2，以后是 3、4… 依此类推，即使 2 被删除，其版本号也不会被重用；</li>
<li>调用 method 时，可以指定方法名和版本号调用不同版本的方法。</li>
<li>也可以为方法设置别名，那么版本信息就对用户透明了，这时 AWS 通常会触发<code>Prod</code>权限的方法。</li>
<li>在 prod 里的多种版本，就会涉及上文提到的”蓝绿部署”和”金丝雀发行”用法了。</li>
</ol>
</li>
<li>完。</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分析一个 linux 命令行查看文件夹大小的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看根目录下各个文件夹的大小，max-depth=n 表示只深入到第 n 层目录</span></span></span><br><span class="line">du -h -max-depth=1 /</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看~目录下文件 size 并从大到小排序</span></span></span><br><span class="line">du -s ~/ | sort -nr</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分享一个 scala 的快排代码，十分精简也很有意思：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qSort</span></span>(a:<span class="type">List</span>[<span class="type">Int</span>]):<span class="type">List</span>[<span class="type">Int</span>]=</span><br><span class="line"><span class="keyword">if</span>(a.length&lt;<span class="number">2</span>) a</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">qSort(a.filter(_&lt;a.head)) ++ </span><br><span class="line">a.filter(_==a.head) ++ </span><br><span class="line">qSort(a.filter(_&gt;a.head))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>AKSK安全认证</title>
    <url>/2021/07/29/AKSK%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p><a href="https://developer.supos.com/">蓝卓开发者社区</a></p>
<p><a href="https://developer.supos.com/683.html">APP集成 ∣ 深度集成方案</a></p>
<p><a href="https://developer.supos.com/820.html">supOS SDK for Java 开发指南</a></p>
<span id="more"></span>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">apibaseURL</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;SUPOS_SUPOS_ADDRESS&quot;</span>);</span><br><span class="line"><span class="comment">//封装消息体</span></span><br><span class="line"><span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\&quot;sender\&quot;: \&quot;admin\&quot;,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\&quot;source\&quot;: \&quot;system\&quot;,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\&quot;type\&quot;:\&quot;stationLetter\&quot;,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\&quot;receivers\&quot;: [\&quot;xwj\&quot;],\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\&quot;content\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\t\&quot;title\&quot;:\&quot;aaaaa\&quot;,\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t\t\&quot;text\&quot;:\&quot;aaa\&quot;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;\t&#125;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"><span class="comment">//调用openapi签名工具类发送请求</span></span><br><span class="line">Map&lt;String, String&gt; headMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;()&#123;&#123;</span><br><span class="line">  put(<span class="string">&quot;X-MC-Date&quot;</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">  put(<span class="string">&quot;X-MC-Type&quot;</span>,<span class="string">&quot;...&quot;</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> SignUtil.doHttpMethod(apiBaseURL,<span class="string">&quot;/api/openapi/notification/v1/message&quot;</span>, HttpMethod.POST, JSON.parseObject(body), headMap);</span><br></pre></td></tr></table></figure>



<p>SignUtil 签名的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.bluetron.eco.sdk.dto.common.SuposConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpMethod;</span><br><span class="line"><span class="keyword">import</span> com.google.common.net.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.HmacAlgorithms;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.HmacUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections4.MapUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClients;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  通过AK/SK签名 发送HTTP请求调用open api接口</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> apiPath api的请求路径 如:/openapi/users/v1?page=1&amp;per_page=2</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> method HttpMethod</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> jsonBody 当method是post put等请求时，所携带的body</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> headMap 签名需要用到的头</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">doHttpMethod</span><span class="params">(String apiPath, HttpMethod method, JSONObject jsonBody, Map&lt;String, String&gt; headMap)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AK/SK 请求, apiPath: &#123;&#125; , method: &#123;&#125; ,jsonBody: &#123;&#125;, headMap: &#123;&#125;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>, apiPath, method, jsonBody, headMap);</span><br><span class="line">		<span class="type">SignRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SignRequest</span>();</span><br><span class="line">		request.setSignUrl(SuposConfig.getSuposApiAddress(), apiPath);</span><br><span class="line">		request.setAppId(SuposConfig.getAppId());</span><br><span class="line">		request.setAppSecret(SuposConfig.getSecretKey());</span><br><span class="line">		request.setHttpMethod(method);</span><br><span class="line">		request.addHeader(HttpHeaders.CONTENT_TYPE, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> != jsonBody) &#123;</span><br><span class="line">			request.setBody(jsonBody.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">HttpRequestBase</span> <span class="variable">requestBase</span> <span class="operator">=</span> createSignatureRequest(request, headMap);</span><br><span class="line">		<span class="type">CloseableHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> HttpClients.custom().build();</span><br><span class="line"></span><br><span class="line">		<span class="type">HttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.execute(requestBase);</span><br><span class="line">		<span class="type">int</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatusLine().getStatusCode();</span><br><span class="line">		<span class="type">HttpEntity</span> <span class="variable">resEntity</span> <span class="operator">=</span> response.getEntity();</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (resEntity != <span class="literal">null</span>) &#123;</span><br><span class="line">			result = EntityUtils.toString(resEntity, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AK/SK 响应状态码: &#123;&#125; , 响应内容: &#123;&#125; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>, statusCode, result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 	创建一个具有AKSK签名的HTTP CLIENT请求</span></span><br><span class="line"><span class="comment">	 *  request 加签参数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> HttpRequestBase <span class="title function_">createSignatureRequest</span><span class="params">(SignRequest request, Map&lt;String, String&gt; headMap)</span> &#123;</span><br><span class="line">		HttpRequestBase httpRequest;</span><br><span class="line">		StringEntity entity;</span><br><span class="line">		<span class="type">HttpMethod</span> <span class="variable">httpMethod</span> <span class="operator">=</span> request.getHttpMethod();</span><br><span class="line">		<span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> request.getBody();</span><br><span class="line">		<span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> request.getSignUrl();</span><br><span class="line">		<span class="keyword">switch</span> (httpMethod) &#123;</span><br><span class="line">			<span class="keyword">case</span> POST:</span><br><span class="line">				<span class="type">HttpPost</span> <span class="variable">postMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPost</span>(url);</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotEmpty(content)) &#123;</span><br><span class="line">					entity = <span class="keyword">new</span> <span class="title class_">StringEntity</span>(content, StandardCharsets.UTF_8);</span><br><span class="line">					postMethod.setEntity(entity);</span><br><span class="line">				&#125;</span><br><span class="line">				httpRequest = postMethod;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PUT:</span><br><span class="line">				<span class="type">HttpPut</span> <span class="variable">putMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPut</span>(url);</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotEmpty(content)) &#123;</span><br><span class="line">					entity = <span class="keyword">new</span> <span class="title class_">StringEntity</span>(content, StandardCharsets.UTF_8);</span><br><span class="line">					putMethod.setEntity(entity);</span><br><span class="line">				&#125;</span><br><span class="line">				httpRequest = putMethod;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PATCH:</span><br><span class="line">				<span class="type">HttpPatch</span> <span class="variable">patchMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpPatch</span>(url);</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotEmpty(content)) &#123;</span><br><span class="line">					entity = <span class="keyword">new</span> <span class="title class_">StringEntity</span>(content, StandardCharsets.UTF_8);</span><br><span class="line">					patchMethod.setEntity(entity);</span><br><span class="line">				&#125;</span><br><span class="line">				httpRequest = patchMethod;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> GET:</span><br><span class="line">				httpRequest = <span class="keyword">new</span> <span class="title class_">HttpGet</span>(url);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> DELETE:</span><br><span class="line">				httpRequest = <span class="keyword">new</span> <span class="title class_">HttpDelete</span>(url);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> OPTIONS:</span><br><span class="line">				httpRequest = <span class="keyword">new</span> <span class="title class_">HttpOptions</span>(url);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">if</span> (httpMethod != HttpMethod.HEAD) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown HTTP method name: &quot;</span> + httpMethod);</span><br><span class="line">				&#125;</span><br><span class="line">				httpRequest = <span class="keyword">new</span> <span class="title class_">HttpHead</span>(url);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取签名头</span></span><br><span class="line">		Map&lt;String, String&gt; headers = getSignatureHeader(request, headMap);</span><br><span class="line">		<span class="keyword">if</span> (MapUtils.isNotEmpty(headMap)) &#123;</span><br><span class="line">			headers.putAll(headMap);</span><br><span class="line">		&#125;</span><br><span class="line">		Iterator&lt;String&gt; iterator = headers.keySet().iterator();</span><br><span class="line">		<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">			httpRequest.addHeader(key, headers.get(key));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> httpRequest;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取AK/SK加签后的签名头</span></span><br><span class="line">	<span class="comment">//request 加签参数</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, String&gt; <span class="title function_">getSignatureHeader</span><span class="params">(SignRequest request, Map&lt;String, String&gt; headMap)</span> &#123;</span><br><span class="line">		Map&lt;String, String&gt; headers = request.getHeaders();</span><br><span class="line">		<span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">		sb.append(request.getHttpMethod().toString()).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				.append(request.getSignUrl()).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">				.append(headers.get(HttpHeaders.CONTENT_TYPE)).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="comment">//CanonicalQueryString</span></span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(request.getQueryString())) &#123;</span><br><span class="line">			sb.append(request.getQueryString().trim());</span><br><span class="line">		&#125;</span><br><span class="line">		sb.append(<span class="string">&quot;\n&quot;</span>).append(getCanonicalCustomHeaders(headMap).toString().trim());</span><br><span class="line">		log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AK/SK 签名源内容：\n&#123;&#125; \n&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>, sb);</span><br><span class="line"></span><br><span class="line">		log.info(<span class="string">&quot;appSecret: &#123;&#125;&quot;</span>, request.getAppSecret());</span><br><span class="line">		<span class="type">HmacUtils</span> <span class="variable">hmacSha256</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HmacUtils</span>(HmacAlgorithms.HMAC_SHA_256, request.getAppSecret());</span><br><span class="line">		<span class="type">String</span> <span class="variable">signature</span> <span class="operator">=</span> hmacSha256.hmacHex(sb.toString());</span><br><span class="line">		<span class="type">String</span> <span class="variable">finalSignature</span> <span class="operator">=</span> <span class="string">&quot;Sign &quot;</span> + request.getAppId() + <span class="string">&quot;-&quot;</span> + signature;</span><br><span class="line">		headers.put(<span class="string">&quot;Authorization&quot;</span>, finalSignature);</span><br><span class="line">		log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AK/SK 签名结果：Authorization : &#123;&#125; &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>, finalSignature);</span><br><span class="line">		<span class="keyword">return</span> headers;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//自定义的请求头</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getCanonicalCustomHeaders</span><span class="params">(Map&lt;String, String&gt; headMap)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;x-mc-date:&quot;</span> + headMap.get(<span class="string">&quot;X-MC-Date&quot;</span>) + <span class="string">&quot;;x-mc-type:&quot;</span> + headMap.get(<span class="string">&quot;X-MC-Type&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javaWeb</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(12)</title>
    <url>/2019/06/07/ARTS-12/</url>
    <content><![CDATA[<h1 id="ARTS-第十二周"><a href="#ARTS-第十二周" class="headerlink" title="ARTS 第十二周"></a>ARTS 第十二周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/4sum/">力扣 18. 四数之和</a></p>
<p>给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。</p>
<p>注意：</p>
<p>答案中不可以包含重复的四元组。</p>
<p>示例：</p>
<p>给定数组 nums &#x3D; [1, 0, -1, 0, -2, 2]，和 target &#x3D; 0。</p>
<p>满足要求的四元组集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p>
<p>思路：</p>
<ol>
<li>先用两个指针 i、j 从左到右遍历。</li>
<li>然后再用两个指针 left、right 从两侧向中间靠拢，对比结果。</li>
</ol>
<ul>
<li>整个数组要先排序。</li>
<li>使用 HashSet 去重，需要子 list 进数组前先排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 四数之和 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = fourSum(nums, target);</span><br><span class="line">		result.forEach(list -&gt; &#123;</span><br><span class="line">			list.forEach(element -&gt;</span><br><span class="line">					System.out.print(element + <span class="string">&quot; &quot;</span>)</span><br><span class="line">			);</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		Set&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		findTargetSum(nums, target, result, temp);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; ret = result.stream().collect(Collectors.toList());</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findTargetSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, Set&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; temp)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">			temp.add(nums[i]);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length - <span class="number">2</span>; ++j) &#123;</span><br><span class="line">				temp.add(nums[j]);</span><br><span class="line">				<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">					temp.add(nums[left]); <span class="comment">// 懒得写加法，直接添加到集合中，后面指针变更时要将元素从数组中移除</span></span><br><span class="line">					temp.add(nums[right]);</span><br><span class="line">					<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> calcu(temp);</span><br><span class="line">					<span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">						<span class="type">List</span> <span class="variable">sortedTemp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(temp);</span><br><span class="line">						Collections.sort(sortedTemp);</span><br><span class="line">						result.add(sortedTemp);</span><br><span class="line">						++left;</span><br><span class="line">						--right;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">						++left;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						--right;</span><br><span class="line">					&#125;</span><br><span class="line">					temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">					temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			temp.remove(temp.size() - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calcu</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">			sum += list.get(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读一篇英文文章：<a href="https://dzone.com/articles/an-introduction-to-apache-kafka">An Introduction to Apache Kafka</a></p>
<p>解读要点：</p>
<ol>
<li><p>如果 n  个app 需要相互交流，传统形式下，可能出现 n×n 种组合形式，在 scalability 系统中，n 可能非常大，过多的组合是无法接受的。所以此时就需要一种类似发布-订阅模式（pub-sub mechanism）来实现上面提过的需求。</p>
</li>
<li><p>历史上来说，一种叫做 JMS(java messaging service)是一种松耦合的消息结构，是早期的 MQ工具，其中的某些特性(比如 producer、consumer、message、queue、topic 等)延续下来，成为后来的MQ工具的核心。</p>
</li>
<li><p>kafka 定义：<strong>Apache Kafka is a distributed, partitioned, replicated commit log service.</strong> </p>
<ol>
<li>关键词：支持分布式，容错性强，scalable弹性好，发布-订阅模式。</li>
<li>append-only logs，producer 会将 event 推送到 distributed logs 中，成为一个 topic。</li>
</ol>
</li>
<li><p>consumer 经过配置后，利用 offset 去消费 topic。此 offset 其实就是 topic 中 record 的编号。</p>
<ol>
<li>让 consumer 决定消费什么，完全避免 producer 侧太过复杂的 routing rules。</li>
</ol>
</li>
<li><p>commit log：是一种 append-only，时序的 records 序列，与 kafka 的 topics 构成映射，并且分区实现分布式的特性。</p>
<ol>
<li><p>记录的是何时发生了何事。log 主体具有独立的时间戳，与物理时钟无关。</p>
</li>
<li><p>分布式系统建议使用异步的方式消费 topic。</p>
<p><img src="/2019/06/07/ARTS-12/1.png"></p>
</li>
<li><p>按上图，producers 从右端添加 log，consumer 按照 offset 找到定位，然后从左到右消费 log。</p>
</li>
</ol>
</li>
<li><p>kafka 的有关缺点：</p>
<ol>
<li>不设 index，甚至分区的 topic 也没有 index。</li>
<li>可能因为消费侧规则的错误配置，导致某些topic未被消费。</li>
<li>当设置 TTL(time-to-live)的消息退出机制（在<code>.properties</code>文件的<code>log.retention.*</code>中配置），kafka才会删除消息。所以日志内容可能会很大，磁盘 swap 时可能出现延迟。</li>
<li>kafka 可以通过 kernel IO 进行流处理 message，比 user space 的 IO 要快很多，但在 kernel 中的操作有一些潜在的风险。</li>
</ol>
</li>
<li><p><a href="https://docs.confluent.io/current/schema-registry/docs/index.html">Confluent Schema Registry</a>，Confluent 支持的一种 schema 注册机制，是与 kafka配合的一种规范用法。</p>
<ol>
<li>producer 注册schema，然后按照此 schema 发布消息，consumer 按照此 schema 解析消息，用以实现 schema 规则的一致性，是 kafka 高级用法的一种。</li>
<li>此机制不是 apache 维护的，当心其未来的兼容性。</li>
</ol>
</li>
<li><p>Aiven 公司也提供了一种开源的 schema 管理工具，<a href="https://karapace.io/">Karapace</a>，简单易用。</p>
</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>分享一波资源网站吧，排名不分先后：</p>
<p>网盘：<a href="https://www.xiaobd.net/">小不点搜索</a> ，<a href="https://www.soohub.com/">soohub</a>，<a href="http://pansou.com/">盘搜</a></p>
<p>电子书：<a href="http://read678.com/">read678</a>，<a href="https://www.ixdzs.com/">爱下电子书</a>，<a href="https://www.jiumodiary.com/">鸠摩搜书</a>，<a href="https://www.kgbook.com/">苦瓜6 寸pdf</a></p>
<p>乱炖：<a href="http://www.idayali.com/">爱吃大鸭梨</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是 zookeeper 的基础知识点，以及 server 和 client 搭建实战，参考本站另一篇文章，</p>
<p>链接如下：<a href="http://likehui.fun/2019/06/22/zk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">zk学习笔记</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(14)</title>
    <url>/2019/06/30/ARTS-14/</url>
    <content><![CDATA[<h1 id="ARTS-第十四周-终篇"><a href="#ARTS-第十四周-终篇" class="headerlink" title="ARTS 第十四周(终篇)"></a>ARTS 第十四周(终篇)</h1><p>ARTS 活动持续了 100 天，到本周正式宣告结束！撒花！！！</p>
<p>虽然ARTS 结束了，但是还要生生不息地折腾啊~~</p>
<blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">力扣 142. 环形链表 II</a></p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p>说明：不允许修改给定的链表。空间复杂度 O(1)</p>
<p>示例 1：</p>
<p>输入：head &#x3D; [3,2,0,-4], pos &#x3D; 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p>
<p>思路：直接看<a href="https://www.cnblogs.com/ganganloveu/p/3715981.html">Linked List Cycle II</a>，浅显易懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		ListNode fast, slow;</span><br><span class="line">		fast = slow = head;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (fast != <span class="literal">null</span>) fast = fast.next;</span><br><span class="line">			<span class="keyword">if</span> (fast != <span class="literal">null</span>) fast = fast.next;</span><br><span class="line">			<span class="keyword">if</span> (slow != <span class="literal">null</span>) slow = slow.next;</span><br><span class="line">		&#125; <span class="keyword">while</span> (fast != slow);</span><br><span class="line">		fast = head;</span><br><span class="line">		<span class="keyword">while</span>(fast!=slow &amp;&amp; fast!=<span class="literal">null</span> &amp;&amp; slow != <span class="literal">null</span>)&#123;</span><br><span class="line">			fast = fast.next;</span><br><span class="line">			slow = slow.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>7 月 3 号的事件，BBC 新闻：<a href="https://www.bbc.com/news/technology-48854213">Baidu chief doused with water at AI event</a></p>
<p>解读：</p>
<ol>
<li>宏颜获水，AI 的发展也会被”泼冷水”。</li>
<li>百度 AI 可以支持中英文，而且无需唤醒语。竞品亚马逊的 Alexa 或者 Google 的家用设备目前都还需要唤醒语。</li>
<li>百度语音助手至今已经安装在了 4 亿多台设备上，月处理请求高达 36 亿条。</li>
<li>百度与国内银行合作，将推出针对个人的理财智能助手。</li>
<li>不久之后，百度会在长沙亮相一个 100 辆车组成的无人驾驶车队。</li>
<li>大会全场，一个名为”茶博士”的长臂机器人做了倒茶的表演。</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>记录个网站吧：<a href="http://zh.d2l.ai/">《动手学深度学习》</a></p>
<p>朋友强推的，虽然我短时间内不会学这个，但想想还是 mark 一下。</p>
<p>还有：<a href="https://github.com/Vonng/ddia">《Designing Data-Intensive Application》DDIA中文翻译</a></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>分享一个 lambda 表达式的骚操作：链接：<a href="https://segmentfault.com/q/1010000015013616/a-1020000015018865">如何使用java8 stream 将两个List<Integer> 集合中的相同下标的值相加生成一个新的List</Integer></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 =Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; list2 =Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; result = IntStream.range(<span class="number">0</span>, list1.size())</span><br><span class="line">                                .map(i -&gt; list1.get(i) + list2.get(i))</span><br><span class="line">                                .boxed()</span><br><span class="line">                                .collect(Collectors.toList());</span><br><span class="line">                                </span><br><span class="line"><span class="comment">//生成 result ：&#123;2,4,6,8,10&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/xujanus/p/6133865.html">使用java8的lambda将list转为map（转）</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Long, String&gt; <span class="title function_">getIdNameMap</span><span class="params">(List&lt;Account&gt; accounts)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其实有缺陷（Duplicate key 问题），参考上面的链接原文</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(13)</title>
    <url>/2019/06/23/ARTS-13/</url>
    <content><![CDATA[<h1 id="ARTS-第十三周"><a href="#ARTS-第十三周" class="headerlink" title="ARTS 第十三周"></a>ARTS 第十三周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/random-flip-matrix/">力扣 519. 随机翻转矩阵</a></p>
<p>题中给出一个 n 行 n 列的二维矩阵 (n_rows,n_cols)，且所有值被初始化为 0。要求编写一个 flip 函数，均匀随机的将矩阵中的 0 变为 1，并返回该值的位置下标 [row_id,col_id]；同样编写一个 reset 函数，将所有的值都重新置为 0。尽量最少调用随机函数 Math.random()，并且优化时间和空间复杂度。</p>
<p>注意:</p>
<p>1.1 &lt;&#x3D; n_rows, n_cols &lt;&#x3D; 10000</p>
<ol start="2">
<li>0 &lt;&#x3D; row.id &lt; n_rows 并且 0 &lt;&#x3D; col.id &lt; n_cols</li>
</ol>
<p>3.当矩阵中没有值为 0 时，不可以调用 flip 函数</p>
<p>4.调用 flip 和 reset 函数的次数加起来不会超过 1000 次</p>
<p>示例 1：</p>
<p>输入:<br>[“Solution”,”flip”,”flip”,”flip”,”flip”]<br>[[2,3],[],[],[],[]]<br>输出: [null,[0,1],[1,2],[1,0],[1,1]]<br>示例 2：</p>
<p>输入:<br>[“Solution”,”flip”,”flip”,”reset”,”flip”]<br>[[1,2],[],[],[],[]]<br>输出: [null,[0,0],[0,1],null,[0,0]]</p>
<blockquote>
<p>执行结果：通过 </p>
<p>显示详情 执行用时 :125 ms, 在所有 Java 提交中击败了100.00%的用户 </p>
<p>内存消耗 :39 MB, 在所有 Java 提交中击败了100.00% 的用户</p>
</blockquote>
<p>思路：</p>
<ol>
<li>首先二维数组摊平成一维数组，使用以下方式转换： int x &#x3D; result % n_rows; int y &#x3D; result &#x2F; n_rows; </li>
<li>size 表示当前未被访问的数字个数，随机数从 0~size-1 之间产生，但随机数并不一定是最终的数字。</li>
<li>维护一个黑名单 map，若随机数已经存在于当前黑名单中，那么取出黑名单中的 value 代替此随机数。</li>
<li>此 value 讲道理应该不在黑名单中，若不幸还在黑名单里，那就以此 value 继续查找黑名单。 </li>
<li>确定最终的数字后，就要往黑名单中添加当前的记录：最终的数字做 key，size 做 value，记录在黑名单中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="type">int</span> n_rows;</span><br><span class="line">	<span class="type">int</span> n_cols;</span><br><span class="line">	<span class="type">int</span> size;</span><br><span class="line">	Map&lt;Integer, Integer&gt; visitedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span> n_rows, <span class="type">int</span> n_cols)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.n_rows = n_rows;</span><br><span class="line">		<span class="built_in">this</span>.n_cols = n_cols;</span><br><span class="line">		<span class="built_in">this</span>.size = n_cols * n_rows;</span><br><span class="line">		<span class="built_in">this</span>.visitedMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] flip() &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * size);</span><br><span class="line">		--size;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> index;</span><br><span class="line">		<span class="keyword">while</span> (visitedMap.containsKey(result)) &#123;</span><br><span class="line">			result = visitedMap.get(result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> result % n_rows;</span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> result / n_rows;</span><br><span class="line">		visitedMap.put(result, size); <span class="comment">// K - V : 黑名单 - 白名单</span></span><br><span class="line">		<span class="type">int</span>[] ret = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">		ret[<span class="number">0</span>] = x;</span><br><span class="line">		ret[<span class="number">1</span>] = y;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.size = n_cols * n_rows;</span><br><span class="line">		<span class="built_in">this</span>.visitedMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享英文文章是:<a href="https://dzone.com/articles/data-streaming-made-easy-with-apache-kafka">Data Streaming Made Easy With Apache Kafka</a> 和 <a href="https://dzone.com/articles/hands-on-apache-kafka-with-scala?fromrel=true">Apache Kafka With Scala Tutorial</a>。</p>
<p>解读：</p>
<ol>
<li>kafka 适用于微服务架构(也就是 MSA)，主要原因就是消息队列的异步特性。producer 什么时候生产 topic 跟 consumer 什么时候消费 topic，是不存在<strong>time、task</strong>依赖的，也无需担心同步锁的问题。</li>
<li>消息中的数据其实就是字节数组，能够以任意形式存储。kafka 中的消息以 topic 数据结构存储，</li>
<li>kafka 的 servers 集群称为 brokers，每个 broker 会存储一个或多个分区。</li>
<li>producer 发布消息的过程是线程安全的，而且能够控制 message 进入哪个分区。<ol>
<li>支持多个 server 发布同一个 topic。</li>
</ol>
</li>
<li>无论 topic 被消费与否，kafka 都会保存消息到一定时间(时间可配置)。</li>
<li>运行 kafka 之前，还需要 zookeeper对 broker 进行管理，参考：<a href="https://blog.csdn.net/u011311291/article/details/85264046">为啥Kafka依赖Zookeeper</a>。</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>今天分享一个 很方便通过可视化的方式进行git 操作的软件——sourcetree，我觉得优点有这么几个：</p>
<ol>
<li>图形化展示工作区、各分支、commit 等</li>
<li>所有 git 命令</li>
<li>能做简单的代码 diff</li>
<li>学习成本低，半天上手</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周对本站之前的一篇 k8s 的文章进行了补充，加了不少干货，参考以下链接：</p>
<p><a href="http://likehui.fun/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">K8s 入门笔记</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(2)</title>
    <url>/2019/03/28/ARTS-2/</url>
    <content><![CDATA[<h1 id="ARTS-第二周分享"><a href="#ARTS-第二周分享" class="headerlink" title="ARTS 第二周分享"></a>ARTS 第二周分享</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.com/problems/sort-array-by-parity/">LeetCode 905. Sort Array By Parity</a></p>
<p>Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</p>
<p>You may return any answer array that satisfies this condition.</p>
<blockquote>
<p>Input: [3,1,2,4]<br>Output: [2,4,3,1]<br>The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</p>
</blockquote>
<p>题意：偶数放在数组前部，奇数放在数组后部。<br>思路：双指针法：两个指针分别指向奇、偶数，适时移动即可。<br>易错点：注意数组下标越界问题。<br>以下解法：时间复杂度O(n2)（最差），空间复杂度O(1)。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Solution</span> &#123;</span></span><br><span class="line"><span class="class">    public int[] sortArrayByParity(<span class="title">int</span>[] <span class="type">A</span>) &#123;</span></span><br><span class="line"><span class="class">        if(<span class="type">A</span> == <span class="title">null</span>)&#123;</span></span><br><span class="line"><span class="class">            return null;</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        int i = 0,j = 0;</span></span><br><span class="line"><span class="class">        while(<span class="title">i</span>&lt;<span class="type">A</span>.<span class="title">length</span> &amp;&amp; <span class="title">j</span>&lt;<span class="type">A</span>.<span class="title">length</span>)&#123;</span></span><br><span class="line"><span class="class">            while(<span class="type">A</span>[<span class="title">j</span>] % 2 == 1)&#123;</span></span><br><span class="line"><span class="class">                ++j;</span></span><br><span class="line"><span class="class">                if(<span class="title">j</span>&gt;=<span class="type">A</span>.<span class="title">length</span>)&#123;</span></span><br><span class="line"><span class="class">                    break;</span></span><br><span class="line"><span class="class">                &#125;</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            while(<span class="type">A</span>[<span class="title">i</span>]%2 == 0)&#123;</span></span><br><span class="line"><span class="class">                ++i;</span></span><br><span class="line"><span class="class">                if(<span class="title">i</span>&gt;=<span class="type">A</span>.<span class="title">length</span>)&#123;</span></span><br><span class="line"><span class="class">                    break;</span></span><br><span class="line"><span class="class">                &#125;</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">            if(<span class="title">j</span>&gt;<span class="title">i</span> &amp;&amp; <span class="title">i</span>&lt;<span class="type">A</span>.<span class="title">length</span> &amp;&amp; <span class="title">j</span>&lt;<span class="type">A</span>.<span class="title">length</span>)&#123;</span></span><br><span class="line"><span class="class">                move(<span class="type">A</span>,<span class="title">i</span>,<span class="title">j</span>);</span></span><br><span class="line"><span class="class">                ++i;</span></span><br><span class="line"><span class="class">                ++j;</span></span><br><span class="line"><span class="class">            &#125;else&#123;</span></span><br><span class="line"><span class="class">                ++j;</span></span><br><span class="line"><span class="class">            &#125;</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        return <span class="type">A</span>;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">    public void move(<span class="title">int</span>[] <span class="type">A</span>,<span class="title">int</span> <span class="title">i</span>,<span class="title">int</span> <span class="title">j</span>)&#123;</span></span><br><span class="line"><span class="class">        int temp = <span class="type">A</span>[j];</span></span><br><span class="line"><span class="class">        for(<span class="title">int</span> <span class="title">k</span> = <span class="title">j</span>;<span class="title">k</span>&gt;<span class="title">i</span>;<span class="comment">--k)&#123;</span></span></span><br><span class="line"><span class="class">            <span class="type">A</span>[<span class="title">k</span>] = <span class="type">A</span>[<span class="title">k</span>-1];</span></span><br><span class="line"><span class="class">        &#125;</span></span><br><span class="line"><span class="class">        <span class="type">A</span>[<span class="title">i</span>] = <span class="title">temp</span>;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>扩展：可以尝试模仿快排的方式解题，应该会更容易，不过同时容易造成不稳定的情况。</p>
<hr>
<p><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/">LeetCode 129. Sum Root to Leaf Numbers</a></p>
<p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</p>
<p>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</p>
<p>Find the total sum of all root-to-leaf numbers.</p>
<blockquote>
<p>Input: [1,2,3]<br>    1<br>   &#x2F; <br>  2   3<br>Output: 25</p>
</blockquote>
<p>题意：从根节点到叶子节点数字组成一个 number，所有 number 的和输出。<br>思路：DFS 的思路，如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">	List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">sumNumbers</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">		sums(root);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sums</span>(<span class="params">TreeNode root</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">			list.<span class="keyword">add</span>(root.val);</span><br><span class="line">			<span class="built_in">int</span> temp = getNum(list);</span><br><span class="line">			result += temp;</span><br><span class="line">			list.<span class="keyword">remove</span>(list.size() - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		list.<span class="keyword">add</span>(root.val);</span><br><span class="line">		sums(root.left);</span><br><span class="line">		sums(root.right);</span><br><span class="line">		list.<span class="keyword">remove</span>(list.size() - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getNum</span>(<span class="params">List&lt;Integer&gt; list</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i) &#123;</span><br><span class="line">			ans = ans * <span class="number">10</span> + list.<span class="keyword">get</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读英文文章来自 javaworld ，名为：<a href="https://www.javaworld.com/article/3336222/java-challengers-6-thread-behavior-in-the-jvm.html">Thread behavior in the JVM</a></p>
<ol>
<li>首先提到“new、runnable、running、suspended、blocked、terminated”Java 线程的六种状态。</li>
<li>然后重点提及了继承 thread 类和实现 Runnable 接口两种实现多线程的方式。</li>
<li>将线程分为：守护线程与非守护线程：<ol>
<li>非守护线程：会一直执行到任务结束，除非出现<code>System.exit()</code>的情况。</li>
<li>守护线程：无需执行到任务最后。如果其他非守护线程都已经结束了，那么此守护线程也会立即结束。</li>
</ol>
</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"><span class="bullet">*</span>  守护线程与非守护线程举例</span><br><span class="line"><span class="bullet">*</span>  执行规律为：main 线程首先 start，然后 daemon 线程开始打印</span><br><span class="line"><span class="bullet">*</span>  main 线程 sleep 后也很快结束任务，此时 daemon 线程还没彻底打印完成</span><br><span class="line"><span class="bullet">*</span></span><br><span class="line"><span class="bullet">*</span> /</span><br><span class="line"></span><br><span class="line">import java.util.stream.IntStream;</span><br><span class="line"></span><br><span class="line">public class NonDaemonAndDaemonThread &#123;</span><br><span class="line"></span><br><span class="line"><span class="code">	public static void main(String... nonDaemonAndDaemon) throws InterruptedException &#123;</span></span><br><span class="line"><span class="code">		System.out.println(&quot;线程开始执行： &quot; + Thread.currentThread().getName());</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		// 遍历打印数字</span></span><br><span class="line"><span class="code">		Thread daemonThread = new Thread(() -&gt; IntStream.rangeClosed(1, 100000)</span></span><br><span class="line"><span class="code">				.forEach(System.out::println));</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		daemonThread.setDaemon(true);</span></span><br><span class="line"><span class="code">		daemonThread.start();</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		Thread.sleep(10);</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">		System.out.println(&quot;线程执行结束： &quot; +</span></span><br><span class="line"><span class="code">				Thread.currentThread().getName());</span></span><br><span class="line"><span class="code">	&#125;</span></span><br><span class="line"><span class="code">&#125;</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<p>笔者本机模拟截图如下：</p>
<p><img src="/2019/03/28/ARTS-2/1.png"></p>
<p><img src="/2019/03/28/ARTS-2/2.png"></p>
<p><img src="/2019/03/28/ARTS-2/3.png"></p>
<p>main 线程 end 后，daemon 线程最终到470左右也发生 end，并未完成打印到 100000 的任务。</p>
<ol start="4">
<li><p>线程有 1~10 的优先级的说法，从低到高，但是并不能保证完全依据优先级先后执行。</p>
<blockquote>
<p>Remember, we can’t rely on program logic (order of threads or thread priority) to predict the JVM’s order of execution.</p>
</blockquote>
</li>
<li><p>Java threads 容易出现的错误：</p>
<ol>
<li>在 run 方法中开启新线程；</li>
<li>同一个线程 start 两次；</li>
<li>多的线程同时改变一个对象的状态；</li>
<li>依赖线程优先级来实现逻辑；</li>
<li>依赖线程 start 的先后顺序来实现逻辑。</li>
</ol>
</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ol>
<li>中英文混写的文章中，为了美观考虑，可以尽量在中英文中间加上空格，这里采用搜狗输入法的相关设置，默认为中文间加上空间，省心省事。</li>
<li>idea 编辑器中，双击 SHIFT 键，可以调出全局搜索，可以搜索 JDK 中的相关类。</li>
<li>lombok 插件尤其有用，可以节省很多 setter&#x2F;getter 的格外设置。</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享我用 Java 代码完成的：<a href="http://likehui.fun/2019/03/22/%E4%B8%83%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">七种内部排序的代码实现</a></p>
<p>That’s all,thank you!</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(3)</title>
    <url>/2019/04/02/ARTS-3/</url>
    <content><![CDATA[<h1 id="ARTS-第三周分享"><a href="#ARTS-第三周分享" class="headerlink" title="ARTS 第三周分享"></a>ARTS 第三周分享</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode.com/problems/valid-square/">LeetCode 593. Valid Square</a></p>
<p>Given the coordinates of four points in 2D space, return whether the four points could construct a square.</p>
<p>The coordinate (x,y) of a point is represented by an integer array with two integers.</p>
<blockquote>
<p>Input: p1 &#x3D; [0,0], p2 &#x3D; [1,1], p3 &#x3D; [1,0], p4 &#x3D; [0,1]<br>Output: True</p>
</blockquote>
<p>思路：以某点（如 p1）为顶点，确定与其他三点的距离是否满足等边及勾股定理。<br>如果满足，轮换顶点（一般三个点即可，轮换四个点更稳妥）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import org.junit.Assert;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> ValidSquare &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void get<span class="constructor">Result()</span> &#123;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> p1 = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> p2 = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> p3 = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> p4 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">		boolean actual = valid<span class="constructor">Square(<span class="params">p1</span>, <span class="params">p2</span>, <span class="params">p3</span>, <span class="params">p4</span>)</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span><span class="keyword">assert</span><span class="constructor">True(<span class="params">actual</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean valid<span class="constructor">Square(<span class="params">int</span>[] <span class="params">p1</span>, <span class="params">int</span>[] <span class="params">p2</span>, <span class="params">int</span>[] <span class="params">p3</span>, <span class="params">int</span>[] <span class="params">p4</span>)</span> &#123;</span><br><span class="line">		return valid<span class="constructor">Once(<span class="params">p1</span>, <span class="params">p2</span>, <span class="params">p3</span>, <span class="params">p4</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">				&amp;&amp; </span>valid<span class="constructor">Once(<span class="params">p2</span>, <span class="params">p3</span>, <span class="params">p4</span>, <span class="params">p1</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">				&amp;&amp; </span>valid<span class="constructor">Once(<span class="params">p3</span>, <span class="params">p1</span>, <span class="params">p2</span>, <span class="params">p4</span>)</span><span class="operator"></span></span><br><span class="line"><span class="operator">				&amp;&amp; </span>valid<span class="constructor">Once(<span class="params">p4</span>, <span class="params">p1</span>, <span class="params">p2</span>, <span class="params">p3</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean valid<span class="constructor">Once(<span class="params">int</span>[] <span class="params">p1</span>, <span class="params">int</span>[] <span class="params">p2</span>, <span class="params">int</span>[] <span class="params">p3</span>, <span class="params">int</span>[] <span class="params">p4</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">int</span> len1 = get<span class="constructor">Len(<span class="params">p1</span>, <span class="params">p2</span>)</span>;</span><br><span class="line">		<span class="built_in">int</span> len2 = get<span class="constructor">Len(<span class="params">p1</span>, <span class="params">p3</span>)</span>;</span><br><span class="line">		<span class="built_in">int</span> len3 = get<span class="constructor">Len(<span class="params">p1</span>, <span class="params">p4</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> a = &#123;len1, len2, len3&#125;;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(a);</span><br><span class="line">		<span class="keyword">if</span> (a<span class="literal">[<span class="number">2</span>]</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="literal">false</span>; <span class="comment">// 避免四点重合的情况</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a<span class="literal">[<span class="number">0</span>]</span> != a<span class="literal">[<span class="number">1</span>]</span><span class="operator"> || </span>a<span class="literal">[<span class="number">0</span>]</span><span class="operator"> * </span><span class="number">2</span> != a<span class="literal">[<span class="number">2</span>]</span>) &#123;</span><br><span class="line">			return <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> get<span class="constructor">Len(<span class="params">int</span>[] <span class="params">a</span>, <span class="params">int</span>[] <span class="params">b</span>)</span> &#123;</span><br><span class="line">		return ((a<span class="literal">[<span class="number">0</span>]</span> - b<span class="literal">[<span class="number">0</span>]</span>)<span class="operator"> * </span>(a<span class="literal">[<span class="number">0</span>]</span> - b<span class="literal">[<span class="number">0</span>]</span>) + (a<span class="literal">[<span class="number">1</span>]</span> - b<span class="literal">[<span class="number">1</span>]</span>)<span class="operator"> * </span>(a<span class="literal">[<span class="number">1</span>]</span> - b<span class="literal">[<span class="number">1</span>]</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://leetcode.com/problems/palindromic-substrings/">LeetCode 647. Palindromic Substrings</a></p>
<p>Given a string, your task is to count how many palindromic substrings in this string.</p>
<p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p>
<blockquote>
<p>Input: “abc”<br>Output: 3<br>Explanation: Three palindromic strings: “a”, “b”, “c”.</p>
</blockquote>
<blockquote>
<p>Input: “aaa”<br>Output: 6<br>Explanation: Six palindromic strings: “a”, “a”, “a”, “aa”, “aa”, “aaa”.</p>
</blockquote>
<p>思路：求回文子串的个数，使用动归时边找边统计。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> PalindromicSubstrings &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test<span class="constructor">Result()</span> &#123;</span><br><span class="line">		String s = <span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(count<span class="constructor">Substrings(<span class="params">s</span>)</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="built_in">int</span> count<span class="constructor">Substrings(String <span class="params">s</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s<span class="operator"> == </span>null<span class="operator"> || </span>s.length<span class="literal">()</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">int</span> n = s.length<span class="literal">()</span>;</span><br><span class="line">		<span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span><span class="literal">[]</span> dp = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="identifier">n</span>]</span><span class="literal">[<span class="identifier">n</span>]</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">i</span>]</span> = <span class="number">1</span>;</span><br><span class="line">			++result;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span><span class="operator"> == </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span> + 1)</span>) &#123;</span><br><span class="line">					dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">i</span> + <span class="number">1</span>]</span> = <span class="number">1</span>;</span><br><span class="line">					++result;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">i</span> + <span class="number">1</span>]</span> = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> step = <span class="number">3</span>; step &lt;= n; ++step) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i + step &lt;= n; ++i) &#123;</span><br><span class="line">				<span class="built_in">int</span> j = i + step - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (dp<span class="literal">[<span class="identifier">i</span> + <span class="number">1</span>]</span><span class="literal">[<span class="identifier">j</span> - <span class="number">1</span>]</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">					dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">j</span>]</span> = <span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s.<span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span><span class="operator"> == </span>s.<span class="built_in">char</span><span class="constructor">At(<span class="params">j</span>)</span>) &#123;</span><br><span class="line">						dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">j</span>]</span> = <span class="number">1</span>;</span><br><span class="line">						++result;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						dp<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">[<span class="identifier">j</span>]</span> = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<p><a href="https://leetcode.com/problems/increasing-subsequences/">LeetCode 491. Increasing Subsequences</a></p>
<p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .</p>
<blockquote>
<p>Example:<br>Input: [4, 6, 7, 7]<br>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]</p>
</blockquote>
<p>思路：使用 DFS 以及 visited 数组去重。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> IncreasingSubsequences &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> testResult() &#123;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">		List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; list = findSubsequences(nums);</span><br><span class="line">		<span class="keyword">for</span> (List&lt;<span class="type">Integer</span>&gt; subList : list) &#123;</span><br><span class="line">			subList.<span class="keyword">forEach</span>(i -&gt; <span class="keyword">System</span>.<span class="keyword">out</span>.print(i + &quot; &quot;));</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; findSubsequences(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; list = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;<span class="type">Integer</span>&gt; subList = <span class="built_in">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		getSubList(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, subList, list);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private <span class="type">void</span> getSubList(<span class="type">int</span>[] nums, <span class="type">int</span> head, <span class="type">int</span> tail, List&lt;<span class="type">Integer</span>&gt; subList, List&lt;List&lt;<span class="type">Integer</span>&gt;&gt; list) &#123;</span><br><span class="line">		<span class="keyword">if</span> (subList.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			list.<span class="keyword">add</span>(<span class="built_in">new</span> ArrayList&lt;&gt;(subList));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">Set</span>&lt;<span class="type">Integer</span>&gt; visited = <span class="built_in">new</span> HashSet&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = head; i &lt;= tail; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (visited.contains(nums[i])) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			visited.<span class="keyword">add</span>(nums[i]);</span><br><span class="line">			<span class="keyword">if</span> (subList.size() == <span class="number">0</span> || nums[i] &gt;= subList.<span class="keyword">get</span>(subList.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">				subList.<span class="keyword">add</span>(nums[i]);</span><br><span class="line">				getSubList(nums, i + <span class="number">1</span>, tail, subList, list);</span><br><span class="line">				subList.remove(subList.size() - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://dzone.com/articles/database-caching-with-redis-and-java">Database Caching With Redis and Java</a></p>
<p>我们对缓存的要求主要有两点：</p>
<ul>
<li>缓存部分数据，等待命中；</li>
<li>保持缓存跟 DB 的数据一致性。</li>
</ul>
<ol>
<li>主要解释了数据库的几种缓存策略：<ol>
<li>Read-Through Caching Strategy（直读缓存机制）。优先从缓存中读取，若没取到，则查 DB，同时将查到的数据在缓存中存一份。特点：适合读任务多的场景。比如新闻网站等的数据，会被大量阅读而不是修改。第一次从缓存中取数据时常常会失败，开发者可以考虑提前缓存一部分可能的热点数据。</li>
<li>Write-Through Caching Strategy（直写缓存机制）。优先写入缓存，然后立即再写入 DB。</li>
<li>Write-Behind Caching Strategy（写回缓存机制）。优先写入缓存，延后写回 DB 中。适合于写任务多的场景。特点：通常是由数据被替换出缓存时，才会被写到 DB 中；缺点：一旦断点，数据无法找回。</li>
</ol>
</li>
<li>使用 Redisson 作为客户端的缓存操作（其将数据放入 Map 中）。<ol>
<li>直读缓存机制中，若缓存未命中，则会通过<code>MapLoader</code>对象进行载入；</li>
<li>直写缓存机制中，只有当缓存跟 DB 的数据都被<code>MapWriter</code>对象更新完成之后，才会退出 update 方法。</li>
<li>写回缓存机制中，同样使用<code>MapWriter</code>接口来完成异步更新，可以设置<code>writeBehindThreads </code>参数来表示执行写操作的线程数量。</li>
</ol>
</li>
<li>总结：Redisson 中的<code>RMap</code>,<code>RMapCache</code>,<code> RLocalCachedMap</code>,<code>RLocalCachedMapCache</code>四个对象都支持上述策略，后两者的读操作更快一些。</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>今天分享一个在 Mac 电脑上使用 workflow （也叫自动操作）功能的实践。</p>
<p><strong>自动化你的工作很重要！！</strong></p>
<p>效果：自动改变图片分辨率，主要用来应对图片尺寸过大的问题。<br>步骤：</p>
<ol>
<li>设置 workflow，如下图：</li>
</ol>
<p><img src="/2019/04/02/ARTS-3/1.png"></p>
<p>说明：将图片拖入 pics 文件夹中，此 workflow 会将图片缩放到1440像素，然后处理后的图片会在桌面上出现。上面的文件夹名称跟像素都可以按个人喜好设置。</p>
<ol start="2">
<li>如果需要修改此 workflow，如下图，在你的 pics 文件夹处右键，进入“文件夹操作设置”，就可以继续修改自定义的 workflow 了。</li>
</ol>
<p><img src="/2019/04/02/ARTS-3/2.png"></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是最近写的一份代码实现，主要是关于类加载过程解读的，请点击下方链接查看：</p>
<p><a href="http://likehui.fun/2019/04/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">自定义一个类加载器代码实现</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(4)</title>
    <url>/2019/04/11/ARTS-4/</url>
    <content><![CDATA[<h1 id="ARTS-第四周分享"><a href="#ARTS-第四周分享" class="headerlink" title="ARTS 第四周分享"></a>ARTS 第四周分享</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">力扣 24. 两两交换链表中的节点</a></p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<blockquote>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
</blockquote>
<p>核心思路：为整个链表增加一个头结点，这样一来可以避免 head 的特殊处理了。其他部分很简单不赘述。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 两两交换链表中的节点 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">		node4.next = <span class="literal">null</span>;</span><br><span class="line">		node3.next = node4;</span><br><span class="line">		node2.next = node3;</span><br><span class="line">		node1.next = node2;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">Head</span> <span class="operator">=</span> swapPairs(node1);</span><br><span class="line">		<span class="keyword">while</span> (Head != <span class="literal">null</span>) &#123;</span><br><span class="line">			System.out.print(Head.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">			Head = Head.next;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> root;</span><br><span class="line">		pre.next = head;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> pre.next;</span><br><span class="line">		<span class="keyword">if</span> (current == <span class="literal">null</span> || current.next == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> current;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> current.next;</span><br><span class="line">		<span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="type">ListNode</span> <span class="variable">newCurr</span> <span class="operator">=</span> next.next;</span><br><span class="line">			next.next = current;</span><br><span class="line">			current.next = newCurr;</span><br><span class="line">			pre.next = next;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 移位</span></span><br><span class="line">			pre = current;</span><br><span class="line">			current = newCurr;</span><br><span class="line">			<span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			next = current.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> root.next;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Definition for singly-linked list.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		ListNode next;</span><br><span class="line"></span><br><span class="line">		ListNode(<span class="type">int</span> x) &#123;</span><br><span class="line">			val = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p> <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">力扣 594 最长和谐子序列</a></p>
<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p><strong>示例 1:</strong></p>
<blockquote>
<p>输入: [1,3,2,2,5,2,3,7]<br>输出: 5<br>原因: 最长的和谐数组是：[3,2,2,2,3].</p>
</blockquote>
<p><strong>说明:</strong> 输入的数组长度最大不超过20,000.</p>
<p>思路：很简单，统计所有元素及出现次数，因为限制最大最小元素差是1，那么将所有相邻和拿出来就 ok 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 最长和谐子序列 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> findLHS(nums);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLHS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">		Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(num))&#123;</span><br><span class="line">				map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				map.put(num,<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:map.keySet())&#123;</span><br><span class="line">			<span class="keyword">if</span>(map.containsKey(i+<span class="number">1</span>))&#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> map.get(i)+map.get(i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(temp&gt;max)&#123;</span><br><span class="line">					max = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(max &gt;Integer.MIN_VALUE)&#123;</span><br><span class="line">			<span class="keyword">return</span> max;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p> <a href="https://leetcode-cn.com/problems/rabbits-in-forest/">力扣781. 森林中的兔子</a></p>
<p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p>
<p>返回森林中兔子的最少数量。</p>
<blockquote>
<p>示例:<br>输入: answers &#x3D; [1, 1, 2]<br>输出: 5<br>解释:<br>两只回答了 “1” 的兔子可能有相同的颜色，设为红色。<br>之后回答了 “2” 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 “2” 的兔子为蓝色。<br>此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。<br>因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</p>
</blockquote>
<blockquote>
<p>输入: answers &#x3D; [10, 10, 10]<br>输出: 11</p>
</blockquote>
<blockquote>
<p>输入: answers &#x3D; []<br>输出: 0</p>
</blockquote>
<p>思路：统计每个数字出现的次数，然后比较次数跟 key+1的大小，执行不同的逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> class 森林中的兔子 &#123;</span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//    int[] answers = &#123;1, 1, 2&#125;;</span></span><br><span class="line">      <span class="type">int</span>[] answers = &#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> numRabbits(answers);</span><br><span class="line">      System.out.println(result);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRabbits</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">         <span class="keyword">if</span> (map.containsKey(num)) &#123;</span><br><span class="line">            map.put(num, map.get(num) + <span class="number">1</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> key : map.keySet()) &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">         <span class="keyword">while</span> (value &gt; key + <span class="number">1</span>) &#123;</span><br><span class="line">            result += key + <span class="number">1</span>;</span><br><span class="line">            value -= key + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (value &lt;= key + <span class="number">1</span>) &#123;</span><br><span class="line">            result += key + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享 ZGC 的一篇文章<br>原文地址：<a href="http://dinfuehr.github.io/blog/a-first-look-into-zgc/">A FIRST LOOK INTO ZGC</a><br>解读地址：本站另一处，点击查看：<a href="http://likehui.fun/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/">ZGC 特性解读</a></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ol>
<li>mac 上压缩时默认使用 UTF-8，拿到的 zip 文件放到 windows 平台下，文件名都是乱码，这时候要么使用另外的压缩软件进行重新压缩，要么直接将 zip 后缀改成 rar 后缀，这样就可以避免编码问题。</li>
<li>进入<a href="http://xxfox.perfma.com/jvm/query">JVM命令查询网站</a>，可以在线查询 JVM 调参各项命令，简单易用。</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是我用 Wireshark 进行网络抓包测试，学习 Http、Tcp 等网络协议的实战。</p>
<p>地址在本站另一处，点击查看：<a href="http://likehui.fun/2019/04/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%8A%93%E5%8C%85%E5%A4%A7%E4%BD%9C%E6%88%98/">网络协议之抓包大作战</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(5)</title>
    <url>/2019/04/18/ARTS-5/</url>
    <content><![CDATA[<h1 id="ARTS-第五周"><a href="#ARTS-第五周" class="headerlink" title="ARTS 第五周"></a>ARTS 第五周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">力扣 121. 买卖股票的最佳时机</a></p>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意你不能在买入股票前卖出股票。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [7,1,5,3,6,4]</span></span><br><span class="line"><span class="section">输出: 5</span></span><br><span class="line"><span class="section">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span></span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">输入: [7,6,4,3,1]</span></span><br><span class="line"><span class="section">输出: 0</span></span><br><span class="line"><span class="section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span></span><br></pre></td></tr></table></figure>

<p>思路：DP，维护一个数组，记录到 i 为止，利润的最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 买卖股票的最佳时机 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//		int[] prices = &#123;7, 1, 5, 3, 6, 4&#125;;</span></span><br><span class="line">		<span class="type">int</span>[] prices = &#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> maxProfit(prices);</span><br><span class="line">		System.out.println(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span> || prices.length == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">		<span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">		dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">				min = prices[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (prices[i] - min &gt; dp[i - <span class="number">1</span>]) &#123;</span><br><span class="line">				dp[i] = prices[i] - min;</span><br><span class="line">			&#125;</span><br><span class="line">			max = Math.max(max, dp[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p> <a href="https://leetcode-cn.com/problems/tenth-line/">力扣 195. 第十行</a></p>
<p>给定一个文本文件 <code>file.txt</code>，请只打印这个文件中的第十行。</p>
<p><strong>示例:</strong></p>
<p>假设 <code>file.txt</code> 有如下内容：</p>
<blockquote>
<p>Line 1<br>Line 2<br>Line 3<br>Line 4<br>Line 5<br>Line 6<br>Line 7<br>Line 8<br>Line 9<br>Line 10</p>
</blockquote>
<p>你的脚本应当显示第十行：</p>
<blockquote>
<p>Line 10</p>
</blockquote>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># <span class="keyword">Read</span> from the <span class="keyword">file</span> <span class="keyword">file</span>.txt <span class="keyword">and</span> output the tenth line <span class="keyword">to</span> stdout.</span><br><span class="line">sed <span class="string">&#x27;10!d&#x27;</span> <span class="keyword">file</span>.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>英文原文：<a href="https://dzone.com/articles/creating-a-springboot-configuration-server-using-d">Creating a Spring Boot Configuration Server Using a Database</a></p>
<p>总结如下：</p>
<ol>
<li><p>一般可以使用”文件系统”或者 git repository 作为配置信息的存储位置(configuration server)，使用数据库存储配置信息也是可行的。使用数据库来配置的特点是：</p>
<ol>
<li>更少的安全性问题；</li>
<li>DB 中数据修改容易；</li>
</ol>
</li>
<li><p>配置步骤：</p>
<ol>
<li><p>配置<code>pom.xml</code>文件。</p>
<ol>
<li>关键是<code>spring-cloud-config-server</code>，然后配置自己的 database driver 依赖。</li>
</ol>
</li>
<li><p>DB 中的表格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE my_properties </span><br><span class="line">  ( </span><br><span class="line">     application VARCHAR(200), </span><br><span class="line">     profile     VARCHAR(200), </span><br><span class="line">     label       VARCHAR(200), </span><br><span class="line">     KEY         VARCHAR(200), </span><br><span class="line">     value       VARCHAR(200) </span><br><span class="line">  )</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>关键：配置<code>application.yml</code>文件</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">spring</span><span class="punctuation">:</span></span><br><span class="line">  <span class="attribute">cloud</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">config</span><span class="punctuation">:</span></span><br><span class="line">      <span class="attribute">server</span><span class="punctuation">:</span></span><br><span class="line">        <span class="attribute">jdbc</span><span class="punctuation">:</span></span><br><span class="line">          <span class="attribute">sql</span><span class="punctuation">:</span> <span class="string">SELECT KEY, VALUE from  MY_PROPERTIES where APPLICATION=? and PROFILE=? and LABEL=?</span></span><br><span class="line">          <span class="attribute">order</span><span class="punctuation">:</span> <span class="string">1 </span></span><br><span class="line">  <span class="attribute">datasource</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">url</span><span class="punctuation">:</span> <span class="string">&lt;your db url here&gt;</span></span><br><span class="line">    <span class="attribute">driver-class-name</span><span class="punctuation">:</span> <span class="string">&lt;your databases driver class here&gt;</span></span><br><span class="line">    <span class="attribute">username</span><span class="punctuation">:</span> <span class="string">&lt;your user to database&gt;</span></span><br><span class="line">    <span class="attribute">password</span><span class="punctuation">: </span></span><br><span class="line">    <span class="attribute">hikari</span><span class="punctuation">:</span></span><br><span class="line">      <span class="attribute">maximum-pool-size</span><span class="punctuation">:</span> <span class="string">10</span></span><br><span class="line">      <span class="attribute">connection-timeout</span><span class="punctuation">:</span> <span class="string">5000</span></span><br><span class="line">  <span class="attribute">profiles</span><span class="punctuation">:</span></span><br><span class="line">    <span class="attribute">active</span><span class="punctuation">:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">jdbc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<p>##Tip</p>
<p>推荐小程序：offerShow，在线比较校招工资，美滋滋~</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本次分享文章在本站另一处： <a href="http://likehui.fun/2019/04/10/Redis-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/">Redis 源码解读(1)</a>，Redis 的源码较多，将分多篇博客逐步解析。</p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(6)</title>
    <url>/2019/04/26/ARTS-6/</url>
    <content><![CDATA[<h1 id="ARTS-第六周"><a href="#ARTS-第六周" class="headerlink" title="ARTS 第六周"></a>ARTS 第六周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/reverse-string-ii/">力扣 541. 反转字符串 II</a></p>
<p>给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。</p>
<p><strong>示例:</strong></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">输入: <span class="attr">s</span> = <span class="string">&quot;abcdefg&quot;</span>, <span class="attr">k</span> = <span class="number">2</span></span><br><span class="line">输出: <span class="string">&quot;bacdfeg&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>要求:</strong></p>
<ol>
<li>该字符串只包含小写的英文字母。</li>
<li>给定字符串的长度和 k 在[1, 10000]范围内。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 反转字符串 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> reverseStr(s, <span class="number">3</span>);</span><br><span class="line">		System.out.println(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		ans = reverseAll(s, ans, k);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">reverseAll</span><span class="params">(String s, String ans, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> s;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">		<span class="keyword">while</span> (n &gt;= k) &#123;</span><br><span class="line">			ans += reverse(s, k);</span><br><span class="line">			<span class="keyword">if</span> (n &lt;= <span class="number">2</span> * k) &#123;</span><br><span class="line">				ans += s.substring(k);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				ans += s.substring(k, <span class="number">2</span> * k);</span><br><span class="line">			&#125;</span><br><span class="line">			s = s.substring(<span class="number">2</span> * k);</span><br><span class="line">			n = s.length();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; k) &#123;</span><br><span class="line">			ans += reverse(s, n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">reverse</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">reverseStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			reverseStr += s.substring(i, i + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> reverseStr;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>英文原文：<a href="https://www.quora.com/What-are-the-advantages-of-DAG-directed-acyclic-graph-execution-of-big-data-algorithms-over-MapReduce-I-know-that-Apache-Spark-Storm-and-Tez-use-the-DAG-execution-model-over-MapReduce-Why-Are-there-any-disadvantages">What are the advantages of DAG execution of big data algorithms over MapReduce?</a></p>
<p>引申文章：<a href="https://www.quora.com/What-are-the-Apache-Spark-concepts-around-its-DAG-Directed-Acyclic-Graph-execution-engine-and-its-overall-architecture">What are the Apache Spark concepts around its DAG execution engine, and its overall architecture?</a> Spark 中的 DAG 引擎：</p>
<p>两篇文章主要讲了 DAG 算法在 Hadoop、Spark、Storm 中的应用。</p>
<p>总结：</p>
<ol>
<li>简介 MapReduce，以及不使用 DAG 可能出现的后果：<ol>
<li>MapReduce 的工作分为三步：① 从 HDFS 中读取数据；② 进行 Map 和 Reduce 操作；③ 计算结果写回 HDFS。</li>
<li>每个 MapReduce 相互独立，Hadoop 也不论多个 MapReduce 的先后顺序。</li>
<li>存在浪费 HDFS 的情况：若两个 MapReduce 的数据读取相互无关，那么使用 HDFS 就是对磁盘的浪费。</li>
<li>存在耗时长的情况：稍微复杂的计算可能需要大量的时间，即使数据量很少的情况，因为有些操作需要等上一步全部完成后，才开始执行。</li>
</ol>
</li>
<li>DAG （有向无环图）不是 MapReduce 专属，它的应用要更广泛一些。</li>
<li>在处理多 jobs 时（让它们 serialize 或 parallelize 时），DAG 是很合适的。</li>
<li>在 Spark 中，DAG 发挥着同样重要的作用，相比之下，Hadoop 在使用时存在严重的磁盘负担(Spark 是依赖内存的)。<ol>
<li><code>Spark RDD</code> 是只读可分区的分布式数据集，是 Spark 中的重要概念。</li>
<li>在 Spark 中，Spark RDD 被<code>DAG scheduler</code>划分为多个 stages（比如map操作会被放进一个 stage 中），每个 stage 被分为多个 tasks。</li>
<li>不同的 stages 会经由<code>cluster manager</code>交付给<code>Task Scheduler</code>，但这些 stages 的依赖关系对于<code>Task Scheduler</code>是透明度。</li>
<li>Spark 使用”连续计算的方式”，对任务的执行进行了优化（主要是手动调整了 MapReduce 任务的执行步骤），尽量减少移动数据的次数。</li>
<li><code>RDD transformation</code>函数能分为<code> narrow transformation</code> 跟<code>wide transformation</code>两种用法。前者不需要跨 stage 移动数据(比如 <code>map()</code>,<code>filter()</code>)，后者则可能需要跨 stage(比如<code>reduceByKey()</code>)。<ol>
<li><code>RDD transformation</code>的意思就是在一些 RDD 中执行一些数据操作，来产生一个或多个新的 RDD。</li>
<li>每个 RDD 都会维护一个指向<code>parent RDD</code>的指针，比如<code> b=a.map()</code>，b 就会指向 a。</li>
</ol>
</li>
</ol>
</li>
<li>Storm 在某一确定时刻只处理少量数据，DAG 在其中使代码模块化，避免大量的 if-else 语句。</li>
</ol>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>今天分享一下手机上的”训练”功能，省时省心。</p>
<p>小米手机上一般使用小爱同学只能够查天气、定闹钟以及简单的打开 app 的功能，一旦想实现一些比较高级的操作比如：打开虾米音乐我的收藏中随机播放歌曲，就需要用到”训练”功能了。</p>
<p>做法：添加一些语音激活关键词，然后把我的个人操作进行录屏。以后只需要向小爱同学发出指令，小爱同学会自动完成剩下的操作。</p>
<p>最佳实践：播放第三方 app 上的音乐、keep 跑步、查看淘宝快递、各种 app 的每日签到等。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享的是位图这种数据结构的特性，文章在本站另一处，点击查看：</p>
<p><a href="http://likehui.fun/2019/04/27/BitMap-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/">BitMap 特性解读</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(7)</title>
    <url>/2019/05/03/ARTS-7/</url>
    <content><![CDATA[<h1 id="ARTS-第七周"><a href="#ARTS-第七周" class="headerlink" title="ARTS 第七周"></a>ARTS 第七周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/word-search/">力扣 79. 单词搜索</a></p>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p><strong>示例:</strong></p>
<blockquote>
<p>board &#x3D;<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]</p>
</blockquote>
<blockquote>
<p>给定 word &#x3D; “ABCCED”, 返回 true.<br>给定 word &#x3D; “SEE”, 返回 true.<br>给定 word &#x3D; “ABCB”, 返回 false.</p>
</blockquote>
<p>思路：DFS 的解法，发现匹配即返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 单词搜索 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[][] visited;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] X = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] Y = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">char</span>[][] board = &#123;&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;, &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;, &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;&#125;;</span><br><span class="line">		<span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;ABCB&quot;</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> exist(board, word);</span><br><span class="line">		System.out.println(result); <span class="comment">// expect false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">char</span>[][] board = &#123;&#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>&#125;, &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;A&#x27;</span>&#125;, &#123;<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>&#125;&#125;;</span><br><span class="line">		<span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;AAB&quot;</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> exist(board, word);</span><br><span class="line">		System.out.println(result); <span class="comment">//expect true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">char</span>[][] board = &#123;&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;, &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;, &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;&#125;;</span><br><span class="line">		<span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> <span class="string">&quot;ABCESEEEFS&quot;</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> exist(board, word);</span><br><span class="line">		System.out.println(result); <span class="comment">//expect true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">		<span class="type">char</span> <span class="variable">head</span> <span class="operator">=</span> word.charAt(<span class="number">0</span>);</span><br><span class="line">		n = board.length;</span><br><span class="line">		m = board[<span class="number">0</span>].length;</span><br><span class="line">		<span class="type">boolean</span> result;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				visited = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">				<span class="keyword">if</span> (board[i][j] == head) &#123;</span><br><span class="line">					<span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">					temp += head;</span><br><span class="line">					visited[i][j] = <span class="number">1</span>;</span><br><span class="line">					<span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">					result = DFS(board, i, j, word, temp, depth);</span><br><span class="line">					<span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">DFS</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y, String word, String temp, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (word.equals(temp)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.length() &gt; word.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 剪枝</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + X[i];</span><br><span class="line">			<span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + Y[i];</span><br><span class="line">			<span class="keyword">if</span> (visited(newX, newY) == <span class="literal">true</span> &amp;&amp; board[newX][newY] == word.charAt(depth + <span class="number">1</span>)) &#123;</span><br><span class="line">				visited[newX][newY] = <span class="number">1</span>;</span><br><span class="line">				temp += board[newX][newY];</span><br><span class="line">				<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> DFS(board, newX, newY, word, temp, depth + <span class="number">1</span>);</span><br><span class="line">				temp = temp.substring(<span class="number">0</span>, temp.length() - <span class="number">1</span>); <span class="comment">// 关键步骤，temp 删尾</span></span><br><span class="line">				visited[newX][newY] = <span class="number">0</span>; <span class="comment">// 关键步骤，visited 状态清空</span></span><br><span class="line">				<span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断边界以及是否已被访问</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">visited</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || j &lt; <span class="number">0</span> || j &gt;= m) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (visited[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周阅读英文：<a href="https://javarevisited.blogspot.com/2017/12/top-5-courses-to-learn-big-data-and.html#ixzz5mvSoslAl">Top 5 Big Data and Apache Spark Courses for Java Developers to Learn Online in 2019</a></p>
<p>文中指出 Spark 比之 Hadoop 效率要更高，并且推荐了五门课程：</p>
<ol>
<li>推荐：<a href="https://click.linksynergy.com/fs-bin/click?id=JVFxdTr9V80&subid=0&offerid=323058.1&type=10&tmpid=14538&RD_PARM1=https://www.udemy.com/apache-spark-course-with-java/">Apache Spark with Java - Learn Spark from a Big Data Guru</a></li>
<li><a href="https://javarevisited.blogspot.com/2017/12/top-5-courses-to-learn-big-data-and.html#ixzz5mvTZTyGZ">Apache Spark with Scala - Learn Spark from a Big Data Guru</a></li>
<li>推荐：<a href="https://www.pluralsight.com/courses/apache-spark-fundamentals?clickid=0rjWZJ1GkxyJTu60OGSitWCIUkl1QHXym20yXE0&irgwc=1&mpid=1193463&utm_source=impactradius&utm_medium=digital_affiliate&utm_campaign=1193463&aid=7010a000001xAKZAA2">Apache Spark Fundamentals</a></li>
<li><a href="https://javarevisited.blogspot.com/2017/12/top-5-courses-to-learn-big-data-and.html">Big Data: The Big Picture By Pluralsight</a></li>
<li>推荐：<a href="https://javarevisited.blogspot.com/2017/12/top-5-courses-to-learn-big-data-and.html#ixzz5mvUoyGij">Apache Spark 2.0 + Java : DO Big Data Analytics &amp; ML</a></li>
</ol>
<p>不定时更新学习内容</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>一点心得：还是要有月计划，不然容易被琐事打乱节奏。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>本周分享机器学习平台 PAI 入门，参考本站文章，点击：<a href="http://likehui.fun/2019/05/09/ali-PAI-1/">Ali 机器学习平台 PAI</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(8)</title>
    <url>/2019/05/14/ARTS-8/</url>
    <content><![CDATA[<h1 id="ARTS-第八周"><a href="#ARTS-第八周" class="headerlink" title="ARTS 第八周"></a>ARTS 第八周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/smallest-range-ii/">力扣 910. 最小差值 II</a></p>
<p>给定一个整数数组 <code>A</code>，对于每个整数 <code>A[i]</code>，我们可以选择 <strong>x &#x3D; -K 或是 x &#x3D; K</strong>，并将 <code>x</code> 加到 <code>A[i]</code> 中。</p>
<p>在此过程之后，我们得到一些数组 <code>B</code>。</p>
<p>返回 <code>B</code> 的最大值和 <code>B</code> 的最小值之间可能存在的最小差值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：A = <span class="comment">[1]</span>, K = 0</span><br><span class="line">输出：0</span><br><span class="line">解释：B = <span class="comment">[1]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：A = <span class="comment">[0,10]</span>, K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：B = <span class="comment">[2,8]</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">输入：A = <span class="comment">[1,3,6]</span>, K = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：B = <span class="comment">[4,6,3]</span></span><br></pre></td></tr></table></figure>



<p>思路：划分左右区间，然后枚举分界点的位置，找到最小差值，详细看代码注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里把中文标题当作类名只是为了方便使用，class 名称不建议使用中文</span></span><br><span class="line"><span class="keyword">public</span> class 最小差值II &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] A = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> smallestRangeII(A, K);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestRangeII</span><span class="params">(<span class="type">int</span>[] A, <span class="type">int</span> K)</span> &#123;</span><br><span class="line">		Arrays.sort(A);</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> A[n - <span class="number">1</span>] - A[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 按 i 的位置划分左右区间，左区间元素全部+K，右区间元素全部-K</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(A[<span class="number">0</span>] + K, A[i] - K); <span class="comment">// 左右区间的最小值选最小</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(A[i - <span class="number">1</span>] + K, A[n - <span class="number">1</span>] - K);</span><br><span class="line">			result = Math.min(result, max - min);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>本周分享英文文章为：<a href="https://dev.to/softchris/weekend-read-serverless-docker-kubernetes-56co">Weekend read, Serverless, Docker, Kubernetes</a></p>
<p>解读见本站另一篇文章：<a href="http://likehui.fun/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">K8s 入门笔记</a></p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><ol>
<li>在印象笔记的笔记本中，将各条笔记按照标题分类，如下图：</li>
</ol>
<p><img src="/2019/05/14/ARTS-8/1.png"></p>
<p>能明显提高工作效率和条理性。</p>
<ol start="2">
<li>在笔记中，特意增加一页”解惑”，把每天遇到的难题记录下来，抽空用来咨询公司其他老司机，把自己的思路和答案写在后面。</li>
</ol>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>分享内容见本站另一篇文章，点链接：<a href="http://likehui.fun/2019/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%90%8D%E8%AF%8D%E8%BE%A8%E6%9E%90/">深度学习名词辨析</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>ARTS(9)</title>
    <url>/2019/05/18/ARTS-9/</url>
    <content><![CDATA[<h1 id="ARTS-第九周"><a href="#ARTS-第九周" class="headerlink" title="ARTS 第九周"></a>ARTS 第九周</h1><blockquote>
<p>每周完成一个ARTS（也就是 Algorithm、Review、Tip、Share 简称ARTS）： </p>
<ol>
<li>每周至少做一个 leetcode 的算法题</li>
<li>阅读并点评至少一篇英文技术文章</li>
<li>学习至少一个技术技巧</li>
<li>分享一篇有观点和思考的技术文章。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p> <a href="https://leetcode-cn.com/problems/minimum-time-difference/">力扣 539. 最小时间差</a></p>
<p>给定一个 24 小时制（小时:分钟）的时间列表，找出列表中任意两个时间的最小时间差并已分钟数表示。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">输入: <span class="selector-attr">[<span class="string">&quot;23:59&quot;</span>,<span class="string">&quot;00:00&quot;</span>]</span></span><br><span class="line">输出: <span class="number">1</span></span><br></pre></td></tr></table></figure>


<p><strong>备注:</strong></p>
<ol>
<li>列表中时间数在 2~20000 之间。</li>
<li>每个时间取值在 00:00~23:59 之间。</li>
</ol>
<p>思路：1. 先转为分钟数；2. 将最小时间增加 1440 分钟后也加入比较（跟当前最大时间比较，取得差值）；3. 比较相邻时间的差值，选择出最小的差值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里把中文标题当作类名只是为了方便使用，class 名称不建议使用中文</span></span><br><span class="line"><span class="keyword">public</span> class 最小时间差 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;String&gt; timePoints = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		timePoints.add(<span class="string">&quot;23:59&quot;</span>);</span><br><span class="line">		timePoints.add(<span class="string">&quot;00:00&quot;</span>);</span><br><span class="line">		<span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> findMinDifference(timePoints);</span><br><span class="line">		Assert.assertEquals(result, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> timePoints.size();</span><br><span class="line">		<span class="type">int</span>[] minutes = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> timePoints.get(i);</span><br><span class="line">			<span class="type">String</span> <span class="variable">clock</span> <span class="operator">=</span> temp.substring(<span class="number">0</span>, temp.indexOf(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">			<span class="type">String</span> <span class="variable">minu</span> <span class="operator">=</span> temp.substring(temp.indexOf(<span class="string">&quot;:&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">			minutes[i] = Integer.parseInt(clock) * <span class="number">60</span> + Integer.parseInt(minu);</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(minutes);</span><br><span class="line">		<span class="type">int</span> <span class="variable">minDiff</span> <span class="operator">=</span> minutes[<span class="number">0</span>] + <span class="number">24</span> * <span class="number">60</span> - minutes[n - <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> minutes[i] - minutes[i - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">if</span> (diff &lt; minDiff) &#123;</span><br><span class="line">				minDiff = diff;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> minDiff;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="REVIEW"><a href="#REVIEW" class="headerlink" title="REVIEW"></a>REVIEW</h2><p>本周主要对官网上的 yarn 进行解读，原文地址：<a href="https://hadoop.apache.org/docs/current/hadoop-yarn/hadoop-yarn-site/YARN.html">Apache Hadoop YARN</a></p>
<p>解读：</p>
<ol>
<li>yarn 分布式资源管理系统，可以容纳多种计算框架，具备集群资源共享，资源弹性收缩功能。</li>
<li>yarn 是负责将<strong>资源管理</strong>和<strong>工作调度</strong>拆分成单独的守护进程的过程。对象是单独的 job 或者 DAG job.<ol>
<li>资源管理器 Resource Manager，负责最终的资源分配；</li>
<li>NodeManager，负责 container 的资源用度，并报告给 Resource Manager。</li>
<li>App Mstr 负责向 Resource Manager 申请资源。</li>
</ol>
</li>
</ol>
<p><img src="/2019/05/18/ARTS-9/1.png"></p>
<pre><code> 2. ResourceManager 有两个组分：scheduler 和 applicationManager。
      1. sheduler 专职负责定位资源，不理会当前 app 的status。比较常见的有：CapacityScheduler 和 FairScheduler。
      2. ApplicationManager 负责接受提交的 job，负责将执行 app 的第一个 container 指定为 ApplicaitonMaster，负责在 Failure 时重启 ApplicationMaster。ApplicationMaster 负责从 sheduler 申请合适的资源。
 3. yarn 支持资源预留（Resource reservation）的概念，为一些重要任务的**可预测执行**，申明某些资源的deadline。
 4. yarn 使用 Yarn 联合(yarn federation)的概念，将一些子集群扩大为更大的 yarn 集群，用于大型工作之中。
</code></pre>
<h2 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h2><p>。。。当程序员千万别认真，认真你就输了</p>
<p>还有，情绪管理很重要</p>
<h2 id="SHARE"><a href="#SHARE" class="headerlink" title="SHARE"></a>SHARE</h2><p>分享内容见本站另一篇文章，点链接：<a href="http://likehui.fun/2019/05/22/Flink-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/">Flink 入门笔记(1)</a></p>
]]></content>
      <categories>
        <category>ARTS</category>
      </categories>
      <tags>
        <tag>ARTS</tag>
      </tags>
  </entry>
  <entry>
    <title>Aoot examination</title>
    <url>/2018/11/13/Aoot-examination/</url>
    <content><![CDATA[<h1 id="aoot-examination"><a href="#aoot-examination" class="headerlink" title="aoot examination"></a>aoot examination</h1><h4 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1. 接口和抽象类的区别"></a>1. 接口和抽象类的区别</h4><ul>
<li>接口是对动作的抽象（这个对象能做什么），抽象类是对根源的抽象（这个对象是什么）。</li>
<li>两者都不能直接实例化，对接口实例化时，接口变量必须指向一个类对象（此类对象必须实现了所有的接口方法）；对抽象类实例化时，抽象类变量必须指向一个子类对象（此子类对象必须实现了所有的抽象方法）。注：如果方法不能全部被类 A 实现，那么类 A 必然是抽象类。</li>
<li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。</li>
<li>抽象方法要被实现，所以不能是静态的，也不能是私有的。</li>
</ul>
<span id="more"></span>

<h4 id="2-嵌套类，内部类的概念"><a href="#2-嵌套类，内部类的概念" class="headerlink" title="2. 嵌套类，内部类的概念"></a>2. 嵌套类，内部类的概念</h4><ul>
<li>嵌套类：一个类的内部定义另一个类，就是嵌套类。分为静态（使用较少）和非静态两种。</li>
<li>内部类：指非静态嵌套类。分为成员内部类、静态嵌套类、方法内部类、匿名内部类。</li>
</ul>
<p>注：对于静态嵌套类，因为其中的所有成员和方法都默认是静态的，所以无法访问外部类中的非静态成员，由此静态嵌套类使用受限。</p>
<h4 id="3-javadoc-标签哪些是类前面的，哪些是方法前面了？"><a href="#3-javadoc-标签哪些是类前面的，哪些是方法前面了？" class="headerlink" title="3. javadoc 标签哪些是类前面的，哪些是方法前面了？"></a>3. javadoc 标签哪些是类前面的，哪些是方法前面了？</h4><ol>
<li>类注释的标签有：author、version、</li>
<li>方法注释的标签有：param、return、throws、exception</li>
<li>通用：see 引用、since 描述文本（支持哪个 jdk 版本）、deprecated、link（链接文档用）</li>
</ol>
<h4 id="4-防御性编程："><a href="#4-防御性编程：" class="headerlink" title="4. 防御性编程："></a>4. 防御性编程：</h4><ul>
<li>目的：打造高质量的模块。</li>
<li>设计系统的每个组件，让其尽可能的<strong>保护</strong>自己。</li>
<li>预见在什么地方可能出现问题，然后创建一个环境来测试错误，<strong>当预见的问题出现的时候通知你，并执行一个你指定的损害控制动作</strong>。</li>
</ul>
<h4 id="5-overload-和-override-深刻理解"><a href="#5-overload-和-override-深刻理解" class="headerlink" title="5. overload 和 override 深刻理解"></a>5. overload 和 override 深刻理解</h4><ul>
<li>override，重写。子类对父类的允许访问的方法的实现过程进行重新编写，外壳完全不变，核心重写。<ul>
<li>不能抛出比原方法更宽泛的异常。原来抛 IOException，重写后只能抛 IOException 或其子类。</li>
<li>final 方法不能被重写。</li>
<li>static 方法不能被重写，但可以被重新声明。</li>
<li>构造方法不能被重写。</li>
</ul>
</li>
<li>overload，重载。一个类中，方法名字相同，而参数不同，返回类型可同可不同。<ul>
<li>必须改变参数列表；</li>
<li>访问修饰符可以改变；</li>
<li>可以声明更广的检查异常；</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
</li>
</ul>
<h4 id="6-Java-中哪些类型有兼容性，哪些类型没有兼容性？"><a href="#6-Java-中哪些类型有兼容性，哪些类型没有兼容性？" class="headerlink" title="6. Java 中哪些类型有兼容性，哪些类型没有兼容性？"></a>6. Java 中哪些类型有兼容性，哪些类型没有兼容性？</h4><p><a href="http://www.sohu.com/a/115257754_480118">java培训:基本数据类型之间的兼容性</a></p>
<blockquote>
<p>“小”的数据类型可以直接赋给“大”的数据类型。<br>“大”的不能赋值给“小”的数据类型(会出现编译错误)</p>
</blockquote>
<ul>
<li>整数类：long &gt; int &gt; short &gt; byte</li>
<li>浮点型：double &gt; float</li>
<li>整型数据类型可以赋给浮点数据类型</li>
<li>char 可以赋给 long 和 int ，但是不能赋给 short 和 byte (编译错误) 。</li>
<li>char 可以赋给float和double</li>
<li>当整数型常量在 0~65535 之间时，可以被赋值给 char 型变量</li>
<li>char 型常量可以被赋值给整数类变量，只要整数变量的类型可以容纳 char 型文字常量所表示的数值。</li>
<li>浮点型常量默认为 double 型，而 double 型常量不能赋值给 float 型变量。</li>
<li>boolean 与其他数据类型没有兼容性。</li>
</ul>
<h4 id="7-float-和-double-为什么不能用等号等号来比较。怎么比较？"><a href="#7-float-和-double-为什么不能用等号等号来比较。怎么比较？" class="headerlink" title="7. float 和 double 为什么不能用等号等号来比较。怎么比较？"></a>7. float 和 double 为什么不能用等号等号来比较。怎么比较？</h4><p><a href="https://blog.csdn.net/bupa900318/article/details/80553695">JAVA - 判断两个浮点数相等</a></p>
<blockquote>
<p>计算机表示浮点数( float 或 double 类型)都有一个精度限制，对于超出了精度限制的浮点数，计算机会把它们的精度之外的小数部分截断。因此，本来不相等的两个浮点数在计算机中可能就变成相等的了</p>
</blockquote>
<ol>
<li>设置误差精度</li>
<li>转换成字符串后使用 equals 方法比较，需要精度很高</li>
<li>转换成 Long 后使用<code>==</code>比较（即使用<code>Double.doubleToLongBits()</code>）</li>
<li>使用 BigDecimal 类型的 equals 方法或 compareTo 方法</li>
</ol>
<h4 id="8-volatile-和-synchronize-的区别？"><a href="#8-volatile-和-synchronize-的区别？" class="headerlink" title="8. volatile 和 synchronize 的区别？"></a>8. volatile 和 synchronize 的区别？</h4><p>分别是什么：</p>
<ol>
<li>volatile是一个变量修饰符，而synchronized是一个方法或块的修饰符。</li>
<li>一个声明为 volatile 类型的变量将在所有的线程中同步的获得数据，不论你在任何线程中更改了变量，其他的线程将立即得到同样的结果。所以 volatile 类型变量在性能上有所消耗。<ul>
<li>是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取（事实上并不确切）。</li>
<li>很多Java程序员认为volatile是让CPU直接访问主存来避免visibility问题, 这是错误的观点。其实Java里面volatile就是放了一个full memory fence（理解：强制将L1、L2刷入线程间的缓存，即多线程可见）等待 write buffer flush 到缓存系统处理结束。参考<a href="https://36kr.com/p/5037166.html">分布式系统一致性的发展历史（一）</a>中的解释。</li>
</ul>
</li>
<li>synchronized 获取和释放由监听器控制的锁，如果两个线程都使用一个监听器(即相同对象锁)，那么监听器可以强制在一个时刻只有一个线程能处理代码块，这是最一般的同步。另外，synchronized 还能使内存同步。在实际当中，synchronized 使得所有的线程内存与主内存相同步。<ul>
<li>本质是：锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住</li>
</ul>
</li>
<li>volatile 只能在线程内存和主内存之间同步一个（或多个，限于写 volatile 变量之前所有对共享变量的值的改变）变量的值，而 synchronized 则同步在线程内存和主内存之间的所有变量的值，并且通过锁住和释放监听器来实现。</li>
</ol>
<p>区别：</p>
<ol>
<li>volatile 是线程同步的轻量级实现，所以 volatile 的性能要比 synchronize 好；但 synchronize 的执行效率也不差；</li>
<li>多线程访问 volatile 不会发生阻塞；而 synchronize 会发生阻塞；</li>
<li>volatile 能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize 可以保证变量原子性；</li>
<li>volatile 是变量在多线程之间的可见性；synchronize 是多线程之间访问资源的同步性；</li>
<li>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ol>
<p> <br>对于 volatile 修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。</p>
<h4 id="9-mvn-x2F-git-x2F-Junit-的命令。"><a href="#9-mvn-x2F-git-x2F-Junit-的命令。" class="headerlink" title="9. mvn&#x2F;git&#x2F;Junit 的命令。"></a>9. mvn&#x2F;git&#x2F;Junit 的命令。</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mvn</span> compile</span><br><span class="line"><span class="keyword">mvn</span> test</span><br><span class="line"><span class="keyword">mvn</span> package</span><br><span class="line"><span class="keyword">mvn</span> clean</span><br><span class="line"><span class="keyword">mvn</span> install</span><br><span class="line"><span class="keyword">mvn</span> checkstyle:checkstyle</span><br><span class="line"><span class="keyword">mvn</span> test &gt; test.log</span><br><span class="line"><span class="keyword">mvn</span> cobertura:cobertura</span><br><span class="line"><span class="keyword">mvn</span> javadoc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> init 将目标编程 git 仓库</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增文件到仓库</span></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">add</span> readme.txt </span><br><span class="line"><span class="symbol">git</span> commit -m <span class="string">&quot;wrote a readme file&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> status 查看结果</span><br><span class="line"><span class="symbol">git</span> diff readme.txt 查看工作区与仓库中的区别</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> log 查看日志记录</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> reset --hard HEAD^  强力回退</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> origin master 推送最新修改</span><br><span class="line"></span><br><span class="line"><span class="symbol">git</span> clone </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="10-maven-的目录结构"><a href="#10-maven-的目录结构" class="headerlink" title="10. maven 的目录结构"></a>10. maven 的目录结构</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">src - main - java</span><br><span class="line"><span class="bullet">			 -</span> resources</span><br><span class="line"><span class="bullet">			 -</span> filters</span><br><span class="line"><span class="bullet">			 -</span> webapp</span><br><span class="line"><span class="bullet">	 -</span> test - java		</span><br><span class="line"><span class="bullet">			 -</span> resources</span><br><span class="line"><span class="bullet">			 -</span> filters</span><br><span class="line"><span class="bullet">	 -</span> it	  </span><br><span class="line"><span class="bullet">	 -</span> assembly </span><br><span class="line"><span class="bullet">	 -</span> site</span><br><span class="line">LICENSE.txt</span><br><span class="line">NOTICE.txt</span><br><span class="line">README.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="11-Java-的-IO-体系"><a href="#11-Java-的-IO-体系" class="headerlink" title="11. Java 的 IO 体系"></a>11. Java 的 IO 体系</h4><p>推荐阅读：<a href="http://www.cnblogs.com/fysola/p/6123947.html">Java IO 体系</a></p>
<p><img src="/2018/11/13/Aoot-examination/1.png" alt="1"></p>
<ol>
<li><p>字节流<br> InputStream、OutputStream：</p>
 <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">读取文本</span><br><span class="line">psvm()&#123;</span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;likehui.txt&quot;</span>); <span class="comment">// try-catch Exception</span></span><br><span class="line">	<span class="keyword">int</span> n = fis.<span class="keyword">read</span>();</span><br><span class="line">	sysout((<span class="keyword">char</span>)n); <span class="comment">// print 文本中第一个字符，比如“H”</span></span><br><span class="line">	fis.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制图片</span></span><br><span class="line">psvm()&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/main/resources/happy.png&quot;</span>);</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/main/resources/happy3.png&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">while</span>((n = fis.<span class="keyword">read</span>(b))!= -<span class="number">1</span>)&#123;</span><br><span class="line">			fos.<span class="keyword">write</span>(b,<span class="number">0</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		fis.close();</span><br><span class="line">		fos.close();</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>字符流</p>
<p> <img src="/2018/11/13/Aoot-examination/1.png" alt="1"></p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">略略略</span><br></pre></td></tr></table></figure>
</li>
<li><p>序列化</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 Goods 类实现了 Serializable接口</span></span><br><span class="line">psvm<span class="literal">()</span>&#123;</span><br><span class="line">	Goods gd001 = <span class="keyword">new</span> <span class="constructor">Goods(<span class="string">&quot;gd001&quot;</span>,0.2)</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		FileOutputStream fos = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">&quot;src/main/resources/imooc.txt&quot;</span>)</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">fos</span>)</span>;</span><br><span class="line">		FileInputStream fis = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">&quot;src/main/resources/imooc.txt&quot;</span>)</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">fis</span>)</span>;</span><br><span class="line">		oos.write<span class="constructor">Object(<span class="params">gd001</span>)</span>;</span><br><span class="line">		oos.write<span class="constructor">Boolean(<span class="params">true</span>)</span>;</span><br><span class="line">		oos.flush<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">		Goods goods = (Goods) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(goods);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(ois.read<span class="constructor">Boolean()</span>);</span><br><span class="line">		fos.close<span class="literal">()</span>;</span><br><span class="line">		oos.close<span class="literal">()</span>;</span><br><span class="line">		fis.close<span class="literal">()</span>;</span><br><span class="line">		ois.close<span class="literal">()</span>;</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">		e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">	&#125; catch (IOException e) &#123;</span><br><span class="line">		e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="12-decorate-pattern"><a href="#12-decorate-pattern" class="headerlink" title="12. decorate pattern"></a>12. decorate pattern</h4><p>装饰模式动态的将责任附加到对象上，若要扩展功能，装饰模式提供了比继承更有弹性的替代方案</p>
<h4 id="13-runtimeException-受检异常"><a href="#13-runtimeException-受检异常" class="headerlink" title="13. runtimeException 受检异常"></a>13. runtimeException 受检异常</h4><p>必须捕获或抛出：checkedException<br>允许忽略：不可查的 RuntimeException（含子类）和 Error（含子类）</p>
<ol>
<li>非检查异常，就是指编译器不要求强制处理的异常。一般指 RuntimeException 及其子类。</li>
<li>检查异常，就是编译器要求强制处理的异常。一般有：IO 异常、SQL 异常</li>
</ol>
<ul>
<li>RuntimeException 的子类：<ul>
<li>NullPointerException；</li>
<li>ArrayIndexOutOfBoundsException；</li>
<li>ArithmeticException；</li>
<li>ClassCastException。</li>
</ul>
</li>
</ul>
<h4 id="14-equals-hashcode-怎么实现的"><a href="#14-equals-hashcode-怎么实现的" class="headerlink" title="14. equals hashcode 怎么实现的"></a>14. equals hashcode 怎么实现的</h4><p>实现 equals 的方法：</p>
<ol>
<li>Use &#x3D;&#x3D; to see if argument is a reference to this (optimization)</li>
<li>Use instanceof to check if argument is of the correct type (properly handles null)</li>
<li>Cast the argument to the correct type</li>
<li>Check each “significant” field</li>
<li>Check reflexivity, symmetry, transitivity</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object obj)&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(!(obj instanceof Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	Person person = (Person)obj;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name.equals(person.name):</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现 hashCode 的方法：</p>
<ol>
<li>取一个非 0 的 int 作为初始值，比如 42，保存在 result 中。</li>
<li>计算你所关心的域（在 equals 起作用的）的 hashCode。如何生成属性的 hashCode 我们等一下再说，先假设生成的 hashCode 为 c。</li>
<li>组合所有的域，result &#x3D; 31 * result + c。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span><br><span class="line">    <span class="built_in">byte</span> b;</span><br><span class="line">    <span class="built_in">char</span> c;</span><br><span class="line">    <span class="built_in">short</span> s;</span><br><span class="line">    <span class="built_in">int</span> i;</span><br><span class="line">    <span class="built_in">long</span> l;</span><br><span class="line">    <span class="built_in">float</span> f;</span><br><span class="line">    <span class="built_in">double</span> d;</span><br><span class="line">    String <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">equals</span>(<span class="params">Object o</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        TestClass testClass = (TestClass) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b != testClass.b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c != testClass.c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != testClass.s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (i != testClass.i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (l != testClass.l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Float.compare(testClass.f, f) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (Double.compare(testClass.d, d) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span> != <span class="literal">null</span> ? <span class="built_in">string</span>.<span class="keyword">equals</span>(testClass.<span class="built_in">string</span>) : testClass.<span class="built_in">string</span> == <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">hashCode</span>()</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> result;</span><br><span class="line">        <span class="built_in">long</span> temp;</span><br><span class="line">        result = (<span class="built_in">int</span>) b;</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="built_in">int</span>) c;</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="built_in">int</span>) s;</span><br><span class="line">        result = <span class="number">31</span> * result + i;</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="built_in">int</span>) (l ^ (l &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        result = <span class="number">31</span> * result + (f != +<span class="number">0.0f</span> ? Float.floatToIntBits(f) : <span class="number">0</span>);</span><br><span class="line">        temp = Double.doubleToLongBits(d);</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="built_in">int</span>) (temp ^ (temp &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">        result = <span class="number">31</span> * result + (<span class="built_in">string</span> != <span class="literal">null</span> ? <span class="built_in">string</span>.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>BitMap 特性解读</title>
    <url>/2019/04/27/BitMap-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="BitMap-特性解读"><a href="#BitMap-特性解读" class="headerlink" title="BitMap 特性解读"></a>BitMap 特性解读</h1><p>主要参考：<a href="https://time.geekbang.org/column/article/76827">极客时间专栏：数据结构与算法之美 45 | 位图：如何实现网页爬虫中的URL去重功能？</a></p>
<ol>
<li><p>应用场景：爬虫爬网页时，要避免重复爬取，对网页去重。</p>
</li>
<li><p>需要暴露的api：<code>add()</code>和<code>isExisted()</code>，即插入跟查询操作。</p>
</li>
<li><p>要求：① 查询、插入效率高；② 省内存。</p>
</li>
<li><p>使用位图的思路：</p>
<ol>
<li>若有 1千万个数据，这些数字落在范围在 1 到 1 亿之间，不使用位图时，使用 hashMap 时，需要使用 Integer 来存储每个数据，需要 40MB 空间。</li>
<li>当使用位图时，需要 1 亿个二进制bit 来表示 boolean，即需要 12MB 空间即可。</li>
</ol>
<span id="more"></span>
</li>
<li><p>使用布隆过滤器的思路：</p>
<ol>
<li>背景：以上位图的思路存在限制，如果数据范围过大，比如数字落在 1 到 10 亿之间，那么一旦使用位图，就需要约 120MB 的空间，相比 hashMap 的方式并不节省空间。</li>
<li>使用布隆过滤器解决以上问题：面对 1 到 10 亿的数据范围，仍然使用一个 1 亿二进制大小的位图，需要使用某哈希函数，对数据进行处理使落到 1 到 1 亿范围内。因为存在哈希冲突的情况，所以使用多个哈希函数进行多重判断，这种方式就叫做布隆过滤器。</li>
<li>布隆过滤器会对存在的情况进行误判。</li>
</ol>
</li>
<li><p>场景难题：</p>
<ol>
<li>直存URL的方式(单 URL 长 64Bytes，10 亿个 URL)，至少需要 64×10^9Bytes，即 64GB 的内存，考虑到装载因子，所需内存将更大（甚至超过 100GB）。</li>
<li>如果采用基于链表的方式解决冲突问题，将无法利用”局部性原理”。</li>
<li>因为 key 是 url，需要进行字符串匹配，效率不高。</li>
</ol>
</li>
<li><p>使用布隆过滤器的解决思路：</p>
<ol>
<li>首先计算这 10 亿个 URL 的哈希值。</li>
<li>然后开辟一个 100 亿二进制大小的位图来存储这些哈希值。</li>
<li>注：一般可以采用 10 倍，当然还需要考虑内存消耗和判错容忍度。</li>
</ol>
</li>
</ol>
<p>二进制位表示 boolean 的技术点：</p>
<ul>
<li>表示 0~nbits 之间的数据是否 existed，同时提供了 get&#x2F;set 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下就是用 char 数组实现 BitMap 的方法：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitMap</span> &#123; <span class="comment">// Java 中 char 类型占 16bit，也即是 2 个字节</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">char</span>[] bytes;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> nbits; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造方法中传入参数 nbits ——允许表示的最大数字(十进制)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">BitMap</span><span class="params">(<span class="type">int</span> nbits)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nbits = nbits;</span><br><span class="line">    <span class="built_in">this</span>.bytes = <span class="keyword">new</span> <span class="title class_">char</span>[nbits/<span class="number">16</span>+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nbits) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">byteIndex</span> <span class="operator">=</span> k / <span class="number">16</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bitIndex</span> <span class="operator">=</span> k % <span class="number">16</span>;</span><br><span class="line">    bytes[byteIndex] |= (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nbits) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">byteIndex</span> <span class="operator">=</span> k / <span class="number">16</span>; <span class="comment">// 第几个 char</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bitIndex</span> <span class="operator">=</span> k % <span class="number">16</span>; <span class="comment">// char 中的第几个 bit</span></span><br><span class="line">    <span class="keyword">return</span> (bytes[byteIndex] &amp; (<span class="number">1</span> &lt;&lt; bitIndex)) != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>位图的扩展用法：</p>
<ol>
<li><p>用户的标签过多时可能使得数据库维护大量的 column，办法：使用BitMap，让每个标签维护自己的 BitMap，其中保存着用户的 ID，参考：<a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg">漫画：Bitmap算法 整合版</a>，使用 BitMap 之后，甚至可以方便地进行交并集运算。</p>
</li>
<li><p>开源的 BitMap 实现：BitSet、EWAHCompressedBitmap（来自 google 开发）。</p>
<ol>
<li><p>EWAHCompressedBitmap对稀疏 BitMap 进行了优化，通过动态扩容、横跨记录的方式(如果是跨度很大的数据，也可以存在临近的位置，只需要记录跨度的大小等)。</p>
</li>
<li><p>EWAHCompressedBitmap源码在：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.javaewah<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JavaEWAH<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>BitMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP-1-1</title>
    <url>/2018/12/19/HTTP-1-1/</url>
    <content><![CDATA[<p>推荐阅读：<a href="https://segmentfault.com/a/1190000013028798">HTTP1.0 HTTP1.1 HTTP2.0 主要特性对比</a></p>
<h2 id="比较-HTTP1-0-、HTTP1-1、-HTTP2-0"><a href="#比较-HTTP1-0-、HTTP1-1、-HTTP2-0" class="headerlink" title="比较 HTTP1.0 、HTTP1.1、 HTTP2.0"></a>比较 HTTP1.0 、HTTP1.1、 HTTP2.0</h2><p>共同点：</p>
<ol>
<li>都是应用层协议，基于 TCP&#x2F;IP 协议。</li>
<li>无状态</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">HTTP1.0</th>
<th align="center">HTTP1.1</th>
<th align="center">HTTP2.0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">特点</td>
<td align="center">无连接、队头阻塞</td>
<td align="center">长连接、管道化、缓存处理</td>
<td align="center">二进制分帧、多路复用、头部压缩、服务器推送</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul>
<li>无连接：在 HTTP1.0 中，浏览器的每次请求都需要新建连接，服务器处理完毕后立即断开连接。</li>
<li>队头阻塞：在 HTTP1.0 中，浏览器需要收到上一个请求的响应后，才能发送下一个请求，如果响应不到，那么之后的请求都将被阻塞。</li>
</ul>
<h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul>
<li>长连接：HTTP1.1 可以设置 keep-Alive 来保持 HTTP 连接不断开。如果浏览器想关闭 HTTP 连接，可以在请求头中携带 Connection：false 来告知服务器关闭请求。</li>
<li>管道化：  使用管道，可以“并行”发送多个请求。但<strong>服务器仍必须按照客户端请求的先后顺序依次回送相应的结果</strong>，以保证客户端能够区分出每次请求的响应内容。<ul>
<li>也就是说管道化，可以让 FIFO 队列从客户端（请求队列）迁移到服务端（响应队列）。</li>
</ul>
</li>
<li>缓存处理：增加了<code>cache-control</code>字段，支持<strong>断点传输</strong>、增加了 <strong>Host</strong> 字段（使得一个服务器能够用来创建多个Web站点）。</li>
</ul>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul>
<li>二进制分帧：在 HTTP2.0 中，在应用层和传输层之间增加一个二进制分帧层，改进了传输性能。</li>
<li>多路复用：在 HTTP2.0 中，一个 TCP 连接可以承载任意数量的双向数据流。<ul>
<li>一个请求是一个数据流，数据流以消息的方式发送，消息可以分成多个帧，帧头部记录着<code>stream id</code>来标识所属，所以不同属的帧可以在连接中随机混杂。接收方可以根据<code>stream id</code>再将帧归属到不同的请求当中去。</li>
<li>实现了真正的并行传输。</li>
</ul>
</li>
<li>头部压缩：在 HTTP1.x 版本中，头部元数据太大。在 HTTP2.0 中，使用<code>encoder</code>来大幅度减少 header 的大小。通讯双方各自<code>cache</code>一份<code>header fields</code>表，header 会减小。</li>
<li>服务器推送：在 HTTP2.0 中，服务器可以额外向客户端推送资源。</li>
</ul>
<p>核心总结比较：</p>
<ol>
<li>Http1.0 中，一个请求就要一个 HTTP，每个 HTTP 就要建立一个 TCP 连接。</li>
<li>Http1.1 中，多个请求共用一个 HTTP，每个 HTTP 就要建立一个 TCP 连接。<ol>
<li>此多个请求实现了按请求FIFO的管道化发送和接收。</li>
</ol>
</li>
<li>Http2.0 中，多个请求共用一个 HTTP，多个 HTTP 也可以共用一个 TCP 连接。<ol>
<li>请求的数据流分多帧，帧头部的 stream id 标识所属。</li>
<li>在 TCP 连接中，允许双向不同属的帧随机混杂，接收方负责按 stream id 将帧归属到不同的请求中去。</li>
</ol>
</li>
</ol>
<h2 id="HTTPS-流程"><a href="#HTTPS-流程" class="headerlink" title="HTTPS 流程"></a>HTTPS 流程</h2><p>client 向 server 发送请求：</p>
<ol>
<li>client 访问 Https:&#x2F;&#x2F;…；</li>
<li>server 返回数字证书（包括 server 的公钥）；</li>
<li>client 使用预置的 CA 列表验证证书，如果有问题，则提示风险；（是为了避免中间人劫持，正常传输 server 的公钥）</li>
<li>client 生成随机的对称密钥，用 server 的公钥加密；</li>
<li>server 用自己的私钥解密，得到对称密钥；</li>
<li>自此，双方都知道对称密钥，可以进行加密传输。</li>
</ol>
<p>第 1<del>3 步是为了安全传输 server 的公钥；<br>第 4</del>6 步是为了安全传输对称密钥。</p>
<ul>
<li><p><strong>数字证书</strong> &#x3D; <strong>数字签名</strong> + （server 的公钥 &amp; server 的个人信息）。</p>
<ul>
<li>其中（server 的公钥 &amp; server 的个人信息）可以使用 Hash 算法得到<strong>消息摘要</strong>。<br><strong>消息摘要</strong>使用 CA 的私钥可以得到<strong>数字签名</strong>。</li>
</ul>
</li>
<li><p>client 验证证书的过程：</p>
<ol>
<li>取出证书中的（server 的公钥 &amp; server 的个人信息），使用相同的 Hash 算法得到消息摘要1；</li>
<li>取出证书中的<strong>数字签名</strong>，使用 CA 的公钥解密，得到消息摘要2；</li>
<li>比较两份消息摘要，如果不同，说明可能遭到了篡改。</li>
</ol>
</li>
</ul>
<p>推荐阅读《码农翻身》第 199~207 页。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>How to send files to cloud server</title>
    <url>/2018/05/10/How-to-send-files-to-cloud-server/</url>
    <content><![CDATA[<p>采用scp的方式，scp的更多用法参考<a href="http://www.cnblogs.com/peida/archive/2013/03/15/2960802.html">scp命令</a></p>
<h3 id="从mac向linux服务器发送文件-x2F-目录"><a href="#从mac向linux服务器发送文件-x2F-目录" class="headerlink" title="从mac向linux服务器发送文件&#x2F;目录"></a>从mac向linux服务器发送文件&#x2F;目录</h3><h4 id="发送文件"><a href="#发送文件" class="headerlink" title="发送文件"></a>发送文件</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">scp <span class="regexp">/Users/</span>lee<span class="regexp">/Desktop/</span>z1.png root@***.**.***.***:<span class="regexp">/usr/</span>local</span><br></pre></td></tr></table></figure>
<p>解释 ：scp  local_file  remote_username@remote_ip:remote_folder </p>
<h4 id="发送目录"><a href="#发送目录" class="headerlink" title="发送目录"></a>发送目录</h4><p>scp  -r  local_folder  remote_username@remote_ip:remote_folder  </p>
<h3 id="从远程服务器复制到本地服务器"><a href="#从远程服务器复制到本地服务器" class="headerlink" title="从远程服务器复制到本地服务器"></a>从远程服务器复制到本地服务器</h3><h4 id="发送文件-1"><a href="#发送文件-1" class="headerlink" title="发送文件"></a>发送文件</h4><p>scp  remote_username@remote_ip:remote_file  local_folder </p>
<h4 id="发送目录-1"><a href="#发送目录-1" class="headerlink" title="发送目录"></a>发送目录</h4><p>scp  -r  remote_username@remote_ip:remote_folder  local_folder</p>
]]></content>
      <categories>
        <category>method</category>
      </categories>
      <tags>
        <tag>cloudServer</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink 入门笔记(1)</title>
    <url>/2019/05/22/Flink-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="Flink-入门笔记-1"><a href="#Flink-入门笔记-1" class="headerlink" title="Flink 入门笔记(1)"></a>Flink 入门笔记(1)</h1><p>好友投稿，整理自慕课网及同事分享</p>
<hr>
<ul>
<li><p>初识Flink</p>
<ul>
<li>什么是Flink：基于有界和无界数据流的有状态的计算，分布式计算引擎<ul>
<li>无界数据流：有开始没有结尾，<strong>流处理</strong>实时处理</li>
<li>有界数据流：有开始有结尾，用<strong>批处理</strong>处理有界数据流</li>
</ul>
</li>
<li>Flink提供的三个层级的API：<ul>
<li>SQL&#x2F;Table API(使用sql语句)</li>
<li>DataStream API</li>
<li>ProcessFunction</li>
</ul>
</li>
</ul>
<span id="more"></span>



<ul>
<li>Flink运行模式：YARN、Mesos、K8S</li>
<li>Flink、Spark Streaming、Storm：<strong>Spark Streaming</strong>以批处理为主，流式处理是批处理的一个特例(将流数据拆成mini batch进行计算)，微批处理框架；<strong>Flink</strong>：以流式为主，批处理是流式处理的一个特例；<strong>Storm</strong>：流式处理，仅支持流</li>
<li>使用场景：事件驱动应用、数据分析应用、数据管道应用</li>
</ul>
</li>
<li><p>应用场景：实时数仓、etl 数据清洗、特征处理等。</p>
</li>
<li><p>四大基础部分：</p>
<ul>
<li>checkpoint；</li>
<li>state(如点击次数等)</li>
<li>time(处理时间等)</li>
<li>window(包括自带窗口和自定义窗口)</li>
</ul>
</li>
<li><p>DataSet API编程(批处理)</p>
<ul>
<li>flink 中使用缓冲块进行批处理，如果超时时间设置为 0，就会变成流处理方式。</li>
</ul>
</li>
<li><p>DataStream API编程(流处理)</p>
<ul>
<li>流处理：实时地处理一些实时数据、实时地产生数据的合集</li>
<li>Flink应用程序开发流程（编程模型）：<ul>
<li>set up execution environment</li>
<li>read</li>
<li>transform operations</li>
<li>sink</li>
<li>execute</li>
</ul>
</li>
<li>Word Count：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">  <span class="comment">// 获取环境</span></span><br><span class="line">  <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">  <span class="comment">// read</span></span><br><span class="line">	DataStreamSource&lt;String&gt; data = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">  <span class="comment">// transfer</span></span><br><span class="line">  dataStreamSource.flatMap(<span class="keyword">new</span> <span class="title class_">FlatMapFunction</span>&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                String[] tokens = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        out.collect(<span class="keyword">new</span> <span class="title class_">Tuple2</span>&lt;&gt;(token, <span class="number">1</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">5</span>)).sum(<span class="number">1</span>).print().setParallelism(<span class="number">1</span>);</span><br><span class="line">  env.execute(<span class="string">&quot;job&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义数据源、转换函数(map、filter、split等iterators)、自定义sink(实现SinkFunction)</li>
</ul>
</li>
<li><p>Flink Table &amp; SQL</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">ExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    <span class="keyword">val</span> tableEnv = <span class="type">TableEnvironment</span>.getTableEnvironment(env)</span><br><span class="line">    <span class="keyword">val</span> path = <span class="string">&quot;file://...&quot;</span></span><br><span class="line">    <span class="keyword">val</span> csv = env.readCsvFile[<span class="type">SalesLog</span>](path, ignoreFirstLine = <span class="literal">true</span>)</span><br><span class="line">    csv.print()</span><br><span class="line">    <span class="keyword">val</span> salesTable = tableEnv.fromDataSet(csv)</span><br><span class="line">    tableEnv.registerTable(<span class="string">&quot;sales&quot;</span>, salesTable)</span><br><span class="line">    <span class="keyword">val</span> resultTable = tableEnv.sqlQuery(<span class="string">&quot;select customerId, sum(amountPaid) money from sales group by customerId&quot;</span>)</span><br><span class="line">    tableEnv.toDataSet[<span class="type">Row</span>](resultTable).print()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SalesLog</span>(<span class="params">transactionId: <span class="type">Int</span>, customerId: <span class="type">Int</span>, itemId: <span class="type">Int</span>, amountPaid: <span class="type">Double</span></span>)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Window和Time操作</p>
<ul>
<li>Event Time</li>
<li>Ingestion Time</li>
<li>Processing Time</li>
<li>Window:滑动窗口（数据可能会重叠）、滚动窗口（数据不会重叠）、会话窗口</li>
</ul>
</li>
<li><p>Flink Connectors</p>
<ul>
<li>Kafka(source&#x2F;sink)：FlinkKafkaConsumer和FlinkKafkaProducer</li>
<li>ElasticSearch(sink)</li>
<li>HDFS(sink)</li>
</ul>
</li>
<li><p>Flink部署及作业提交</p>
<ul>
<li>单机部署：下载Flink源码进行编译：mvn clean install -DskipTests -Dhadoop.version&#x3D;2.6.1</li>
<li>Standalone</li>
<li>on YARN</li>
</ul>
</li>
<li><p>Flink监控及调优</p>
</li>
<li><p>状态容错， 无感知从失败中恢复：</p>
<ol>
<li>flink 使用单数据源时，使用 checkpoint 流转所有算子，然后记录状态(即 barrier)，用来充当作业的恢复机制(flink 自动进行)。当出现 failed 时，会把整个 jobmanager 停掉，然后一次性恢复到 checkpoint 处。</li>
<li>flink 使用多数据源时，需要 barrier 对齐，可能出现延迟或数据丢失，可以选择关闭 barrier 对齐。</li>
<li>flink 使用savepoints，是通过用户手动配置的，充当手动备份的作用。</li>
</ol>
</li>
<li><p>窗口计算：窗口内的消息的计算。</p>
</li>
<li><p>窗口：</p>
<ul>
<li>session window：如果出现 session gap 时间没有新的到达的情况，那么就触发上一个窗口的计算</li>
<li>tumbling count window：满足多少元素数量，就可以触发计算；</li>
<li>sliding time window</li>
<li>tumbling time window：可能存在数据重叠，比如每隔 3 秒计算 5 秒的数据，有数据重叠需求时采用此模型。</li>
<li>raw stream data</li>
</ul>
</li>
<li><p>water mark:(blog.csdn.net&#x2F;lmalds&#x2F;article&#x2F;details&#x2F;52704170)</p>
<ul>
<li>window触发的条件：watermark时间 &gt;&#x3D; window_end_time;在[window_start_time,window_end_time]中有数据存在</li>
<li>flink处理乱序：watermark+window机制</li>
<li>默认配置好的，断言性质的(认为比 watermarks 小的都已经排好序了)。一般 5s 发一个，触发窗口计算，然后做排序。</li>
</ul>
</li>
</ul>
<p>其他：flink 实现了与 kafka 的内部连接，可以做到对 kafka 的幂等写。</p>
<p>water mark、本地跑flink、产品、es</p>
]]></content>
  </entry>
  <entry>
    <title>InnoDB 读书笔记 1</title>
    <url>/2018/07/30/InnoDB-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="数据库内容纵览"><a href="#数据库内容纵览" class="headerlink" title="数据库内容纵览"></a>数据库内容纵览</h1><p>副标题：姜承尧《MySQL技术内幕 InnoDB存储引擎》读书笔记  1</p>
<ul>
<li><p>MySQL被设计为 一个单进程多线程架构的数据库，故<strong>MySQL数据库实例在系统上的表现就是一个进程</strong></p>
  <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">	[root@VM_0_2_centos bin]<span class="comment"># mysql --help | grep my.cnf</span></span><br><span class="line"></span><br><span class="line">	order of preference, my.cnf, <span class="variable">$MYSQL_TCP_PORT</span>,</span><br><span class="line"><span class="regexp">/etc/my</span>.cnf <span class="regexp">/etc/my</span>sql<span class="regexp">/my.cnf /u</span>sr<span class="regexp">/etc/my</span>.cnf ~/.my.cnf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出，MySQL数据库实例启动时，是按照<code>/etc/my.cnf</code> -&gt; <code>/etc/mysql/my.cnf</code> -&gt;<code>/usr/etc/my.cnf</code>-&gt; <code>~/.my.cnf</code>的顺序读取配置文件。</li>
<li>配置文件有一个参数 <code>datadir</code>指定了数据库所在的路径，如<code>datadir=/var/lib/mysql</code></li>
</ul>
</li>
<li><p>数据库是由一个个文件（二进制）组成的，要对这些文件执行SELECT、INSERT等操作，不能通过操作文件更改数据库的内容，需要通过数据库实例来完成</p>
</li>
<li><p>MySQL组成部分：</p>
<ul>
<li>连接池组件</li>
<li>管理服务和工具组件</li>
<li>SQL接口组件</li>
<li>查询分析器组件</li>
<li>优化器组件</li>
<li>缓冲组件</li>
<li><strong>插件式存储引擎</strong>（important）</li>
<li>物理文件</li>
</ul>
</li>
<li><p>InnoDB存储引擎支持事务，通过使用多版本并发控制（MVCC）来获得高并发性，并实现SQL标准的4种隔离级别。同时使用next-key locking的策略（也就是间隙锁）来避免幻读（phantom）现象的产生。此外，提供了插入缓存 、二次写、自适应哈希索引、预读等高性能和高可用的功能（其他引擎略过）</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li>MVCC，是行锁的一种妥协，很多情况下避免使用锁，同时提供更小的开销，根据实现的不同，可以允许非阻塞式读，写操作时只锁定必要的记录<ul>
<li>MVCC是通过保存数据在某个时间点的<strong>快照</strong>来实现的，在每行后面保存两个隐藏列（创建时系统version、销毁时系统version），每开始一个新的事务，系统version会递增</li>
<li>SELECT时，InnoDB按照以下两个条件检查每行记录：<ul>
<li>只会查找创建version早于（小于）当前事务version的数据行，这样可以确保事务读取的行，要么是事务开始前已经存在的，要么是事务自身插入或修改过的（属于快照读的方式，另一种方式当前读即加锁读）</li>
<li>行的删除version要么未定义，要么大于当前的事务version，这样可以确保事务读取到的行，在事务开始之前未被删除</li>
<li>只有同时满足了以上两点，才能返回作为查询结果</li>
</ul>
</li>
<li>DELEDE时，会将当前事务version，写入该行的销毁version项中</li>
<li>UPDATE时，会生成新的一行，version写入新行的创建时间中，同时在原来要修改的行的销毁version项上，写上当前事务的version</li>
</ul>
</li>
<li>进程连接MySQL数据库实例进行通信<ul>
<li>常用的方式有：管道、命名管道、命名字、TCP&#x2F;IP套接字、UNIX套接字 </li>
<li>用户在客户端，可以请求一台远程服务器上的MySQL实例</li>
</ul>
</li>
</ul>
<h2 id="InnoDB特性"><a href="#InnoDB特性" class="headerlink" title="InnoDB特性"></a>InnoDB特性</h2><ul>
<li><p>InnoDB存储引擎有多个内存块，组成了一个大的内存池，负责：</p>
<ol>
<li>维护所有进程&#x2F;线程 需要访问的多个内部数据结构</li>
<li>缓存磁盘上的数据，方便快速的读取，同时在对磁盘文件的数据修改之前在这里缓存</li>
<li>redo log缓冲</li>
</ol>
</li>
<li><p>因为是多线程的模型，负责处理不同的任务：</p>
</li>
</ul>
<h3 id="多线程的任务"><a href="#多线程的任务" class="headerlink" title="多线程的任务"></a>多线程的任务</h3><ol>
<li><p>Master Thread。负责将缓冲池的数据异步刷到磁盘，保证数据的一致性</p>
</li>
<li><p>IO Thread。InnoDB使用了大量的AIO（Async）来处理IO请求，此线程的作用就是负责这些IO请求的回调处理。</p>
 <figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看InnoDB版本</span></span><br><span class="line">mysql&gt; show variables like <span class="emphasis">&#x27;innodb_version&#x27;</span>\G</span><br><span class="line"><span class="bullet">*************************** </span>1. row <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span><br><span class="line">Variable_name: innodb_version</span><br><span class="line"><span class="code">        Value: 5.7.22</span></span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">//read和write线程各4个</span></span><br><span class="line">mysql&gt; show variables like <span class="emphasis">&#x27;innodb_%io_threads&#x27;</span>\G;</span><br><span class="line"><span class="bullet">*************************** </span>1. row <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**</span><br><span class="line">Variable<span class="emphasis">_name: innodb_read_io_threads</span></span><br><span class="line"><span class="emphasis">        Value: 4</span></span><br><span class="line"><span class="emphasis">*************************** 2. row ***************************</span></span><br><span class="line"><span class="emphasis">Variable_name: innodb_write_io_</span>threads</span><br><span class="line"><span class="code">        Value: 4</span></span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看IO Thread细节(放上部分关键代码 )</span></span><br><span class="line"><span class="section">mysql&gt; show engine  innodb  status\G;</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line"><span class="section">FILE I/O</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line">I/O thread 0 state: waiting for completed aio requests (insert buffer thread)</span><br><span class="line">I/O thread 1 state: waiting for completed aio requests (log thread)</span><br><span class="line">I/O thread 2 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 3 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 4 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 5 state: waiting for completed aio requests (read thread)</span><br><span class="line">I/O thread 6 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 7 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 8 state: waiting for completed aio requests (write thread)</span><br><span class="line">I/O thread 9 state: waiting for completed aio requests (write thread)</span><br><span class="line">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="line"><span class="code"> ibuf aio reads:, log i/o&#x27;s:, sync i/o&#x27;s:</span></span><br><span class="line">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="line">318 OS file reads, 13231 OS file writes, 5396 OS fsyncs</span><br><span class="line"><span class="section">0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s</span></span><br><span class="line"><span class="section">-------------------------------------</span></span><br></pre></td></tr></table></figure>
<p> 说明：</p>
<blockquote>
<p>可以看到IO Thread 0 为insert buffer thread。IO Thread 1 为log thread，之后就是根据innodb_read_io_threads和innodb_write_io_threads来设置的读写线程，并且读线程的ID总是小于写线程
 </p>
</blockquote>
</li>
<li><p>Purge Thread。事务被提交后，所使用的undolog可能不再需要，因此需要PurgeThread来回收已经使用并分配的undo页。在InnoDB高版本中，还支持多个PurgeThread，可以进一步加快undo页的回收，同时由于PurgeThread需要离散的读取undo页，这样也能更近一步利用磁盘的随机读取性能</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb<span class="emphasis">_purge_</span>threads&#x27;\G</span><br><span class="line"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** 1. row **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span><br><span class="line">Variable<span class="emphasis">_name: innodb_</span>purge<span class="emphasis">_threads</span></span><br><span class="line"><span class="emphasis">        Value: 4</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure>
<p> 以上显示PurgeThread有4个</p>
</li>
<li><p>Page Cleaner Thread。将脏页的刷新操作放入单独的线程中完成</p>
 <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb<span class="emphasis">_page_</span>cleaners&#x27;\G</span><br><span class="line"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** 1. row **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span><br><span class="line">Variable<span class="emphasis">_name: innodb_</span>page<span class="emphasis">_cleaners</span></span><br><span class="line"><span class="emphasis">        Value: 1</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成全书36页 </p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB 读书笔记 2</title>
    <url>/2018/07/31/InnoDB-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h1 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h1><p>副标题：姜承尧《MySQL技术内幕 InnoDB存储引擎》读书笔记 2</p>
<h2 id="缓冲池的简介"><a href="#缓冲池的简介" class="headerlink" title="缓冲池的简介"></a>缓冲池的简介</h2><ul>
<li><p>InnoDB引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理</p>
</li>
<li><p>缓冲池是一块内存区域，在数据库进行读取页的操作，首先将磁盘读到的页放在缓冲池中，称为将页“FIX”在缓冲池。下一次读到相同页时，首先判断该页是否在缓冲池中，若是则直接在缓冲池中读取该页，否则，读取磁盘上的页</p>
</li>
<li><p>对于数据库中页的修改操作，首先修改在缓冲池中的页，然后以一定的频率刷新到磁盘上。但并不是每一次修改都会触发刷回数据的操作，而是按照一种称为checkpoint的机制进行</p>
</li>
<li><p>缓冲池的大小直接影响数据库的整体性能，32位操作系统下，该值最多可以设置为3G，此外用户可以打开操作系统的PAE选项来获得32位OS下最大64G内存的支持</p>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">//查看缓冲池的大小，以下134217728B表示128MB</span><br><span class="line">mysql&gt; show variables like &#x27;innodb<span class="emphasis">_buffer_</span>pool<span class="emphasis">_size&#x27;\G;</span></span><br><span class="line"><span class="emphasis"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** 1. row **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line"><span class="emphasis">Variable_</span>name: innodb<span class="emphasis">_buffer_</span>pool<span class="emphasis">_size</span></span><br><span class="line"><span class="emphasis">        Value: 134217728</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<span id="more"></span>

<ul>
<li><p>缓冲池中缓存的数据页类型：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等，如下图</p>
<p>  <img src="/2018/07/31/InnoDB-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/1.png" alt="1"></p>
</li>
<li><p>InnoDB允许有多个缓冲池实例，如下图查看，可以在配置文件中修改。同时也可以使用命令<code>SHOW ENGINE INNODB STATUS</code>查看每个缓冲池实例对象运行的状态</p>
  <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables  like &#x27;innodb<span class="emphasis">_buffer_</span>pool<span class="emphasis">_instances&#x27;\G;</span></span><br><span class="line"><span class="emphasis"><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">*** 1. row **</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span><span class="strong">****</span>*</span></span><br><span class="line"><span class="emphasis">Variable_</span>name: innodb<span class="emphasis">_buffer_</span>pool<span class="emphasis">_instances</span></span><br><span class="line"><span class="emphasis">        Value: 1</span></span><br><span class="line"><span class="emphasis">1 row in set (0.00 sec)</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">//部分代码：</span></span><br><span class="line"><span class="emphasis">mysql&gt; show engine innodb  status\G;</span></span><br><span class="line"><span class="emphasis">Total large memory allocated 137428992</span></span><br><span class="line"><span class="emphasis">Dictionary memory allocated 216425</span></span><br><span class="line"><span class="emphasis">Buffer pool size   8191</span></span><br><span class="line"><span class="emphasis">Free buffers       6983</span></span><br><span class="line"><span class="emphasis">Database pages     1190</span></span><br><span class="line"><span class="emphasis">Old database pages 419</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="InnoDB如何管理缓存池（即一大块内存）"><a href="#InnoDB如何管理缓存池（即一大块内存）" class="headerlink" title="InnoDB如何管理缓存池（即一大块内存）"></a>InnoDB如何管理缓存池（即一大块内存）</h2><ul>
<li>通常的缓冲池是通过LRU（Latest Recent Used）算法来进行管理的，最常使用页放在LRU列表的前端，最少使用的页放在尾端。当缓冲池不能存放新读取的页时，将首先释放LRU列表中尾段的页。</li>
<li>InnoDB对LRU算法进行了一些优化，在LRU列表中新增了midpoiont位置，新读取的页并不放在首部，而是放在midpoint处，约5&#x2F;8的位置，可由参数innodb_old_blocks_pct控制。至于为什么不放在首部，是因为新读取的页通常仅是这次查询操作中需要，并不是活跃的热点数据。所以InnoDB引入另一个参数来进一步管理LRU列表，即innodb_old_blocks_time，用于表示页读取到mid位置后需要等待多久才会被加入到LRU列表的热端。</li>
<li>当页从LRU列表的old部分加入到new部分时，此时发生的操作为page made young，而因为innodb_old_blocks_time的设置导致页没有从old部分移动到new部分的操作称为page not made young，page made young显示了LRU列表中页移动到热端的次数。</li>
<li>还有一个重要的观察变量——Buffer pool hit rate ，表示缓冲池的命中率，通常不应该小于95%。</li>
<li>在LRU列表中的页被修改后，称该页为脏页，这时DB会通过CheckPoint机制将脏页刷回磁盘，而Flush列表中的页即为脏页列表。</li>
</ul>
<h4 id="日志缓存和额外的内存池"><a href="#日志缓存和额外的内存池" class="headerlink" title="日志缓存和额外的内存池"></a>日志缓存和额外的内存池</h4><ul>
<li>InnoDB将重做日志信息先放入重做日志缓存区，一般每一秒钟将重做日志缓冲刷新到日志文件，由参数innodb_log_buffer_size 控制，默认为8MB；</li>
<li>InnoDB对内存的管理使用heap的方式，详略</li>
</ul>
<h4 id="CheckPoint技术"><a href="#CheckPoint技术" class="headerlink" title="CheckPoint技术"></a>CheckPoint技术</h4><ul>
<li><p>背景：如果每次update或delete都要将新页的版本刷新到磁盘，这个开销是非常大的。同时如果在刷新时发生了宕机，那么数据就不能恢复了。</p>
</li>
<li><p>所以为了避免数据丢失的情况，事务数据库系统普遍采取了Write Ahead Log策略，即当事务提交时，先写重做日志，再修改页。</p>
</li>
<li><p>CheckPoint技术目的是为了解决以下几个问题：</p>
<ol>
<li>缩短DB的恢复时间；</li>
<li>缓冲池不够用时，将脏页刷新到磁盘；</li>
<li>重做日志不可用时（重做日志被需要，不能被覆盖的情形下），刷新脏页</li>
</ol>
</li>
<li><p>InnoDB采用LSN（Log Sequence Number）来标记版本，每个页有LSN，重做日志也有LSN，CheckPoint也有LSN。</p>
</li>
<li><p>CheckPoint有两种：Sharp CheckPoint和Fuzzy CheckPoint</p>
<ol>
<li>Sharp CheckPoint发生在DB关闭时将所有脏页刷回磁盘；</li>
<li>Fuzzy Checkpoint只刷新部分脏页，有四种方式，此处咱不讨论</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM（1）</title>
    <url>/2018/09/24/JVM%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java-amp-内存相关"><a href="#Java-amp-内存相关" class="headerlink" title="Java &amp; 内存相关"></a>Java &amp; 内存相关</h1><p>副标题：《深入理解 Java 虚拟机》读书笔记（1）</p>
<h2 id="一、Java-须知"><a href="#一、Java-须知" class="headerlink" title="一、Java 须知"></a>一、Java 须知</h2><h3 id="1-1-组成"><a href="#1-1-组成" class="headerlink" title="1.1 组成"></a>1.1 组成</h3><ul>
<li>Java 技术体系组成：<ol>
<li>① Java 程序设计语言；</li>
<li>② 各种硬件平台上的Java 虚拟机；</li>
<li>③ Class 文件格式；</li>
<li>④ Java API 类库；</li>
<li>⑤ 第三方 Java 类库（商业机构&#x2F;开源社区）；</li>
</ol>
</li>
<li>JDK &#x3D;	①+②+④，是进行 Java 程序开发的最小环境；</li>
<li>JRE &#x3D; ②+④中的部分子集（Java SE API），是支持Java程序运行的标准环境。</li>
<li>Java 技术体系平台：<ol>
<li>Java Card：支持一些 Java 小程序运行在小内存设备的平台（用在SIM卡、提款卡上）；</li>
<li>Java ME（micro edition）：支持 Java 程序运行在移动端的平台，使用精简后的 Java API，也被称为 J2ME（用在手机、PDA 上）；</li>
<li>Java SE（standard edition）：支持面向桌面级应用的平台，使用完整的 Java 核心 API，也被称为 J2SE（用在桌面软件）；</li>
<li>Java EE（Enterprise edition）：支持使用<a href="https://blog.csdn.net/Zuocheng_Liu/article/details/45048091">多层架构</a>的企业应用(如常见的 MVC 等)的平台，除了 Java SE API 外，还做了扩充，称为 J2EE（用在 ERP、CRM 应用）。</li>
</ol>
</li>
</ul>
<span id="more"></span>

<h3 id="1-2-Java-各版本简史"><a href="#1-2-Java-各版本简史" class="headerlink" title="1.2 Java 各版本简史"></a>1.2 Java 各版本简史</h3><ol>
<li>Java 1.0：“Write once，Run Anywhere”；JDK 1.0：Java JVM，Applet（运行在支持Java的Web浏览器中），AWT 等；</li>
<li>JDK 1.1：Jar  格式，JDBC，JavaBeans，<a href="https://www.cnblogs.com/dongguacai/p/5617698.html">RMI</a>（Remote Procedure Invocation，一个 JVM 对象调用另一个 JVM 对象上的方法），语法：Inner Class 和 Reflection；</li>
<li>JDK 1.2：把 Java 系统分拆为三个方向：J2SE、J2ME和J2EE；出现了 EJB、Java Plug-in，Swing，JIT，strictfp，Collections，HotSpot；</li>
<li>JDK 1.3：部分类库（数学运算和新的 Timer API上），JNDI，Java 2D 改进，JavaSound 类库。</li>
<li>JDK 1.4：正则表达式、异常链、NIO、日志类、XML 解析器、XSLT 转换器；</li>
<li>JDK 1.5：Java 语法改进：自动装箱、泛型、动态注解、枚举、可变长参数、foreach 循环；改进了内存模型（JMM，Java Memory Model），提供了 java.util.concurrent 并发包；</li>
<li>JDK 1.6：提供动态语言支持（动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译器）、编译 API 和微型 HTTP 服务器 API；JVM 内部改进：锁和同步、垃圾收集、类加载；</li>
<li>JDK 1.7：新的G1收集器，加强对非Java语言的调用支持，升级类加载架构；</li>
<li><a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html">JDK 8</a></li>
<li><a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">JDK 9</a></li>
<li><a href="https://www.oracle.com/technetwork/java/javase/10-relnote-issues-4108729.html">JDK 10</a></li>
</ol>
<h2 id="二、Java-内存"><a href="#二、Java-内存" class="headerlink" title="二、Java 内存"></a>二、Java 内存</h2><h3 id="2-1-运行时数据区域"><a href="#2-1-运行时数据区域" class="headerlink" title="2.1 运行时数据区域"></a>2.1 运行时数据区域</h3><ul>
<li>包括：方法区、堆、虚拟机栈、本地方法栈、程序计数器<ul>
<li>方法区和堆是所有线程共享，另外三个是线程隔离的。</li>
<li>JDK 8 版本中，方法区被换成了 metaspace（元数据空间）</li>
</ul>
</li>
</ul>
<p><img src="/2018/09/24/JVM%EF%BC%881%EF%BC%89/1.png" alt="jvm模型"></p>
<h4 id="2-1-1-程序计数器"><a href="#2-1-1-程序计数器" class="headerlink" title="2.1.1 程序计数器"></a>2.1.1 程序计数器</h4><ul>
<li>推荐阅读：<a href="http://www.cnblogs.com/manayi/p/9290490.html">01-JVM 内存模型：程序计数器</a></li>
<li>当前线程所执行的字节码的行号指示器。</li>
<li>java代码编译成字节码后，在尚未经过 JIT（实时编译器）编译前，要通过“字节码解释器”进行解释执行，流程：<ol>
<li>解释器读取载入内存中的字节码，按照顺序读取指令；</li>
<li>读入指令后，将该指令翻译成固定的操作，完成操作进行分支、循环、跳转等过程；</li>
<li>按照以上流程是不需要计数器的。但多线程的实现，要求完成线程的切换，所以需要程序计数器。而且，每个线程都需要一个独立地程序计数器。</li>
</ol>
</li>
<li>特点：<ol>
<li>如果执行 native 方法，程序计数器的值为 undefined，因为 native 方法是 java 通过 JNI 直接调用本地 C&#x2F;C++ 库（理解：C&#x2F;C++ 给 java 的一个接口，java 调用此接口从而调用 C&#x2F;C++ 方法，自然不需要字节码，此时的内存分配不是 JVM 管理的）；</li>
<li>如果执行 Java 方法，此时计数器就的是正在执行的虚拟机字节码指令的地址；</li>
<li>此内存区域是唯一一个没有规定任何 OutOfMemoryError 情况的区域。</li>
</ol>
</li>
</ul>
<h4 id="2-1-2-Java-虚拟机栈"><a href="#2-1-2-Java-虚拟机栈" class="headerlink" title="2.1.2 Java 虚拟机栈"></a>2.1.2 Java 虚拟机栈</h4><ul>
<li>是线程私有的，生命周期同线程。</li>
<li>虚拟机栈描述的是 <strong>Java 方法执行</strong>的内存模型（即方法在执行的同时，内存区的动作）：每个方法执行时都会创建一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，对应栈帧在虚拟机栈中入栈和出栈的过程。</li>
<li>程序员常说的“堆”与“栈”中，“栈”指的就是虚拟机栈中的局部变量表部分。<ul>
<li>局部变量表中存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型；</li>
<li>局部变量表所需的内存空间在编译期间完成分配，当进入一个方式时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，而且在方法运行期间不会改变局部变量表的大小。</li>
</ul>
</li>
<li>此区域的两种异常：<ol>
<li>StackOverflowError 异常：线程请求的栈深度大于虚拟机所允许的深度，会报此异常；</li>
<li>OutOfMemoryError 异常：如果是可以动态扩展的虚拟机（大部分 JVM 都可扩展），在扩展时无法申请到足够的内存，会报此异常。</li>
</ol>
</li>
</ul>
<h4 id="2-1-3-本地方法栈"><a href="#2-1-3-本地方法栈" class="headerlink" title="2.1.3 本地方法栈"></a>2.1.3 本地方法栈</h4><ul>
<li>作用类似于 Java 虚拟机栈，但本地方法栈是为 native 方法服务的，虚拟机可以自由实现它。</li>
<li>异常也跟 Java 虚拟机栈相同。</li>
<li>常用的 HotSpot 虚拟机将虚拟机栈和本地方法栈合二为一。</li>
</ul>
<h4 id="2-1-4-Java-堆"><a href="#2-1-4-Java-堆" class="headerlink" title="2.1.4 Java 堆"></a>2.1.4 Java 堆</h4><ul>
<li>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，目的是存放对象实例（几乎所有的对象实例都在这里分配内存）。目前的一些技术，如 JIT 的发展、栈上分配、标量替换优化技术等，也会允许某些对象不在堆上分配的例外。<ul>
<li>推荐阅读：<a href="https://segmentfault.com/a/1190000004606059">Java对象分配简要流程</a>，精华如下：</li>
<li>逃逸分析：分析对象的动态作用域。<ul>
<li>方法逃逸：例如作为调用参数传递到其他方法中；</li>
<li>线程逃逸：有可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量。</li>
</ul>
</li>
<li>栈上分配：如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。</li>
</ul>
</li>
<li>Java 堆是占 Java 虚拟机所管理的内存中最大的一块，可以处在物理上不连续的内存空间上，只需要逻辑连续即可。在实现时也有固定式和可扩展式两种现象。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</li>
<li>Java 堆也称“GC 堆”，是垃圾收集器管理的主要区域。<ul>
<li>从内存回收角度来看，Java 堆可以细分为：新生代和老年代。再细致可分为 Eden 空间、From Survivor 空间、To Survivor 空间等；</li>
<li>从内存分配的角度来看，Java 堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation buffer,TLAB）。在开启 TLAB 的情况下，虚拟机会为每个 Java 线程分配一块 TLAB 空间。TLAB 空间的内存非常小，如果请求对象过大时，会选择在堆中分配。</li>
</ul>
</li>
<li>扩展：对象分配内存的两种方法：指针碰撞、空闲列表。<ul>
<li>指针碰撞：假设 Java 堆中内存是规整的，用过的内存放在一边，空闲的内存放在另一边，中间设置一个分隔指示的指针，那么分配内存时，把指针横移一段与请求对象大小相同的距离，这种分配方式即指针碰撞；</li>
<li>空闲列表：假设 Java 堆中内存不是规整的，虚拟机必须维护一个列表，记录哪些内存块是可用的，在分配时从空闲列表中选择足够大的空间划分为请求对象实例，并更新列表上的记录，这种分配方式即空闲列表。</li>
<li>Java 堆是否规整，是由所采用的垃圾收集器是否带有压缩整理功能决定的。</li>
</ul>
</li>
</ul>
<h4 id="2-1-5-方法区（JDK-8-后的-metaspace）"><a href="#2-1-5-方法区（JDK-8-后的-metaspace）" class="headerlink" title="2.1.5 方法区（JDK 8 后的 metaspace）"></a>2.1.5 方法区（JDK 8 后的 metaspace）</h4><ul>
<li>是各个线程共享的内存区域。</li>
<li>用于存储已被虚拟机加载的类的版本、字段、方法、接口等描述信息和常量池：<ul>
<li>存储的类型信息：此类型的完整有效名、此类直接父类的完整有效名（如果此类是 interface 和 java.lang.Object 则不需要父类的有效名）、此类的修饰符、直接接口的有序列表。</li>
<li>类型的常量池：JVM 为每个已加载的类都维护一个常量池。常量池就是这个类用到的常量的一个有序集合，包括实际的常量（如 String，Integer 等）和对类、域、方法的引用等。数据项像数组项一样，是通过索引访问的。</li>
<li>域信息&#x2F;字段信息：类的所有域的相关信息以及域的声明顺序。包括：域名、域类型、域修饰符。</li>
<li>方法信息：方法的所有信息，以及声明顺序。包括：方法名、方法返回类型（或 void）、方法参数的数量和类型（有序的）、方法的修饰符、保存方法（除 abstract 和 native 外的其他方法）的字节码（bytecodes）操作数栈和方法栈帧的局部变量区的大小、异常表等。</li>
<li>类变量，即静态变量。方法区中为每个 non-final 类变量分配空间。</li>
<li>指向类加载器的引用：每个被 JVM 加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。</li>
<li>指向 Class 实例的引用：类加载过程中，虚拟机会创建该类的 Class 实例，方法区会保存对该对象的引用。通过 Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。</li>
<li>方法表：JVM 可能对每个装载的非抽象类，都创建一个数组，数组的每个元素是方法的直接引用（实例可能会调用的），包括父类中继承来的方法。在抽象类和接口中不存在此方法表。</li>
<li>运行时常量池：当 java 文件被编译成 class 文件后，会生成 class 文件常量池。而 JVM 在执行某个类时，必须经过加载、连接（又细分为验证、准备、解析三个阶段）、初始化。当类加载到内存中后，JVM 会将 class 常量池中的内容存放到运行时常量池中。在经过解析（resolve）后，把符号引用替换为直接引用，解析的过程会去查询全局字符串池，以保证运行时常量池所引用的字符串与全局字符串池（StringTable）中所引用的是一致的。<ul>
<li>class文件常量池：用于存放编译器生成的各种字面量（literal，即常量概念，比如文本字符串、被声明为 final 的常量值等）和符号引用（Symbolic References，起到无歧义定位到目标的作用）。</li>
</ul>
</li>
</ul>
</li>
<li>推荐阅读：<a href="https://blog.csdn.net/qingtiantianqing/article/details/51405517">java 方法区究竟存储了什么？</a></li>
</ul>
<h4 id="2-1-6-直接内存-DirectMemory"><a href="#2-1-6-直接内存-DirectMemory" class="headerlink" title="2.1.6 直接内存 DirectMemory"></a>2.1.6 直接内存 DirectMemory</h4><ul>
<li>使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</li>
<li>相对于堆内内存，堆外内存的优点：<ol>
<li>减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作（可能使用多线程或者时间片的方式，根本感觉不到） </li>
<li>加快了复制的速度。因为堆内在flush到远程时，会先复制到直接内存（非堆内存），然后再发送；而堆外内存相当于省略掉了这个工作。</li>
</ol>
</li>
<li>缺点：<ol>
<li>堆外内存难以控制，如果内存泄漏，那么很难排查；</li>
<li>堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</li>
</ol>
</li>
</ul>
<h2 id="三、new-一个对象时发生了什么"><a href="#三、new-一个对象时发生了什么" class="headerlink" title="三、new 一个对象时发生了什么"></a>三、new 一个对象时发生了什么</h2><h3 id="3-1-JVM-遇到一条new指令后"><a href="#3-1-JVM-遇到一条new指令后" class="headerlink" title="3.1 JVM 遇到一条new指令后"></a>3.1 JVM 遇到一条new指令后</h3><ol>
<li>首先检查这个指令的参数能否在常量池中定位到一个类的符号引用；然后检查这个符号引用代表的类是否已经被加载、解析和初始化过；如果没有，那必须执行相应的类加载过程。</li>
<li>类加载检查通过后，JVM 为新生对象分配内存（采用指针碰撞或空闲列表方式）。<ul>
<li>如果分配内存的操作因为并发而线程不安全，那么需要采用两种方法来避免：采用 CAS 保证更新内存指针操作的原子性；采用 TLAB 将指针操作划分在不同的空间进行。</li>
</ul>
</li>
<li>内存分配完成后，JVM 需要将分配到的内存空间都初始化为零值，此步保证了对象的实例字段在 Java 代码中可以不赋初始值就可以直接使用。</li>
<li>接着，JVM 要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的 Hash 码、对象的 GC 分代年龄等信息。这些信息放在对象的 Object Header 之中。</li>
<li>虚拟机要做的事情基本完成，但是还需要执行<code>&lt;init&gt;</code>方法，把对象按照程序员的意愿进行初始化，才会诞生一个真正可用的对象。</li>
</ol>
<h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>对象在内存中存储的布局分为 3 个区域：<a href="https://blog.csdn.net/varyall/article/details/78778004">对象头</a>（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>
<ul>
<li>对象头的作用是通过<code>标记字段</code>存储自身的运行时数据、以及通过<code>类型指针</code>确定此对象是哪个类的实例。</li>
<li>实例数据是对象真正存储的有效信息，包括程序代码中定义的各种类型（自己定义的，或者从父类继承的）都记录进来。</li>
<li>对齐填充起着占位符的作用，用来将整个对象的大小凑成 8 的整数倍。</li>
</ul>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>栈上的 reference 数据是指向对象的引用，利用引用操作堆上的具体对象。但这个引用采用何种方式去定位、访问堆中的对象的具体位置呢？目前主流的访问方式有：使用句柄和直接指针两种。</p>
<ol>
<li>使用句柄：在 Java 堆中划分一块内存作为句柄池，reference（在栈的本地变量表中） 中存储对象的句柄地址（句柄池中），句柄中包含了对象实例数据（实例池中）和类型数据各自的具体地址信息（方法区）。好处是：reference 中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，reference 本身不需要修改。</li>
<li>直接指针：reference 中存储的是对象地址。好处是：速度更快，节省了一次指针定位的时间开销，HotSpot 使用的就是直接指针的方式。</li>
</ol>
<h3 id="3-4-Java-内存溢出"><a href="#3-4-Java-内存溢出" class="headerlink" title="3.4 Java 内存溢出"></a>3.4 Java 内存溢出</h3><ul>
<li>推荐阅读：[JVM 垃圾回收 GC Roots Tracing](GC Roots Tracing)</li>
<li>如果是内存泄漏，可查看泄漏对象到 GC Roots 的引用链，之后就可以定位到泄漏代码处。</li>
<li>如果是不是内存泄漏，那么内存中的对象还存活着，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期的内存消耗。</li>
</ul>
<h4 id="3-4-1-虚拟机栈和本地方法栈溢出"><a href="#3-4-1-虚拟机栈和本地方法栈溢出" class="headerlink" title="3.4.1 虚拟机栈和本地方法栈溢出"></a>3.4.1 虚拟机栈和本地方法栈溢出</h4><ul>
<li>如果线程请求的栈深度大于 JVM 允许的最大深度，抛出 StackOverflowError 异常；</li>
<li>如果 JVM 在扩展栈时无法申请到足够的内存空间，抛出 OutOfMemoryError 异常，此异常难以出现，一般也是抛出 StackOverflowError 异常的。</li>
<li>栈深大约 1000 ~ 2000 左右，对于一般的方法调用是足够了。但如果建立了过多线程导致的内存溢出，只能采取减少线程数、减少最大堆、减少栈容量来解决。</li>
</ul>
<h4 id="3-4-2-方法区和运行时常量池溢出"><a href="#3-4-2-方法区和运行时常量池溢出" class="headerlink" title="3.4.2 方法区和运行时常量池溢出"></a>3.4.2 方法区和运行时常量池溢出</h4><ul>
<li>是一种常见的内存溢出异常，在经常动态生成大量 Class 应用的情况，以及 CGLib 字节码增强、动态语言、大量 JSP、基于 OSGi 的应用等。</li>
</ul>
<h4 id="3-4-3-本机直接内存溢出"><a href="#3-4-3-本机直接内存溢出" class="headerlink" title="3.4.3 本机直接内存溢出"></a>3.4.3 本机<code>直接内存</code>溢出</h4><ul>
<li>直接内存，DirectMemory容量默认跟 Java 堆一般大小，因直接内存异常导致的异常，最明显的特征是在 Heap Dump 文件中不会看见明显的异常。如果发现 OOM（OutOfMemory）后 Dump 文件很小，而程序中又直接或间接的使用了 NIO ，那么可以检查直接内存是否溢出。</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM（2）</title>
    <url>/2018/09/26/JVM%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、GC-背景知识"><a href="#一、GC-背景知识" class="headerlink" title="一、GC 背景知识"></a>一、GC 背景知识</h1><p>副标题：《深入理解 Java 虚拟机》读书笔记（2）</p>
<p>推荐阅读：<a href="https://www.cnblogs.com/lfs2640666960/p/9297176.html">面试必问之JVM篇</a></p>
<h2 id="1-1-GC-背景"><a href="#1-1-GC-背景" class="headerlink" title="1.1  GC 背景"></a>1.1  GC 背景</h2><p>GC：garbage collection。<br>程序计数器、虚拟机栈、本地方法栈这三个区域随线程生灭，所以不需要过多考虑内存的回收问题。而 Java 堆和方法区则不同，不同之处在于：</p>
<ul>
<li>一个接口的多个实现类需要的内存可能不一样；</li>
<li>一个方法的多个分支需要的内存可能不一样。</li>
</ul>
<p>只有程序运行期间时才能知道会创建哪些对象，这部分内存分配是动态的，是垃圾收集器所关注的部分。</p>
<h2 id="1-2-四种引用类型"><a href="#1-2-四种引用类型" class="headerlink" title="1.2 四种引用类型"></a>1.2 四种引用类型</h2><ul>
<li>强引用，Strong Reference。类似<code>Dog dog = new Dog();</code>。</li>
<li>软引用，Soft Reference。只有内存不足时，JVM 才会回收该对象。属于<code>java.lang.ref.SoftReference</code>，一般用来实现缓存（如图片缓存、网页缓存，有用但非必须）。</li>
<li>弱引用，Weak Reference。当 JVM 进行 GC 时，无论内存充足与否，都会被回收的对象。属于<code>java.lang.ref.WeakReference</code>，一般用来在回调函数中防止内存泄漏。</li>
<li>虚引用，Phantom Reference。仅用在，这个对象呗收集器回收时收到一个系统通知。</li>
</ul>
<span id="more"></span>


<table>
<thead>
<tr>
<th align="center">级别</th>
<th align="center">回收时机</th>
<th align="center">用途</th>
<th align="center">生存时间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">强</td>
<td align="center">从来不会</td>
<td align="center">对象的一般状态</td>
<td align="center">JVM 停止运行时终止</td>
</tr>
<tr>
<td align="center">软</td>
<td align="center">在内存不足时</td>
<td align="center">联合 ReferenceQueue 构造有效期短&#x2F;占内存大&#x2F;生命周期长的对象的二级高速缓冲器（内存不足时清空此缓冲器）</td>
<td align="center">内存不足时终止</td>
</tr>
<tr>
<td align="center">弱</td>
<td align="center">在垃圾回收时</td>
<td align="center">联合 ReferenceQueue 构造有效期短&#x2F;占内存大&#x2F;生命周期长的对象的一级高速缓冲器（系统发生 GC 时清空此缓冲器）</td>
<td align="center">GC 运行后终止</td>
</tr>
<tr>
<td align="center">虚</td>
<td align="center">在垃圾回收时</td>
<td align="center">联合 ReferenceQueue 来跟踪对象呗垃圾收集器回收的活动</td>
<td align="center">GC 运行后终止</td>
</tr>
</tbody></table>
<h2 id="1-3-对象是否是垃圾的判断标准"><a href="#1-3-对象是否是垃圾的判断标准" class="headerlink" title="1.3 对象是否是垃圾的判断标准"></a>1.3 对象是否是垃圾的判断标准</h2><p>释放对象的根本原则是该对象不再被引用。常见的几个判断方法，引用计数算法、可达性分析算法：</p>
<h3 id="1-3-1-引用计数算法"><a href="#1-3-1-引用计数算法" class="headerlink" title="1.3.1 引用计数算法"></a>1.3.1 引用计数算法</h3><ul>
<li>为对象添加一个引用计数器，每当有一个地方引用它，计数器加一；每当一个引用失效，计数器减一；任何时刻计数器为 0 的对象就是不可能再被使用的。</li>
<li>评价：实现简单、判定效率高，但不乏解决对象间相互循环引用的问题，所以此算法不被当下的 JVM 采用。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象间相互循环引用	</span></span><br><span class="line"> <span class="keyword">public</span> void buidDog()&#123;</span><br><span class="line"> 	Dog <span class="keyword">new</span><span class="type">Dog</span> = <span class="keyword">new</span> <span class="type">Dog</span>();</span><br><span class="line">	Tail <span class="keyword">new</span><span class="type">Tail</span> = <span class="keyword">new</span> <span class="type">Tail</span>();</span><br><span class="line">	<span class="keyword">new</span><span class="type">Dog</span>.tail = <span class="keyword">new</span><span class="type">Tail</span>;</span><br><span class="line">	<span class="keyword">new</span><span class="type">Tail</span>.dog = <span class="keyword">new</span><span class="type">Dog</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>newTail 拿着对 newDog 的引用，newDoy 拿着对 newTail 的引用，垃圾回收管理似乎始终无法回收这两个实际已经不再需要的对象。但虽然两个引用都是强引用，但垃圾收集器除了看强引用关系外，还会看对象是否被至少一个 GC roots 对象直接或间接引用。</li>
</ul>
<blockquote>
<p>“It’s important to note that not just any strong reference will hold an object in memory. These must be references that chain from a garbage collection root. GC roots are a special<br> class of variable that includes<br>Temporary variables on the stack (of any thread)<br>Static variables (from any class)<br>Special references from JNI native code”。</p>
</blockquote>
<h3 id="1-3-2-可达性分析算法"><a href="#1-3-2-可达性分析算法" class="headerlink" title="1.3.2 可达性分析算法"></a>1.3.2 可达性分析算法</h3><ul>
<li>通过一系列“GC Root”的对象作为起始点，从这些结点向下搜索（搜索路径称为引用链），当一个对象到 GC Roots 没有任何引用链相连时（即不可达时），证明此对象时不可用的。</li>
<li>[重点]哪些对象是 GC Roots ？<ol>
<li>虚拟机栈的本地变量表中引用的对象，即局部变量；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中 JNI（即 native 方法）引用的变量</li>
<li>官方文档：<a href="http://help.eclipse.org/luna/index.jsp?topic=/org.eclipse.mat.ui.help/concepts/gcroots.html&cp=37_2_3">Garbage Collection Roots</a></li>
</ol>
</li>
</ul>
<h3 id="1-3-3-待回收对象在-finalize-方法复活"><a href="#1-3-3-待回收对象在-finalize-方法复活" class="headerlink" title="1.3.3 待回收对象在 finalize()方法复活"></a>1.3.3 待回收对象在 finalize()方法复活</h3><ul>
<li><p>首先，此方法强烈不建议使用。</p>
</li>
<li><p>某对象在标记为不可达后，会进行第一次标记，并筛选是否有必要执行 finalize()方法。</p>
<ul>
<li>Java 中假定 finalize 的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的 finalize 方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！</li>
<li>finalize()的作用：finalize 用于在 GC 发生前事先调用去回收 JNI 调用中申请的特殊内存，下次 GC 发生时候保证 GC 后所有该对象的内存都释放了。</li>
<li>finalize 一般使用在使用了 JNI 的情景下，需要在 finalize 中调用 native 方法释放特殊内存，一般情况下不要使用 finalize。</li>
</ul>
</li>
<li><p>如果没有必要执行，会被 GC 回收；</p>
</li>
<li><p>如果判定有必要执行，那么对象会进入 F-Queue 队列中，GC 将对队列中的对象进行二次标记，如果对象未能摆脱队列，那么将被彻底回收。</p>
<ul>
<li>摆脱方式就是在二级标记检查执行 finalize()方法时，与引用链上任何一个对象建立关联即可。</li>
</ul>
</li>
</ul>
<h2 id="1-4-内存泄漏"><a href="#1-4-内存泄漏" class="headerlink" title="1.4 内存泄漏"></a>1.4 内存泄漏</h2><p>存在一些被分配的对象，具有以下两个特点：</p>
<ol>
<li>对象是可达的；</li>
<li>对象是无用的。</li>
</ol>
<p>造成的结果就是存在一些对象不会被 GC 回收，但占用了内存。</p>
<h3 id="1-4-1-System-gc-语句"><a href="#1-4-1-System-gc-语句" class="headerlink" title="1.4.1 System.gc()语句"></a>1.4.1 System.gc()语句</h3><p>特点：</p>
<ul>
<li>运行了<code>System.gc()</code>方法，但不保证 JVM 的垃圾收集器一定会执行。</li>
<li>GC 的线程优先级别较低。</li>
<li>HotSpot 将 GC 分解为一系列的小步骤，能够通过平缓的方式释放内存。</li>
</ul>
<h2 id="1-5-方法区的-GC"><a href="#1-5-方法区的-GC" class="headerlink" title="1.5 方法区的 GC"></a>1.5 方法区的 GC</h2><ul>
<li>这里的方法区即 HotSpot 中的永久代；</li>
<li>永久代的回收效率较低；</li>
<li>永久代的垃圾收集主要包括两个部分：废弃常量和无用的类；前者类似于回收 Java 堆中的对象；后者判定无用类较繁琐，需要同时满足 3 个条件：<ol>
<li>该类的所有实例都已经被回收；</li>
<li>加载该类的 ClassLoader 已经被回收；</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方呗引用，无法再任何地方通过反射访问该类的方法。</li>
</ol>
</li>
<li>判定了是无用的类，也不是必然被回收。</li>
<li>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。<ul>
<li>由用户自定义的类加载器所加载的类是可以被卸载的。</li>
</ul>
</li>
</ul>
<h1 id="二、GC-算法思想及实现"><a href="#二、GC-算法思想及实现" class="headerlink" title="二、GC 算法思想及实现"></a>二、GC 算法思想及实现</h1><h2 id="2-1-常见的-GC-算法"><a href="#2-1-常见的-GC-算法" class="headerlink" title="2.1 常见的 GC 算法"></a>2.1 常见的 GC 算法</h2><p>常见的 GC 算法有：标记-清除算法、复制算法、标记-整理算法、分代收集算法。</p>
<h3 id="2-1-1-标记-清除算法"><a href="#2-1-1-标记-清除算法" class="headerlink" title="2.1.1 标记-清除算法"></a>2.1.1 标记-清除算法</h3><ul>
<li>思想：首先标记处所有需要回收的对象，标记完成后统一回收。</li>
<li>特点：<ul>
<li>两个过程效率低；</li>
<li>清除后产生大量内存碎片，如果碎片过多会导致以后分配较大对象时，因为无法找到足够的连续内存引起二次 GC 动作。</li>
</ul>
</li>
</ul>
<h3 id="2-1-2-复制算法"><a href="#2-1-2-复制算法" class="headerlink" title="2.1.2 复制算法"></a>2.1.2 复制算法</h3><ul>
<li>思想：将可用内存标记为两块，每次仅使用一块，另一块用来复制（如 hotSpot 将 Eden 区和 Survivor 区*2 大小设为 8：1：1；每次留出 1 份 Survivor 区不使用）。需要 GC 时，将<code>使用区</code>中的存活对象复制到<code>复制区</code>上，然后将已使用的内存空间一次性清理掉。</li>
<li>特点：<ul>
<li>实现简单、运行高效，内存使用占约90%；</li>
<li>适合复制量不大（对象迭代快、存活对象不多）的新生代；</li>
<li>如果一份 Survivor 区大小不足，那么需要依赖其他内存（指老年代）进行分配担保。</li>
</ul>
</li>
</ul>
<h3 id="2-1-3-标记-整理算法"><a href="#2-1-3-标记-整理算法" class="headerlink" title="2.1.3 标记-整理算法"></a>2.1.3 标记-整理算法</h3><ul>
<li>老年代适用；</li>
<li>思想：首先标记待回收的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>
</ul>
<h3 id="2-1-4-分代收集算法"><a href="#2-1-4-分代收集算法" class="headerlink" title="2.1.4 分代收集算法"></a>2.1.4 分代收集算法</h3><ul>
<li>思想：根据对象存活周期的不同将内存划分为几块。一般将 Java 堆分为新生代和老年代，然后可以按块选择不同的 GC 算法。</li>
</ul>
<h2 id="2-2-GC-算法的具体实现"><a href="#2-2-GC-算法的具体实现" class="headerlink" title="2.2 GC 算法的具体实现"></a>2.2 GC 算法的具体实现</h2><h3 id="枚举-GC-Roots"><a href="#枚举-GC-Roots" class="headerlink" title="枚举 GC Roots"></a>枚举 GC Roots</h3><ul>
<li>GC Roots 主要在全局性引用（常量、类静态属性）和执行上下文（栈帧的本地变量表）中。枚举过程需要关注两个问题：检查引用的耗时问题和枚举根节点的 GC 停顿问题上。</li>
</ul>
<h4 id="检查引用"><a href="#检查引用" class="headerlink" title="检查引用"></a>检查引用</h4><ul>
<li>保守式 GC：JVM 不知道内存某个位置上的数据是引用类型还是整型还是别的什么类型。在 GC 时，判断数字是不是指向堆的指针，涉及到上下边界的检查、对齐检查等。缺点：如果有疑似指针指向对象，那么本该回收的对象就会逃过检查；因为不能断定某个数据是指针，所以数值不能修改，即不能移动对象，但添加句柄（即中间层）可以同时做到保守式 GC 和移动对象的功能。</li>
<li>半保守式 GC：JVM 在栈上不记录类型信息，在对象上记录类型信息。特点：支持部分对象的移动，但仍然有“疑似指针”的问题。</li>
<li>准确式 GC：JVM 能够判断所有位置上的数据是不是指向 GC 堆里的引用，包括活动记录（栈+寄存器）里的数据。</li>
<li>在HotSpot中，使用 OopMap 的数据结构来让 JVM 获知存放对象引用的地方。这样就不用遍历整个内存去查找了，也不会将所有指令都生成 OopMap ，只会在安全点上生成 OopMap，在安全区域上开始 GC。</li>
<li>扩展阅读：<a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html">JVM参数设置、分析</a></li>
</ul>
<h4 id="OopMap"><a href="#OopMap" class="headerlink" title="OopMap"></a>OopMap</h4><ul>
<li>可以把 OopMap 简单理解成是<strong>调试信息</strong>。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。OopMap 就是一个附加的信息，告诉你栈上哪个位置本来是个什么类型的东西。</li>
<li>这个信息是在 <strong>JIT 编译时跟机器码一起产生的（会在特定的位置记录下栈和寄存器中哪些位置是引用）</strong>。因为只有编译器知道源代码跟产生的代码的对应关系。 </li>
<li>这样，GC 在扫描时就可以直接得知这些信息了。 </li>
<li>附：这些特定的位置就是<strong>安全点</strong>。主要在：<ul>
<li>循环的末尾</li>
<li>方法临返回前&#x2F;调用方法的 call 指令后</li>
<li>可能抛异常的位置</li>
</ul>
</li>
</ul>
<h4 id="安全点-safepoint"><a href="#安全点-safepoint" class="headerlink" title="安全点 safepoint"></a>安全点 safepoint</h4><ul>
<li>浅显的理解：安全点，意思是当前 JVM 的状态是安全的，如果有需要，可以在这个位置暂停。</li>
<li>每个方法可能会有好几个 OopMap ，就是根据 safepoint 把一个方法的代码分成几段，每一段代码一个 OopMap ，作用域自然也仅限于这一段代码。</li>
<li>循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的 OopMap 就会包含多条记录。</li>
<li>让所有线程停顿在安全点，有两种策略：抢占式（不采用）和主动式。</li>
<li>安全区域：在一段代码中，引用关系不会发生变化，整个区域发生 GC 都是安全的。</li>
</ul>
<h4 id="GC-停顿"><a href="#GC-停顿" class="headerlink" title="GC 停顿"></a>GC 停顿</h4><ul>
<li>可达性分析时，整个执行系统最好被冻结在某个时间点上，以免发生分析过程中对象引用关系还在不断变化的情况。所以在 GC 进行时，必须停顿所有 Java 执行线程。</li>
</ul>
<h1 id="三、HotSpot-的收集器"><a href="#三、HotSpot-的收集器" class="headerlink" title="三、HotSpot 的收集器"></a>三、HotSpot 的收集器</h1><p>HotSpot的收集器有大约7款，用于新生代：Serial、ParNew、Parallel Scavenge；用于老年代：CMS、Serival Old、Parallel Old；跨界G1。</p>
<h2 id="3-1-Serial-收集器"><a href="#3-1-Serial-收集器" class="headerlink" title="3.1 Serial 收集器"></a>3.1 Serial 收集器</h2><ul>
<li>历史最早收集器；</li>
<li>新生代采取复制算法、老年代采用标记-整理算法。</li>
<li>单线程，即垃圾回收时，必须暂停其他所有的工作线程，直到它收集结束。称为“stop the world”。</li>
<li>特点：简单高效，是 client 模式下的默认新生代收集器。</li>
</ul>
<h2 id="3-2-ParNew-收集器"><a href="#3-2-ParNew-收集器" class="headerlink" title="3.2 ParNew 收集器"></a>3.2 ParNew 收集器</h2><ul>
<li>是 Serival 收集器的多线程版本，即多线程收集。</li>
<li>新生代采取复制算法、老年代采用标记-整理算法。</li>
<li>只有 ParNew 能与 CMS 收集器（是第一款真正意义上的并发收集器，可以边制造垃圾边收集垃圾）配合工作，所以是 Server 模式下首选的新生代收集器。</li>
</ul>
<h2 id="3-3-Parallel-Scavenge-收集器"><a href="#3-3-Parallel-Scavenge-收集器" class="headerlink" title="3.3 Parallel Scavenge 收集器"></a>3.3 Parallel Scavenge 收集器</h2><ul>
<li>跟 ParNew 类似，但关注点不同；</li>
<li>其他收集器关注点在于尽可能地缩短垃圾收集时用户线程的停顿时间；Parallel Scavenge 收集器关注一个可控的吞吐量（Throughput）：CPU用于运行用户代码的时间与CPU总消耗时间的比值。<ul>
<li>前者适合较多交互的程序，能够提升用户体验；后者可以高效率利用 CPU 时间，能够尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</li>
</ul>
</li>
<li>虚拟机运行 100 分钟，GC 耗时 1 分钟，那么吞吐量就是 99%。</li>
<li>提供两个参数 MaxGCPauseMillis 和 GCTimeRatio 参数。<ul>
<li>MaxGCPauseMillis 控制最大垃圾收集停顿时间。过大引起单次 GC 耗时长，过小引起 GC 次数增加，吞吐量下降。</li>
<li>GCTimeRatio 直接设置吞吐量大小。介于 0 到 100 之间（默认 99），运行客户代码时间&#x2F;垃圾回收时间，若参数设为19，则最大 GC 时间占总时间的 5%。</li>
</ul>
</li>
</ul>
<h2 id="3-4-Serial-Old-收集器"><a href="#3-4-Serial-Old-收集器" class="headerlink" title="3.4 Serial Old 收集器"></a>3.4 Serial Old 收集器</h2><ul>
<li>Serial 收集器的老年代版本；</li>
<li>主要给 Client 模式下的虚拟机使用；如果在 Server 模式下，有两大用途：<ul>
<li>与 Parallel Scavenge收集器搭配使用；</li>
<li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure时使用。</li>
</ul>
</li>
</ul>
<h2 id="3-5-Parallel-Old-收集器"><a href="#3-5-Parallel-Old-收集器" class="headerlink" title="3.5 Parallel Old 收集器"></a>3.5 Parallel Old 收集器</h2><ul>
<li>Parallel Scavenge 收集器的老年代版本；</li>
<li>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</li>
</ul>
<h2 id="3-6-CMS-收集器"><a href="#3-6-CMS-收集器" class="headerlink" title="3.6 CMS 收集器"></a>3.6 CMS 收集器</h2><ul>
<li>Concurrent Mark Sweep</li>
<li>目标为获得最短回收停顿时间，应用在很大部分的互联网站或者 B&#x2F;S 系统的服务端上。</li>
<li>基于标记-清除算法实现。清理过程分为四步：<ul>
<li>初始标记：依然需要“STW”，标记 GC Roots 能直接关联到的对象，速度快。</li>
<li>并发标记：进行 GC RootsTracing。</li>
<li>重新标记：依然需要“STW”，修正并发标记期间因用户程序继续运作导致的标记产生变动的那一部分对象的标记记录。耗时比初始标记时间稍长，但比并发标记时间短。</li>
<li>并发清除。</li>
</ul>
</li>
<li>特点：<ul>
<li>并发收集、低停顿；</li>
<li>对 CPU 资源非常敏感，如果 CPU 多于 4 个，GC 线程不少于 25%，并且随 CPU 数量的增加而下降。但如果 CPU 个数不足 4 个时，GC 线程数量对用户程序的影响可能变得很大。为了应对这种情况，JVM 提供了一种“增量式并发收集器”，但因效果差被标记为 deprecated ，不提倡使用。</li>
<li>无法处理浮动垃圾，此处的浮动垃圾主要指“并发清除”阶段用户产生的垃圾，只能留待下一次 GC 时再清理掉。</li>
<li>因为采用的标记-清除算法，所以会产生大量空间碎片。</li>
</ul>
</li>
</ul>
<h2 id="3-7-G1-收集器"><a href="#3-7-G1-收集器" class="headerlink" title="3.7 G1 收集器"></a>3.7 G1 收集器</h2><ul>
<li><p>成熟、商用级别的收集器，面向服务端应用。</p>
</li>
<li><p>特点：并行与并发、分代收集、空间整合、可预测的停顿。</p>
<ul>
<li>并行与并发：使用多个 CPU 来缩短 STW 停顿的时间，GC 时仍能够运行 Java 程序。</li>
<li>分代收集：能够独立管理整个 GC 堆。</li>
<li>空间整合：运行期间不会产生内存碎片，收集之后能提供规整的可用内存。</li>
<li>可预测的停顿：建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不超过 N 毫秒。</li>
<li>重新划分 Java 堆，新老生代的隔离不再是物理隔离（新生代不再需要物理上连续），而是逻辑隔离。</li>
<li>内存“化整为零”的漏洞：即回收新生代时也需要扫描老生代，可以通过在GC roots 枚举范围中加入 Remembered Set 来解决。</li>
</ul>
</li>
<li><p>不计算维护 Remembered Set 的操作，G1 运作步骤：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>筛选回收</li>
</ol>
</li>
</ul>
<h2 id="3-8-GC-日志"><a href="#3-8-GC-日志" class="headerlink" title="3.8 GC 日志"></a>3.8 GC 日志</h2><ul>
<li>最前面的数字是 GC 发生的时间（自 JVM 启动以来经过的秒数）；</li>
<li>“GC”和“FULL GC”，如果有“FULL”说明这次 GC 发生了 STW；</li>
<li>“3324K -&gt; 152K(3712K)”：方括号内的表示“GC 前该内存区域已使用容量-&gt;GC 后该内存区域已使用容量（该内存区域总容量）”；方括号外的表示“GC 前 Java 堆已使用容量-&gt; GC 后 Java 堆已使用容量（Java 堆总容量）”。</li>
<li>“0.0025925 secs”，指该区域内 GC 耗时。</li>
</ul>
<h1 id="四、内存如何分配"><a href="#四、内存如何分配" class="headerlink" title="四、内存如何分配"></a>四、内存如何分配</h1><p>内存分配规则并不是百分百固定的，分配细节取决于采用的哪一种垃圾收集器组合，还取决于 JVM 中与内存相关的参数的设置。<br>以下是一些最普遍的内存分配规则：</p>
<h2 id="4-1-对象优先在-Eden-分配"><a href="#4-1-对象优先在-Eden-分配" class="headerlink" title="4.1 对象优先在 Eden 分配"></a>4.1 对象优先在 Eden 分配</h2><ul>
<li>大多数情况下，对象在新生代 Eden 区中分配，当 Eden 区没有足够空间进行分配时，JVM 将发起一次 Minor GC。<ul>
<li>Minor GC，即新生代 GC，发生频繁，回收速度较快；</li>
<li>Major GC&#x2F;Full GC，即老年代 GC，出现了 Major GC，经常会伴随至少一次的 Minor GC。</li>
</ul>
</li>
</ul>
<h2 id="4-2-大对象直接进入老年代"><a href="#4-2-大对象直接进入老年代" class="headerlink" title="4.2 大对象直接进入老年代"></a>4.2 大对象直接进入老年代</h2><ul>
<li>大对象多指很长的字符串以及数组。会给 JVM 带来不少麻烦，比如提前触发 GC 等。</li>
</ul>
<h2 id="4-3-长期存活的对象将进入老年代"><a href="#4-3-长期存活的对象将进入老年代" class="headerlink" title="4.3 长期存活的对象将进入老年代"></a>4.3 长期存活的对象将进入老年代</h2><ul>
<li>JVM 给每个对象定义了一个对象年龄（Age）计数器。</li>
<li>如果对象在Eden出生，并经历一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并且 Age 设为1；对象在 Survivor 区中没熬过一次 Minor GC ，Age加一，当年龄增加到一个阈值（默认15），会被晋升到老年代。</li>
</ul>
<h2 id="4-4-动态对象年龄判定"><a href="#4-4-动态对象年龄判定" class="headerlink" title="4.4 动态对象年龄判定"></a>4.4 动态对象年龄判定</h2><ul>
<li>除了配置年龄晋升阈值外，还可以适应不同程序的内存状况动态调节。</li>
<li>比如：如果 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，那么大于或等于该年龄的对象直接进入老年代。</li>
</ul>
<h2 id="4-5-空间分配担保"><a href="#4-5-空间分配担保" class="headerlink" title="4.5 空间分配担保"></a>4.5 空间分配担保</h2><ul>
<li>Minor GC 前，JVM 会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。<ul>
<li>如果这个条件成立，那么 Minor GC 可以担保是安全的。</li>
<li>如果不成立，JVM 会查看 HandlePromotionFailure 设置值是否允许担保失败（此 Handle 在 JDK 6 后已不再使用）。<ul>
<li>如果允许担保失败（即冒风险），那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次有风险的 Minor GC；如果小于，或者不允许担保失败，那么要改为一次 FULL GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM（3）</title>
    <url>/2018/09/30/JVM%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h2 id="JVM-学习资源"><a href="#JVM-学习资源" class="headerlink" title="JVM 学习资源"></a>JVM 学习资源</h2><p><a href="https://blog.csdn.net/lirenzuo/article/details/81182686">JVM 系列文章</a></p>
<p>以下图片参考上方链接</p>
<span id="more"></span>

<p><img src="/2018/09/30/JVM%EF%BC%883%EF%BC%89/1.png"></p>
<h1 id="JVM-性能监测工具剖析"><a href="#JVM-性能监测工具剖析" class="headerlink" title="JVM 性能监测工具剖析"></a>JVM 性能监测工具剖析</h1><p>注：代码中以<code>//</code>开头的为笔者备注\</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">主要作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jps</td>
<td align="center">显示指定系统内所有的 HotSpot 虚拟机进程</td>
</tr>
<tr>
<td align="center">jstat</td>
<td align="center">用于收集 HotSpot 虚拟机各方面的运行数据</td>
</tr>
<tr>
<td align="center">jinfo</td>
<td align="center">显示虚拟机配置信息</td>
</tr>
<tr>
<td align="center">jmap</td>
<td align="center">生成虚拟机的内存转储快照（即 heapdump 文件）</td>
</tr>
<tr>
<td align="center">jhat</td>
<td align="center">用于分析 heapdump 文件，会建立一个 HTTP 服务器，用户可使用浏览器查看</td>
</tr>
<tr>
<td align="center">jstack</td>
<td align="center">显示虚拟机的线程快照</td>
</tr>
</tbody></table>
<p>推荐阅读：<a href="https://blog.csdn.net/fenglibing/article/details/6411999">JDK 内置工具使用</a></p>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><ul>
<li>查看虚拟机进程，JVM Process Status</li>
<li>格式：jps[option][hostid]</li>
<li>option：<ul>
<li>-q：只输出 LVMID</li>
<li>-m：输出虚拟机进程启动时传递给主类 main()函数的参数</li>
<li>-l：输出主类的全名，如果进程执行的是 jar 包，输出 jar 路径</li>
<li>-v：输出虚拟机进程启动时 JVM 参数</li>
</ul>
</li>
<li>hostid：指定特定主机，若不填默认本机</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[root@VM_0_2_centos ~]<span class="comment"># jps -l</span></span><br><span class="line"><span class="number">18340</span> sun.tools.jps.Jps   <span class="regexp">//</span>当前查询进程，即 jps 进程</span><br><span class="line"><span class="number">27848</span> <span class="regexp">/opt/gi</span>tblit/gitblit.jar</span><br><span class="line"><span class="number">14479</span> gitblit.jar</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>说明当前有 <span class="number">14479</span> 和 <span class="number">27848</span> 两个虚拟机进程</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><ul>
<li>收集 HotSpot 虚拟机各方面的运行数据，JVM Statistics Monitoring</li>
<li>格式：jstat[option vmid [interval[s|ms][count] ] ]</li>
<li>vmid:<ul>
<li>如果是本地，即Lvmid；</li>
<li>如果是远程，则vmid要用[protocol:][&#x2F;&#x2F;]lvmid[@hostname[:port]&#x2F;servername]，官方文档：<a href="https://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html">jstat - Java Virtual Machine Statistics Monitoring Tool</a></li>
</ul>
</li>
<li>option：<ul>
<li>-class，监视<strong>类</strong>装载、卸载数量、总空间、装载耗时</li>
<li>-gc，监视 Java 堆状况，包括 Eden 区、两个 Survivor 区、老年代、永久代的容量，已用空间、GC 时间合计等信息</li>
<li>-gcutil，监视内容类似gc，但主要关注已使用空间占总空间的百分比</li>
<li>。。。不详述</li>
</ul>
</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">[root@VM_0_2_centos ~]# jstat -<span class="keyword">class</span> 14479 <span class="comment">// 查看类</span></span><br><span class="line">Loaded  Bytes  Unloaded  Bytes     Time <span class="comment">// 装数量 空间 卸数量 空间 装耗时</span></span><br><span class="line"> 12042 21286.9     4260  6564.5       8.09</span><br><span class="line"></span><br><span class="line">[root@VM_0_2_centos ~]# jstat -gcnew 14479 <span class="comment">// 监视新生代的 GC</span></span><br><span class="line"> S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT</span><br><span class="line">2688.0 2688.0    0.0  143.0 15  15 1344.0  22016.0  17339.3   1595    5.526</span><br><span class="line"><span class="comment">//S0C、S0U 分别是第一个 Survivor 区的总容量和使用量；</span></span><br><span class="line">TT、MTT 是持有次数限制与最大持有次数限制；</span><br><span class="line">DSS 是当前需要 Survivor 的容量</span><br><span class="line">EC、EU 分别是新生代中总容量和已使用量；</span><br><span class="line">YGC 是<span class="keyword">app</span>启动到当前新生代 GC 的次数；</span><br><span class="line">YGCT 是<span class="keyword">app</span>启动到当前新生代 GC 的总耗时（s）；</span><br><span class="line"></span><br><span class="line">[root@VM_0_2_centos ~]# jstat -gcutil 14479 <span class="comment">// 关注已使用空间的百分比</span></span><br><span class="line">  S0     S1     <span class="keyword">E</span>      O      <span class="keyword">M</span>     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line">  0.00   5.32  78.76  84.37  95.41  91.95   1595    5.526    26    2.402    7.928</span><br><span class="line"><span class="comment">//S0、S1、E、O、M分别是两个 Survivor、新生代、老年代、永久代的使用百分比；</span></span><br><span class="line">CCS 是压缩使用比例</span><br><span class="line">YGC、FGC 是<span class="keyword">app</span>启动到当前新生代、老年代 GC 的次数；</span><br><span class="line">YGCT、FGCT 是<span class="keyword">app</span>启动到当前新生代、老年代 GC 的总耗时（s）；</span><br><span class="line">GCT 是<span class="keyword">app</span>启动到当前 GC 的总耗时（s）；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>S0C：年轻代中第一个survivor（幸存区）的容量 (字节) <br>S1C：年轻代中第二个survivor（幸存区）的容量 (字节) <br>S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (字节) <br>S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (字节) <br>EC：年轻代中Eden（伊甸园）的容量 (字节) <br>EU：年轻代中Eden（伊甸园）目前已使用空间 (字节) <br>OC：Old代的容量 (字节) <br>OU：Old代目前已使用空间 (字节) <br>PC：Perm(持久代)的容量 (字节) <br>PU：Perm(持久代)目前已使用空间 (字节) <br>YGC：从应用程序启动到采样时年轻代中gc次数 <br>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s) <br>FGC：从应用程序启动到采样时old代(全gc)gc次数 <br>FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s) <br>GCT：从应用程序启动到采样时gc用的总时间(s) <br>NGCMN：年轻代(young)中初始化(最小)的大小 (字节) <br>NGCMX：年轻代(young)的最大容量 (字节) <br>NGC：年轻代(young)中当前的容量 (字节) <br>OGCMN：old代中初始化(最小)的大小 (字节) <br>OGCMX：old代的最大容量 (字节) <br>OGC：old代当前新生成的容量 (字节) <br>PGCMN：perm代中初始化(最小)的大小 (字节) <br>PGCMX：perm代的最大容量 (字节)   <br>PGC：perm代当前新生成的容量 (字节) <br>S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比 <br>S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比 <br>E：年轻代中Eden（伊甸园）已使用的占当前容量百分比 <br>O：old代已使用的占当前容量百分比 <br>P：perm代已使用的占当前容量百分比 <br>S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (字节) <br>S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (字节) <br>ECMX：年轻代中Eden（伊甸园）的最大容量 (字节) <br>DSS：当前需要survivor（幸存区）的容量 (字节)（Eden区已满） <br>TT： 持有次数限制 <br>MTT ： 最大持有次数限制</p>
</blockquote>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><ul>
<li>实时查看 JVM 各项参数，功能不全，一般只用flag</li>
<li>格式：jinfo[option] pid</li>
<li>option：<ul>
<li>-flag：</li>
</ul>
</li>
</ul>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><ul>
<li>生成堆转储快照</li>
<li>格式：jmap[option]vmid</li>
<li>option：<ul>
<li>-dump：生成快照</li>
<li>-heap：显示 Java 堆详细信息</li>
<li>-histo：显示堆中对象统计信息，包括类、实例数量、合计容量</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><ul>
<li>虚拟机堆转储快照分析工具，JVM Heap Analysis Tool</li>
<li>功能较少，推荐使用更专业的工具，如 VisualVM 等</li>
</ul>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><ul>
<li>Java 堆栈跟踪工具，用来用来监控 JVM 中每一条线程正在执行的方法堆栈的集合，想知道某个线程正在做什么，或者因为什么不响应了</li>
<li>格式：jstack[option]vmid</li>
<li>option：<ul>
<li>-l：除堆栈外，显示关于锁的附加信息</li>
<li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-m：如果调用到本地方法的话，可以显示 C&#x2F;C++ 的堆栈</li>
</ul>
</li>
</ul>
<pre><code>[root@VM_0_2_centos ~]# jstack -l 14479  //查的gitblit.jar
2018-10-01 10:31:58
Full thread dump OpenJDK 64-Bit Server VM (25.171-b10 mixed mode):

//jstack 连接
&quot;Attach Listener&quot; #168 daemon prio=9 os_prio=0 tid=0x00007f9c18075d70 nid=0x1d6a waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE //说明正常运行

   Locked ownable synchronizers:
    - None

&quot;qtp1279149968-166&quot; #166 prio=5 os_prio=0 tid=0x00007f9c1088fd10 nid=0x22af waiting on condition [0x00007f9c07dfe000]
   java.lang.Thread.State: TIMED_WAITING (parking)
    at sun.misc.Unsafe.park(Native Method)
    - parking to wait for  &lt;0x00000000ece65c08&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
    at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:215)
    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2078)
    at org.eclipse.jetty.util.BlockingArrayQueue.poll(BlockingArrayQueue.java:389)
    at org.eclipse.jetty.util.thread.QueuedThreadPool.idleJobPoll(QueuedThreadPool.java:531)
    at org.eclipse.jetty.util.thread.QueuedThreadPool.access$700(QueuedThreadPool.java:47)
    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:590)
    at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
    - None

...
//删减
...

&quot;qtp1279149968-11-selector-ServerConnectorManager@2f0559e0/0&quot; #11 prio=5 os_prio=0 tid=0x00007f9c40638230 nid=0x389c runnable [0x00007f9c0f735000]
   java.lang.Thread.State: RUNNABLE
    at sun.nio.ch.EPollArrayWrapper.epollWait(Native Method)
    at sun.nio.ch.EPollArrayWrapper.poll(EPollArrayWrapper.java:269)
    at sun.nio.ch.EPollSelectorImpl.doSelect(EPollSelectorImpl.java:93)
    at sun.nio.ch.SelectorImpl.lockAndDoSelect(SelectorImpl.java:86)
    - locked &lt;0x00000000ed2fdb60&gt; (a sun.nio.ch.Util$3)
    - locked &lt;0x00000000ed2fdb70&gt; (a java.util.Collections$UnmodifiableSet)
    - locked &lt;0x00000000ed2fdb18&gt; (a sun.nio.ch.EPollSelectorImpl)
    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:97)
    at sun.nio.ch.SelectorImpl.select(SelectorImpl.java:101)
    at org.eclipse.jetty.io.SelectorManager$ManagedSelector.select(SelectorManager.java:600)
    at org.eclipse.jetty.io.SelectorManager$ManagedSelector.run(SelectorManager.java:549)
    at org.eclipse.jetty.util.thread.NonBlockingThread.run(NonBlockingThread.java:52)
    at org.eclipse.jetty.util.thread.QueuedThreadPool.runJob(QueuedThreadPool.java:635)
    at org.eclipse.jetty.util.thread.QueuedThreadPool$3.run(QueuedThreadPool.java:555)
    at java.lang.Thread.run(Thread.java:748)

   Locked ownable synchronizers:
    - None

&quot;Gitblit Shutdown Monitor&quot; #8 daemon prio=5 os_prio=0 tid=0x00007f9c4062f4a0 nid=0x389a runnable [0x00007f9c0f937000]
   java.lang.Thread.State: RUNNABLE
    at java.net.PlainSocketImpl.socketAccept(Native Method)
    at java.net.AbstractPlainSocketImpl.accept(AbstractPlainSocketImpl.java:409)
    at java.net.ServerSocket.implAccept(ServerSocket.java:545)
    at java.net.ServerSocket.accept(ServerSocket.java:513)
    at com.gitblit.GitBlitServer$ShutdownMonitorThread.run(GitBlitServer.java:517)

   Locked ownable synchronizers:
    - None

&quot;Service Thread&quot; #7 daemon prio=9 os_prio=0 tid=0x00007f9c400eaf20 nid=0x3897 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
    - None

&quot;C1 CompilerThread1&quot; #6 daemon prio=9 os_prio=0 tid=0x00007f9c400dc2f0 nid=0x3896 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
    - None

&quot;C2 CompilerThread0&quot; #5 daemon prio=9 os_prio=0 tid=0x00007f9c400da750 nid=0x3895 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
    - None

&quot;Signal Dispatcher&quot; #4 daemon prio=9 os_prio=0 tid=0x00007f9c400d8c20 nid=0x3894 runnable [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE

   Locked ownable synchronizers:
    - None

&quot;Finalizer&quot; #3 daemon prio=8 os_prio=0 tid=0x00007f9c400af720 nid=0x3893 in Object.wait() [0x00007f9c44197000]
   java.lang.Thread.State: WAITING (on object monitor) //等待资源来唤醒
    at java.lang.Object.wait(Native Method)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
    - locked &lt;0x00000000ecdb7dd8&gt; (a java.lang.ref.ReferenceQueue$Lock)
    at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
    at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:212)

   Locked ownable synchronizers:
    - None

&quot;Reference Handler&quot; #2 daemon prio=10 os_prio=0 tid=0x00007f9c400ab4b0 nid=0x3892 in Object.wait() [0x00007f9c44298000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.lang.Object.wait(Object.java:502)
    at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
    - locked &lt;0x00000000ecdb7f90&gt; (a java.lang.ref.Reference$Lock)
    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

   Locked ownable synchronizers:
    - None

&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00007f9c400093c0 nid=0x3890 in Object.wait() [0x00007f9c47b48000]
   java.lang.Thread.State: WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    - waiting on &lt;0x00000000ece31020&gt; (a java.lang.Object)
    at java.lang.Object.wait(Object.java:502)
    at org.eclipse.jetty.util.thread.QueuedThreadPool.join(QueuedThreadPool.java:381)
    - locked &lt;0x00000000ece31020&gt; (a java.lang.Object)
    at org.eclipse.jetty.server.Server.join(Server.java:556)
    at com.gitblit.GitBlitServer.start(GitBlitServer.java:461)
    at com.gitblit.GitBlitServer.main(GitBlitServer.java:124)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at org.moxie.MxLauncher.main(MxLauncher.java:129)

   Locked ownable synchronizers:
    - None

&quot;VM Thread&quot; os_prio=0 tid=0x00007f9c400a2000 nid=0x3891 runnable

&quot;VM Periodic Task Thread&quot; os_prio=0 tid=0x00007f9c4001b250 nid=0x3898 waiting on condition

JNI global references: 281

// 着重关注 Deadlock 死锁、Waiting on condition 等待资源或条件来唤醒、Blocked 阻塞、Waiting on monitor entry 等待获取锁。
// 如果 CPU 高，线程可能有死循环，需要关注 Runable 状态 
</code></pre>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础刷题指南</title>
    <url>/2020/09/09/Java%E5%9F%BA%E7%A1%80%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>刷题来自牛客网。lee 的错题记录。</p>
<span id="more"></span>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1.</span> 说法正误</span><br><span class="line">在java中，无论在何处调用，使用静态属性必须以类名做前缀。<span class="comment">//false。</span></span><br><span class="line"><span class="comment">//1如果是本类使用，可以直接就用静态变量名。2如果是其他类使用，可以使用类名来调用，也可以创建一个实例对象来调用。3如果静态变量所在的类是静态类，那么不管在本类里或者在其他外部类，都可以直接使用静态变量名。</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 说法正误</span><br><span class="line">在方法中定义的局部变量在该方法被执行时创建。<span class="comment">//false。</span></span><br><span class="line"><span class="comment">//不是局部变量在该方法被执行/调用时创建，而是应该为在该变量被声明并赋值时创建，可以理解为“当代码执行到该变量被赋值的代码时才被创建”。</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 语法正误</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>; <span class="comment">// false。final修饰的类为终态类，而抽象类是必须被继承的才有其意义的。所以 final 不能用来修饰抽象类的。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>; <span class="comment">//false。final修饰的方法为终态方法，不能被重写，而继承抽象类，必须重写其方法。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123; <span class="comment">// false。抽象方法是仅声明，并不做实现的方法。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">													 <span class="comment">// true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 结果正误</span><br><span class="line">String str1=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">String str2=<span class="string">&quot;he&quot;</span>+ <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">System.out.println(str1==str2); <span class="comment">// false。str1 指向字面量“hello”，这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new String(&quot;llo&quot;)在编译期时创建一个“llo”的字面量（在 String pool 中），在运行期执行new命令创建另一个“llo”（在堆中）</span></span><br><span class="line"><span class="comment">//String s = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;; 语句中，“a”,&quot;b&quot;, &quot;c&quot;都是常量，编译时就直接存储他们的字面值，而不是他们的引用，在编译时就直接将它们连接的结果提取出来变成&quot;abc&quot;了。</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 语法正误</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">1.0f</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">			<span class="type">Test</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">			t.f;<span class="comment">//true。因为main函数在该类中，所以即使private也仍可使用</span></span><br><span class="line">			<span class="built_in">this</span>.n;<span class="comment">//false。this不能在static的方法中使用</span></span><br><span class="line">			Test.m;<span class="comment">//false。m 和 f 都是普通成员属性</span></span><br><span class="line">			Test.f;<span class="comment">//false。m 和 f 都是普通成员属性</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 输出结果：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharToString</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">char</span> <span class="variable">myChar</span> <span class="operator">=</span> <span class="string">&#x27;g&#x27;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">myStr</span> <span class="operator">=</span> Character.toString(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line">  myStr = String.valueOf(myChar);</span><br><span class="line">  System.out.println(<span class="string">&quot;String is: &quot;</span>+myStr);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">output：</span><br><span class="line">String is: g <span class="comment">// toString 和 valueOf 方法返回值都是 String</span></span><br><span class="line">String is: g <span class="comment">// 只有char变成 int 的时候才会变为对应的assic码</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 输出结果</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">		Thread t=<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		t.start();</span><br><span class="line">		t.join();</span><br><span class="line">		System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">output：<span class="number">21</span> <span class="comment">// thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。</span></span><br><span class="line"><span class="comment">//t.join();      //使调用线程 t 在此之前执行完毕。</span></span><br><span class="line"><span class="comment">//t.join(1000);  //等待 t 线程，等待时间是1000毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span> 说法正误</span><br><span class="line">Hashtable 和 HashMap 的区别是：</span><br><span class="line">  Hashtable 是一个哈希表，该类继承了 AbstractMap，实现了Map接口 <span class="comment">// false。Hashtable 继承了Dictionary 类。</span></span><br><span class="line">  HashMap 是内部基于哈希表实现，该类继承AbstractMap，实现Map接口 <span class="comment">// true。</span></span><br><span class="line">  Hashtable 线程安全的，而 HashMap 是线程不安全的 <span class="comment">// true。</span></span><br><span class="line">  Properties 类 继承了 Hashtable 类，而 Hashtable 类则继承Dictionary 类 <span class="comment">// true。</span></span><br><span class="line">  HashMap允许将 <span class="literal">null</span> 作为一个 entry 的 key 或者 value，而 Hashtable 不允许。<span class="comment">// true。Hashtable 的key、value都不可以为null。</span></span><br><span class="line"><span class="comment">// 另外，Hashtable 使用对象的hashCode，而 HashMap 重新计算 hash</span></span><br><span class="line">  </span><br><span class="line"><span class="number">9.</span> 输出结果</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">B</span>().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span> <span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value= value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                value ++;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(<span class="number">5</span>);</span><br><span class="line">            setValue(getValue()- <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.setValue(<span class="number">2</span> * value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output：<span class="number">22</span> <span class="number">34</span> <span class="number">17</span></span><br><span class="line">Step <span class="number">1</span>:  <span class="keyword">new</span> <span class="title class_">B</span>()构造一个B类的实例</span><br><span class="line">  此时<span class="built_in">super</span>(<span class="number">5</span>)语句调用显示调用父类A带参的构造函数，该构造函数调用setValue(v)，这里有两个注意点一是虽然构造函数是A类的构造函数，但此刻正在初始化的对象是B的一个实例，因此这里调用的实际是B类的setValue方法，于是调用B类中的setValue方法 ==&gt; 而B类中setValue方法显示调用父类的setValue方法，将B实例的value值设置为<span class="number">2</span> x <span class="number">5</span> = <span class="number">10</span>。</span><br><span class="line">  紧接着，B类的构造函数还没执行完成，继续执行setValue(getValue()- <span class="number">3</span>) <span class="comment">// 备注1语句。</span></span><br><span class="line">  先执行getValue方法，B类中没有重写getValue方法，因此调用父类A的getValue方法。这个方法比较复杂，需要分步说清楚：</span><br><span class="line">  调用getValue方法之前，B的成员变量value值为<span class="number">10</span>。</span><br><span class="line">  value++ 执行后， B的成员变量value值为<span class="number">11</span>，此时开始执行到<span class="keyword">return</span>语句，将<span class="number">11</span>这个值作为getValue方法的返回值返回出去</span><br><span class="line">  但是由于getValue块被<span class="keyword">try</span> <span class="keyword">finally</span>块包围，因此<span class="keyword">finally</span>中的语句无论如何都将被执行，所以步骤<span class="number">2</span>中<span class="number">11</span>这个返回值会先暂存起来，到<span class="keyword">finally</span>语句块执行完毕后再真正返回出去。</span><br><span class="line">  这里有很重要的一点：<span class="keyword">finally</span>语句块中 <span class="built_in">this</span>.setValue(value)方法调用的是B类的setValue方法。为什么？因为此刻正在初始化的是B类的一个对象（运行时多态），就像最开始第一步提到的一样(而且这里用了使用了<span class="built_in">this</span>关键词显式指明了调用当前对象的方法)。因此，此处会再次调用B类的setValue方法，同上，<span class="built_in">super</span>.关键词显式调用A的setValue方法，将B的value值设置成为了<span class="number">2</span> * <span class="number">11</span> = <span class="number">22</span>。</span><br><span class="line">  因此第一个打印项为<span class="number">22</span>。  </span><br><span class="line">  <span class="keyword">finally</span>语句执行完毕 会把刚刚暂存起来的<span class="number">11</span> 返回出去，也就是说这么经历了这么一长串的处理，getValue方法最终的返回值是<span class="number">11</span>。</span><br><span class="line">  回到前面标注了 <span class="comment">//备注1 的代码语句，其最终结果为setValue(11-3)=&gt;setValue(8)</span></span><br><span class="line">  而大家肯定也知道，这里执行的setValue方法，将会是B的setValue方法。 之后B的value值再次变成了<span class="number">2</span>*<span class="number">8</span> = <span class="number">16</span>;</span><br><span class="line">Step2:  <span class="keyword">new</span> <span class="title class_">B</span>().getValue()</span><br><span class="line">  B类中没有独有的getValue方法，此处调用A的getValue方法。同Step <span class="number">1</span>，</span><br><span class="line">  调用getValue方法之前，B的成员变量value值为<span class="number">16</span>。</span><br><span class="line">  value++ 执行后， B的成员变量value值为<span class="number">17</span>，此时执行到<span class="keyword">return</span>语句，会将<span class="number">17</span>这个值作为getValue方法的返回值返回出去</span><br><span class="line">  但是由于getValue块被<span class="keyword">try</span> <span class="keyword">finally</span>块包围而<span class="keyword">finally</span>中的语句无论如何都一定会被执行，所以步骤<span class="number">2</span>中<span class="number">17</span>这个返回值会先暂存起来，到<span class="keyword">finally</span>语句块执行完毕后再真正返回出去。</span><br><span class="line">  <span class="keyword">finally</span>语句块中继续和上面说的一样: <span class="built_in">this</span>.setValue(value)方法调用的是B类的setValue()方法将B的value值设置成为了<span class="number">2</span> * <span class="number">17</span> = <span class="number">34</span>。</span><br><span class="line">  因此第二个打印项为<span class="number">34</span>。</span><br><span class="line">  <span class="keyword">finally</span>语句执行完毕 会把刚刚暂存起来的<span class="number">17</span>返回出去。</span><br><span class="line">  因此<span class="keyword">new</span> <span class="title class_">B</span>().getValue()最终的返回值是<span class="number">17.</span></span><br><span class="line">Step3:  main函数中的System.out.println</span><br><span class="line">	将刚刚返回的值打印出来，也就是第三个打印项：<span class="number">17</span></span><br><span class="line">  </span><br><span class="line"><span class="number">10.</span> 输出结果</span><br><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.print(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;e&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;E&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  <span class="comment">// 由于arr[0] =0,所以在进入 test()方法里面会在第一个if 上抛出一个 NullPointerException,接着会执行 finally 的语句, (finally语句先于 return 和 throw语句执行)，输出一个&#x27;e，然后回到 main方法中，由于捕捉到异常，所以进入到catch语句中，然后打印一个&#x27;E&#x27;,所以最终结果为&quot;eE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span> 输出结果</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span></span><br><span class="line"><span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.print(str.split(<span class="string">&quot;,&quot;</span>).length);</span><br><span class="line">output：<span class="number">1</span> <span class="comment">// String split 这个方法默认返回一个数组，如果没有找到分隔符，会把整个字符串当成一个长度为1的字符串数组</span></span><br><span class="line">  </span><br><span class="line"><span class="number">12.</span> 判断正误：关于Java中的ClassLoader 的描述：</span><br><span class="line">默认情况下，Java应用启动过程涉及三个ClassLoader: Boostrap, Extension, System <span class="comment">// true, System加载器也称应用加载器</span></span><br><span class="line">一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的 <span class="comment">// false</span></span><br><span class="line">类装载器需要保证类装载过程的线程安全 <span class="comment">// true</span></span><br><span class="line">ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回<span class="literal">null</span> <span class="comment">//false，会直接报错</span></span><br><span class="line">ClassLoader的父子结构中，默认装载采用了父优先 <span class="comment">// true</span></span><br><span class="line">所有ClassLoader装载的类都来自CLASSPATH环境指定的路径 <span class="comment">// false，自定义类加载器实现继承ClassLoader后重写了findClass方法，所以会加载指定路径（程序员自定义的）上的class</span></span><br><span class="line">  </span><br><span class="line"><span class="number">13.</span> 输出结果</span><br><span class="line"><span class="number">2009</span>的<span class="number">2009</span>次方，将结果各位数相加，得出结果如果不是一位数就继续各位相加，直到一位数，最后的结果是？</span><br><span class="line">output：<span class="number">5</span> <span class="comment">// 数字各位相加相当于原数字对 9 取模，2009 % 9可以表示成(9x+2) % 9 = 2，而2009*2009可以表示成(9x+2)(9x+2) % 9 = (9y + 4) % 9 = 4，同理接下去可以表示成(9z+4)(9x+2) % 9 = 8,可以得到规律是2，4，8，7，5，1，那第2009次就是5了</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现WEB-SSO单点登录</title>
    <url>/2018/08/10/Java%E5%AE%9E%E7%8E%B0WEB-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<h1 id="SSO的基本原理与Java代码实现"><a href="#SSO的基本原理与Java代码实现" class="headerlink" title="SSO的基本原理与Java代码实现"></a>SSO的基本原理与Java代码实现</h1><p>推荐阅读:<a href="https://www.cnblogs.com/ywlaker/p/6113927.html">单点登录原理与简单实现</a></p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li><p>Http无状态协议。浏览器使用http协议对服务器发出的每一次请求，服务器都会独立处理，不与之前或之后的请求产生关联，即无状态。所以为了保护服务器的某些资源，必须限制浏览器请求，鉴定请求的合法性。既然http无状态，就让服务器和浏览器共同维护一个状态，即会话机制。</p>
</li>
<li><p>会话。浏览器第一次请求服务器，服务器创建一个会话，并将会话的id作为响应的一部分发送给浏览器。浏览器存储该id，并在第二次第三次请求时带上该id，服务器取得请求中的会话id就知道是不是同一个用户了。</p>
</li>
<li><p>会话机制。服务器在内存中保存session对象。浏览器在cookie中保存sessionId，在Tomcat中sessionId用的是<code>JSESSIONID</code>，流程如下：</p>
<p>  <img src="/2018/08/10/Java%E5%AE%9E%E7%8E%B0WEB-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/1.png"></p>
</li>
<li><p>浏览器第一次输入帐密，服务器拿到帐密去数据库比对，比对正确说明是合法用户，将该会话标记为“已授权”或“已登录”的状态，该会话状态被服务器保存在会话对象中，当用户再次访问时，服务器在会话对象中查看登录状态，判断是否合法，合法后才允许访问。</p>
</li>
<li><p>单系统登录解决方案的核心是cookie，cookie携带会话id在浏览器和服务器之间维护会话状态，但cookie受到域的限制（通常对应网站的域名）。浏览器在发送http请求时会自动携带与该域匹配的cookie，而不是所有cookie。。需要注意的是，曾经流行过的顶级域名的方式虽然可行，但面临着应用群域名不统一，技术不同，共享cookie无法跨语言平台登录，cookie本身不安全等诸多问题。</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>单点登录（SSO）。举例：淘宝网上登录后，打开天猫、闲鱼、飞猪等网站会自动登录，无需重复进行身份验证，好处是方便管理、保障安全、节省登录时间。</p>
</li>
<li><p>认证中心。相比单系统登录，sso需要一个独立的认证中心，只有认证中心能接受帐密等安全信息，其他系统不提供登录入口。</p>
<p>  <img src="/2018/08/10/Java%E5%AE%9E%E7%8E%B0WEB-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/SSO.png"></p>
</li>
<li><p>间接授权ticket。sso认证中心验证用户的帐密没有问题，创建授权令牌ticket，在接下来的跳转中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，即得到授权，可以借此创建局部session，局部session的登录方式与单系统登录方式相同。</p>
<p>  <img src="/2018/08/10/Java%E5%AE%9E%E7%8E%B0WEB-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/2.png"></p>
<ol>
<li>用户访问系统1的受保护资源，系统1发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数</li>
<li>sso认证中心发现用户未登录，将用户引导至登录页面</li>
</ol>
</li>
</ul>
<p>用户输入用户名密码提交登录申请<br>    3. sso认证中心校验用户信息，创建用户与sso认证中心之间的会话，称为全局会话，同时创建授权令牌<br>    4. sso认证中心带着令牌跳转回最初的请求地址（系统1）<br>    5. 系统1拿到令牌，去sso认证中心校验令牌是否有效<br>    6. sso认证中心校验令牌，返回有效，注册系统1<br>    7. 系统1使用该令牌创建与用户的会话，称为局部会话，返回受保护资源<br>    8. 用户访问系统2的受保护资源<br>    9. 系统2发现用户未登录，跳转至sso认证中心，并将自己的地址作为参数<br>    10. sso认证中心发现用户已登录，跳转回系统2的地址，并附上令牌<br>    11. 系统2拿到令牌，去sso认证中心校验令牌是否有效<br>    12. sso认证中心校验令牌，返回有效，注册系统2<br>    13. 系统2使用该令牌创建与用户的局部会话，返回受保护资源</p>
<ul>
<li><p>用户登录成功之后，会与SSO认证中心及各个子系统建立会话，用户与SSO认证中心建立全局会话，用户与子系统建立局部会话。局部会话存在，全局会话一定存在；但全局会话存在，局部会话不一定存在</p>
</li>
<li><p>单点注销。在一个子系统中注销，所有子系统的会话都将被注销。sso认证中心一直监听全局会话的状态，一旦全局会话销毁，监听器将通知所有注册系统执行注销操作。如下图：</p>
<p>  <img src="/2018/08/10/Java%E5%AE%9E%E7%8E%B0WEB-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/3.png"></p>
<ol>
<li>用户向系统1发起注销请求</li>
<li>系统1根据用户与系统1建立的会话id拿到令牌，向sso认证中心发起注销请求</li>
<li>sso认证中心校验令牌有效，销毁全局会话，同时取出所有用此令牌注册的系统地址</li>
<li>sso认证中心向所有注册系统发起注销请求</li>
<li>各注册系统接收sso认证中心的注销请求，销毁局部会话</li>
<li>sso认证中心引导用户至登录页面</li>
</ol>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>课程网址：<a href="https://class.imooc.com/course/445">慕课网——Java实现单点登录</a></p>
<h5 id="文件结构-仅列出关键部分-："><a href="#文件结构-仅列出关键部分-：" class="headerlink" title="文件结构(仅列出关键部分)："></a>文件结构(仅列出关键部分)：</h5><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.SSO_Server</span><br><span class="line">	<span class="string">|_src</span></span><br><span class="line">		<span class="string">|_com.imooc.sso.servlet</span></span><br><span class="line">			<span class="string">|_LoginServlet</span></span><br><span class="line">	<span class="string">|_web</span></span><br><span class="line">		<span class="string">|_index.jsp</span></span><br><span class="line">		<span class="string">|_WEB-INF</span></span><br><span class="line">			<span class="string">|_web.xml</span></span><br><span class="line"><span class="number">2</span>.WebApp1</span><br><span class="line">	<span class="string">|_src</span></span><br><span class="line">		<span class="string">|_com.imooc.sso</span></span><br><span class="line">			<span class="string">|_filter</span></span><br><span class="line">				<span class="string">|_UserFilter</span></span><br><span class="line">			<span class="string">|_servlet</span></span><br><span class="line">				<span class="string">|_MainServlet</span></span><br><span class="line">	<span class="string">|_web				</span></span><br><span class="line">		<span class="string">|_index.jsp</span></span><br><span class="line">		<span class="string">|_WEB-INF</span></span><br><span class="line">			<span class="string">|_web.xml</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. WebApp2与WebApp1目录结构一致，此处略				</span><br></pre></td></tr></table></figure>

<ol>
<li>采用一个认证服务器，两个应用服务器来模拟SSO；</li>
<li>使用idea作IDE，并使用Tomcat的local模拟，SSO_server使用<code>localhost:8080</code>，WebApp1使用<code>localhost:8081</code>，WebApp1使用<code>localhost:8082</code></li>
</ol>
<h5 id="LoginServlet-java"><a href="#LoginServlet-java" class="headerlink" title="LoginServlet.java"></a>LoginServlet.java</h5><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">package com.imooc.sso.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> *;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class LoginServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> domains;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> init(ServletConfig sc) throws ServletException &#123;</span><br><span class="line">        super.init(sc);</span><br><span class="line">        domains = sc.getInitParameter(<span class="string">&quot;domains&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="literal">void</span> service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Objects.<span class="keyword">equals</span>(<span class="string">&quot;/login&quot;</span>, request.getServletPath())) &#123;</span><br><span class="line"><span class="comment">//            如果是登录操作</span></span><br><span class="line">            <span class="built_in">String</span> username = request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">            <span class="built_in">String</span> password = request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            <span class="built_in">String</span> source = request.getParameter(<span class="string">&quot;source&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">null</span>==source||Objects.<span class="keyword">equals</span>(<span class="string">&quot;&quot;</span>,source))&#123;</span><br><span class="line">                <span class="comment">//referer是当前的url，刚被filter拦截下来，source内无值</span></span><br><span class="line">                <span class="built_in">String</span> <span class="keyword">referer</span>=request.getHeader(<span class="string">&quot;referer&quot;</span>);</span><br><span class="line">                source=<span class="keyword">referer</span>.substring(<span class="keyword">referer</span>.indexOf(<span class="string">&quot;source=&quot;</span>)+<span class="number">7</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Objects.<span class="keyword">equals</span>(username, password)) &#123;</span><br><span class="line">                <span class="comment">//设定用户名与密码一致时表示登录成功，申请ticket放入url，并将source和domains放入url</span></span><br><span class="line">                <span class="built_in">String</span> ticket = UUID.randomUUID().toString().replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;****************:&quot;</span> + ticket);</span><br><span class="line"></span><br><span class="line"><span class="comment">//                response.sendRedirect(source+&quot;/main?ticket=&quot;+ticket+&quot;&amp;domains=&quot;+domains.replace(source,&quot;&quot;));//将source之外的domain都通知到</span></span><br><span class="line">                response.sendRedirect(source + <span class="string">&quot;/main?ticket=&quot;</span> + ticket + <span class="string">&quot;&amp;domains=&quot;</span> + domains.replace(source + <span class="string">&quot;,&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;,&quot;</span> + source, <span class="string">&quot;&quot;</span>).replace(source, <span class="string">&quot;&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//登录失败</span></span><br><span class="line">                request.setAttribute(<span class="string">&quot;source&quot;</span>,source);</span><br><span class="line">                request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/views/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Objects.<span class="keyword">equals</span>(<span class="string">&quot;/ssoLogin&quot;</span>, request.getServletPath())) &#123;</span><br><span class="line">            <span class="comment">//如果是跳转登录的请求</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/WEB-INF/views/login.jsp&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;  <span class="keyword">else</span> <span class="keyword">if</span>(Objects.<span class="keyword">equals</span>(<span class="string">&quot;/ssoLogout&quot;</span>,request.getServletPath()))&#123;</span><br><span class="line">            <span class="comment">//如果退出请求</span></span><br><span class="line">            <span class="built_in">String</span> source = request.getParameter(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">null</span>==source||Objects.<span class="keyword">equals</span>(<span class="string">&quot;&quot;</span>,source))&#123;</span><br><span class="line">                <span class="built_in">String</span> <span class="keyword">referer</span>=request.getHeader(<span class="string">&quot;referer&quot;</span>);</span><br><span class="line">                source=<span class="keyword">referer</span>.substring(<span class="keyword">referer</span>.indexOf(<span class="string">&quot;source=&quot;</span>)+<span class="number">7</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            response.sendRedirect(source+<span class="string">&quot;/logout?domains&quot;</span>+domains.replace(source+<span class="string">&quot;,&quot;</span>,<span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;,&quot;</span>+source,<span class="string">&quot;&quot;</span>).replace(source,<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>对login和ssoLogin两种不同路径采用不同的处理方式。若login路径，则取出帐密和source（url中从头到端口号的位置）；</li>
<li>如果帐密验证通过，获取随机ticket，与init时获取的domains（替换掉source部分）一起放入url中重定向到main页面；</li>
<li>如果帐密验证失败，则将source加入属性，并转发到login页面；</li>
<li>如果是ssoLogin路径，则转发到login页面。</li>
<li>如果时ssoLogout路径，则携带source和domains转发到各WebApp的logout路径</li>
</ol>
<h5 id="SSO-Server的web-xml"><a href="#SSO-Server的web-xml" class="headerlink" title="SSO Server的web.xml"></a>SSO Server的web.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.imooc.sso.servlet.LoginServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>domains<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://127.0.0.1:8081,http://127.0.0.1:8082<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ssoLogin<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>LoginServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ssoLogout<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>建立ssoLogin和login的servlet，并设置初始化参数domains;</li>
<li>domains中包含所有WebApp的地址，如代码块中的<code>http://127.0.0.1:8081</code>和<code>http://127.0.0.1:8082</code></li>
</ol>
<h5 id="UserFilter-java"><a href="#UserFilter-java" class="headerlink" title="UserFilter.java"></a>UserFilter.java</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package com.imooc.sso.filter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import *;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> UserFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String server;</span><br><span class="line">    <span class="keyword">private</span> String app;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        server = filterConfig.get<span class="constructor">InitParameter(<span class="string">&quot;server&quot;</span>)</span>;</span><br><span class="line">        app = filterConfig.get<span class="constructor">InitParameter(<span class="string">&quot;app&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">request</span>, ServletResponse <span class="params">response</span>, FilterChain <span class="params">filterChain</span>)</span> throws IOException, ServletException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进入WebApp的情况分类：</span></span><br><span class="line"><span class="comment">         * 1。首次进入，无cookie，无ticket，由情况2的else处理后response</span></span><br><span class="line"><span class="comment">         * 2。首次SSO_Server判定成功，重定向回本WebApp的main方法，url携带着source、ticket、domains，由 情况2的if处理request，然后</span></span><br><span class="line"><span class="comment">         *  在MainServlet对其他app设置cookie后，跳转到main.jsp页面，并对response设置cookie超时时间，由 情况2的if处理response</span></span><br><span class="line"><span class="comment">         * 3。第二次、第三次进入被拦截时，从cookie中提取ticket，若未超时则放行；若超时，则分情况，当属性ticket为空，即未登录访问main路径时，跳转到 ssoLogin路径</span></span><br><span class="line"><span class="comment">         *   当属性ticket不为空，即单点登录后回来的请求，ticket加上超时时间，然后放行</span></span><br><span class="line"><span class="comment">         * 4。如果是ssoLogout进来，则携带source转发到Server的ssoLogout路径</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        request.set<span class="constructor">Attribute(<span class="string">&quot;app&quot;</span>,<span class="params">app</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;/ssoLogout&quot;</span>,((HttpServletRequest)request).get<span class="constructor">ServletPath()</span>))&#123;</span><br><span class="line">            ((HttpServletResponse) response).send<span class="constructor">Redirect(<span class="params">server</span> + <span class="string">&quot;/ssoLogout?source=&quot;</span> + <span class="params">app</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String ticket = null;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况1：cookie有该用户</span></span><br><span class="line">        <span class="keyword">if</span> (null != ((HttpServletRequest) request).get<span class="constructor">Cookies()</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : ((HttpServletRequest) request).get<span class="constructor">Cookies()</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(cookie.get<span class="constructor">Name()</span>, <span class="string">&quot;Ticket_Granting_Ticket&quot;</span>)) &#123;</span><br><span class="line">                    ticket = cookie.get<span class="constructor">Value()</span>;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(null, ticket)) &#123;</span><br><span class="line">            <span class="comment">//判断超时时间</span></span><br><span class="line">            String<span class="literal">[]</span> values = ticket.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            ticket = request.get<span class="constructor">Parameter(<span class="string">&quot;ticket&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Long</span>.</span></span>value<span class="constructor">Of(<span class="params">values</span>[1])</span> &lt; <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span>) &#123;</span><br><span class="line">                <span class="comment">//超时</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(null, ticket)) &#123;</span><br><span class="line">                    <span class="comment">//非单点登录后跳过来的请求</span></span><br><span class="line">                    ((HttpServletResponse) response).send<span class="constructor">Redirect(<span class="params">server</span> + <span class="string">&quot;/ssoLogin?source=&quot;</span> + <span class="params">app</span>)</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//单点登录之后回来的请求</span></span><br><span class="line">                    ticket = ticket + <span class="string">&quot;:&quot;</span> + (<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span> + <span class="number">100000</span>);</span><br><span class="line">                    <span class="comment">//登录成功,在response时，从url取出ticket放入cookie中</span></span><br><span class="line">                    ((HttpServletResponse) response).add<span class="constructor">Cookie(<span class="params">new</span> Cookie(<span class="string">&quot;Ticket_Granting_Ticket&quot;</span>, <span class="params">ticket</span>)</span>);</span><br><span class="line">                    filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//情况2：cookie里没有该用户，第一次时走此逻辑</span></span><br><span class="line">        ticket = request.get<span class="constructor">Parameter(<span class="string">&quot;ticket&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(null, ticket)<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;&quot;</span>, ticket.trim<span class="literal">()</span>)) &#123;</span><br><span class="line">            ticket = ticket + <span class="string">&quot;:&quot;</span> + (<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>current<span class="constructor">TimeMillis()</span> + <span class="number">100000</span>);</span><br><span class="line">            <span class="comment">//登录成功,在response时，从url取出ticket放入cookie中</span></span><br><span class="line">            ((HttpServletResponse) response).add<span class="constructor">Cookie(<span class="params">new</span> Cookie(<span class="string">&quot;Ticket_Granting_Ticket&quot;</span>, <span class="params">ticket</span>)</span>);</span><br><span class="line">            filterChain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//cookie和ticket均登录失败</span></span><br><span class="line">            ((HttpServletResponse) response).send<span class="constructor">Redirect(<span class="params">server</span> + <span class="string">&quot;/ssoLogin?source=&quot;</span> + <span class="params">app</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy<span class="literal">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>UserFilter用来过滤登录操作和注销操作；</li>
<li>当cookie中有该用户且ticket不为空时，为请求放行；（经过app1，ssoServer，login成功之后，访问app2的情形）</li>
<li>当cookie没有该用户且ticket不为空时，说明登录成功，从请求的url中获取该ticket参数，放入cookie中，为请求放行；（经过app1，ssoServer，login登录success的进行时）</li>
<li>当cookie没有该用户，且ticket为空时，说明登录不成功，在url中添加上server和app参数，重定向到ssoLogin中；（未经过ssoServer认证，直接路径链接到功能页面的非法情形）</li>
<li>仅当ssoLogout路径进来时请求会被转发到ssoServer最终抵达本app的MainServlet.java中完成剩下的注销步骤，其余情况会被拦截</li>
</ol>
<h5 id="MainServlet-java"><a href="#MainServlet-java" class="headerlink" title="MainServlet.java"></a>MainServlet.java</h5><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">package com.imooc.sso.servlet;</span><br><span class="line"></span><br><span class="line">import *;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> MainServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExecutorService service = <span class="module-access"><span class="module"><span class="identifier">Executors</span>.</span></span><span class="keyword">new</span><span class="constructor">FixedThreadPool(10)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String servers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void sync<span class="constructor">Cookie(String <span class="params">server</span>, String <span class="params">ticket</span>,String <span class="params">method</span>)</span> &#123;</span><br><span class="line">        service.submit(<span class="keyword">new</span> <span class="constructor">Runnable()</span> &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run<span class="literal">()</span> &#123;</span><br><span class="line">                HttpPost httpPost = <span class="keyword">new</span> <span class="constructor">HttpPost(<span class="params">server</span> + <span class="string">&quot;/setCookie?ticket=&quot;</span> + <span class="params">ticket</span>)</span>;</span><br><span class="line">                CloseableHttpClient httpClient = null;</span><br><span class="line">                CloseableHttpResponse response = null;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    httpClient = <span class="module-access"><span class="module"><span class="identifier">HttpClients</span>.</span></span>create<span class="constructor">Default()</span>;</span><br><span class="line">                    response = httpClient.execute(httpPost);</span><br><span class="line">                    HttpEntity entity = response.get<span class="constructor">Entity()</span>;</span><br><span class="line">                    String responseContent = <span class="module-access"><span class="module"><span class="identifier">EntityUtils</span>.</span></span><span class="keyword">to</span><span class="constructor">String(<span class="params">entity</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;=========&quot;</span> + responseContent);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (null != response) &#123;</span><br><span class="line">                            response.close<span class="literal">()</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (null != httpClient) &#123;</span><br><span class="line">                            httpClient.close<span class="literal">()</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;/main&quot;</span>, request.get<span class="constructor">ServletPath()</span>)) &#123;</span><br><span class="line">            <span class="comment">// 从server端登录后转发过来</span></span><br><span class="line">            String domains = request.get<span class="constructor">Parameter(<span class="string">&quot;domains&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(null!=domains)&#123;</span><br><span class="line">                this.servers=domains;</span><br><span class="line">            &#125;</span><br><span class="line">            String ticket = request.get<span class="constructor">Parameter(<span class="string">&quot;ticket&quot;</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(null!=domains&amp;&amp;null!=ticket)&#123;</span><br><span class="line">                <span class="keyword">for</span> (String server : domains.split(<span class="string">&quot;,&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(null, server)<span class="operator"> &amp;&amp; </span>!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;&quot;</span>, server.trim<span class="literal">()</span>)) &#123;</span><br><span class="line">                        sync<span class="constructor">Cookie(<span class="params">server</span>, <span class="params">ticket</span> ,<span class="string">&quot;setCookie&quot;</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            request.get<span class="constructor">RequestDispatcher(<span class="string">&quot;/WEB-INF/views/main.jsp&quot;</span>)</span>.forward(request, response);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;/setCookie&quot;</span>, request.get<span class="constructor">ServletPath()</span>)) &#123;</span><br><span class="line">            String ticket = request.get<span class="constructor">Parameter(<span class="string">&quot;ticket&quot;</span>)</span>;</span><br><span class="line">            response.add<span class="constructor">Cookie(<span class="params">new</span> Cookie(<span class="string">&quot;Ticket_Granting_Ticket&quot;</span>, <span class="params">ticket</span>)</span>);</span><br><span class="line">            response.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">            response.set<span class="constructor">ContentType(<span class="string">&quot;application/text; charset=utf-8&quot;</span>)</span>;</span><br><span class="line">            PrintWriter out = null;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                out = response.get<span class="constructor">Writer()</span>;</span><br><span class="line">                out.write(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                <span class="keyword">if</span> (null != out) &#123;</span><br><span class="line">                    out.close<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">Desktop</span>.</span></span>get<span class="constructor">Desktop()</span>.browse(<span class="keyword">new</span> <span class="constructor">URI(<span class="params">request</span>.<span class="params">getAttribute</span>(<span class="string">&quot;app&quot;</span>)</span>+<span class="string">&quot;/?ticket=&quot;</span>+ticket));</span><br><span class="line">            &#125; catch (URISyntaxException e) &#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;/logout&quot;</span>,request.get<span class="constructor">ServletPath()</span>))&#123;</span><br><span class="line">            Cookie cookie=<span class="keyword">new</span> <span class="constructor">Cookie(<span class="string">&quot;Ticket_Granting_Ticket&quot;</span>,<span class="params">null</span>)</span>;</span><br><span class="line">            cookie.set<span class="constructor">MaxAge(0)</span>;</span><br><span class="line">            response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(null!=servers)&#123;</span><br><span class="line">                <span class="keyword">for</span>(String server:servers.split(<span class="string">&quot;,&quot;</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(null,server)&amp;&amp;!<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;&quot;</span>,server.trim<span class="literal">()</span>))&#123;</span><br><span class="line">                        sync<span class="constructor">Cookie(<span class="params">server</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;removeCookie&quot;</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            request.get<span class="constructor">RequestDispatcher(<span class="string">&quot;/WEB-INF/views/logout.jsp&quot;</span>)</span>.forward(request,response);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">Objects</span>.</span></span>equals(<span class="string">&quot;/removeCookie&quot;</span>,request.get<span class="constructor">ServletPath()</span>))&#123;</span><br><span class="line">            Cookie cookie =<span class="keyword">new</span> <span class="constructor">Cookie(<span class="string">&quot;Ticket_Granting_Ticket&quot;</span>,<span class="params">null</span>)</span>;</span><br><span class="line">            cookie.set<span class="constructor">MaxAge(0)</span>;</span><br><span class="line">            response.add<span class="constructor">Cookie(<span class="params">cookie</span>)</span>;</span><br><span class="line"></span><br><span class="line">            response.set<span class="constructor">CharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">            response.set<span class="constructor">ContentType(<span class="string">&quot;application/text,charset=utf-8&quot;</span>)</span>;</span><br><span class="line">            PrintWriter out =null;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                out=response.get<span class="constructor">Writer()</span>;</span><br><span class="line">                out.write(<span class="string">&quot;removeOK&quot;</span>);</span><br><span class="line">            &#125;catch(IOException  e)&#123;</span><br><span class="line">                e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">            &#125;finally &#123;</span><br><span class="line">                <span class="keyword">if</span>(null!=out)&#123;</span><br><span class="line">                    out.close<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>先看service方法，如果是main路径，说明是经过LoginServlet.java的登录成功操作后转发过来的，需要先将domains中的各个app的cookie中写入ticket；如果是setCookie路径，则只能是上一步写入ticket的后续操作；（例：app1登录成功进入service方法的main路径，将其他app的server进入syncCookie方法，其他app会进入setCookie路径）</li>
<li>如果是logout路径，将cookie置空，将其他WebApp调用syncCookie方法将对应cookie依次置空；</li>
<li>再看setCookie方法，使用线程池的方法，使用HttpClient进行申请异步Http服务；</li>
</ol>
<h5 id="WebApp1的Web-xml"><a href="#WebApp1的Web-xml" class="headerlink" title="WebApp1的Web.xml"></a>WebApp1的Web.xml</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UserFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.imooc.sso.filter.UserFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>server<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://127.0.0.1:8080<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>app<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>http://127.0.0.1:8081<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>UserFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.imooc.sso.servlet.MainServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/main<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/setCookie<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/logout<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/removeCookie<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MainServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/ssoLogout<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>配置UserFilter和MainServlet；</li>
<li>为UserFilter设置初始化参数server和app</li>
</ol>
<h5 id="WebApp2的java类和xml与WebApp1的基本一致，此处代码略"><a href="#WebApp2的java类和xml与WebApp1的基本一致，此处代码略" class="headerlink" title="WebApp2的java类和xml与WebApp1的基本一致，此处代码略"></a>WebApp2的java类和xml与WebApp1的基本一致，此处代码略</h5>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s 入门笔记</title>
    <url>/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="K8s-入门笔记"><a href="#K8s-入门笔记" class="headerlink" title="K8s 入门笔记"></a>K8s 入门笔记</h1><p>本文第一章来源自 <a href="https://dev.to/softchris/weekend-read-serverless-docker-kubernetes-56co">Weekend read, Serverless, Docker, Kubernetes</a>，及文中涉及的五篇 tutorials。主要针对以下问题：</p>
<ol>
<li>什么是 K8s？</li>
<li>Pods、Nodes、Services，又是什么？</li>
<li>Serverless 又是什么？</li>
<li>Cluster 该如何开始，又该怎么维护？</li>
</ol>
<p>本文第二章开始，就是对极客时间出品的《深入剖析Kubernetes》，进行概括总结。</p>
<p><a href="https://time.geekbang.org/column/article/17841">K8s 知识图谱</a></p>
<span id="more"></span>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><ol>
<li><p>k8s 的使用背景：需要多台机器分担负载并可能随时发生弹性缩放的场景下，k8s 是处理 containers 的好的实践方案。</p>
<ol>
<li>使用 containers 可实现环境的复用，让 dev&#x2F;pre&#x2F;Online 环境都表现得一致。</li>
<li>使用 container API 可一次管理多个 containers，适用于任务调度、负载均衡、分布式等场景。</li>
</ol>
</li>
<li><p>k8s 是一个开源系统，能够自动进行部署、缩放、管理容器内的 app 等。</p>
</li>
<li><p>Minikube 是一个工具，能够让k8s 跑在本地。</p>
<ol>
<li>另外有一个开源的 kubernetes-client，不知道跟 Minukube 相比孰优孰劣。</li>
</ol>
</li>
<li><p>Nodes——作为 Pod 运行的地方。通常是一个 worker machine(可以是物理机或者虚拟机)。</p>
<ol>
<li>Node ：pods &#x3D; 1 ：N</li>
<li>在集群中，Master 通过 Nodes 管理 pods。</li>
<li>每个 Node 都有至少一个<strong>Kubelet</strong>，至少一个<strong>container runtime</strong><ol>
<li>Kubelet，负责 k8s master 跟 node 之间交流的进程， 负责管理 pods，是 node 节点的核心。<strong>kubelet 主要负责同容器运行时（比如 Docker 项目）打交道</strong>。而这个交互所依赖的，是一个称作 CRI（Container Runtime Interface）的远程调用接口，这个接口定义了容器运行时的各项核心操作，比如：启动一个容器需要的所有参数。<ol>
<li>所以 K8s 不关心部署的是什么容器运行时，只要能够运行标准的容器镜像，就可以通过 CRI 接入到 K8s 中。</li>
<li><strong>kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互</strong>，用在对 GPU 等硬件使用上。</li>
<li><strong>kubelet通过 CNI 和 CSI 两个接口调用网络插件和存储插件为容器配置网络和持久化存储</strong>。</li>
</ol>
</li>
<li>A container runtime（如 docker），负责从 registry 中拉 image，开启 container，并运行 app。</li>
</ol>
</li>
</ol>
</li>
<li><p>Pods——k8s平台上的原子单位，是部署环境的最小单元。</p>
</li>
<li><p>最精辟的定义：<strong>Pod，其实是一组共享了某些资源的容器</strong>。详细解释：<strong>Pod 里的所有容器，共享的是同一个 Network Namespace，并且可以声明共享同一个 Volume</strong>。</p>
</li>
<li><p>通常是一个或一些 containers。常见的有 docker、containers 之间的共享资源(如共享存储、网络、镜像信息等)。</p>
</li>
<li><p>pod 里的containers，共享同一个 ip 和端口。就算是同一个 Node 里的 Pod，也有唯一独立的 IP 地址。</p>
</li>
<li><p>Pods 是具有生命周期的，当一个 Pod 死亡时，K8s 会通过一个叫做 <strong>ReplicaSet</strong> 的机制开启新的 Pods 来保证 app 的正常运行。</p>
<ol>
<li>使用 Service 来实现 Pods 间的同步机制。</li>
<li>死亡后 ip 地址回收，重启 Pods 时，会发放新的 ip 地址。所以会出现同一个 Pod，经过短暂下线又上线后，换了个 ip 的情况。</li>
</ol>
</li>
<li><p>K8s 中的 Service 维护了一系列 Pods 的集合，并提供访问它们的方式。 </p>
<ol>
<li>用 <strong>Label</strong> 和 <strong>Selector</strong> 来实现 Service 跟 Pods 之间的沟通，通常用 Label+logicalName 来指代某个Pod，而不是 ip 地址。Label 是 K-V 格式的。</li>
<li>有依赖关系的 Pods 间使用 yaml&#x2F;json 进行记录。</li>
</ol>
</li>
<li><p>Service 有多种分类（角色）：</p>
<ol>
<li>ClusterIP(default)：仅允许集群访问的内部 IP。</li>
<li>NodePort：让集群中的某一部分 Node使用同一个端口暴露服务，用 NAT 来实现。<ol>
<li>外部使用”：”访问。</li>
<li>是 ClusterIP 的父集合。</li>
</ol>
</li>
<li>LoadBalancer：一个外部的负载均衡器，通常分配一个固定的外部 IP。<ol>
<li>是 NodePort 的父集合。</li>
</ol>
</li>
<li>ExternalName：相当于取一个别名，然后返回一个 CNAME 记录。<ol>
<li>不使用代理，需要 v1.7 或更高版本的 kube-dns。</li>
</ol>
</li>
</ol>
</li>
<li><p>像上文提到的 Docker，其实就是一种 container runtime，帮助用户创建可复制的环境(指定 os、lib 的版本、环境变量等等)。Docker 负责创建 container，这个 container 中会包含 app 运行需要的所有东西（含源码）。</p>
<ol>
<li>注意 Docker 跟虚拟机的区别。Docker 使用 <strong>layered file system</strong>（分层文件系统），让containers 之间共享部分资源，相比虚拟机，更少出现独占资源的情况。</li>
<li>Docker containers 间相互独立，而且是轻量级的、安全的系统单元。</li>
<li>欲开启一个 Docker。首先需要定义一个<code>Dockerfile</code>，文件中需要指定 os、环境变量等信息。然后创建 image(或者从别的地方拉)。最后运行一个container。</li>
<li>Docker 采用 <strong>volume</strong> （或称为 Docker volume 数据卷）的方式向 containers 提供持久化存储，比如存储 log、json、SQLite 等，就算 containers 生命周期结束了，存在 volume 中的数据也不会被删除。</li>
<li>使用 <strong>Docker Compose</strong> 实现组件复用，具备了微服务的思想。使用了 Compose 后，开启 Docker时，可能仅需要定义 <strong>Dockerfile</strong>了，后续的image 和 containers 的管理都可以交给compose 来完成。<ol>
<li>使用 docker-compose.yaml 进行配置，配置内容为：Build、Environment、Image、Networks、Ports、Volumes 等。</li>
</ol>
</li>
<li>更多 Docker 内容参考：<a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 菜鸟教程</a></li>
</ol>
</li>
<li><p>Serverless，服务端逻辑运行在无状态的计算容器中，通常是 Event-driven。</p>
</li>
<li><p>并非不需要服务器作为计算资源，而是程序员无需理会计算资源的申请和维护，而交由平台来管理。</p>
</li>
<li><p>参考：<a href="https://yq.aliyun.com/articles/59483">大道至简 - 基于Docker的Serverless探索之旅</a></p>
</li>
</ol>
<h2 id="二、极客时间《深入剖析Kubernetes》-学习笔记"><a href="#二、极客时间《深入剖析Kubernetes》-学习笔记" class="headerlink" title="二、极客时间《深入剖析Kubernetes》 学习笔记"></a>二、极客时间《深入剖析Kubernetes》 学习笔记</h2><ol>
<li><p>docker 最简介绍，源自 PaaS，但因为 DockerImage 的存在，使得程序在打包时附带上了操作系统的文件系统，使得程序在多服务器上实现近似的”一键部署”的功能。</p>
</li>
<li><p>沙盒技术，容器本质是一种具有<strong>边界</strong>的<strong>沙盒技术</strong>，沙盒中盛装的就是外部应用。</p>
<ol>
<li>边界：<strong>容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。</strong></li>
<li>回顾<strong>进程</strong>的概念：<strong>一个程序运行起来后的计算机执行环境的总和</strong>。</li>
<li>Docker 容器属于单进程模型，是指只有一个进程时 Docker 可控的。所以Docker 容器是允许多个进程的，区别在于其他进程不为 Docker 容器控制。</li>
</ol>
</li>
<li><p>Docker 最核心两个技术：<strong>Cgroups</strong> 和 <strong>Namespace</strong>。</p>
</li>
</ol>
<h3 id="1-Groups"><a href="#1-Groups" class="headerlink" title="1. Groups"></a>1. Groups</h3><ol>
<li><p>Cgroups，或叫 Linux Control Groups：制造约束（边界）的主要手段，多是指资源限制。</p>
</li>
<li><p>限制 docker 控制的进程对 host os （宿主机）的资源使用情况，避免此进程饥饿或占据过多资源(CPU、内存等)。</p>
</li>
<li><p>Cgroups 就是用来<strong>限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等</strong>的工具。</p>
</li>
<li><p>具体过程是：使用<strong>一个子系统目录</strong>加上<strong>一组资源限制文件</strong>完成资源限制的意图。</p>
</li>
</ol>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># cgroup 挂载的资源(cpuset（单独 cpu 核与内存结点），cpu，cpuacct，blkio（IO 限制），memory等)</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mount -t cgroup</span> </span><br><span class="line">cpuset on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cpu on /sys/fs/cgroup/cpu type cgroup (rw,nosuid,nodev,noexec,relatime,cpu)</span><br><span class="line">cpuacct on /sys/fs/cgroup/cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct)</span><br><span class="line">blkio on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">memory on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 比如在cpu 目录/sys/fs/cgroup/cpu 下，创建新文件夹container，linux 会自动生成一系列资源限制文件（也称控制组，归属于 container 子系统），如下：</span></span></span><br><span class="line">1. cgroup.clone_children </span><br><span class="line">2. cpu.cfs_period_us  ## 总 cpu 时间，默认100ms</span><br><span class="line">3. cpu.rt_period_us  </span><br><span class="line">4. cpu.shares notify_on_release</span><br><span class="line">5. cgroup.procs      </span><br><span class="line">6. cpu.cfs_quota_us  ## 此 container 最大cpu 时间限制</span><br><span class="line">7. cpu.rt_runtime_us </span><br><span class="line">8. cpu.stat  </span><br><span class="line">9. tasks ## 将某程序的 pid 写入，说明控制组的配置就会生效</span><br></pre></td></tr></table></figure>


<h4 id="2-Namespace"><a href="#2-Namespace" class="headerlink" title="2. Namespace"></a>2. Namespace</h4><p>也可以在 <code>Docker run</code>命令执行时带上一些参数。</p>
<ol>
<li><p>Namespace：修改进程视图的手段，包括 PID Namespace、Mount&#x2F;UTS&#x2F;UTS&#x2F;Network&#x2F;User 等Namespace。</p>
<ol>
<li><p>PID Namespace 举例：一个 docker 在 run 了某个应用之后，此应用只能看到一个<strong>全新的进程空间（其实是 mock 空间）</strong>，此空间里一般只有自己应用的进程（pid 被修改为 1，也是后续创建进程的父进程），看不到其他进程。</p>
<ol>
<li>为什么这么设计？因为这么做之后，容器应用就可以跟应用同生命周期，对后续的容器编排非常重要。</li>
</ol>
</li>
<li><p>Mount Namespace：只让当前应用看到此 namespace 下的挂载点信息。</p>
<ol>
<li><p>挂载：将新的文件系统关联至当前根文件系统（一般在分区后使用，举例：外置硬盘都被当成 file，但需要挂载后才能被 linux 识别）。参考：<a href="https://www.cnblogs.com/Link-Luck/p/9856168.html">Linux 文件系统挂载</a>， <a href="https://blog.csdn.net/daydayup654/article/details/78788310">Linux中挂载详解以及mount命令用法</a>，<a href="http://mini.eastday.com/mobile/180105000516046.html">一文看懂linux的挂载原理和流程</a>。</p>
</li>
<li><p><strong>Mount Namespace 对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效</strong>。</p>
<ol start="3">
<li>完整操作系统文件一般是root 开始，然后<code>/etc,/dev,…</code>文件，挂载时，将一套完整的 os 文件挂载到某个子目录下，这样一来，docker 中的进程只能看到此子目录下的文件系统，实现管窥而不得全貌。这一套完成的 os 文件系统也是俗称的<strong>容器镜像</strong>，官方名称—— <strong>rootfs（根文件系统，撑死几百兆，比虚拟机 OS 占用空间小太多了）</strong>。</li>
</ol>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># rootfs 包含的一级目录：</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /</span></span><br><span class="line">bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>docker 是使用命令<code> pivot_root 系统调用</code>来实现以上文件挂载过程的（此命令借鉴并升级 自 linux 系统中的<code>chroot</code>命令）。</p>
<ol start="5">
<li><p>用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出来了。</p>
<ol>
<li><p>不过这里的容器镜像其实是<strong>增量镜像</strong>（笔者自己编的词），因为一个 rootfs 可能是经过多次多人修改后的，每次修改都保存全量并不现实，所以会带上一些增量记录(专业名词：lay)，将多个增量 lay 进行文件合并(AuFS命令，联合文件系统)，最终组成一个完成的 os 文件系统。</p>
</li>
<li><p>rootfs 一般分成三成：只读层、可读写层、init 层。只读层对应的正是 ubuntu:latest 镜像的五层。可读写层默认为空，一般增删改都发生在这一层，如果是删除操作，会通过创建<code>whiteout</code>文件，遮挡住只读层的文件来实现。init 层是容器启动时用户想设置的 hosts、resolv.conf 等信息，此信息一般不会再 Docker Hub 间流通，所以放在 init 层中。</p>
</li>
</ol>
</li>
</ol>
<blockquote>
<ol>
<li>上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。知道这一点，就不难理解镜像文件的修改，比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。</li>
<li>查了一下，包括但不限于以下这几种：aufs, device mapper, btrfs, overlayfs, vfs, zfs。aufs是ubuntu 常用的，device mapper 是 centos，btrfs 是 SUSE，overlayfs ubuntu 和 centos 都会使用，现在最新的 docker 版本中默认两个系统都是使用的 overlayfs，vfs 和 zfs 常用在 solaris 系统。</li>
<li>镜像的多层结构使得它可以在多个镜像之间共享和征用。</li>
</ol>
</blockquote>
</li>
<li><p>需要明确的是，挂载了文件系统，但内核仍然是宿主机内核，而且无解。</p>
<ol start="3">
<li><p>Network Namespace：只让当前应用看到此 namespace 下的网络设置和配置。</p>
<ol start="4">
<li><p>但是，如果 docker 中的 app 想修改时间，然后影响到了 host os 的时间，这种情况是不能被允许的。所以对于 docker 来说，有一些资源和对象(比如时间)，是<strong>不能被 Namespace 化的</strong>。</p>
</li>
<li><p>一个进程的每种 Linux Namespace，都在它对应的 &#x2F;proc&#x2F;[进程号]&#x2F;ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="3-Docker-技术与虚拟机比较"><a href="#3-Docker-技术与虚拟机比较" class="headerlink" title="3. Docker 技术与虚拟机比较"></a>3. Docker 技术与虚拟机比较</h4><pre><code> ![](1.jpg)
</code></pre>
<ol>
<li><p>左虚拟机，右 docker。</p>
</li>
<li><p>虚拟机需要 <strong>Hypervisor</strong> 对应用进程的隔离负责，需要 <strong>Guest OS</strong> 作为真实的虚拟机提供一个各种虚拟化软件，占用了百兆的内存资源。而且多经过虚拟化软件这一层对 IO、网络等性能损耗也大。</p>
</li>
<li><p>docker 不需要 Hypervisor 和 Guest OS ，更加敏捷、更高性能。</p>
</li>
<li><p>但是就是因为没有 GuestOS，那么也就不存在自己专属的 OS 内核。</p>
</li>
<li><p>举例：在左图中，hostOS 可以是 win，但 app 是运行在 linux 环境下，所以GuestOS 安装上linux后，app 就可以运行。</p>
</li>
<li><p>但在右图，如果是同一个 hostOS 跟 app，那么因为内核是 win，所以 app 无法正常运行。即使可以挂载不同 OS 的操作系统文件，但内核没变，也变不了。</p>
</li>
<li><p>结论：如果应用依赖内核版本，那么 docker 也无法解决，除非再使用虚拟机。</p>
</li>
<li><p>数据卷 Volume</p>
<ol>
<li><strong>Volume 机制，允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。</strong></li>
<li>挂载技术：Linux 的<strong>绑定挂载（bind mount）机制</strong>。挂载的本质就是修改 inode，实现了重定向。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s 学习笔记</title>
    <url>/2019/07/06/K8s-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="K8s-学习笔记"><a href="#K8s-学习笔记" class="headerlink" title="K8s 学习笔记"></a>K8s 学习笔记</h1><p>上篇<a href="http://likehui.fun/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">K8s 入门笔记</a>第一部分讲的是 K8s 的部分名词，第二部分讲解的是 docker 技术，而 k8s 其实是一种容器编排工具（远不止此），是作为 docker 技术的上层建筑而定位的。</p>
<p>核心名词补充（参考下文 K8s 的架构辅助理解）：</p>
<ol>
<li>控制节点，master 节点。有三个组件（kube-apiserver、kube-scheduler、kube-controller-manager）分别负责<strong>API 服务、调度、容器编排</strong>等三项功能。</li>
<li>计算节点，Node 节点。</li>
</ol>
<p>其他名词还是参考<a href="http://likehui.fun/2019/05/26/K8s%20-%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/">K8s 入门笔记</a>中的第一部分。</p>
<span id="more"></span>



<p><img src="/2019/07/06/K8s-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1.png"></p>
<p>K8s 的全局架构：</p>
<p><img src="/2019/07/06/K8s-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/k8s1.png"></p>
<ol>
<li>场景：一个 Web 容器，一个 DB 容器，两个容器运行在两个不同的机器上，对于一个容器而言，它的 IP 地址信息是不固定的，所以 Web 容器如何找到 DB 容器的 Pod 呢？<ol>
<li>K8s 给 Pod 绑定了一个 Service 服务，比如 DB 容器所在的 Pod 就有一个对应的 Service，这个 Service 对外暴露一个固定的网络地址，使外界可以找到此 Service。当 Pod 的 IP 地址等信息发生变化时，由 K8s 完成此信息的维护。</li>
</ol>
</li>
</ol>
<h2 id="一键部署-k8s的实践"><a href="#一键部署-k8s的实践" class="headerlink" title="一键部署 k8s的实践"></a>一键部署 k8s的实践</h2><p>参考自 <a href="https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/">K8s 官网教程</a>、极客时间出品的《深入剖析Kubernetes》第 10、11 讲</p>
<h4 id="1-手动安装-kubeadm-因为-kubelet需要上帝视角，不能通过-docker-安装"><a href="#1-手动安装-kubeadm-因为-kubelet需要上帝视角，不能通过-docker-安装" class="headerlink" title="1. 手动安装 kubeadm(因为 kubelet需要上帝视角，不能通过 docker 安装)"></a>1. 手动安装 kubeadm(因为 kubelet需要上帝视角，不能通过 docker 安装)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># CentOS 系统</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 使用 k8s 国内源</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 确定关闭 SElinux，因为 kubelet 目前不支持 SElinux</span></span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 安装 kubelet kubeadm kubectl</span></span></span><br><span class="line">yum install -y kubelet-1.11.3-0.x86_64 kubeadm-1.11.3-0.x86_64 kubectl-1.11.3-0.x86_64 --disableexcludes=kubernetes</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 4. sysctl 配置中 net.bridge.bridge-nf-call-iptables 设为1</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure>

<p>在第 3 步可能会报关于 kubernetes-cmi 的错误，参考链接：<a href="https://blog.csdn.net/u013355826/article/details/89557989">kubeadm1.10安装缺少包：kubernetes-cmi &#x3D; 0.6.0</a></p>
<p>安装 kubernetes-cmi 后，再将过高版本的 kubelet 卸掉，重新安装低版本。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubelet --version // 查看当前版本</span></span><br><span class="line">Kubernetes v1.15.0</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> yum remove -y kubelet-1.15.0</span></span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yum install -y kubelet-1.11.3-0.x86_64 --disableexcludes=kubernetes</span></span><br><span class="line">...</span><br><span class="line">Complete!</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubelet --version // 查看重装后的版本</span></span><br><span class="line">Kubernetes v1.11.3</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-部署-master-结点"><a href="#2-部署-master-结点" class="headerlink" title="2. 部署 master 结点"></a>2. 部署 master 结点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> Kubernetes master 的 init 全过程</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 新增配置文件 kubeadm.yaml，说明：使用的是 kubelet-1.11.3</span></span></span><br><span class="line">apiVersion: kubeadm.k8s.io/v1alpha1</span><br><span class="line">kind: MasterConfiguration</span><br><span class="line">controllerManagerExtraArgs:</span><br><span class="line">  horizontal-pod-autoscaler-use-rest-clients: &quot;true&quot;</span><br><span class="line">  horizontal-pod-autoscaler-sync-period: &quot;10s&quot;</span><br><span class="line">  node-monitor-grace-period: &quot;10s&quot;</span><br><span class="line">apiServerExtraArgs:</span><br><span class="line">  runtime-config: &quot;api/all=true&quot;</span><br><span class="line">kubernetesVersion: &quot;v1.11.1&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 执行 init 操作</span></span></span><br><span class="line">kubeadm init --config kubeadm.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2.1 init 可能会失败，因为国内不好获取 gcr.io 镜像，所以使用以下命令。pull 成功了可再次尝试 2# 中命令</span></span></span><br><span class="line">docker pull mirrorgooglecontainers/kube-apiserver-amd64:v1.11.1</span><br><span class="line">docker pull mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">docker pull mirrorgooglecontainers/kube-scheduler-amd64:v1.11.1</span><br><span class="line">docker pull mirrorgooglecontainers/kube-proxy-amd64:v1.11.1</span><br><span class="line">docker pull mirrorgooglecontainers/pause:3.1</span><br><span class="line">docker pull mirrorgooglecontainers/etcd-amd64:3.2.18</span><br><span class="line">docker pull coredns/coredns:1.1.3</span><br><span class="line"></span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-proxy-amd64:v1.11.1 k8s.gcr.io/kube-proxy-amd64:v1.11.1</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-scheduler-amd64:v1.11.1 k8s.gcr.io/kube-scheduler-amd64:v1.11.1</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-apiserver-amd64:v1.11.1 k8s.gcr.io/kube-apiserver-amd64:v1.11.1</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/kube-controller-manager-amd64:v1.11.1 k8s.gcr.io/kube-controller-manager-amd64:v1.11.1</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/etcd-amd64:3.2.18  k8s.gcr.io/etcd-amd64:3.2.18</span><br><span class="line">docker tag docker.io/mirrorgooglecontainers/pause:3.1  k8s.gcr.io/pause:3.1</span><br><span class="line">docker tag docker.io/coredns/coredns:1.1.3  k8s.gcr.io/coredns:1.1.3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2.2 init 后会拿到一个指令(kubeadm join 指令，用于 master 增加 worker)，记下来，worker 结点添加时会用到</span></span></span><br><span class="line">kubeadm join 172.17.0.2:6443 --token 7f4nt1.gimuf5n1g76twyca --discovery-token-ca-cert-hash sha256:d2d3cedb006a27fce293f3d1f1611c9cc0e0ae68c13f256dc0b1c2c49d8cf20b</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2.3 第一次使用 k8s 集群要执行以下命令，这是将安全配置文件cp 到当前用户的.kube 目录下，kubectl会通过此路径下的安全文件访问k8s 集群</span></span></span><br><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3.-2 执行get 命令，查看 Pod 状态，可以发现master 结点是 notReady</span></span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3.-1 执行以下命令，查看 Pod 详细信息，发现 Conditions 下，造成 Ready False 的原因是 network plugin is not ready:</span></span></span><br><span class="line">kubectl describe node master</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3.0 为了解决 master 的 ready 问题，需要部署网络插件，部署完成后，master 就会变成 ready 状态</span></span></span><br><span class="line">kubectl apply -f https://git.io/weave-kube-1.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3.1 也可以通过以下命令查看所有 pods 的 status，可以看出多了一个名为weave-net-* 的 pods</span></span></span><br><span class="line">kubectl get pods -n kube-system</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-部署-worker-结点"><a href="#3-部署-worker-结点" class="headerlink" title="3. 部署 worker 结点"></a>3. 部署 worker 结点</h4><ol>
<li><p>在 worker 机器上重复以上”手动安装 kubeadm”中的全部步骤</p>
</li>
<li><p>执行 2.2 中的 kubeadm join 之前保存好的命令</p>
</li>
<li><p>如果 token 丢了或者不记得了，可以在 master 结点上执行以下命令重新生成 token</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm token generate</span><br><span class="line">kubeadm token create &lt;generated-token&gt; --print-join-command --ttl=0</span><br></pre></td></tr></table></figure>


</li>
<li><p>搞定</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器设置自启动uwsgi和Redis</title>
    <url>/2018/08/30/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%90%AF%E5%8A%A8uwsgi%E5%92%8CRedis/</url>
    <content><![CDATA[<h1 id="在Linux服务器上设置uwsgi和redis自启动"><a href="#在Linux服务器上设置uwsgi和redis自启动" class="headerlink" title="在Linux服务器上设置uwsgi和redis自启动"></a>在Linux服务器上设置uwsgi和redis自启动</h1><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a href="https://www.cnblogs.com/kross/p/3236231.html">linux自启动、定时启动脚本</a></li>
<li><a href="https://yq.aliyun.com/ask/30398">rc.local配置uwsgi启动</a></li>
<li><a href="https://blog.csdn.net/wanggangabc111/article/details/78133170">Redis 如何在系统启动时设置为开机自启</a></li>
</ul>
<h3 id="人为启动"><a href="#人为启动" class="headerlink" title="人为启动"></a>人为启动</h3><ul>
<li>uwsgi：进入uwsgi.ini路径（本系统中为&#x2F;usr&#x2F;local&#x2F;python-uwsgi&#x2F;）<code>uwsgi uwsgi.ini</code>可以启动uwsgi；</li>
<li>redis：进入redis路径（本系统中为&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin）<code>./redis-server</code>可以启动redis；</li>
</ul>
<span id="more"></span>

<h3 id="设置uwsgi自启动"><a href="#设置uwsgi自启动" class="headerlink" title="设置uwsgi自启动"></a>设置uwsgi自启动</h3><ol>
<li>进入<code>/etc/rc.local</code>文件，末尾添入以下代码</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/opt/</span>python3<span class="regexp">/bin/u</span>wsgi -d --ini <span class="regexp">/usr/</span>local<span class="regexp">/python-uwsgi/u</span>wsgi.ini</span><br></pre></td></tr></table></figure>


<h3 id="设置redis自启动"><a href="#设置redis自启动" class="headerlink" title="设置redis自启动"></a>设置redis自启动</h3><ol>
<li><p>修改配置文件redis.conf(本系统中在&#x2F;usr&#x2F;local&#x2F;redis&#x2F;etc&#x2F;redis.conf)，将daemonize后面设置为yes；</p>
</li>
<li><p>根据启动脚本要求，将修改好的配置文件以端口为名复制一份到制定目录，需要使用root的用户</p>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir <span class="regexp">/etc/</span>redis</span><br><span class="line">cp redis.conf <span class="regexp">/etc/</span>redis/<span class="number">6379</span>.conf</span><br></pre></td></tr></table></figure></li>
<li><p>将启动脚本复制到&#x2F;etc&#x2F;init.d目录下，本例将启动脚本命名为redisd(通常都以d结尾表示后台自启动服务)</p>
 <figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cp redis_init_script <span class="regexp">/etc/i</span>nit.d/redisd</span><br></pre></td></tr></table></figure></li>
<li><p>在启动脚本redisd开头添加如下两行注释以修改其运行级别：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># chkconfig:   2345 90 10</span></span><br><span class="line"><span class="comment"># description:  Redis is a persistent key-value database</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置有关内容</p>
 <figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置为开机自启动服务器</span></span><br><span class="line">chkconfig redisd <span class="keyword">on</span></span><br><span class="line"><span class="comment">#打开服务</span></span><br><span class="line">service redisd <span class="built_in">start</span></span><br><span class="line"><span class="comment">#关闭服务</span></span><br><span class="line">service redisd <span class="built_in">stop</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="查看所有自启项"><a href="#查看所有自启项" class="headerlink" title="查看所有自启项"></a>查看所有自启项</h3><p>命令行输入<code>chkconfig</code>，会得到类似如下结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">NetworkManager</span> 	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:启用	<span class="number">3</span>:启用	<span class="number">4</span>:启用	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br><span class="line"><span class="attribute">abrt</span>-ccpp      	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:关闭	<span class="number">3</span>:启用	<span class="number">4</span>:关闭	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br><span class="line"><span class="attribute">abrtd</span>          	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:关闭	<span class="number">3</span>:启用	<span class="number">4</span>:关闭	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br><span class="line"><span class="attribute">acpid</span>          	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:启用	<span class="number">3</span>:启用	<span class="number">4</span>:启用	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br><span class="line"><span class="attribute">atd</span>            	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:关闭	<span class="number">3</span>:启用	<span class="number">4</span>:启用	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br><span class="line"><span class="attribute">auditd</span>         	<span class="number">0</span>:关闭	<span class="number">1</span>:关闭	<span class="number">2</span>:启用	<span class="number">3</span>:启用	<span class="number">4</span>:启用	<span class="number">5</span>:启用	<span class="number">6</span>:关闭</span><br></pre></td></tr></table></figure>

<blockquote>
<p>0:系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动，机器关闭。<br>1:单用户工作状态，root权限，用于系统维护，禁止远程登陆，就像Windows下的安全模式登录。<br>2:多用户状态，没有NFS支持（即无网络连接）。<br>3:完整的多用户模式，有NFS，登陆后进入控制台命令行模式。<br>4:系统未使用，保留一般不用，在一些特殊情况下可以用它来做一些事情。例如在笔记本电脑的电池用尽时，可以切换到这个模式来做一些设置。<br>5:X11控制台，登陆后进入图形GUI模式，X Window系统。<br>6:系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动。运行init 6机器就会重启。</p>
</blockquote>
<p>标准的Linux运行级别为3或5，如果是3的话，系统就在多用户状态(命令页面)；如果是5的话，则是运行着X Window系统（图形页面）。</p>
<p><strong>一般选3或5</strong></p>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>cloudServer</tag>
      </tags>
  </entry>
  <entry>
    <title>MS 100题-1</title>
    <url>/2019/03/26/MS-100%E9%A2%98-1/</url>
    <content><![CDATA[<h2 id="1-把二元查找树转变成排序的双向链表-树"><a href="#1-把二元查找树转变成排序的双向链表-树" class="headerlink" title="1.把二元查找树转变成排序的双向链表(树)"></a>1.把二元查找树转变成排序的双向链表(树)</h2><p><img src="/2019/03/26/MS-100%E9%A2%98-1/1.png"></p>
<p>思路：</p>
<ol>
<li>中序递归遍历的方式，将前驱后继相连，因为 Java 是引用传递，所以需要在返回值处更新 PNode 值。</li>
<li>本处使用了 lombok，所以 idea 要提前安装 lombok 插件。</li>
</ol>
<span id="more"></span>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BST2List</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">pNode</span> <span class="operator">=</span> <span class="literal">null</span>,pHead;</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">1</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">2</span>,node1,node3);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">5</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">7</span>,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">6</span>,node5,node7);</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTreeNode</span>(<span class="number">4</span>,node2,node6);</span><br><span class="line"></span><br><span class="line">		pHead = converts(root,pNode);</span><br><span class="line">		<span class="keyword">while</span>(pHead != <span class="literal">null</span> &amp;&amp; pHead.left != <span class="literal">null</span>)&#123;</span><br><span class="line">			pHead = pHead.left; <span class="comment">// 回溯到链表头</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(pHead!=<span class="literal">null</span>)&#123;</span><br><span class="line">			System.out.print(pHead.value+<span class="string">&quot; &quot;</span>);</span><br><span class="line">			pHead = pHead.right;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pNode 当前 root 的前驱结点</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> BSTreeNode <span class="title function_">converts</span><span class="params">(BSTreeNode root, BSTreeNode pNode)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="literal">null</span> == root)&#123;</span><br><span class="line">			<span class="keyword">return</span> pNode;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">BSTreeNode</span> <span class="variable">pCur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归左子树</span></span><br><span class="line">		<span class="keyword">if</span>(pCur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">			pNode = converts(pCur.left,pNode);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 左右相连</span></span><br><span class="line">		pCur.left = pNode;</span><br><span class="line">		<span class="keyword">if</span>(pNode != <span class="literal">null</span>)&#123;</span><br><span class="line">			pNode.right = pCur;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 更新前驱结点</span></span><br><span class="line">		pNode = pCur;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归右子树</span></span><br><span class="line">		<span class="keyword">if</span>(pCur.right!= <span class="literal">null</span>)&#123;</span><br><span class="line">			pNode = converts(pCur.right,pNode);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> pNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Data</span></span><br><span class="line">	<span class="meta">@AllArgsConstructor</span></span><br><span class="line">	<span class="meta">@ToString</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSTreeNode</span>&#123;</span><br><span class="line">		<span class="type">int</span> value;</span><br><span class="line">		BSTreeNode left;</span><br><span class="line">		BSTreeNode right;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-求子数组的最大值"><a href="#2-求子数组的最大值" class="headerlink" title="2. 求子数组的最大值"></a>2. 求子数组的最大值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 输入一个整形数组，数组里有正数也有负数。</span><br><span class="line"> * 数组中连续的一个或多个整数组成一个子数组，每个子数组都有一个和。</span><br><span class="line"> * 求所有子数组的和的最大值。要求时间复杂度为 O(n)。</span><br><span class="line"> 例如输入的数组为 <span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, -<span class="number">5</span>，和最大的子数组为 <span class="number">3</span>, <span class="number">10</span>, -<span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>， 因此输出为该子数组的和 <span class="number">18</span>。</span><br><span class="line"> */</span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">求子数组的最大和</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">	@Test</span></span><br><span class="line">	public void findMax()&#123;</span><br><span class="line">		<span class="built_in">int</span>[] a = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">10</span>,-<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,-<span class="number">5</span>&#125;;</span><br><span class="line">		<span class="built_in">int</span>[] <span class="built_in">sum</span> = new <span class="built_in">int</span>[a.length];</span><br><span class="line">		<span class="built_in">int</span> <span class="built_in">max</span> = Integer.MIN_VALUE;</span><br><span class="line">		<span class="built_in">sum</span>[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">1</span>;i&lt;a.length;++i)&#123;</span><br><span class="line">			<span class="built_in">sum</span>[i] = Math.<span class="built_in">max</span>(a[i],<span class="built_in">sum</span>[i-<span class="number">1</span>]+a[i]);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">sum</span>[i]&gt;<span class="built_in">max</span>)&#123;</span><br><span class="line">				<span class="built_in">max</span> = <span class="built_in">sum</span>[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="built_in">max</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-多线程顺序打印0-100"><a href="#3-多线程顺序打印0-100" class="headerlink" title="3. 多线程顺序打印0~100"></a>3. 多线程顺序打印0~100</h2><p>输入数字N，使用N个线程执行打印操作，要求顺序打印0~100之间的数字<br>以 N&#x3D;4 为例，格式为：</p>
<blockquote>
<p>线程 0 打印数字 0<br>线程 1 打印数字 1<br>线程 2 打印数字 2<br>线程 3 打印数字 3<br>线程 0 打印数字 4<br>线程 1 打印数字 5<br>…<br>线程 3 打印数字 99</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.<span class="property">util</span>.<span class="property">Scanner</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多线程顺序打印0~100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">	<span class="keyword">private</span> int threadId;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="title class_">Object</span> <span class="built_in">object</span>; <span class="comment">// 静态对象用于上锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> int count = <span class="number">0</span>; <span class="comment">// 静态变量用于计数</span></span><br><span class="line">	<span class="keyword">private</span> int totalCount;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">thread</span>(<span class="params"><span class="built_in">Object</span> <span class="built_in">object</span>,<span class="built_in">String</span> name, int threadId, int totalCount</span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">object</span> = <span class="built_in">object</span>;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">threadId</span> = threadId;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">totalCount</span> = totalCount;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">		synchronized (<span class="built_in">object</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span> (count &lt; <span class="number">100</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (count % totalCount == threadId) &#123;</span><br><span class="line">					<span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; 打印数字 &quot;</span> + count);</span><br><span class="line">					++count;</span><br><span class="line">					<span class="built_in">object</span>.<span class="title function_">notifyAll</span>();</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="built_in">object</span>.<span class="title function_">wait</span>();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (<span class="title class_">InterruptedException</span> e) &#123;</span><br><span class="line">						e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) &#123;</span><br><span class="line">		<span class="title class_">Scanner</span> sc = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="title class_">System</span>.<span class="property">in</span>);</span><br><span class="line">		<span class="title class_">Object</span> <span class="built_in">object</span> = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		int N = sc.<span class="title function_">nextInt</span>();</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">			<span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title function_">thread</span>(<span class="built_in">object</span>,<span class="string">&quot;线程 &quot;</span> + i, i, N)).<span class="title function_">start</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-最大数字"><a href="#4-最大数字" class="headerlink" title="4. 最大数字"></a>4. 最大数字</h2><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.ArrayUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="language-markdown">/**</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span></span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"> * 输入一个非负的整形数组，然后输出使用输入数组里的元素组合成的最大数字</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span> 如：输入[45, 9 ,7]，输出字符串 “9745”</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"><span class="bullet"> *</span> 另外，输入数组可以有重复的数字</span></span></span><br><span class="line"><span class="language-markdown"><span class="comment"> <span class="emphasis">*/</span></span></span></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">test01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	public <span class="keyword">void</span> getResult()&#123;</span><br><span class="line">		<span class="built_in">int</span>[] <span class="built_in">num</span> = &#123;<span class="number">45</span>,<span class="number">729</span>,<span class="number">72</span>&#125;;</span><br><span class="line">		<span class="built_in">String</span>[] numStr = <span class="keyword">new</span> <span class="built_in">String</span>[<span class="built_in">num</span>.length];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(ArrayUtils.isEmpty(<span class="built_in">num</span>))&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">num</span>.length;++i)&#123;</span><br><span class="line">			numStr[i] = <span class="built_in">String</span>.valueOf(<span class="built_in">num</span>[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(numStr, <span class="keyword">new</span> Comparator&lt;<span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			public <span class="built_in">int</span> compare(<span class="built_in">String</span> o1, <span class="built_in">String</span> o2) &#123;</span><br><span class="line">				<span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="built_in">num</span>.length;++i)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(numStr[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="5-在二元树中找出和为某一值的所有路径-树"><a href="#5-在二元树中找出和为某一值的所有路径-树" class="headerlink" title="5. 在二元树中找出和为某一值的所有路径(树)"></a>5. 在二元树中找出和为某一值的所有路径(树)</h2><blockquote>
<p>例如 输入整数 22 和如下二元树<br>  10<br>   &#x2F; <br>  5  12<br> &#x2F; <br>4   7</p>
</blockquote>
<p>则打印出两条路径: 10, 12 和 10, 5, 7</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import lombok.AllArgsConstructor;</span><br><span class="line">import lombok.Data;</span><br><span class="line">import lombok.NoArgsConstructor;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  DFS 遍历的方式，叶节点处满足条件，则直接打印返回</span></span><br><span class="line"><span class="comment">*  注意 list 中元素的进出时机</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public <span class="keyword">class</span> 和为某值的所有路径 &#123;</span><br><span class="line"></span><br><span class="line">	static List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test<span class="constructor">Result()</span> &#123;</span><br><span class="line">		TreeNode node4 = <span class="keyword">new</span> <span class="constructor">TreeNode(4, <span class="params">null</span>, <span class="params">null</span>)</span>;</span><br><span class="line">		TreeNode node7 = <span class="keyword">new</span> <span class="constructor">TreeNode(7, <span class="params">null</span>, <span class="params">null</span>)</span>;</span><br><span class="line">		TreeNode node5 = <span class="keyword">new</span> <span class="constructor">TreeNode(5, <span class="params">node4</span>, <span class="params">node7</span>)</span>;</span><br><span class="line">		TreeNode node12 = <span class="keyword">new</span> <span class="constructor">TreeNode(12, <span class="params">null</span>, <span class="params">null</span>)</span>;</span><br><span class="line">		TreeNode node10 = <span class="keyword">new</span> <span class="constructor">TreeNode(10, <span class="params">node5</span>, <span class="params">node12</span>)</span>;</span><br><span class="line">		<span class="built_in">int</span> target = <span class="number">22</span>;</span><br><span class="line">		<span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		get<span class="constructor">Result(<span class="params">node10</span>, <span class="params">target</span>, <span class="params">sum</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> void get<span class="constructor">Result(TreeNode <span class="params">root</span>, <span class="params">int</span> <span class="params">target</span>, <span class="params">int</span> <span class="params">sum</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root<span class="operator"> == </span>null) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (sum + root.<span class="keyword">val</span> &gt; target) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">list</span>.add(root.<span class="keyword">val</span>);</span><br><span class="line">		<span class="keyword">if</span> (root.left<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>root.right<span class="operator"> == </span>null) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sum + root.<span class="keyword">val</span><span class="operator"> == </span>target) &#123;</span><br><span class="line">				print<span class="constructor">List(<span class="params">list</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">list</span>.remove(<span class="built_in">list</span>.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		get<span class="constructor">Result(<span class="params">root</span>.<span class="params">left</span>, <span class="params">target</span>, <span class="params">sum</span> + <span class="params">root</span>.<span class="params">val</span>)</span>;</span><br><span class="line">		get<span class="constructor">Result(<span class="params">root</span>.<span class="params">right</span>, <span class="params">target</span>, <span class="params">sum</span> + <span class="params">root</span>.<span class="params">val</span>)</span>;</span><br><span class="line">		<span class="built_in">list</span>.remove(<span class="built_in">list</span>.size<span class="literal">()</span> - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> void print<span class="constructor">List(List&lt;Integer&gt; <span class="params">list</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (Integer i : <span class="built_in">list</span>) &#123;</span><br><span class="line">			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Data</span><br><span class="line">	@AllArgsConstructor</span><br><span class="line">	@NoArgsConstructor</span><br><span class="line">	<span class="comment">//	  Definition for a binary tree node.</span></span><br><span class="line">	public <span class="keyword">class</span> TreeNode &#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line"></span><br><span class="line">		<span class="constructor">TreeNode(<span class="params">int</span> <span class="params">x</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">val</span> = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 1</title>
    <url>/2018/05/05/Note-for-Computer-Network-1/</url>
    <content><![CDATA[<p><strong>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记1</strong></p>
<h1 id="开篇思考"><a href="#开篇思考" class="headerlink" title="开篇思考"></a>开篇思考</h1><p>Q： 为什么在DNS失效时，还能够用QQ聊天呢？<br>A： QQ是直接通过IP地址来连接服务器的。</p>
<p>Q：网络怎么通信？怎么传输数据？<br>A：浏览器和服务器需要一个传递请求和接受响应的机制，机制需要确定正确的传输对象，避免信息丢失，并准确无误发送给对方。即一份将数字信息搬运到指定目的地的机制。</p>
<p>Q：浏览器如何发送信息？<br>A：浏览器不亲自发送信息，而是委托机制，具体说就是委托操作系统中的网络控制软件（即协议栈）发送消息。</p>
<p>Q：协议栈的职责？<br>A：将从浏览器接收来的信息打包，加上目的地址等控制信息，将包交给网卡（负责以太或者无线通信的硬件），由网卡将包转换成电信号并通过网线发送出去。协议栈还具有通信错误时重新发包，或调节数据发送的速率等功能。</p>
<p>Q：客户端是如何接入互联网的？<br>A：eg：PC机连到局域网，再通过ADSL和光纤等宽带线路接入互联网，中途会经过交换机和路由器，路由器后面就是互联网</p>
<p>Q：接入网？<br>A：数据发出端到路由器这段线路，就是接入网。从路由器往里走就是互联网的内部。使用电话线&#x2F;ISDN&#x2F;ADSL&#x2F;有线电视&#x2F;光线&#x2F;专线等通信线路，也称为接入网。</p>
<p>Q：接入点？<br>A：接入网连接到网络运营商，并接入接入点（某种设备，即PoP，point of presence）。接入点实体是专为运营商设计的路由器。在路由器后面是大量的运营商和路由器。</p>
<p>Q：路由器间连接方式的差异？<br>A：局域网使用以太线连接，互联网有以太线&#x2F;电话技术&#x2F;光通信技术。</p>
<span id="more"></span>

<p>Q：请求进入服务器前的流程？<br>A：防火墙：检查是否有危险的包；缓存服务器，访问的数据是否直接读出，若能就不去web服务器；大型网站中还有将消息分布到多台web服务器的负载均衡器，可能使用通过分布在整个互联网中的缓存服务器来分发内容的服务。之后进入web服务器。</p>
<p>Q：web服务器如何工作？<br>A：将数据解包还原成请求消息，交给web服务器程序，以上由协议栈完成。之后web服务器程序分析请求含义，按照指示将数据装入响应消息中，发回客户端。</p>
<p>Q：服务器端口号是什么？<br>A：[理解]服务器程序的编号。web是80，邮件是25.</p>
<h1 id="干货正文"><a href="#干货正文" class="headerlink" title="干货正文"></a>干货正文</h1><h2 id="探索浏览器"><a href="#探索浏览器" class="headerlink" title="探索浏览器"></a>探索浏览器</h2><h3 id="URL解析中省略文件名的情况"><a href="#URL解析中省略文件名的情况" class="headerlink" title="URL解析中省略文件名的情况"></a>URL解析中省略文件名的情况</h3><pre><code>1. &gt;http://www.lab.glasscom.com/dir/
    服务器上预设要访问的默认文件名，一般是类似index.html 或者 default.htm
2. &gt;http://www.lab.glasscom.com/
    这是要访问名叫&quot;/&quot;的目录，默认访问/index.html 或者 /default.htm文件
3. &gt;http://www.lab.glasscom.com
    此写法与2相同
4. &gt;http://www.lab.glasscom.com/whatisthis
    whatisthis既可以指目录名，也可以指文件名，不会冲突
</code></pre>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><pre><code>“HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤”。
客户端向服务器发送请求，请求内容包括**URL**和**如何操作（即方法）**两个部分。
这个URL是一个存放网页数据的文件名，或者CGI程序的文件名，例.html或.cgi等。
CGI程序是调用其他程序的web服务器程序。
</code></pre>
<h4 id="HTTP主要方法"><a href="#HTTP主要方法" class="headerlink" title="HTTP主要方法"></a>HTTP主要方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>GET</strong></td>
<td align="center"><strong>“获取 URI 指定的信息。如果 URI 指定的是文件，则返回文件的内容；如果 URI 指定的是 CGI 程序，则返回该程序的输出数据”</strong></td>
</tr>
<tr>
<td align="center"><strong>POST</strong></td>
<td align="center"><strong>“从客户端向服务器发送数据。一般用于发送表单中填写的数据等情况下”</strong></td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">“和 GET 基本相同。不过它只返回 HTTP 的消息头（message header），而并不返回数据的内容。用于获取文件最后更新时间等属性信息”</td>
</tr>
<tr>
<td align="center">OPTION</td>
<td align="center">“用于通知或查询通信选项”</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">“替换 URI 指定的服务器上的文件。如果 URI 指定的文件不存在，则创建该文件”</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">“删除 URI 指定的服务器上的文件”</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">“将服务器收到的请求行和头部（header）直接返“回给客户端。用于在使用代理的环境中检查改写请求的情况”</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">“使用代理传输加密消息时使用的方法”</td>
</tr>
</tbody></table>
<h5 id="GET方法的简易案例："><a href="#GET方法的简易案例：" class="headerlink" title="GET方法的简易案例："></a>GET方法的简易案例：</h5><ul>
<li>首先在请求消息中写上 GET 方法，然后在 URI 中写上存放网页数据的文件名“&#x2F;dir1&#x2F;file1.html”，这就表示我们需要获取 &#x2F;dir1&#x2F;file1.html 文件中的数据。</li>
<li>随后当 Web 服务器收到消息后，会打开 &#x2F;dir1&#x2F;file1.html 文件并读取出里面的数据，然后将读出的数据存放到响应消息中，并返回给客户端。</li>
<li>最后，客户端浏览器会收到这些数据并显示在屏幕上</li>
</ul>
<h5 id="POST方法的简易流程："><a href="#POST方法的简易流程：" class="headerlink" title="POST方法的简易流程："></a>POST方法的简易流程：</h5><ul>
<li>使用 POST 方法时，URI 会指向 Web 服务器中运行的一个应用程序的文件名，典型的例子包括“index.cgi”“index.php”等。</li>
<li>然后，在请求消息中，除了方法和 URI 之外，还要加上传递给应用程序和脚本的数据。这里的数据也就是用户在输入框里填写的信息。</li>
<li>当服务器收到消息后，Web 服务器会将请求消息中的数据发送给 URI 指定的应用程序。</li>
<li>最后，Web 服务器从应用程序接收输出的结果，会将它存放到响应消息中并返回给客户端。</li>
</ul>
<h3 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a>HTTP消息</h3><p>参考：<a href="http://www.cnblogs.com/jacktu/archive/2008/01/16/1041710.html">理解HTTP消息头</a><br><br>未完待续</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Multithread and ThreadPool</title>
    <url>/2018/05/17/Multithread-and-ThreadPool/</url>
    <content><![CDATA[<h1 id="多线程与线程池"><a href="#多线程与线程池" class="headerlink" title="多线程与线程池"></a>多线程与线程池</h1><p>参考博客 ：<a href="https://www.jianshu.com/p/b8197dd2934c">孙福生简书</a>，<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665514609&idx=1&sn=ba61f8b37acc79b1a17871fc7ec5c353&chksm=80d67e32b7a1f724242c38502b9aad8ad398b6b5c56c4e980c802a880ec1c70e5dfdcaafd9ae&scene=38#wechat_redirect">码农翻身</a></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>进程（process）：<strong>计算机已运行程序的实体</strong>。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。<strong>用户下达运行程序的命令后，就会产生进程</strong>。同一程序可产生多个进程（一对多关系），以允许同时有多位用户运行同一程序，却不会相冲突。<strong>进程是拥有资源的基本单位</strong>。进程需要一些资源才能完成工作，如CPU使用时间、存储器、文件以及I&#x2F;O设备，且为依序逐一进行，也就是每个CPU核心任何时间内仅能运行一项进程。进程之间是资源隔离的，如果在进程间共享内容&#x2F;消息传递代价较大。</li>
<li>线程：进程中负责程序执行的执行单元，<strong>线程是独立调度（CPU调度）和分派的基本单位</strong>，OS做调度时处理的是线程。一个进程中至少有一个线程，每个线程执行的都是进程代码中的某个片段。每个线程都拥有单独的栈内容来做存储本地数据。</li>
<li>Java有没有多进程编程？否！java程序运行在JVM中，JVM本身就是java.exe运行起来，所以对OS而言，JVM是一个进程，其中无法进行多进程编程。</li>
<li>多线程：多条线程同时存在，例如写word时，一边输入一边自动保存，就需要两条线程来分别完成。关键技术：线程间通信，线程间共用资源。</li>
<li>线程池：一种线程使用模式。使用少量线程并让线程保持忙碌。以避免每个用户的请求都反复创建线程的开销。当线程池的线程刚创建时，让他们进入阻塞状态，等到任务来了唤醒即可。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。</li>
</ul>
<h2 id="有关线程你该知道的"><a href="#有关线程你该知道的" class="headerlink" title="有关线程你该知道的"></a>有关线程你该知道的</h2><h3 id="创建线程的两种方式："><a href="#创建线程的两种方式：" class="headerlink" title="创建线程的两种方式："></a>创建线程的两种方式：</h3><ol>
<li>继承Thread类，扩展线程；</li>
<li>实现Runnable接口，java不支持多类继承，所以要继承其他类时调用Runnable接口更好。<br><br>具体代码及解释参考文首孙富生简书链接。</li>
</ol>
<h3 id="Thread类中的start-和run-方法区别"><a href="#Thread类中的start-和run-方法区别" class="headerlink" title="Thread类中的start()和run()方法区别"></a>Thread类中的start()和run()方法区别</h3><ul>
<li>调用run()方法，用当前线程去执行一个普通方法，并没有创建新线程；</li>
<li>调用start()方法才会启动新线程，该方法会做一些准备工作：设置好这个线程的上下文，比如这个线程的栈（用于函数调用），线程的状态，这个线程的PC(Program Counter）等等一系列信息以后，这个线程才可以被调度，一旦被调度，就会执行那个run()方法了。</li>
</ul>
<span id="more"></span>


<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><h4 id="使用多线程的优缺点"><a href="#使用多线程的优缺点" class="headerlink" title="使用多线程的优缺点"></a>使用多线程的优缺点</h4><p>优点：</p>
<ol>
<li>适当的提高程序的执行效率（多个线程同时执行）。</li>
<li>适当的提高了资源利用率（CPU、内存等）。</li>
</ol>
<p>缺点：</p>
<ol>
<li>占用一定的内存空间。</li>
<li>线程越多CPU的调度开销越大。</li>
<li>程序的复杂度会上升。</li>
</ol>
<h4 id="多线程的技术点"><a href="#多线程的技术点" class="headerlink" title="多线程的技术点"></a>多线程的技术点</h4><h5 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h5><p>同步由关键字synchronized来实现，所有加上synchronized的块语句和方法（成员方法&#x2F;静态方法），在多线程访问的时候，同一时刻只能有一个线程能够访问。<br><strong>同步问题解决办法：</strong><br>1.将竞争资源标记为private；2.用synchronized关键字同步那些修改变量的代码</p>
<h5 id="wait-、notify-、notifyAll"><a href="#wait-、notify-、notifyAll" class="headerlink" title="wait()、notify()、notifyAll()"></a>wait()、notify()、notifyAll()</h5><blockquote>
<p>这三个方法是 java.lang.Object 的 final native 方法，任何继承 java.lang.Object 的类都有这三个方法（不属于thread）。它们是Java语言提供的实现线程间阻塞和控制进程内调度的底层机制，平时我们会很少用到的。</p>
</blockquote>
<blockquote>
<ul>
<li>wait()：<br>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll唤醒，该方法只能在同步方法中调用。</li>
<li>notify()：<br>随机选择一个在该对象上调用wait方法的线程，解除其阻塞状态，该方法只能在同步方法或同步块内部调用。</li>
<li>notifyAll()：<br>解除所有那些在该对象上调用wait方法的线程的阻塞状态，同样该方法只能在同步方法或同步块内部调用。</li>
</ul>
</blockquote>
<blockquote>
<p>调用这三个方法中任意一个，当前线程必须是锁的持有者，如果不是会抛出一个 IllegalMonitorStateException 异常。</p>
</blockquote>
<h5 id="wait-与-Thread-sleep-long-millis-int-nanos"><a href="#wait-与-Thread-sleep-long-millis-int-nanos" class="headerlink" title="wait() 与 Thread.sleep(long millis,int nanos)"></a>wait() 与 Thread.sleep(long millis,int nanos)</h5><blockquote>
<ul>
<li>wait() 方法使实体所处线程暂停执行，从而使对象进入等待状态，直到被 notify() 方法通知或者 wait() 的等待的时间到。</li>
<li>sleep() 方法使持有的线程暂停运行（仅能控制当前正在运行的线程），从而使线程进入休眠状态，直到用 interrupt 方法来打断他的休眠或者 sleep 的休眠的时间到。</li>
</ul>
</blockquote>
<blockquote>
<p>wait()会释放同步锁，sleep()方法不会</p>
</blockquote>
<h5 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h5><blockquote>
<ul>
<li>volatile 是一个特殊的修饰符，只有成员变量才能使用它。在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。</li>
</ul>
</blockquote>
<ul>
<li>volatile 变量可以保证下一个读取操作会在前一个写操作之后发生（使该 变量可被其他线程正确的读取）。线程都会直接从内存中读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。</li>
<li>valatile 不可用在final变量前</li>
</ul>
<h5 id="ThreadLocal-变量"><a href="#ThreadLocal-变量" class="headerlink" title="ThreadLocal 变量"></a>ThreadLocal 变量</h5><blockquote>
<p>ThreadLocal 是Java里一种特殊的变量。每个线程都有一个，ThreadLocal 就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。首先，通过复用减少了代价高昂的对象的创建个数。其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。</p>
</blockquote>
<h5 id="join-方法"><a href="#join-方法" class="headerlink" title="join() 方法"></a>join() 方法</h5><blockquote>
<p>join() 方法定义在 Thread 类中，所以调用者必须是一个线程，join() 方法主要是让调用该方法的 Thread 完成 run() 方法里面的东西后，再执行 join() 方法后面的代码（实现了顺序性，避免了并发执行）</p>
</blockquote>
<h5 id="Thread-yield-方法"><a href="#Thread-yield-方法" class="headerlink" title="Thread.yield() 方法"></a>Thread.yield() 方法</h5><blockquote>
<ul>
<li>线程放弃运行，将CPU的控制权让出。</li>
<li>虽然让出了，但还有可能被系统的调度机制再次选中来运行。</li>
</ul>
</blockquote>
<p>未完待续  。。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>Multithread</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 2</title>
    <url>/2018/07/05/Note-for-Computer-Network-2/</url>
    <content><![CDATA[<h1 id="Note-for-Computer-Network-2"><a href="#Note-for-Computer-Network-2" class="headerlink" title="Note for Computer Network 2"></a>Note for Computer Network 2</h1><p><strong>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记2</strong></p>
<h2 id="生成-HTTP-请求消息"><a href="#生成-HTTP-请求消息" class="headerlink" title="生成 HTTP 请求消息"></a>生成 HTTP 请求消息</h2><p>动作：对URL 进行解析<br>效果：浏览器确定了 Web 服务器和文件名<br>后续：根据这些信息来生成 HTTP 请求消息</p>
<p><img src="/2018/07/05/Note-for-Computer-Network-2/1.png" alt="1"></p>
<ul>
<li>消息头存放“请求行没说清楚的”额外信息，消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。比如Date、Pragma、Cache-control、Connection、Transfer-Encoding、Via等，参考<a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5">HTTP头字段-wiki百科</a></li>
<li>写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据（即消息体）</li>
</ul>
<p><img src="/2018/07/05/Note-for-Computer-Network-2/2.png" alt="2"></p>
<ul>
<li>响应消息与请求消息差别仅在第一行，内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="center">告知请求的处理进度和情况</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="center">成功</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="center">表示需要进一步操作</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="center">客户端错误</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="center">服务器错误</td>
</tr>
</tbody></table>
<ul>
<li>返回响应消息之后，浏览器会将数据提取出来并显示在屏幕上，我们就能够看到网页的样子了。如果网页的内容只有文字，那么到这里就全部处理完毕了，但如果网页中还包括图片等资源，则还有下文</li>
<li>当网页中包含图片时，会在网页中的相应位置<strong>嵌入</strong>表示图片文件的标签的<strong>控制信息</strong>。浏览器会在显示文字时搜索相应的标签，当遇到图片相关的标签时，会在屏幕上留出用来显示图片的空间，然后<strong>再次访问</strong> Web服务器，按照标签中指定的文件名向Web服务器请求获取相应的图片并显示在预留的空间中<br>  [扩展思考]就是因为图文的异步，所以可以考虑采用多线程的方式，先刷出文字，后刷出图片，提升浏览器阅读体验</li>
<li>由于每条请求消息中只能写 1 个 URI，所以每次只能获取 1 个文件，如果需要获取多个文件，必须对每个文件单独发送 1 条请求。即，3张图片&#x3D;&#x3D;额外3次request</li>
</ul>
<span id="more"></span>

<h2 id="向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="向 DNS 服务器查询 Web 服务器的 IP 地址"></a>向 DNS 服务器查询 Web 服务器的 IP 地址</h2><ul>
<li>浏览器虽然可以生成标准Http消息，但不具备发送功能，需要借助os来完成</li>
<li>os发送Http消息时，需要知道目标的IP地址，而非域名，所以发送前需要通过域名查询到IP地址，之后才能委托给os</li>
</ul>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul>
<li>IP地址主体表示为：10.12.13.14格式，网络号和主机号连起来总共是 32 比特，但这两部分的具体结构是不固定的 </li>
<li>在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息（即子网掩码）来表示 IP 地址的内部结构</li>
<li>子网掩码为1的部分表示网络号、为 0的部分表示主机号，子网掩码表示网络号与主机号之间的边界</li>
<li>带子网掩码的IP地址为：10.1.2.3&#x2F;255.255.255.0或者10.1.2.3&#x2F;24，两者含义完全一致（24表示子网掩码中1有24位）</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">十进制表示</th>
<th align="center">二进制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IP地址</td>
<td align="center">10.1.2.3</td>
<td align="center">00001010.00000001.00000010.00000011</td>
</tr>
<tr>
<td align="center">子网掩码</td>
<td align="center">255.255.255.0</td>
<td align="center">11111111.11111111.11111111.00000000</td>
</tr>
<tr>
<td align="center">网络号</td>
<td align="center">10.1.2</td>
<td align="center">00001010.00000001.00000010</td>
</tr>
<tr>
<td align="center">主机号</td>
<td align="center">3</td>
<td align="center">00000011</td>
</tr>
<tr>
<td align="center">[注]上例中，子网掩码刚好分隔在小数点。。事实上化分在字节中间亦可</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><img src="/2018/07/05/Note-for-Computer-Network-2/3.png" alt="3"></p>
<h3 id="DNS服务器-amp-DNS解析器"><a href="#DNS服务器-amp-DNS解析器" class="headerlink" title="DNS服务器&amp;DNS解析器"></a>DNS服务器&amp;DNS解析器</h3><ul>
<li>DNS解析器向DNS服务器发送查询IP的消息，并接受响应消息</li>
<li>解析器其实是OS的socket库中的一段程序（一种程序组件），Socket库也是一种库（一堆程序组件），其中包含的程序组件可以让其他的应用程序调用操作系统的<strong>网络功能</strong></li>
<li>在编写浏览器等应用程序的时候，只要写上解析器的程序名称“gethostbyname”以及 Web服务器的域名（待解析），就完成了对解析器的调用。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--网络应用程序，</span></span><br><span class="line"><span class="comment">运行以下代码后，服务器的IP地址就会被写入内存地址中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">内存地址</span>&gt;</span> = gethostbyname(&quot;www.baidu.com&quot;);</span><br><span class="line"><span class="comment">&lt;!--发送Http消息--&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="解析器内部工作原理"><a href="#解析器内部工作原理" class="headerlink" title="解析器内部工作原理"></a>解析器内部工作原理</h4><ul>
<li>解析器发送查询消息的过程，与浏览器生成要发送给 Web 服务器的 HTTP请求消息的过程类似，但发送消息的操作由解析器委托给OS内部协议栈（也叫<strong>TCP&#x2F;IP驱动</strong>）来执行。</li>
<li>协议栈通过网卡将消息发送给DNS服务器</li>
<li>其中，DNS服务器的IP地址是作为TCP&#x2F;IP的一个设置项目提前设置好了的，无需进行查询操作</li>
</ul>
<h4 id="查询消息"><a href="#查询消息" class="headerlink" title="查询消息"></a>查询消息</h4><ol>
<li>域名：服务器或邮件服务器名称</li>
<li>Class：目前只有互联网，所以是IN</li>
<li>记录类型：类型A代表IP地址；类型MX代表邮件服务器</li>
</ol>
<p>[理解：链级查询]客户端会先访问最近的一台DNS服务器，如果没有想要查询的记录，就会将查询消息发送给根域DNS服务器，再向下查询最终找到目标DNS服务器。向目标DNS服务器发送查询消息，就会得到对应的IP地址</p>
<ul>
<li>实际的互联网中，上下级域可能采用共享方式，链级查询时可以跳级查询；DNS服务器还可以缓存最近查询信息。以上两种方法提高查询效率</li>
<li>缓存的方式有可能造成不一致，所以缓存信息有一个有效期，超过有效期将删除缓存数据</li>
</ul>
<h2 id="委托协议栈发送消息"><a href="#委托协议栈发送消息" class="headerlink" title="委托协议栈发送消息"></a>委托协议栈发送消息</h2><ul>
<li>此处的消息是数字信息——digital data</li>
<li>向协议栈发送消息时，需按照指定的顺序调用socket库中的多个程序组件（即进行委托）</li>
</ul>
<h2 id="补充内容-协议栈接受委托后收发数据操作的整体思路"><a href="#补充内容-协议栈接受委托后收发数据操作的整体思路" class="headerlink" title="[补充内容]协议栈接受委托后收发数据操作的整体思路"></a>[补充内容]协议栈接受委托后收发数据操作的整体思路</h2><ol>
<li>收发数据的两台计算机之间连接了一条双向数据通道</li>
<li>建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字</li>
<li>服务器程序在启动后就创建好套接字并等待客户端连接；客户端也会先创建一个套接字，从该套接字延伸出管道，连接到服务器端的套接字上，由此，通信准备工作完成</li>
<li>当数据发送完毕后，管道会被断开，断开可由两方的任意一方发起（一般Http版本有规定），断开后套接字也会被删除，通信结束</li>
<li>四个阶段分别为：创建套接字阶段、连接阶段、通信阶段、断开阶段</li>
</ol>
<h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--DNS服务器，信息流--&gt;</span></span><br><span class="line">...</span><br><span class="line">//获取IP地址</span><br><span class="line">	<span class="tag">&lt;<span class="name">内存地址</span>&gt;</span> = gethostbyname(&quot;www.baidu.com&quot;);</span><br><span class="line">...</span><br><span class="line">//1.准备，创建套接字，创建完成后协议栈返回一个描述符，用于识别不同的套接字（本方，对网络另一端透明）</span><br><span class="line">	<span class="tag">&lt;<span class="name">描述符</span>&gt;</span> = socket(<span class="tag">&lt;<span class="name">使用IPv4</span>&gt;</span>,<span class="tag">&lt;<span class="name">流模式</span>&gt;</span>,...);</span><br><span class="line">...</span><br><span class="line">//2.连接，协议栈执行连接操作，IP和端口号是识别对方套接字的机制</span><br><span class="line">	connect(<span class="tag">&lt;<span class="name">描述符</span>&gt;</span>,<span class="tag">&lt;<span class="name">服务器的IP地址和端口号</span>&gt;</span>,...);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--协议栈，数据流--&gt;</span></span><br><span class="line">//3.协议栈将数据发送出去</span><br><span class="line">	write(<span class="tag">&lt;<span class="name">描述符</span>&gt;</span>,<span class="tag">&lt;<span class="name">发送数据</span>&gt;</span>,<span class="tag">&lt;<span class="name">发送数据长度</span>&gt;</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Web服务器，数据流--&gt;</span></span><br><span class="line">//3.接收，响应信息放入接收缓冲区中</span><br><span class="line">	<span class="tag">&lt;<span class="name">接收数据长度</span>&gt;</span> = read(<span class="tag">&lt;<span class="name">描述符</span>&gt;</span>,<span class="tag">&lt;<span class="name">接收缓冲区</span>&gt;</span>,...);</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--Web服务器，信息流--&gt;</span></span><br><span class="line">//4.断开</span><br><span class="line">	close(<span class="tag">&lt;<span class="name">描述符</span>&gt;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>每次都要连删，造成效率低下，后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在 HTTP 版本 1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作</li>
<li>注：地址解析协议，Address Resolution Protocol，ARP，根据已知IP求出MAC地址</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 3</title>
    <url>/2018/07/13/Note-for-Computer-Network-3/</url>
    <content><![CDATA[<h1 id="协议栈如何处理数据发送请求"><a href="#协议栈如何处理数据发送请求" class="headerlink" title="协议栈如何处理数据发送请求"></a>协议栈如何处理数据发送请求</h1><p>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记3</p>
<p><img src="/2018/07/13/Note-for-Computer-Network-3/1.png" alt="1"></p>
<p>Tips:</p>
<ul>
<li>IEEE802.3&#x2F;802.2因长度太长、效率降低并未完全普及，更古老的以太网DIX规格仍在使用</li>
<li>TCP&#x2F;IP协议以前是合为一体的，现在分开成两个</li>
<li>像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像 DNS 查询等收发较短的控制数据的时候则使用UDP</li>
<li>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP 用于根据IP地址查询相应的以太网MAC地址</li>
<li>套接字的实体就是通信控制信息：IP地址、端口号、通信操作的进行状态、是否收到响应、执行发送操作后经过了多长时间等</li>
</ul>
<p><img src="/2018/07/13/Note-for-Computer-Network-3/2.png" alt="2"></p>
<ul>
<li>图2.3的步骤1中，协议栈申请内存空间准备存放套接字（控制信息），刚刚创建时，数据收发操作还未开始，故写入初始状态的控制信息；之后将套接字描述符告知应用程序</li>
<li>步骤2的连接是指双方交换控制信息，必要的信息放在了网络包的头部，另一类放在套接字内存区<ul>
<li>将浏览器查到的对方IP和端口号等告知协议栈</li>
<li>服务器创建套接字（其实一般在服务器启动时已经创建好了），客户端将本机IP和端口号等告知服务器</li>
<li>创建一块缓存区，用于临时存放收发的数据</li>
<li>connect详见后面段落</li>
</ul>
</li>
</ul>
<span id="more"></span>	
<ul>
<li>步骤3为数据收发阶段，步骤2结束时，控制流程被交还给应用程序，应用程序调用write将数据以一大串二进制字节序列的形式交给协议栈，协议栈将数据存入发送缓存区中（不选择一次性发送是因为应用程序可能逐行或其他形式发送数据，或者积攒一定量的数据再发送以避免小包）<ul>
<li>积累多少数据才能发送，要看操作系统的种类和版本，主要看以下参数：</li>
<li>MTU参数（即一个网络包的最大长度，以太网中一般为1500字节）</li>
<li>等待时间（避免积攒太久）</li>
</ul>
</li>
<li>步骤3补：TCP模块会设计<code>序号</code>和<code>ACK号</code>，可以计算发送的某包是从第几个字节开始，长度多少了，可以用来确认遗漏情况</li>
<li>步骤3补补：客户端在连接时需要计算出与从客户端到服务器方向通信相关的<code>序号初始值</code>，发送给服务器，写在SYN值中，不是从1开始，可避免网络攻击；服务器返回ACK号表示确认，并返回反方向的<code>序号初始值</code>，客户端接收完毕，发送ACK给服务器，服务器接收表示两个<code>序号初始值</code>传递完毕。注：此步操作再connect中完成</li>
<li>步骤4，read程序接收响应，数据进入数据缓存区，在发送请求后接收响应前，read的工作会被挂起，等响应到达时再处理</li>
<li>步骤5，调用Socket库的close程序，将TCP头部的FIN比特设为1，套接字记录断开的控制信息，同时通过IP模块向对方发送数据，对方接收到数据后，返回FIN为1和ACK的包，并更改自己的套接字为断开操作状态。此数据被协议栈调取，协议栈告知应用程序数据已经全部收到，通信结束。</li>
<li>步骤5补，为了避免误操作，套接字会延迟删除，大约是几分钟</li>
</ul>
<h3 id="重要！connect过程"><a href="#重要！connect过程" class="headerlink" title="重要！connect过程"></a>重要！connect过程</h3><ol>
<li>协议栈中的TCP 模块处创建表示连接控制信息的<code>头部</code>，通过 TCP 头部中的发送方和接收方端口号可以找到要连接的套接字</li>
<li>TCP模块会将信息传递给IP模块并委托它发送</li>
<li>网络包由IP模块经网络发送到服务器的IP模块再传递给TCP模块</li>
<li>服务器的TCP模块会根据TCP头部信息找到端口号对应的套接字，服务器的套接字会改变状态为<code>正在连接</code></li>
<li>发回响应：在TCP头部设置双方的端口号、设<code>SYN比特</code>(接收连接设为1，若不接受，则不设SYN，改设RST为1)，设<code>ACK比特</code>为1(客户端向服务器发送第一个网络包时，ACK设为0，ACK比特并非前文ACK号，是一个ACK号字段的两个部分)，将TCP头部传递给IP模块，委托IP模块向客户端发回响应</li>
<li>到达客户端的网络包通过IP模块到达TCP模块，并通过TCP头部的信息确认连接是否成功</li>
<li>SYN为1表示连接成功，之后向套接字写入服务器的IP、端口，并将状态改为<code>连接完毕</code></li>
<li>ACK为1的响应信息已经到达客户端，相应的，客户端需要将ACK设置为1并发回服务器，告知服务器刚刚的响应包已收到，等服务器收到此包则意味着整个连接操作全部完成</li>
<li>此connect也有人称为’session‘，此处不作延伸</li>
</ol>
<h3 id="ACK号的管理"><a href="#ACK号的管理" class="headerlink" title="ACK号的管理"></a>ACK号的管理</h3><ol>
<li>根据网络包平均往返时间调整 ACK 号等待时间，TCP采用了动态调整等待时间的方法，ACK号返回变慢，就延长ACK号等待时间</li>
<li>使用滑动窗口管理：在发送一个包之后，不等待 ACK 号返回，而是直接发送后续的一系列包。但是可能出现发送包的频率超过接收方处理能力的情况，严重的后果是造成缓存区溢出。避免的方法是，接收方先告诉发送方自己的承载能力，然后发送方根据这个值对数据发送操作进行控制，注：其中有个名词<code>窗口字段</code>，能够接收的最大数据量的大小称为<code>窗口大小</code>，一般与接收方的缓存区大小一致 </li>
<li>每接收到一个包，就要向发送方传递ACK号和窗口更新这两个独立的包，会造成效率下降。解决办法：独立包发送前等待一下，凑足两个后一齐发送，可以减少包的数量</li>
</ol>
<p>已完成全书219页</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 4</title>
    <url>/2018/07/14/Note-for-Computer-Network-4/</url>
    <content><![CDATA[<h1 id="包收发操作"><a href="#包收发操作" class="headerlink" title="包收发操作"></a>包收发操作</h1><p>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记4</p>
<h2 id="IP模块如何将包发给对方"><a href="#IP模块如何将包发给对方" class="headerlink" title="IP模块如何将包发给对方"></a>IP模块如何将包发给对方</h2><h3 id="通用流程"><a href="#通用流程" class="headerlink" title="通用流程"></a>通用流程</h3><ol>
<li>发送方的网络设备负责创建包，即生成含控制信息的头部，然后附上要发送的数据</li>
<li>接着，包被发往最近的网络转发设备</li>
<li>然后转发设备会根据头部信息判断接下来应该发往哪里，这个过程会用到一张表，按照头部记录的目的地址在表里查询，根据查到的信息判断接下来应该发往哪个方向</li>
<li>转发设备层层接力，最后到达接收方</li>
<li>发送方和接收方统称为终端节点，转发设备称为转发节点或中间节点</li>
</ol>
<h3 id="扩展流程——TCP-x2F-IP网络，用以太网规则传输包"><a href="#扩展流程——TCP-x2F-IP网络，用以太网规则传输包" class="headerlink" title="扩展流程——TCP&#x2F;IP网络，用以太网规则传输包"></a>扩展流程——TCP&#x2F;IP网络，用以太网规则传输包</h3><ul>
<li>转发设备包括路由器和集线器两种</li>
<li>路由器根据目标地址判断下一个路由器的位置，是按照IP规则传输包的设备</li>
<li>集线器在子网中将网络包传递给下一个路由，是按照以太网规则传输包的设备</li>
<li>TCP&#x2F;IP包包含<code>MAC头部</code>和<code>IP头部</code>、<code>TCP头部和数据块</code>，IP头部存入下一级路由器的IP地址，MAC头部存入下一级路由器的MAC地址(即以太网地址，是IP协议写入的，使用ARP广播的形式获取)，<strong>MAC地址也叫物理地址(Physical Address)</strong></li>
<li>例：<ol>
<li>客户端向服务器发包，先经集线器配合自己的一张表读取<code>MAC头部</code>获取下一个路由器甲的MAC地址，根据MAC地址，让以太网进行包的传输</li>
<li>包会到达下一个路由器甲，路由器有一张IP协议的表，再读取<code>IP头部</code>获取再下一个路由器乙的IP地址，为了将包发给再下一个路由器，就必须要下一个路由器乙的MAC地址，并记录到MAC头部</li>
</ol>
</li>
</ul>
<span id="more"></span>

<p><img src="/2018/07/14/Note-for-Computer-Network-4/1.png" alt="1"></p>
<h3 id="委托操作"><a href="#委托操作" class="headerlink" title="委托操作"></a>委托操作</h3><ol>
<li>包收发操作的起点：TCP模块委托IP模块发包，过程为TCP模块在数据块的前面加上TCP头部，然后整个传递给IP模块；</li>
<li>收到委托的IP模块，将包的内容当作一整块二进制数据，并不关心内容，在前面加上IP头部和MAC头部</li>
<li>封装好的包被交给网络硬件即网卡，网卡会将该数字信息转换成光信号或电信号，以此到达集线器、路由器等转发设备</li>
</ol>
<h3 id="以太网的3个性质"><a href="#以太网的3个性质" class="headerlink" title="以太网的3个性质"></a>以太网的3个性质</h3><ol>
<li>接收方的MAC地址代表目的地，并放在包的MAC头部 </li>
<li>发送方的MAC地址用来识别发送方</li>
<li>使用以太类型识别包的内容</li>
</ol>
<h3 id="网卡做了啥"><a href="#网卡做了啥" class="headerlink" title="网卡做了啥"></a>网卡做了啥</h3><ul>
<li><p>网卡驱动从IP模块获取包，将其复制到网卡内的缓存区中，然后向MAC模块发出发送包的命令</p>
</li>
<li><p>接着MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列FCS，如下图：</p>
<p> <img src="/2018/07/14/Note-for-Computer-Network-4/2.png" alt="2"></p>
</li>
<li><p>报头是一串101010…交替出现的规则序列，长度56比特，形成波形用来判断读取时机，加上8比特的起始帧，网卡可以将它作为包的起始位置</p>
</li>
<li><p>另，报头可以用来测量时钟信号，向接收方发送时钟信号的变化周期</p>
</li>
<li><p>数据信号如果连续为1或连续为0时，比特之间的界限就会消失，所以增加时钟信号有助于判断比特之间的界限，所以一般实际传输的信号都是：数据信号和时钟信号异或之后的结果，如下图：</p>
<p>  <img src="/2018/07/14/Note-for-Computer-Network-4/3.png" alt="3"></p>
</li>
<li><p>FCS用来检查包传输过程中因噪声导致的波形紊乱、数据错误，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的</p>
</li>
</ul>
<h3 id="完整的包发出去"><a href="#完整的包发出去" class="headerlink" title="完整的包发出去"></a>完整的包发出去</h3><ol>
<li>一种是使用集线器的半双工模式，另一种使用交换机的全双工模式（即可以并行收发）</li>
<li>半双工中，需要等待信号传输完毕再发送下一组信号：<ol>
<li>MAC模块从报头开始将数字信息转换成电信号，然后由PHY（或者MAU，速率100Mbit&#x2F;s以下叫MAU）的信号收发模块发送出去，每秒将10Mbit的数字信息转换成 电信号发送出去，速率就是10Mbit&#x2F;s</li>
<li>PHY（MAU）模块将信号转换成可在 网线上传输的格式，并通过 网线发送出去，PHY另一职责是监控接收线路有没有信号进来，没有信号进入时才允许发送，但以太网不会确认对方有没有收到信号</li>
<li>但出现碰撞的可能性仍较高，因此 必须要让等待的时间相互错开，等待的时间是根据MAC地址生成一个随机数计算出来的</li>
<li>如果冲突，等待时间延长一倍，然后重试，以此类推，最多重试10次，如果还是不行就报告通信错误</li>
</ol>
</li>
<li>收包的过程是发包的逆序，但有一些注意点：<ol>
<li>MAC模块完成收包工作后，需要使用中断通知计算机收到了一个包：网卡向扩展总线中的中断信号线发送信号，CPU挂起正在处理的任务，然后切换到操作系统的中中断处理程序，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作</li>
<li>接收操作一般是判断协议类型，再交给对应协议栈处理，比如TCP&#x2F;IP协议栈，接着轮到IP模块开始工作，判断是否是发给自己的包，如果发生这样的错误，IP模块会通过ICMP消息将错误告知发送方</li>
<li>如果接收方IP地址正确，IP协议需要完成分片重组的功能，将多个小包还原成原始包</li>
<li>然后交给TCP模块，TCP模块查找套接字，找到对应的套接字后根据通信状态执行相应的操作，比如通知应用程序干嘛干嘛</li>
</ol>
</li>
</ol>
<h2 id="UDP协议的收发操作"><a href="#UDP协议的收发操作" class="headerlink" title="UDP协议的收发操作"></a>UDP协议的收发操作</h2><h3 id="UDP协议使用场景"><a href="#UDP协议使用场景" class="headerlink" title="UDP协议使用场景"></a>UDP协议使用场景</h3><ol>
<li>数据很短的场景，一般一个包就能装下，回复的数据就可以当作接收确认了，不再需要专门的接收确认包，也就没有窗口机制，比如DNS的查询操作</li>
<li>对实时性要求很高的场景，比如发送音频和视频数据，可以忍受少许丢帧，但不能忍受卡顿</li>
</ol>
<p>完成全书第2章，334页</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 5</title>
    <url>/2018/07/14/Note-for-Computer-Network-5/</url>
    <content><![CDATA[<h1 id="创建好了的包是如何进入互联网的"><a href="#创建好了的包是如何进入互联网的" class="headerlink" title="创建好了的包是如何进入互联网的"></a>创建好了的包是如何进入互联网的</h1><p>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记5</p>
<h3 id="网线中的信号衰减情况"><a href="#网线中的信号衰减情况" class="headerlink" title="网线中的信号衰减情况"></a>网线中的信号衰减情况</h3><ol>
<li>信号从网卡出口到达集线器，会出现衰减、失真、噪声、能量损失等，严重时产生通信错误</li>
<li>局域网的网线使用双绞线，可以抑制噪声，使得网线周围或内部的电磁波在网线中产生的的干扰电流</li>
</ol>
<h2 id="集线器和交换机"><a href="#集线器和交换机" class="headerlink" title="集线器和交换机"></a>集线器和交换机</h2><ul>
<li>集线器将信号发往所有线路</li>
<li>以太网的基本架构就是将包发到所有的设备，设备根据接收方的MAC地址来判断应该接收哪些包</li>
<li>交换机按照地址表进行转发：当接收到包时，会将对应的端口号和发送方MAC地址写入表中，这样就可以根据地址判断出该设备连接在哪个端口上了</li>
</ul>
<table>
<thead>
<tr>
<th align="center">MAC地址</th>
<th align="center">端口</th>
<th align="center">控制信息</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00-60-97-A-43-3C</td>
<td align="center">2</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">00-00-C0-18-AE-FD</td>
<td align="center">7</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>MAC地址表</p>
<span id="more"></span>

<h3 id="交换机中MAC地址表的维护"><a href="#交换机中MAC地址表的维护" class="headerlink" title="交换机中MAC地址表的维护"></a>交换机中MAC地址表的维护</h3><ol>
<li>收到包时，将发送方MAC地址以及其输入端口的号码写入MAC地址表中</li>
<li>删除记录，是为了防止设备移动时产生问题，将笔记本电脑从办公室移到会议室，记录会过时，所以地址表的记录在一段时间不使用后会自动删除，只要笔记本电脑连接到会议室的交换机，交换机就会根据笔记本电脑发出的包来更新它的地址表</li>
<li>过时记录删除前，交换机仍有可能将包转发到老的端口，通信就会发生错误，情况尽管罕见，但仍可能发生，只要重启交换机，地址表就会被清空，并更新正确的信息，然后网络又可以正常工作了</li>
</ol>
<h3 id="（网线-gt-接收端口）信号通过双绞线到达网线接口传入时，进入PHY模块的接收部分"><a href="#（网线-gt-接收端口）信号通过双绞线到达网线接口传入时，进入PHY模块的接收部分" class="headerlink" title="（网线-&gt;接收端口）信号通过双绞线到达网线接口传入时，进入PHY模块的接收部分"></a>（网线-&gt;接收端口）信号通过双绞线到达网线接口传入时，进入PHY模块的接收部分</h3><ol>
<li>PHY模块将网线中的信号转换为通用格式，然后传递给MAC模块。MAC模块将信号转换为数字信息，然后经过FCS校验错误，无误则存放入缓存区。</li>
<li>放入缓存区后，要查询一下这个包的接收方MAC地址是否已经在MAC地址表中有记录了，若有，查到端口号，通过交换电路将包发送到该端口</li>
</ol>
<h3 id="交换电路工作方式"><a href="#交换电路工作方式" class="headerlink" title="交换电路工作方式"></a>交换电路工作方式</h3><p><img src="/2018/07/14/Note-for-Computer-Network-5/1.png" alt="1"></p>
<p>如图，每个交叉点都有一个交换开关，交换开关由电子控制</p>
<h3 id="（发送端口-gt-网线）半双工模式下发送部分"><a href="#（发送端口-gt-网线）半双工模式下发送部分" class="headerlink" title="（发送端口-&gt;网线）半双工模式下发送部分"></a>（发送端口-&gt;网线）半双工模式下发送部分</h3><ol>
<li>发送前确认，接收线路中没有信号过来</li>
<li>发送时，对接收信号进行监控，如果检测到，说明出现信号碰撞，这时需要发送阻塞信号停止网络中所有的发送操作，等待一段时间之后尝试重新发送</li>
</ol>
<h3 id="特殊操作"><a href="#特殊操作" class="headerlink" title="特殊操作"></a>特殊操作</h3><ol>
<li><p>交换机查询地址后发现，记录中的目标端口和这个包的源端口是同一个端口：</p>
<p> <img src="/2018/07/14/Note-for-Computer-Network-5/2.png" alt="2"></p>
<ul>
<li>A发出包，集线器广播到B和交换机，交换机接入端口和目标端口是同一个（设为P），从P又会到达集线器，集线器再次发包到B和交换机。此时交换机会重复得到同一个包。因此，当交换机发现一个包要发回到原端口时，就会直接丢弃这个包。</li>
</ul>
</li>
<li><p>地址表找不到指定的MAC地址。可能是该地址设备尚未向该交换机发过包，又或者地址表中记录删除了。所以此时交换机无法判断应该把包发给哪个端口，只能把包发给除源端口外的所有端口。</p>
</li>
</ol>
<h2 id="全双工模式"><a href="#全双工模式" class="headerlink" title="全双工模式"></a>全双工模式</h2><ul>
<li>使用双绞线，发送和接收的信号线是各自独立的</li>
<li>交换机端口、网卡的PHY和MAC模块，其内部发送和接收电路也是各自独立的，信号也不会发生碰撞，因此只要不适用集线器，就可以避免信号碰撞</li>
<li>全双工模式下，以太网规范有所修改，不需要进行碰撞处理机制，因此速度快，性能高</li>
</ul>
<h2 id="自动协商"><a href="#自动协商" class="headerlink" title="自动协商"></a>自动协商</h2><ul>
<li>全双工和半双工模式可以进行自动切换</li>
<li>相互连接的双方探测对方是否支持全双工模式，并自动切换成相应的工作模式，甚至探测对方的传输速率并进行自动切换</li>
</ul>
<h2 id="间歇脉冲"><a href="#间歇脉冲" class="headerlink" title="间歇脉冲"></a>间歇脉冲</h2><ul>
<li>在以太网中，当没有数据在传输时，网络中会填充一种被称为连续脉冲的脉冲信号。因为一直有信号，从而能够检测对方是否在正常工作，或者说网线有没有正常连接</li>
<li>以太网设备的网络接口周围有一个绿色的LEC指示灯，如果绿灯亮，说明PHY模块以及网线连接正常</li>
<li>脉冲信号还承载着自动协商的功能</li>
</ul>
<p>完成全书 381页</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Note for Computer Network 6</title>
    <url>/2018/07/29/Note-for-Computer-Network-6/</url>
    <content><![CDATA[<h1 id="路由器、ADSL、FTTH"><a href="#路由器、ADSL、FTTH" class="headerlink" title="路由器、ADSL、FTTH"></a>路由器、ADSL、FTTH</h1><p>副标题：阅读《网络是怎么连接的（户根勤）》读书笔记6</p>
<h2 id="路由器基础知识"><a href="#路由器基础知识" class="headerlink" title="路由器基础知识"></a>路由器基础知识</h2><ul>
<li>路由器分为<code>转发模块</code>和<code>端口模块</code>两部分</li>
<li><code>转发模块</code>负责，判断包的转发目的地</li>
<li><code>端口模块</code>负责，进行包的收发操作</li>
<li>如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网了</li>
</ul>
<h2 id="路由器基本原理"><a href="#路由器基本原理" class="headerlink" title="路由器基本原理"></a>路由器基本原理</h2><ol>
<li>接收。路由器在转发包时，会通过端口将发过来的包接收进来，采取以太网规范或者无线局域网规范来接收</li>
<li>查找目标地址。转发模块根据收到的包的IP头部中记录的接收方IP地址，在路由表中进行查询，以此判断转发目标</li>
<li>转发模块将包转移到转发目标对应的端口，再按照硬件的规则（委托端口模块）将包发送出去</li>
<li>注：端口模块会根据相应通信技术的规范来执行包收发的操作，意味着端口模块具备了发送方或接收方的身份。以以太网端口为例，端口具有MAC地址、IP地址，此时可以理解为实现了<strong>网卡</strong>的功能</li>
</ol>
<table>
<thead>
<tr>
<th align="center">目标地址</th>
<th align="center">子网掩码</th>
<th align="center">网关</th>
<th align="center">接口</th>
<th align="center">跃点数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.10.1.0</td>
<td align="center">255.255.255.0</td>
<td align="center">-</td>
<td align="center">e2</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">10.10.1.101</td>
<td align="center">255.255.255.255</td>
<td align="center">-</td>
<td align="center">e2</td>
<td align="center">1</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="ADSL接入网的工作方式"><a href="#ADSL接入网的工作方式" class="headerlink" title="ADSL接入网的工作方式"></a>ADSL接入网的工作方式</h2><ul>
<li>互联网接入路由器的包转发操作。根据包IP头部中的接收方IP地址，在路由表的目标地址中进行匹配，找到相应的路由记录后将包转发到这条路由的目标网关。</li>
<li>互联网接入路由器是按照接入网规则来发送包的。<code>接入网</code>：连接互联网与家庭、公司网络的通信线路。比较有代表性的是ADSL（Asymmetric Digital Subscriber Line）不对称数字用户线，利用金属电话线进行通信，它的上行速率和下行速率是不对称的。</li>
</ul>
<blockquote>
<p>接入流程：</p>
</blockquote>
<ol>
<li>用户端路由器发出的网络包通过ADSL Modem和电话线到达电话局；</li>
<li>然后到达ADSL的网络运营商（ISP）；</li>
<li>经过隧道专用路由器进入互联网；</li>
</ol>
<h3 id="网络包的形态变化"><a href="#网络包的形态变化" class="headerlink" title="网络包的形态变化"></a>网络包的形态变化</h3><ol>
<li>网络包前加上MAC头部、PPPoE头部、PPP头部总共3种头部，，然后发送给ADSL Modem（PPPoE方式下）</li>
<li>ADSL Modem接收到包后，拆包成很多小信元。信元是非常小的数据块 ，开头是有5个字节的头部，后面是48个字节的数据，用于一种ATM的通信技术。<code>ATM</code>：Asynchronous Transfer Mode异步传输</li>
<li>ADSL Modem采用正弦波对信号进行合成来表示0和1的技术，这种技术叫做<code>调制</code>，调制有<code>振幅调制ASK</code>和<code>相位调制PSK</code>相结合而成的<code>正交调幅</code>方式</li>
<li>ASK：用信号强弱，即振幅的大小对应0和1。也可以增加振幅到4个级别，从小到大表示00、01、10、11。但振幅级别太多，易出现衰减、噪声影响失真等问题，所以级别不能太多</li>
<li>PSK：根据相位来对应0和1，从0度开始的波为0，从180度开始的波是1，也可以将角度细分，但角度太接近容易造成误判，所以以此来提升速率效果有限</li>
<li>ASK和PSK的结合可以大幅度提高表示的比特数（4级*4级&#x3D;16级）</li>
<li>以上是一个频率的波，实际上可以多个频率的波进行合成，也可以使用滤波器从合成波中国呢分离出特定的波，所以合成波可以大大提升传输效率</li>
<li>ADSL使用间隔为4.3125kHz的上百个不同频率的波进行合成，每个波都采用正交调幅。而且，噪声小的频段可以给波分配更多的比特</li>
<li>上下行频段不同，下行使用频段较高信号易衰减，上行使用26个频段，下行则可以使用95个或223个频段，波的数量不同，导致上下行速率不同。</li>
<li>分离器的作用。信号从电话线传入时，负责将电话和ADSL的信号进行分离，以确保ADSL信号不会进入电话机。另一个作用是防止电话对ADSL产生干扰，如果没有分离器，那么在ADSL通信同时接听电话，会造成几十秒的通信中断</li>
<li>信号通过电话线到达电话局之后，会经过配线盘、分离器到达DSLAM。DSLAM通过读波形，根据振幅和相位判断对应的比特值，将信号还原成数字 信息——信元。因为按照太多Modem占用大量空间以及监控的困难，所以电话局使用DSLAM设备，相当于多个ADSL Modem的集中设备。DSLAM相比ADSL Modem不具备以太网接口，只有ATM接口</li>
<li>信元从DSLAM出来后，到达一个叫做BAS的包转发设备，BAS也有ATM接口，BAS将收到的包前面的MAC头部和PPPoE头部丢弃，取出PPP头部及后面的数据，再加上隧道专用头部，并发送到隧道的出口</li>
<li>然后网络包到达隧道出口的隧道专用路由器，隧道头部会被丢弃，IP包被取出，并被转发到互联网的内部</li>
</ol>
<h2 id="光纤接入网（FTTH）的工作方式"><a href="#光纤接入网（FTTH）的工作方式" class="headerlink" title="光纤接入网（FTTH）的工作方式"></a>光纤接入网（FTTH）的工作方式</h2><ul>
<li>光信号亮表示1，暗表示0。发送端：数字信息被转换成电压和电流并输入到LED、激光二极管等光源，进而发出明暗不同的光。接收端：光电二极管可以感光，并根据光的明暗产生相应的电压和电流，这些电信号会被还原成数字信号</li>
<li>纤芯的直径对光的传导影响很大，并且只有入射角较小的光线会被包层全反射，从而在纤芯中前进</li>
<li>光在光纤中反射时，会发生相位的变化，不同相位的光可能会被干涉抵消。只有几个特定的角度下，反射回来的光与原光相位保持一致，这样的光才能保证传输。纤芯直径也是根据这个角度来确定的</li>
<li>单模光纤（8～10um），多模光纤（50～62.5um）。多模光纤可允许较大入射角的光，可选角度更多一些</li>
<li>单模光纤：只能传导一条光线，对光源和光敏元件性能要求高，反射次数少，但走的距离短，信号失真小</li>
<li>上行信号和下行信号采用不同波长的光，波长不同的光混合后可通过棱镜原理进行分离，这种方式也被称为“波分复用”</li>
<li>FTTH具有直连和分路两种方式，这两种方式只是光信号的传输方式有一些区别，实际传输的网络包是相同的</li>
</ul>
<h2 id="PPP拨号上网的工作方式"><a href="#PPP拨号上网的工作方式" class="headerlink" title="PPP拨号上网的工作方式"></a>PPP拨号上网的工作方式</h2><h3 id="使用电话线或ISDN拨号上网时"><a href="#使用电话线或ISDN拨号上网时" class="headerlink" title="使用电话线或ISDN拨号上网时"></a>使用电话线或ISDN拨号上网时</h3><ol>
<li>用户向运营商的接入点拨打电话，电话接通后输入user和password进行登录操作；</li>
<li>user和password通过RADIUS协议从RAS发送到认证服务器，认证服务器校验这些信息是否正确</li>
<li>确认无误后，认证服务器会返回IP地址等配置信息，并将这些信息下发给用户</li>
<li>用户的计算机根据这些信息配置IP地址等参数，完成TCP&#x2F;IP收发网络包的准备工作</li>
<li>完成了准备工作后，就可以发送TCP&#x2F;IP包了</li>
</ol>
<p>tips：以上步骤中，重点在2、3两步</p>
<blockquote>
<p>“在接入互联网时，必须为计算机分配一个公有地址，但这个地址并不是事先确定的。因为在拨号连接时，可以根据电话号码来改变接入点，而不同的接入点具有不同的 IP 地址，因此无法事先在计算机上设置这个地址。所以，在连接时运营商会向计算机下发 TCP&#x2F;IP 配置信息，其中就包括为计算机分配的公有地址。”<br>Excerpt From: ［日］ 户根勤. “网络是怎样连接的.” </p>
</blockquote>
<p>已完成全书501页  </p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>Pictures play in turn</title>
    <url>/2018/07/06/Pictures-play-in-turn/</url>
    <content><![CDATA[<h1 id="图片轮播效果"><a href="#图片轮播效果" class="headerlink" title="图片轮播效果"></a>图片轮播效果</h1><h3 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h3><p><img src="/2018/07/06/Pictures-play-in-turn/1.png" alt="1"></p>
<h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><ol>
<li>三张背景图片采用的一张出现一张消失，还有上下替换或左右替换的方式，本次未采用</li>
<li>背景图片采用2秒一次自动循环轮播</li>
<li>图片两侧采用“上一页”和“下一页”的切换按钮</li>
<li>图片右下角采用圆点定位</li>
</ol>
<h2 id="HTML和CSS部分"><a href="#HTML和CSS部分" class="headerlink" title="HTML和CSS部分"></a>HTML和CSS部分</h2><ol>
<li><p>   将三张图片重叠放置，banner-slide绝对定位，banner相对定位</p>
</li>
<li><p>使用slide-active并设置display实现隐&#x2F;现</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner&quot;</span> <span class="attr">id</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide1 slide-active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--css--&gt;</span></span><br><span class="line">.banner&#123;</span><br><span class="line">	width: 1200px;</span><br><span class="line">	height:460px;</span><br><span class="line">	position: relative;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.banner-slide&#123;</span><br><span class="line">	width: 1200px;</span><br><span class="line">	height:460px;</span><br><span class="line">	position: absolute;</span><br><span class="line">	background-repeat: no-repeat;	</span><br><span class="line">	display: none;</span><br><span class="line">&#125;</span><br><span class="line">.slide-active&#123;</span><br><span class="line">	display: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<hr>
<ol>
<li><p>将箭头设置a标签，可以实现hover变色效果</p>
</li>
<li><p>圆点设计class&#x3D;‘active’，实现原点定位</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--html--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 箭头按钮 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button prev&quot;</span> <span class="attr">id</span>=<span class="string">&quot;prev&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button next&quot;</span> <span class="attr">id</span>=<span class="string">&quot;next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 切换圆点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dots&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dots&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--css--&gt;</span></span><br><span class="line">.button&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	width: 40px;</span><br><span class="line">	height: 80px; </span><br><span class="line">	left:244px;</span><br><span class="line">	top:50%;</span><br><span class="line">	margin-top: -40px;</span><br><span class="line">	background:url(../img/arrow.png) no-repeat center center ;</span><br><span class="line">&#125;</span><br><span class="line">.button:hover&#123;</span><br><span class="line">	background-color: #333;</span><br><span class="line">	opacity: 0.5;</span><br><span class="line">	filter:alpha(opacity=50);</span><br><span class="line">&#125;</span><br><span class="line">.prev&#123;</span><br><span class="line">	transform: rotate(180deg);</span><br><span class="line">&#125;</span><br><span class="line">.next&#123;</span><br><span class="line">	left:auto;</span><br><span class="line">	right:0 ;</span><br><span class="line">&#125;</span><br><span class="line">.dots&#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	right: 15px;</span><br><span class="line">	bottom: 24px;</span><br><span class="line">	text-align: right;</span><br><span class="line">&#125;</span><br><span class="line">.dots span&#123;</span><br><span class="line">	display: inline-block;</span><br><span class="line">	width: 12px;</span><br><span class="line">	height: 12px;</span><br><span class="line">	line-height: 12px;</span><br><span class="line">	border-radius: 50%;</span><br><span class="line">	background: rgba(7,17,27,0.4);</span><br><span class="line">	box-shadow: 0 0 0 2px rgba(255,255,255,0.8) inset;</span><br><span class="line">	margin-right: 8px;</span><br><span class="line">	cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">.dots span.active&#123;</span><br><span class="line">	box-shadow: 0 0 0 2px rgba(7,17,27,0.4) inset;	</span><br><span class="line">	background: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="CSS部分"><a href="#CSS部分" class="headerlink" title="CSS部分"></a>CSS部分</h2><ol>
<li><p>封装<code>document.getElementById()</code>方法</p>
 <figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> byId(<span class="built_in">id</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">typeof</span>(<span class="built_in">id</span>)<span class="operator">===</span><span class="string">&quot;string&quot;</span><span class="operator">?</span>document.getElementById(<span class="built_in">id</span>)<span class="operator">:</span><span class="built_in">id</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>js文件自动运行滑过图片slideImage()方法，执行slideImage时会自动触发图片轮播</p>
</li>
<li><p>从标签中获得<code>main</code>类，鼠标滑入或滑出时触发事件</p>
 <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">slideImage</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> main = byId(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="comment">//滑过清除定时器，离开继续</span></span><br><span class="line">  main.onmouseover = <span class="keyword">function</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//清除定时器</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  main.onmouseout=<span class="keyword">function</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//继续定时器</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//自动触发图片轮播</span></span><br><span class="line">  main.onmouseout();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">slideImage();	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>全局变量index监控要显示图片的编号</p>
</li>
<li><p>切换时index++</p>
</li>
<li><p>timer做计时器</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var index=<span class="number">0</span>,</span><br><span class="line">    timer=null,</span><br><span class="line">    pics = by<span class="constructor">Id(<span class="string">&quot;banner&quot;</span>)</span>.get<span class="constructor">ElementsByTagName(<span class="string">&quot;div&quot;</span>)</span>,</span><br><span class="line">    dots=by<span class="constructor">Id(<span class="string">&quot;dots&quot;</span>)</span>.get<span class="constructor">ElementsByTagName(<span class="string">&quot;span&quot;</span>)</span>,</span><br><span class="line">    prev=by<span class="constructor">Id(<span class="string">&quot;prev&quot;</span>)</span>;</span><br><span class="line">    next=by<span class="constructor">Id(<span class="string">&quot;next&quot;</span>)</span>;</span><br><span class="line">    len=pics.length;<span class="operator"></span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="operator"></span></span><br><span class="line"><span class="operator"></span><span class="keyword">function</span> slide<span class="constructor">Image()</span>&#123;</span><br><span class="line">    var main = by<span class="constructor">Id(<span class="string">&quot;main&quot;</span>)</span>;</span><br><span class="line">		<span class="comment">//滑过清除定时器，离开继续</span></span><br><span class="line">		main.onmouseover = <span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">		<span class="comment">//清除定时器</span></span><br><span class="line">		<span class="keyword">if</span>(timer) clear<span class="constructor">Interval(<span class="params">timer</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	main.onmouseout=<span class="keyword">function</span><span class="literal">()</span>&#123;</span><br><span class="line">	<span class="comment">//继续定时器</span></span><br><span class="line">	timer = set<span class="constructor">Interval(<span class="params">function</span>()</span>&#123;</span><br><span class="line">	  index++;</span><br><span class="line">	  <span class="comment">// console.log(index); </span></span><br><span class="line">	  <span class="keyword">if</span>(index&gt;=len)</span><br><span class="line">	    index=<span class="number">0</span>;</span><br><span class="line">	  <span class="comment">//切换图片</span></span><br><span class="line">	  change<span class="constructor">Img()</span>;</span><br><span class="line">	&#125;,<span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作上一张或下一张按钮，就是对index进行操作</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--slideImage()方法中--&gt;</span></span><br><span class="line">//点击上一张下一张按钮</span><br><span class="line">next.onclick=function()&#123;</span><br><span class="line">	index++;</span><br><span class="line">	if(index&gt;=len)</span><br><span class="line">	  index=0;</span><br><span class="line">	changeImg();</span><br><span class="line">&#125;</span><br><span class="line">prev.onclick = function()&#123;</span><br><span class="line">	index--;</span><br><span class="line">	if(index&lt;0)</span><br><span class="line">	  index=len-1;</span><br><span class="line">	changeImg();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换前，将banner.div的所有class设置为‘none’，均不显示</p>
</li>
<li><p>将所有圆点class设置为‘’</p>
</li>
<li><p>根据index，找到当前div，将banner.div和dots显示</p>
 <figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//切换图片</span></span><br><span class="line">function changeImg()&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">    pics[i].style.<span class="keyword">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    dots[i].className=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据index索引，找到当前div，将其显示出来</span></span><br><span class="line">  pics[<span class="keyword">index</span>].style.<span class="keyword">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">  dots[<span class="keyword">index</span>].className = <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="本项目所有源码"><a href="#本项目所有源码" class="headerlink" title="本项目所有源码"></a>本项目所有源码</h2><pre><code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--index.html--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>综合实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 图片轮播 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner&quot;</span> <span class="attr">id</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide1 slide-active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;banner-slide slide3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 箭头按钮 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button prev&quot;</span> <span class="attr">id</span>=<span class="string">&quot;prev&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">class</span>=<span class="string">&quot;button next&quot;</span> <span class="attr">id</span>=<span class="string">&quot;next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 切换圆点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dots&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dots&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="attr">--style</span><span class="selector-class">.css--</span>&gt;</span><br><span class="line">*&#123;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">	<span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">	<span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>;</span><br><span class="line">	<span class="attribute">color</span>: <span class="number">#14191e</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">460px</span>;</span><br><span class="line">	<span class="attribute">margin</span>:<span class="number">30px</span> auto;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">460px</span>;</span><br><span class="line">	<span class="attribute">position</span>: relative;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.banner-slide</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">1200px</span>;</span><br><span class="line">	<span class="attribute">height</span>:<span class="number">460px</span>;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">background-repeat</span>: no-repeat;	</span><br><span class="line">	<span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide-active</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide1</span>&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/bg1.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide2</span>&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/bg2.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.slide3</span>&#123;</span><br><span class="line">	<span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&quot;../img/bg3.jpg&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">80px</span>; </span><br><span class="line">	<span class="attribute">left</span>:<span class="number">244px</span>;</span><br><span class="line">	<span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">	<span class="attribute">background</span>:<span class="built_in">url</span>(<span class="string">../img/arrow.png</span>) no-repeat center center ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">	<span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">	<span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">	<span class="attribute">filter</span>:<span class="built_in">alpha</span>(opacity=<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.prev</span>&#123;</span><br><span class="line">	<span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">180deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span>&#123;</span><br><span class="line">	<span class="attribute">left</span>:auto;</span><br><span class="line">	<span class="attribute">right</span>:<span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dots</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">	<span class="attribute">right</span>: <span class="number">15px</span>;</span><br><span class="line">	<span class="attribute">bottom</span>: <span class="number">24px</span>;</span><br><span class="line">	<span class="attribute">text-align</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dots</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-block;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">12px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">12px</span>;</span><br><span class="line">	<span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">0.4</span>);</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.8</span>) inset;</span><br><span class="line">	<span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line">	<span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.dots</span> <span class="selector-tag">span</span><span class="selector-class">.active</span>&#123;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2px</span> <span class="built_in">rgba</span>(<span class="number">7</span>,<span class="number">17</span>,<span class="number">27</span>,<span class="number">0.4</span>) inset;	</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!--script.<span class="property">js</span>--&gt;</span><br><span class="line"><span class="comment">// 封装document.getElementById</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">byId</span>(<span class="params">id</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">typeof</span>(id)===<span class="string">&quot;string&quot;</span>?<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id):id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index=<span class="number">0</span>,</span><br><span class="line">    timer=<span class="literal">null</span>,</span><br><span class="line">    pics = <span class="title function_">byId</span>(<span class="string">&quot;banner&quot;</span>).<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>),</span><br><span class="line">    dots=<span class="title function_">byId</span>(<span class="string">&quot;dots&quot;</span>).<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;span&quot;</span>),</span><br><span class="line">    prev=<span class="title function_">byId</span>(<span class="string">&quot;prev&quot;</span>);</span><br><span class="line">    next=<span class="title function_">byId</span>(<span class="string">&quot;next&quot;</span>);</span><br><span class="line">    len=pics.<span class="property">length</span>;</span><br><span class="line">    <span class="comment">// console.log(len);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">slideImage</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> main = <span class="title function_">byId</span>(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">  <span class="comment">//滑过清除定时器，离开继续</span></span><br><span class="line">  main.<span class="property">onmouseover</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//清除定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">  &#125;</span><br><span class="line">  main.<span class="property">onmouseout</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//继续定时器</span></span><br><span class="line">    timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      index++;</span><br><span class="line">      <span class="comment">// console.log(index); </span></span><br><span class="line">      <span class="keyword">if</span>(index&gt;=len)</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">      <span class="title function_">changeImg</span>();</span><br><span class="line">    &#125;,<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//自动触发图片轮播</span></span><br><span class="line">  main.<span class="title function_">onmouseout</span>();</span><br><span class="line">  <span class="comment">//点击原点切换图片</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> d=<span class="number">0</span>;d&lt;len;++d)&#123;</span><br><span class="line">    <span class="comment">//给所有span添加一个id的属性，值为当前span的索引</span></span><br><span class="line">    dots[d].<span class="property">id</span> = d;</span><br><span class="line">    dots[d].<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">//改变 index为当前span的索引</span></span><br><span class="line">      index = <span class="variable language_">this</span>.<span class="property">id</span>;</span><br><span class="line">      <span class="title function_">changeImg</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//点击上一张下一张按钮</span></span><br><span class="line">  next.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span>(index&gt;=len)</span><br><span class="line">      index=<span class="number">0</span>;</span><br><span class="line">    <span class="title function_">changeImg</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  prev.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    index--;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;<span class="number">0</span>)</span><br><span class="line">      index=len-<span class="number">1</span>;</span><br><span class="line">    <span class="title function_">changeImg</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换图片</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeImg</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">    pics[i].<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    dots[i].<span class="property">className</span>=<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据index索引，找到当前div，将其显示出来</span></span><br><span class="line">  pics[index].<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;block&#x27;</span>;</span><br><span class="line">  dots[index].<span class="property">className</span> = <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">slideImage</span>();</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title> Presto &amp; Alluxio综述</title>
    <url>/2021/03/13/Presto-Alluxio%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>本文为 <strong>presto &amp; Alluxio &amp; 缓存白名单策略</strong>的技术综述，摘录自各处最佳实践。</p>
<p>链接：<a href="https://www.infoq.cn/article/ryyocgqgr4voq5jjeemt">Alluxio 应用实践- 贝壳找房</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/55939711">基于Alluxio与HDFS支撑Presto和TPC-DS查询场景的性能测试</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/51638076">基于Presto+Alluxio的adhoc查询方案在网易游戏的实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/201518612">唯品会实践案例：基于Alluxio优化电商平台热点数据访问性能</a></p>
<span id="more"></span>



<p><a href="https://zhuanlan.zhihu.com/p/100070360">网易严选：基于Alluxio+Impala深度融合架构的BI系统性能优化实践</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/80066121">探秘Presto+Alluxio高效云端SQL查询</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/57873784">百度案例：使用Alluxio提速数据查询30倍</a></p>
<p><a href="https://blog.csdn.net/DolphinScheduler/article/details/109882480">Presto在滴滴的探索与实践</a></p>
<p><a href="https://blog.csdn.net/wypblog/article/details/111399181">Presto在车好多的实践</a></p>
<p>别的文章：</p>
<p><a href="https://blog.csdn.net/DolphinScheduler/article/details/112386876">即席查询（Ad Hoc）如何做到又快又稳？</a></p>
<p> <a href="https://my.oschina.net/dataclub/blog/4983931">网易云音乐数仓建模案例—声波APP</a></p>
<p><a href="http://www.databanker.cn/project/77058.html">大数据展现——即席查询</a></p>
<p><a href="https://www.sohu.com/a/284946736_99916561">教育大数据智能分析平台研究与实践</a>  架构图有趣，文字价值一般</p>
<h2 id="贝壳找房"><a href="#贝壳找房" class="headerlink" title="贝壳找房"></a>贝壳找房</h2><h3 id="为什么使用-Alluxio"><a href="#为什么使用-Alluxio" class="headerlink" title="为什么使用 Alluxio"></a>为什么使用 Alluxio</h3><p>QueryEngine 底层目前使用三种查询引擎：MR、Tez 和 Spark SQL，根据用户的选择及查询的代价来智能的选择执行引擎。为了降低对 Spark SQL 的影响，Spark SQL 引擎使用的是独有的 Yarn 集群。原始架构有如下问题：</p>
<p>1）数据量大，而且请求量变大，查询性能变差；</p>
<p>2）Spark SQL 计算与存储分离，每次查询都需要远程加载数据，数据本地行查，性能差；</p>
<p>3）目前的分析基本都是 T+1 的数据，数据基本不变，每次查询都要远程拉取数据，对大数据存储集群和网络 IO 压力很大；</p>
<p>4）对相同的数据会有多次的访问查询。</p>
<p>基于上面 Alluxio 的特性分析，alluxio 非常适合我们的业务场景，可以用于加速 QueryEngine 的查询分析。</p>
<h3 id="缓存白名单做法"><a href="#缓存白名单做法" class="headerlink" title="缓存白名单做法"></a>缓存白名单做法</h3><p>考虑到成本问题，SSD 的存储有限，而 adhoc 查询的数据量却非常庞大，高达数百 TB。因此我们基于过去 30 天内的 adhoc 查询记录，分析出表的访问频率和分区范围以及表的大小等三个维度的信息，只对中小表、高频访问的热表以及每个表的高频分区进行 Alluxio 缓存加速，针对进入 Spark SQL 的非白名单查询，则访问 HDFS 中的数据。</p>
<p>针对 Spark SQL 的查询，我们使用的是 Spark ThriftServer。<strong>为了使进入白名单的数据查询 Alluxio 中的数据，而不是 HDFS 中的数据，我们修改了 HiveMetaStore 的相关源码，使数据地址指向 alluxio 中的数据地址，而非 HDFS 中数据的地址</strong>。这样进入白名单表的查询，使用修改源码的 HiveMetaStore，而非白名单表的查询使用原始的 HiveMetaStore，从 HDFS 读取数据。</p>
<p>考虑到 Alluxio 冷读较直接访问 HDFS 有性能损失，因此我们每天都会定期提前加载新白名单中的数据，缓存到 Alluxio 中，并且淘汰旧的不需要的分区中的数据。</p>
<h2 id="基于Alluxio与HDFS支撑Presto和TPC-DS查询场景的性能测试"><a href="#基于Alluxio与HDFS支撑Presto和TPC-DS查询场景的性能测试" class="headerlink" title="基于Alluxio与HDFS支撑Presto和TPC-DS查询场景的性能测试"></a>基于Alluxio与HDFS支撑Presto和TPC-DS查询场景的性能测试</h2><h3 id="为什么要引入-Alluxio"><a href="#为什么要引入-Alluxio" class="headerlink" title="为什么要引入 Alluxio"></a>为什么要引入 Alluxio</h3><ol>
<li>通过监控发现计算节点的物理内存有富余，不需要增加额外机器成本</li>
<li>机器网卡较为空闲，瓶颈主要存在于磁盘IO</li>
<li>HDFS所在磁盘存在多种不同类型负载，数据读取速度不稳定</li>
<li>热数据读取加速</li>
<li>存储计算分离，在计算节点提高数据本地性</li>
<li>统一命名空间，虚拟数据湖</li>
</ol>
<h3 id="场景依赖"><a href="#场景依赖" class="headerlink" title="场景依赖"></a>场景依赖</h3><p>Alluxio 的落地非常依赖场景，否则优化效果并不明显（无法发挥内存读取的优势）。</p>
<ol>
<li>存储计算分离</li>
<li>有明显热表&#x2F;热数据</li>
<li>多数据中心访问加速</li>
<li>相同数据被单应用多次访问</li>
<li>数据并发访问</li>
</ol>
<h2 id="基于Presto-Alluxio的adhoc查询方案在网易游戏的实践"><a href="#基于Presto-Alluxio的adhoc查询方案在网易游戏的实践" class="headerlink" title="基于Presto+Alluxio的adhoc查询方案在网易游戏的实践"></a>基于Presto+Alluxio的adhoc查询方案在网易游戏的实践</h2><p>数据分析人员通常会经两种途径来访问这些海量的原始或表格数据:</p>
<ol>
<li><p>常规的业务指标会经由成熟的报表系统落到到数仓存储系统；</p>
</li>
<li><p>除此外还存在着另外一种类型的adhoc(即席)报表查询需求，其业务特点为:</p>
</li>
</ol>
<blockquote>
<ol>
<li>查询条件灵活，无法事先确定查询的表名和SQL语法</li>
<li>查询的数据量相比于离线ETL一般比较少</li>
<li>能够提供查询过程的进度百分比(经过与业务同学的沟通，发现对这个的需求出奇的高)</li>
<li>查询实效性要求高，以满足业务人员数据探索的需求。根据数据量的不同，查询平均时延要求在2-15s左右</li>
</ol>
</blockquote>
<h3 id="SparkSQL的-adhoc-缺点"><a href="#SparkSQL的-adhoc-缺点" class="headerlink" title="SparkSQL的 adhoc 缺点"></a>SparkSQL的 adhoc 缺点</h3><ol>
<li><p>SparkSQL在进行查询的时候，一般都需要先向YARN申请一定量的资源，在集群比较繁忙的时候，申请资源的时间往往都是秒到分钟级别，会极大程度影响查询速度;</p>
</li>
<li><p>SparkSQL存在大量的HDFS IO: 源数据在HDFS上;另外，SparkSQL的默认的shuffle配置会导致超过executor内存大小的中间数据落到HDFS IO。但是从我们线上环境来看，datanode的磁盘IO延迟和吞吐极不稳定—特别是在离线作业高峰期的时候更加明显—导致查询的性能存在比较严重的波动。</p>
</li>
</ol>
<h2 id="唯品会实践案例：基于Alluxio优化电商平台热点数据访问性能"><a href="#唯品会实践案例：基于Alluxio优化电商平台热点数据访问性能" class="headerlink" title="唯品会实践案例：基于Alluxio优化电商平台热点数据访问性能"></a>唯品会实践案例：基于Alluxio优化电商平台热点数据访问性能</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在互联网电商平台上，广告是提升成交总额（GrossMerchandise Volume）和拉取新客的常见途经。在广告系统或广告运营中都需要<strong>基于人群数据分析进行定向的用户广告投放</strong>。在第三方平台进行广告投放，同样需要使用人群数据分析计算。根据计算分析方的不同，可以分为两类，第一类是基础数据全部发送给第三方广告平台，如抖音，腾讯等，由第三方在投放人群时候进行人群计算并作选择；第二类是<strong>人群计算工作在电商平台内部完成</strong>，推送给第三方的只是单个的人群包数据（设备数据）。在唯品会，我们目前采用第二类方式进行人群计算投放。我们<strong>每天需要完成数万的人群包计算，这些计算都是基于几张位于HDFS的之上的Hive表完成，这些表每天通常都行需要被访问上万次</strong>。</p>
<p>引申：人群包一般是怎么计算的？</p>
<blockquote>
<p>人群包就是将用户进行分类。一般根据用户的设备号、手机号等，将用户分为几个类别，当然类别之间可以重复。例如常用的人群包种类包括：电商人群包、学生人群包、美容人群包等等。广告主可以选某种人群进行定向投放。</p>
<p>一般就是聚类算法，他们通过聚类算法等分析这批样本客户在自己媒体中的行为数据及注册数据，比如爱看什么视频啦、什么时间上网啦等等之类的。不断优化算法并对样本客户进行训练，看看自己的算法和购买来的特征数据差异有多大，如此一直优化到准确率可接受为止。当算法准确率到达可接受程度了，就可以让算法发挥作用了，在广告投放过程中使用这套算法猜测访问者的特征，然后对符合特征的访问者投放指定的广告。</p>
</blockquote>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在集群相对稳定的情况下，一个人群计算任务的执行时间约3分钟。在集群不稳定的情况下，执行时间的变化会比较大，具体部分运行时间如下图2所示。在这种情况下，计算任务的资源消耗比正常情况大很多，大约能达到30&#x2F;3&#x3D;10倍左右，同时人群计算也难以达到业务时间要求(20:00前运行完成)。我们将运行不稳定的原因总结为以下几个方面：</p>
<ul>
<li>人群计算任务的数据本地性不好。</li>
<li>在单个节点计算热点数据，交换机80G上下行带宽也常常打满（DN节点双万兆网络）。</li>
<li>HDFS读写本身存在长尾现象。</li>
</ul>
<h3 id="新的目标"><a href="#新的目标" class="headerlink" title="新的目标"></a>新的目标</h3><p>为了更好地满足热点数据的计算需求，我们需要取得较好的数据本地性。因此，我们希望能够达到以下目标：</p>
<ol>
<li><p>计算与存储同置，这样数据就不需通过网络反复读取，造成网络流量浪费。</p>
</li>
<li><p>减少HDFS读写长尾对人群计算造成的额外影响，同时减少人群计算对于HDFS稳定性的影响。</p>
</li>
<li><p>广告人群计算介于线上生产任务跟离线任务之间的任务类型。这里我们希望能保证这类应用的可靠性和稳定性，从而更好地为公司业务赋能。</p>
</li>
</ol>
<h3 id="结果评价"><a href="#结果评价" class="headerlink" title="结果评价"></a>结果评价</h3><p>基于Alluxio的新架构解决了HDFS热点数据的读取问题，从而使得广告人群计算这类准生产应用也能得以保障，实现了技术赋能业务。另外，计算效率的提升也对带来了可观的资源的节约，额外支撑的硬件只是少量SSD盘。</p>
<h2 id="网易严选：基于Alluxio-Impala深度融合架构的BI系统性能优化实践"><a href="#网易严选：基于Alluxio-Impala深度融合架构的BI系统性能优化实践" class="headerlink" title="网易严选：基于Alluxio+Impala深度融合架构的BI系统性能优化实践"></a>网易严选：基于Alluxio+Impala深度融合架构的BI系统性能优化实践</h2><h3 id="Alluxio在网易严选BI场景的挑战分析"><a href="#Alluxio在网易严选BI场景的挑战分析" class="headerlink" title="Alluxio在网易严选BI场景的挑战分析"></a>Alluxio在网易严选BI场景的挑战分析</h3><p>Alluxio的部署和使用方式非常简单，然而在大规模数据的BI场景中不经调优地直接使用Alluxio，性能结果与预想的存在一定差距。具体原因分析如下：</p>
<ol>
<li>Alluxio并不像我们最初设想的那样，只是一个单纯的缓存服务。Alluxio首先是一个分布式的虚拟文件系统，有完整的元数据管理、块数据管理、UFS管理（底层文件系统的简称）以及健康检查机制，尤其是它的元数据管理实现比很多底层文件系统更加强大。这些功能是Alluxio的优点和特色，但也意味着<strong>如果每次都完整地使用Alluxio的全部功能</strong>，完成整个读操作的<strong>链路额外开销</strong>要比从一个单纯的代理服务、或支持自动Load的缓存服务要高。</li>
<li><strong>对于大数据场景，内存缓存容量相对于计算引擎需要读取的数据量之间的比例常常是很低的。</strong>以严选为例，计算引擎每天需要读取的数据量在30TB左右，对比之下我们提供的1TB内存盘就显得捉襟见肘。低缓存量会导致低命中率和频繁逐出（Cache Eviction）开销，此时无论使用LRU、LRFU还是其他缓存策略，都无法带来明显改善。</li>
</ol>
<p>在使用Alluxio之前，网易有数系统已经使用Redis开发了内部的图表缓存功能（即下图中的一级缓存），用于<strong>主动缓存相对稳定或相对重要的图表数据</strong>。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li>由于我们的场景下缓存空间&#x2F;数据量比例很小且数据的热度普遍不高，因此直接使用LRU等缓存策略的效果和性能不理想。我们的解决思路是将需要缓存的数据量减少，高效利用缓存，具体方式是只缓存最有“缓存价值”的数据。<ul>
<li>数据块的缓存价值&#x3D;节省的IO时间<br>&#x3D;(数据块大小 &#x2F; 平均IO速度+读取数据块的额外时间开销)*数据块的读取次数</li>
<li>分区&#x2F;表的缓存价值 &#x3D; 该分区&#x2F;表中所有数据块的缓存价值之和</li>
</ul>
</li>
<li>设计实现了<strong>缓存价值分析程序</strong>，根据每天的数据请求记录<strong>计算出被访问到的表或分区的缓存价值</strong>，然后按照缓存价值大小取其中排名靠前的表或分区加入缓存白名单，不在白名单中的数据将不使用Alluxio进行缓存。我们会将缓存空间&#x2F;数据量比例控制在30%-70%的区间，然后结合使用LRFU策略就可以得到较好的缓存命中率和性能提升。</li>
<li>对于不在缓存白名单中的数据（较低缓存价值的数据），我们会使用Impala的数据路由功能，跳过Alluxio直连HDFS，从而避免从Alluxio读带来的开销。</li>
</ol>
<h2 id="探秘Presto-Alluxio高效云端SQL查询"><a href="#探秘Presto-Alluxio高效云端SQL查询" class="headerlink" title="探秘Presto+Alluxio高效云端SQL查询"></a>探秘Presto+Alluxio高效云端SQL查询</h2><p>当Alluxio的数据编排层和Presto一起部署时，可以优化整体的数据栈，使得数据栈在每个工作节点上具有更紧密的数据本地性。首先，用户可以使用Alluxio来对Presto缓存数据。这意味着计算驱动着数据需要从底层数据竖井和存储系统中取出。<strong>数据根据查询行为存储到缓冲区中，而查询行为又意味着最终用户行为，而最终用户行为又意味着最热的数据</strong>。I&#x2F;O的操作从底层的慢速存储系统交给了Alluxio中一个非常快的数据访问层来进行。</p>
<h2 id="百度案例：使用Alluxio提速数据查询30倍"><a href="#百度案例：使用Alluxio提速数据查询30倍" class="headerlink" title="百度案例：使用Alluxio提速数据查询30倍"></a>百度案例：使用Alluxio提速数据查询30倍</h2><p>使用Alluxio<strong>将原先的批处理查询将转换为交互式查询</strong>，这使百度能够以交互方式分析数据，从而提升了生产力，并改善了用户体验。</p>
<h3 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h3><p>由于PB级别的数据分布在多个数据中心，因此数据查询很可能需要将数据从远程数据中心传输到计算所在数据中心，这就是导致用户运行查询时出现很大延迟的原因。由于数据存储中心节点和数据计算中心节点具有不同的最优硬件规格，因此解决方案并不是将计算过程移动到存储数据中心那么简单。我们需要一个内存级的存储系统来存储常用的“热”数据，并且该系统能够位于计算节点上。</p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>我们的系统包含以下组件：</p>
<ul>
<li>操作管理器：包装Spark SQL的持久化Spark应用程序。它接受来自查询UI的查询，并提供查询解析和查询优化功能。</li>
<li>视图管理器：管理缓存元数据并处理来自操作管理器的查询请求。</li>
<li>Alluxio：用作存储常用数据内存级存储系统，提供计算本地性。</li>
<li>数据仓库：基于HDFS系统的远程数据中心，用于存储数据。</li>
</ul>
<h2 id="Presto在滴滴的探索与实践"><a href="#Presto在滴滴的探索与实践" class="headerlink" title="Presto在滴滴的探索与实践"></a>Presto在滴滴的探索与实践</h2><p>presto 在滴滴的业务场景：</p>
<p><strong>业务场景</strong></p>
<ul>
<li>Hive SQL查询加速</li>
<li>数据平台Ad-Hoc查询</li>
<li>报表（BI报表、自定义报表）</li>
<li>活动营销</li>
<li>数据质量检测</li>
<li>资产管理</li>
<li>固定数据产品</li>
</ul>
<p>使用 Presto + HDFS 有一些痛点：</p>
<ul>
<li>latency高，QPS较低 </li>
<li>不能查实时数据，如果有实时数据需求，需要再构建一条实时数据链路，增加了系统的复杂性</li>
<li>要想获得极限性能，必须与HDFS DataNode 混部，且DataNode使用高级硬件，有自建HDFS的需求，增加了运维的负担</li>
</ul>
<p><strong>特性增强</strong></p>
<ul>
<li><p>insert数据时，将插入数据的总行数写入HMS，为业务方提供毫秒级的元数据感知能力</p>
</li>
<li><p>支持查询进度滚动更新，提升了用户体验</p>
</li>
<li><p><strong>支持查询可以指定优先级，为用户不同等级的业务提供了优先级控制的能力</strong></p>
</li>
<li><p>修改通信协议，支持业务方可以传达自定义信息，满足了用户的日志审计需要等</p>
</li>
<li><p>支持DeprecatedLzoTextInputFormat格式</p>
</li>
<li><p>支持读HDFS Parquet文件路径</p>
</li>
</ul>
<p><strong>稳定性建设</strong>：Presto在使用过程中会遇到很多稳定性问题，比如Coordinator OOM，Worker Full GC等，为了解决和方便定位这些问题，首先我们做了监控体系建设，主要包括：</p>
<ul>
<li><strong>通过Presto Plugin实现日志审计功能</strong></li>
<li>通过JMX获取引擎指标将监控信息写入Ganglia</li>
<li>将日志审计采集到HDFS和ES；统一接入运维监控体系，将所有指标发到 Kafka；</li>
<li>Presto UI改进：可以查看Worker信息，可以查看Worker死活信息</li>
</ul>
<p><strong>引擎优化及调研</strong>：作为一个Ad-Hoc引擎，Presto查询性能越快，用户体验越好，为了提高Presto的查询性能，在Presto on Hive场景，我们做了很多引擎优化工作，主要工作：</p>
<ul>
<li>某业务集群进行了JVM调优，将Ref Proc由单线程改为并行执行，普通查询由30S~1分钟降低为3-4S，性能提升10倍+</li>
<li>ORC数据优化，<strong>将指定string字段添加了布隆过滤器，查询性能提升20-30%，针对一些业务做了调优</strong></li>
<li>数据治理和小文件合并，某业务方查询性能由20S降低为10S，性能提升一倍，且查询性能稳定</li>
<li>ORC格式性能优化，查询耗时减少5%</li>
<li>分区裁剪优化，解决指定分区但获取所有分区元信息问题，减少了HMS的压力</li>
<li>下推优化，实现了Limit、Filter、Project、Agg下推到存储层</li>
</ul>
<p>18年我们为了提高Presto查询性能，也调研了一些技术方案，包括Presto on Alluxio和Presto on Carbondata，但是这2种方案最后都被舍弃了，原因是：</p>
<ul>
<li><strong>Presto on Alluxio查询性能提升35%，但是内存占用和性能提升不成正比</strong>，所以我们放弃了Presto on Alluxio，后续可能会对一些性能要求敏感的业务使用。</li>
<li>Presto on Carbondata是在18年8月份测试的，当时的版本，Carbondata稳定性较差，性能没有明显优势，一些场景ORC更快，所以我们没有再继续跟踪调研Presto on Carbondata。因为滴滴有专门维护Druid的团队，所以我们对接了Presto on Druid，一些场景性能提升4~5倍，后续我们会更多关注Presto on Clickhouse及Presto on Elasticsearch。</li>
</ul>
<h2 id="Presto在车好多的实践"><a href="#Presto在车好多的实践" class="headerlink" title="Presto在车好多的实践"></a>Presto在车好多的实践</h2><p>优化：</p>
<p>客户端和服务端之间加一层代理</p>
<ul>
<li>代理层的作用不仅隐藏了 Coordinator 真实地址，而且可以根据需求设置一些客户端接入规范，以便能区分接入方式&#x2F;类型等。我们还在代理层附加了下面两个主要功能：在每一个 Query 结束时，会记录其所有信息并发送到 Kafka，最终落入到 Hive，即日志审计，方便管理员后续分析&#x2F;治理；监控一些 Query 指标，在超出阈值时主动 kill Query，提高集群稳定性。</li>
</ul>
<p>服务经常 OOM，很不稳定。经过调研，我们采取以下措施来优化 OOM 问题：</p>
<ul>
<li>设置堆外内存最大使用量 MaxDirectMemorySize</li>
<li>设置 glibc 的参数 export MALLOC_ARENA_MAX&#x3D;1</li>
</ul>
<h3 id="2-3-棘手的排队问题出现"><a href="#2-3-棘手的排队问题出现" class="headerlink" title="2.3 棘手的排队问题出现"></a>2.3 棘手的排队问题出现</h3><p>背景</p>
<blockquote>
<p>经过了一年多的迭代，Presto 在车好多集团内部成为了提供 Adhoc 查询的核心组件，数十个业务线的数百名用户都重度依赖 Presto 来实现他们的分析需求或者报表结果，基本上集群每天有 600+用户（数据分析师、运营、市场、产品等），高峰期每秒提交数目最大能达到百级别。在这样的一个情况下，高峰期任务排队的情况就会出现并且越来越严重，严重影响了用户的使用体验。</p>
</blockquote>
<p>解决方案&amp;效果</p>
<p>首先的想到的是任务治理</p>
<p>•  大查询限制：导致集群排队的主要原因是大查询（耗费计算资源多的 Query）长时间占用集群资源不释放，集群最大运行 Query 数目被打满，后续提交的 Query 只能排队。为了限制大查询，我们下调单个 Query 的最大运行时间、最大扫描分区数目、内存使用最大值、stage 数目等，让集群资源快速流转起来；</p>
<p>•  单个用户 Query 数目限制：我们下调单个用户的最大运行数目以及最大排队数目，防止单个用户提交过多查询占满集群资源，其他用户没有机会提交；</p>
<p>•  优化 SQL：我们根据一些规则，给出 SQL 优化的建议，比如：避免笛卡尔积、distinct 滥用、非等值 join 等情况，并推动用户优化 SQL；</p>
<p>•  推动上层 BI 工具缓存结果：为了方便用户使用，有一些 BI 工具来对接 Presto，有多个用户会查看同一张报表，基于这样的情况，没有必要每次查看都要发起一次查询，工具层缓存这个结果，对底层 Presto 的压力会大大缓解；</p>
<p>•  推动中间表的建设，优化查源表的情况，减少计算资源的浪费；</p>
<p>•  每周统计出各个部门的资源使用账单&amp;资源消耗排名 Top N 的用户，并通知，这是推动用户优化任务重要的数据来源；</p>
<p>其次，增加资源，这也是必然要尝试的一个方法。然而由于一些客观原因，比如：成本、机房初始容量规划等，无法给集群进行提供充足的资源，只能小规模有限扩容。</p>
<p>通过以上两个方面的优化，尤其是任务治理，排队情况得到缓解，然而总会有一些新用户会提交一些不合理的任务，因此任务治理是一项长期持续的工作。资源方面，没有条件新增，那么就只能在存量资源上想办法。</p>
<hr>
<h2 id="即席查询（Ad-Hoc）如何做到又快又稳？"><a href="#即席查询（Ad-Hoc）如何做到又快又稳？" class="headerlink" title="即席查询（Ad Hoc）如何做到又快又稳？"></a>即席查询（Ad Hoc）如何做到又快又稳？</h2><p>以下的这四种问题虽然都是在即席查询场景中相对常见的问题，但解决起来却并不容易。</p>
<ul>
<li>只查询单个总 PV 和总 UV，但是却读取了上百 G 数据；</li>
<li>虽然 CPU 还没跑满，但是内存一直不够，各种 OOM；</li>
<li>CPU、内存、磁盘 IO 都空闲，但是查询性能就是慢；</li>
<li>晚上跑 ETL 集群资源足够，白天分析师互相杀 SQL。</li>
</ul>
<p>“<strong>减 IO、控内存、降带宽、优调度</strong>“这四个手段</p>
<ol>
<li>减 IO 是一个统称，是指在查询的每个环节中，都需尽量去减少向上一步传输的数据量。<ol>
<li>场景1、只读取相关数据</li>
<li>场景 2、建立稀疏索引</li>
<li>场景 3、使用转换漏斗模型（用户分群、商品价格稀疏索引、事件名称分桶）</li>
</ol>
</li>
<li>经常会需要在有限的资源下满足客户多种的数据分析需求的挑战，所以需要控内存。<ol>
<li>场景 1、分桶执行策略。<strong>Bucket Execution：优化后的内存占用&#x3D;原内存占用&#x2F;数据分桶个数</strong></li>
<li>场景2、流量洪峰时的策略执行（<strong>Dynamic Bucekt Execution</strong>，即动态分桶执行策略：优化后的内存占用&#x3D;原内存占用&#x2F;数据分桶个数&#x2F;用户 ID 分片数。）在动态分桶的基础上，优先保证每个桶的主键全局有序，再按照主键进一步进行范围切割。</li>
</ol>
</li>
<li>​	但是在大数据场景中，影响效率的并非只有上文所提到的这两个因素，集群之间的网络带宽情况经常也会成为导致查询性能降低的诱因之一。<ol>
<li>因此这部分的重点是<strong>降低带宽</strong>。通过把用户数据进行 hash 并分成多片，使每台机器只处理特定数据，这样就不会涉及到计算中间结果的再次 shuffle。</li>
</ol>
</li>
<li>即便通过上述『减 IO、控内存、降带宽』这3个环节的性能优化后，在实际数据处理的过程中往往还是会遇到集群压力负载大、多用户同时查询等场景下的不可用情况。<ol>
<li>此时就需要进一步梳理客户场景对 ad-hoc 查询的需求是什么，一般来说，有以下三点：<ul>
<li>查询结果确定可以出结果，而不是直接报错和多次人工重试；</li>
<li>在多人使用的场景下，分析师希望自己先提交的查询一定能先出结果，而不是被后面的查询抢占资源；</li>
<li>日常数据分析过程中，有一些紧急查询需要提前，不能等待其它任务完成。</li>
</ul>
</li>
<li>通过以上一些场景需求，从而可以针对性定义了3个优化目标，分别为：<strong>查询结果可保证、查询速度可预期以及查询队列可控制。</strong></li>
</ol>
</li>
</ol>
<h2 id="网易云音乐数仓建模案例—声波APP"><a href="#网易云音乐数仓建模案例—声波APP" class="headerlink" title="网易云音乐数仓建模案例—声波APP"></a>网易云音乐数仓建模案例—声波APP</h2><p><strong>3.1现有设计</strong></p>
<p>快速便捷获取高质量数据是业务侧的希冀，同时为减少ad-hoc式的查询也是我们的希冀。因此构建声波olap模型，目标是帮助业务人员快速使用数据，获取结果并用于业务生产。</p>
<p>取数模型设计：</p>
<p><img src="/2021/03/13/Presto-Alluxio%E7%BB%BC%E8%BF%B0/%E5%8F%96%E6%95%B0%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1.png"></p>
<p>目前模型建设流程：</p>
<ol>
<li>业务侧&#x2F;已有报表中归纳常用指标</li>
<li>模型设计（常分析的业务过程（交易、互动）的明细、用户、房间、用户+房间的汇总表）</li>
<li>模型评审</li>
<li>配置模型（使用场景的说明、字段业务口径、技术口径、添加自定义维度、自定义度量）</li>
<li>测试使用</li>
</ol>
<p>流量自动化的解决方案：</p>
<ol>
<li>策划梳理坑位信息-〉与策划勾兑坑位信息-〉设计埋点scm信息-〉上传埋点到埋点平台-〉与开发勾兑埋点内容–〉下载最终版坑位信息制作坑位码表。</li>
<li>设计流量自动化的聚合表模型：uid+os+appver+mspm+source（+房间id+房间模版类型id）的粒度统计对应的(曝光、点击、进房)次数、人数和时长等信息。构建流量自动化模型，最终可由取数展示，<strong>该模型可以查看日常曝光点击的坑位PV、UV，同时可以查看核心（曝光-点击-进房）漏斗数据</strong>。</li>
</ol>
<p><strong>3.2思考</strong></p>
<p>目前存在的难点，这些都是后期会优化的内容。</p>
<ul>
<li>数据侧：a.模型设计(聚合、解耦)  b.模型迭代回跑</li>
<li>平台侧：a.平台开发进度无法满足模型使用  b.问题响应速度依赖其他部门</li>
<li>业务侧：a.对数据的维度、度量、聚合、日期分区的理解困难 b.自主分析数据的习惯尚未建立</li>
</ul>
<h2 id="大数据展现——即席查询"><a href="#大数据展现——即席查询" class="headerlink" title="大数据展现——即席查询"></a>大数据展现——即席查询</h2><p><strong>产品定位</strong></p>
<p>　　即席查询（BONC Intelligent Query）是北京东方国信科技股份有限公司针对商业智能应用领域、面向公司内部开发人员和行业最终用户使用的快速查询、取数的应用工具。即席查询能有效地减少取数环节、实现快速取数响应，并能够有效缓解支撑人员的工作压力、能够防止各级人员理解差异或偏差，低成本、高效地保证统计口径一致。通过即席查询以“IT系统”替代“IT部门”实现取数支撑，能够促进IT支撑的转型，把更多的精力投入到数据保障和数据分析领域。</p>
<h3 id="1-统一的语义管理体系"><a href="#1-统一的语义管理体系" class="headerlink" title="1. 统一的语义管理体系"></a>1. 统一的语义管理体系</h3><p>　　由元数据平台提供<strong>统一的指标与维度语义管理体系</strong>，避免重复定义维度和指标，独立、业务语义管理与物理数据层的管理各自独立且通过映射关联，具备更强的灵活性和可扩展性，关注业务、查询。业务人员不需要了解数据物理上是如何存放、如何理解、如何获取，只需要知道自已在业务上想要什么数据。</p>
<h3 id="2-智能化查询取数"><a href="#2-智能化查询取数" class="headerlink" title="2. 智能化查询取数"></a>2. 智能化查询取数</h3><p>　　后台可以根据立方体配置信息，自动选择表及表关联进行查询。保证找到数据量最小，运算量最小的数据进行取数。系统可进行自动优化，对于汇总级较快的查询，直接展示，<strong>对于明细级较慢的查询，自动生成后台任务</strong>；并且可以根据系统的使用情况进行<strong>自组织管理，自动优化数据存储、优化数据查询语句、优化数据索引、自动重复利用数据缓存</strong>等。</p>
<h3 id="3-多样化取数方式"><a href="#3-多样化取数方式" class="headerlink" title="3. 多样化取数方式"></a>3. 多样化取数方式</h3><p>　　包括规则定义取数、模版取数、预约任务取数、文件上传取数、SQL模版取数等取数方式。</p>
<ul>
<li><strong>规则定义取数</strong>：用户可以根据实际需求通过页面自定义取数规则。通过设定描述性的维度约束、设定查询特定的指标数值范围来实现。</li>
<li>模板取数：针对在一定时期内存在需要重复多次但约束条件变更不大的需求。在规则定义取数基础之上，将按一定规则配置的取数查询，保存为共享的模版，通过定制好的模版提供查询，为快速查询提供了良好的解决方式。</li>
<li>预约任务取数：在规则定义取数时，如果是明细查询，查询数据时会自动转为任务执行，任务在一定的时间段内才会被执行，出于系统的性能考虑，需要对系统的任务执行情况作相应的调度和控制。</li>
<li>文件上传取数：主要用于小规模小范围，而且需求比较明确的快速查询，可以省去通过自己构建维度来查询，大大的方便了操作人员的使用。</li>
<li><strong>SQL模板取数</strong>：（也就是自助 SQL）通常情况下，专业IT人员如果想要操作数据库，必须使用数据库客户端工具连接到数据库服务器上进行操作，SQL模板取数提供了一个WEB版的SQL客户端工具，用户通过使用浏览器即可对数据库进行数据操作、查询。</li>
</ul>
]]></content>
      <categories>
        <category>review</category>
      </categories>
      <tags>
        <tag>bigData</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 源码解读(1)</title>
    <url>/2019/04/10/Redis-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/</url>
    <content><![CDATA[<p>版本：redis 5.0.3</p>
<h1 id="1-解读-Redis-的-adlist-x2F-dict源码"><a href="#1-解读-Redis-的-adlist-x2F-dict源码" class="headerlink" title="1. 解读 Redis 的 adlist &#x2F;dict源码"></a>1. 解读 Redis 的 adlist &#x2F;dict源码</h1><h2 id="1-adlist"><a href="#1-adlist" class="headerlink" title="1. adlist"></a>1. adlist</h2><p>相比一般的双向链表，adlist 的独特之处在于：</p>
<ol>
<li>list 的结构体中，存在 dup、free、match 三种函数指针。</li>
<li>涉及到内存管理的 <code>zfree</code>方法（在 zmalloc中）。此处先不整理，可以提前参考：<a href="https://blog.csdn.net/guodongxiaren/article/details/44747719">zmallc.c源码解读</a>。</li>
<li>增加了迭代器的相关操作。</li>
</ol>
<span id="more"></span>

<h3 id="adlist-h"><a href="#adlist-h" class="headerlink" title="adlist.h"></a>adlist.h</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// adlist.h:</span></span><br><span class="line"><span class="comment">// 首先有这么三个结构体：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个结点，指向前驱后继</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listNode &#123;</span><br><span class="line">    <span class="keyword">struct</span> listNode *prev;</span><br><span class="line">    <span class="keyword">struct</span> listNode *next;</span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器，并指明方向</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> listIter &#123;</span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整个链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> list &#123;</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr); <span class="comment">// 复制函数指针</span></span><br><span class="line">    <span class="type">void</span> (*free)(<span class="type">void</span> *ptr); <span class="comment">// 释放函数指针</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key); <span class="comment">// 匹配函数指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; list;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>解释<code>free()</code>函数：在 del、empty 等方法中，如果要释放一个结点的内存，会首先调用这个free 函数指针，如果指向的函数有定义，那么将执行这个定义，否则不执行。</li>
</ul>
<h3 id="adlist-c"><a href="#adlist-c" class="headerlink" title="adlist.c"></a>adlist.c</h3><h4 id="1-常规方法："><a href="#1-常规方法：" class="headerlink" title="1. 常规方法："></a>1. 常规方法：</h4><ul>
<li>listCreate——创建新的 list。</li>
<li>listEmpty——清空元素。释放内存，指针置 null，长度置0，但 list 本身不删。</li>
<li>listRelease——清空 list。先执行 listEmpty，然后执行 zfree 方法。</li>
<li>listAddNodeHead——头插新结点。<ol>
<li>新建结点，分配内存，若失败返回 null，成功则下一步；</li>
<li>判断长度，若为0，则该结点为 list 唯一结点，改变指针；</li>
<li>若长度不为0，头插入链表中，改变指针，返回指向该 list 的指针。</li>
<li>以下的常规方法逻辑不再重复解释。</li>
</ol>
</li>
<li>listAddNodeTail——尾插新结点。</li>
<li>listInsertNode——中间插入新结点。并传入待插入位置的相邻结点，并告知是前驱还是后继，然后执行插入。</li>
<li>listDelNode——删除某结点。</li>
</ul>
<h4 id="2-迭代器相关方法："><a href="#2-迭代器相关方法：" class="headerlink" title="2. 迭代器相关方法："></a>2. 迭代器相关方法：</h4><ul>
<li>listGetIterator——新建迭代器。传入 list 以及指明方向（从头还是从尾开始），新建迭代器，并返回该迭代器。</li>
<li>listReleaseIterator——释放迭代器。传入迭代器，调用 zfree 释放其内存。</li>
<li>listRewind——迭代器指头。传入 list 及一个迭代器，让迭代器指向 list 的头部。</li>
<li>listRewindTail——迭代器指尾。同上，只是让迭代器指向 list 的尾部。</li>
<li>listNext——指向迭代器的下一处。同时更新迭代器的 next 指针指向位置。</li>
</ul>
<h4 id="3-adlist-的高级操作"><a href="#3-adlist-的高级操作" class="headerlink" title="3. adlist 的高级操作"></a>3. adlist 的高级操作</h4><ul>
<li>listDup——制造 list 的副本。传入原始 list，先分配内存，然后复制 dup、free、match 函数指针，让迭代器指向 head；遍历链表的同时，对每个结点执行 dup 函数（若无 dup 函数，那么仅赋值就 ok 了）。<ul>
<li>深拷贝的过程。</li>
</ul>
</li>
<li>listSearchKey——返回第一个匹配的结点。传入目标值key，迭代器指头，遍历链表的同时，对结点执行 match 函数（若无 match 函数，那么仅比较 value 就 ok 了）。</li>
<li>listIndex——按 list 中结点的脚标（从0开始计数）返回结点。</li>
<li>listRotate——链表最尾部结点移到head 处。</li>
<li>listJoin——拼接链表 l 和 o。将 链表 o 拼接到 l 的后边，将链表 o 的指针置 null，同时将 len 置0。</li>
</ul>
<h2 id="2-dict"><a href="#2-dict" class="headerlink" title="2. dict"></a>2. dict</h2><p>跟我们常见的 HashMap 很接近，dict 独特之处在于：</p>
<ol>
<li>dictht（两张哈希表，一张新表、一张旧表） +  dictType(dict 中操作函数的集合) +  iterators(迭代器) 一起组成 dict 结构。</li>
<li>可通过<code>dict_can_resize</code>参数设置是否允许扩容，0表示不允许，1表示允许。<ol>
<li>但存在例外，即使设为0，如果结点总数与桶数量的比值大于<code>dict_force_resize_ratio</code>(默认是5)时，也会触发扩容。</li>
</ol>
</li>
<li></li>
</ol>
<p><img src="/2019/04/10/Redis-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-1/1.png"></p>
<h3 id="dict-h"><a href="#dict-h" class="headerlink" title="dict.h"></a>dict.h</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dict 结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">// 字典类型</span></span><br><span class="line">    <span class="type">void</span> *privdata; <span class="comment">// 私有数据的指针</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">// 若为 -1 表示尚未 rehash</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">// 当前迭代器数量</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictht 结构体，一个 dict 中有两个 dictht，在进行 incremental rehashing 时会用到。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table; <span class="comment">// dictEntry 实体</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used; <span class="comment">// 已使用量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictEntry 结构体，K-V 结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictType 结构体，操作函数的集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> (*hashFunction)(<span class="type">const</span> <span class="type">void</span> *key); <span class="comment">// 计算 hash 的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key); <span class="comment">// 复制 key 的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj); <span class="comment">// 复制 val 的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2); <span class="comment">// 比较 key 的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key); <span class="comment">// key 的析构函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj); <span class="comment">// val 的析构函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// dictIterator 结构体，</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    dict *d; <span class="comment">// 当前字典</span></span><br><span class="line">    <span class="type">long</span> index; <span class="comment">// 脚标</span></span><br><span class="line">  <span class="comment">// safe 若是1，说明是安全的迭代器，迭代时可以调用各种方法,</span></span><br><span class="line">  <span class="comment">// safe 若是0，说明是不安全的迭代器，只能调用 dictNext()函数</span></span><br><span class="line">    <span class="type">int</span> table, safe; <span class="comment">// table 指示是新、旧表格</span></span><br><span class="line">    dictEntry *entry, *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> fingerprint; </span><br><span class="line">&#125; dictIterator;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="dict-c"><a href="#dict-c" class="headerlink" title="dict.c"></a>dict.c</h3><h4 id="1-内部方法"><a href="#1-内部方法" class="headerlink" title="1. 内部方法"></a>1. 内部方法</h4><ul>
<li>dictSetHashFunctionSeed——设置 hash 种子方法。传入 seed，将 seed 按照<code>sizeof(dict_hash_function_seed)</code>的 size 复制到<code>dict_hash_function_seed</code>中。</li>
<li>dictGetHashFunctionSeed——拿到上面 Set 后的 hash 种子。</li>
<li>dictGenHashFunction——根据 key、len，计算出索引值（调用 siphash.c）。</li>
<li>dictGenCaseHashFunction——简易 hash 算法。传入 buff 和 len（调用 siphash.c）。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// siphash.c，待补充</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-对外-API"><a href="#2-对外-API" class="headerlink" title="2. 对外 API"></a>2. 对外 API</h4><ul>
<li>_dictReset——将传入的 dictht 变量重置为默认态（清空）。dictht 中的<code>dictht-&gt;table=null</code>，这里的 table 有歧义，实际上是 dictEntry置 null，将 size、sizemas、used 置0。</li>
<li>dictCreate——新建一个 hash table。开辟内存，执行<code>_dictInit()</code>方法。</li>
<li>_dictInit——dict 初始化。将传入的dictType（操作参数的集合）、privDataPtr(操作函数需要的参数)置入 dict 中，其他参数要么 reset，要么恢复默认值。</li>
<li>_dictNextPower——传入 size，返回大于等于 size ，同时是2的幂次的整数。</li>
<li>dictResize——调整 size。 确定将要调整后的 size， 调用dictExpand 函数。</li>
<li>dictExpand——将 size 调用<code>_dictNextPower</code>替换为 realSize。按照 realSize 初始化一个新表(即 dictht)。</li>
</ul>
]]></content>
      <categories>
        <category>java+</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis专题</title>
    <url>/2019/02/18/Redis%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Redis-专题"><a href="#Redis-专题" class="headerlink" title="Redis 专题"></a>Redis 专题</h1><h2 id="1-为什么要用-redis-而不用-map-x2F-guava-做缓存，Redis-跟-Memcached-的区别"><a href="#1-为什么要用-redis-而不用-map-x2F-guava-做缓存，Redis-跟-Memcached-的区别" class="headerlink" title="1. 为什么要用 redis 而不用 map&#x2F;guava 做缓存，Redis 跟 Memcached 的区别"></a>1. 为什么要用 redis 而不用 map&#x2F;guava 做缓存，Redis 跟 Memcached 的区别</h2><ol>
<li>因为缓存分为本地缓存和分布式缓存，map&#x2F;guava 属于本地缓存，Redis&#x2F;Memcached 属于分布式缓存。</li>
<li>本地缓存特点：轻量、快速，生命周期随 JVM 销毁而结束；在多实例下，每个实例保存着独立的缓存，相互不一致。</li>
<li>分布式缓存特点：在多实例下，各实例共用一份缓存，具有一致性；要维护分布式服务高可用，程序架构复杂。</li>
</ol>
<p>Redis 与 Memcached 区别：</p>
<ol>
<li><p>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 是单线程，多路 IO 复用的网络模型。</p>
</li>
<li><p>Memcached 只支持 String 类型；Redis 支持更丰富的数据类型（主要五种，String、hash、list、set、zset）。</p>
<blockquote>
<p>[官网] It supports data structures such as strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes with radius queries and streams</p>
</blockquote>
</li>
<li><p>Memcached 将数据全部存在内存中；Redis 支持数据的持久化。</p>
</li>
<li><p>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；Redis 是原生支持 Cluster 模式的。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="2-如何解决-Redis-的并发竞争-Key-问题"><a href="#2-如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="2. 如何解决 Redis 的并发竞争 Key 问题"></a>2. 如何解决 Redis 的并发竞争 Key 问题</h2><p>并发竞争key问题，主要是<strong>并发写</strong>的问题<br>有五种解决方案：</p>
<ol>
<li><p>使用 redis 自带的 incr 命令：</p>
<ul>
<li>incr 和 expire 操作用 lua 脚本执行，保证原子性，<a href="https://blog.csdn.net/z69183787/article/details/79033670">代码实现</a>。</li>
<li>如果有其他原子性命令需求，可以通过 lua 脚本自己创建。</li>
</ul>
<blockquote>
<p>[官网]Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI &#x2F; EXEC</p>
</blockquote>
</li>
<li><p>使用独占锁的方式，实现复杂，成本较高。</p>
</li>
<li><p>使用乐观锁的方式，使用 watch 监视键是否被修改。</p>
</li>
<li><p>针对客户端使用，在代码中对 redis 操作时，针对同一 key 的资源要先加锁。</p>
</li>
<li><p>利用 redis 的 setnx 实现内置的锁。</p>
</li>
</ol>
<p>推荐阅读:<a href="https://www.cnblogs.com/shamo89/p/8385390.html">Redis 的并发竞争问题的解决方案总结</a></p>
<h2 id="3-设置-key-的过期时间"><a href="#3-设置-key-的过期时间" class="headerlink" title="3. 设置 key 的过期时间"></a>3. 设置 key 的过期时间</h2><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">redis&gt; <span class="keyword">SET</span> key <span class="comment">yes</span></span><br><span class="line">OK</span><br><span class="line">redis&gt; EXPIREAT <span class="comment">key 1550469300</span></span><br><span class="line">(integer) 1</span><br><span class="line">redis&gt; GET <span class="comment">key</span></span><br><span class="line"><span class="string">&quot;yes&quot;</span>   <span class="comment">// 未超时</span></span><br><span class="line">redis&gt; GET <span class="comment">key</span></span><br><span class="line">(nil)  <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Redis-的用途小结"><a href="#4-Redis-的用途小结" class="headerlink" title="4. Redis 的用途小结"></a>4. Redis 的用途小结</h2><p><img src="/2019/02/18/Redis%E4%B8%93%E9%A2%98/1.png" alt="1"></p>
<ol>
<li>用作缓存。</li>
<li>排行榜，使用 SortSet 数据结构。</li>
<li>计数器，使用 Redis 中原子性的自增操作；限速器，限制某用户访问某 API 的频率。</li>
<li>好友关系，利用集合中交集、并集、差集的操作。</li>
<li>简单消息队列，可以使用 Redis 的订阅&#x2F;发布模式，或者 List 来实现。</li>
<li>Session 共享</li>
</ol>
<p>不适合 Redis 的地方：</p>
<ol>
<li>使用 Redis 去保存用户的基本信息，因为其持久化方案并不能保持数据绝对的落地，而且持久化频率若过高可能会降低 Redis 的效率。</li>
<li>数据量太大，数据访问频率较低的场合不适合使用 Redis，因为这些数据一直放在内存中会造成资源的浪费。</li>
</ol>
<h2 id="5-Redis-的有序集合主要由跳表来实现"><a href="#5-Redis-的有序集合主要由跳表来实现" class="headerlink" title="5. Redis 的有序集合主要由跳表来实现"></a>5. Redis 的有序集合主要由跳表来实现</h2><p>[理解]跳表：对于单链表而言，线性查找的时间复杂度很高，是 O(n)。从链表中每隔几个结点提取出一层索引，可以在索引的基础上继续提取一层索引，如此下去直到索引中只有少数几个结点（比如只留两个结点），这种做法的时间复杂度是 O(logN)，空间复杂度是 O(N)。时间复杂度与二分法、红黑树相当。</p>
<p>跳表的<strong>插入和删除</strong>的时间复杂度也是 O(logN)。当插入过多而不更新索引时，跳表的效率会降低，所以需要进行“平衡性”的维护，这里用到了<strong>随机函数</strong>的做法。使用随机函数，来决定将这个结点插入到哪几级索引中。</p>
<p>Redis 中为什么采用跳表，而不是红黑树：</p>
<ol>
<li>Redis主要操作有：插入、删除、查找、按区间查找、迭代输出。 </li>
<li>除了<strong>按区间查找</strong>外，其他几项跳表与红黑树都能完成，而且时间复杂度一致。</li>
<li><strong>按区间查找</strong>，红黑树效率不如跳表。</li>
</ol>
<h2 id="6-Spring-配置-Redis-注解缓存"><a href="#6-Spring-配置-Redis-注解缓存" class="headerlink" title="6. Spring 配置 Redis 注解缓存"></a>6. Spring 配置 Redis 注解缓存</h2><p>【一定要看这篇博客！！！超牛批】<a href="https://www.cnblogs.com/qlqwjy/p/8574121.html">spring配置redis注解缓存</a>和<a href="http://www.cnblogs.com/qlqwjy/p/8559119.html">spring+redis的集成，redis做缓存</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM框架整合说明</title>
    <url>/2019/02/16/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>SSM 框架整合的思路</p>
<h3 id="1-Dao-层"><a href="#1-Dao-层" class="headerlink" title="1. Dao 层"></a>1. Dao 层</h3><ol>
<li>使用mybatis框架。创建SqlMapConfig.xml（Mybatis 的全局配置文件），如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">		<span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">		<span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="2">
<li><p>创建一个 applicationContext-dao.xml，功能：</p>
</li>
<li><p>配置数据源</p>
</li>
<li><p>需要让spring容器管理SqlsessionFactory，单例存在。</p>
<ul>
<li>SqlSessionFactory 中的 configLocation 属性指向上面提到过的 SqlMapConfig.xml的路径；</li>
<li>SqlSessionFactory 中的 dataSource 属性指向上面提到的数据源；</li>
</ul>
</li>
<li><p>把mapper的代理对象放到spring容器中。使用扫描包的方式加载mapper的代理对象。</p>
<ul>
<li>配置扫描包时，将 basePackage 属性指向 mapper 包</li>
</ul>
</li>
</ol>
<h3 id="2-Service-层"><a href="#2-Service-层" class="headerlink" title="2. Service 层"></a>2. Service 层</h3><ol>
<li>需要把service实现类Impl对象放到spring容器中管理。<ul>
<li>添加配置文件 applicationContext-service.xml</li>
<li>在 context:component-scan 标签中，设置扫描包 base-package</li>
</ul>
</li>
<li>配置事务。<ul>
<li>添加配置文件 applicationContext-trans.xml</li>
<li>添加 transactionManager</li>
<li>配置传播行为（比如 save* ,表示以 save 开头），如下：<ul>
<li><code>tx:method name = &quot;save* propagation = &quot;REQUIRED&quot; </code></li>
</ul>
</li>
<li>切面配置（aop:config 标签）</li>
</ul>
</li>
</ol>
<h3 id="3-表现层"><a href="#3-表现层" class="headerlink" title="3. 表现层"></a>3. 表现层</h3><ol>
<li>需要扫描controller</li>
<li>配置注解驱动  mvc:annotatio n-driven</li>
<li>配置视图解析器</li>
</ol>
<h3 id="4-Web-xml"><a href="#4-Web-xml" class="headerlink" title="4. Web.xml"></a>4. Web.xml</h3><ol>
<li>spring容器的配置<ul>
<li>将上面提到的applicationContext*.xml 文件</li>
</ul>
</li>
<li>Springmvc前端控制器的配置<ul>
<li>servlet 配置，即DispatcherServlet</li>
<li>加载Springmvc.xml 文件</li>
<li>静态资源映射（本来静态资源在WEB-INF目录下无法被访问，但所有url被拦截的同时，可以将静态资源映射到指定目录下），代码如下：<br> <code>&lt;mvc:resources location&quot;/WEB-INF/css/&quot; mapping=&quot;/css/**&quot; /&gt;</code></li>
</ul>
</li>
<li>Post乱码过滤器</li>
</ol>
<h3 id="5-框架整合"><a href="#5-框架整合" class="headerlink" title="5. 框架整合"></a>5. 框架整合</h3><p>需要把配置文件放到taotao-manager-web工程下。因为此工程为war工程，其他的工程只是一个jar包。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>Set Character utf8</title>
    <url>/2018/05/30/Set-Character-utf8/</url>
    <content><![CDATA[<h1 id="MySQL修改默认字符集为utf8的方法"><a href="#MySQL修改默认字符集为utf8的方法" class="headerlink" title="MySQL修改默认字符集为utf8的方法"></a>MySQL修改默认字符集为utf8的方法</h1><p>安装MySQL默认是latin1，而不是utf8，所以最好在本地修改为utf8格式，以下是具体方法 。</p>
<ol>
<li>在MySQL下输入：</li>
</ol>
  <figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">variables</span> like <span class="comment">&#x27;character%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>检查各项是否为utf8格式，其中character_set_filesystem为binary。</p>
<ol start="2">
<li>MySQL安装在Linux环境下，其配置文件位于&#x2F;etc&#x2F;my.cnf，如果不清楚路径可以输入：</li>
</ol>
  <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">whereis <span class="keyword">my</span>.cnf</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>使用vim进入修改，修改之前一定要将mysql服务关闭，可以使用</li>
</ol>
  <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">sudo service mysqld stop</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>在[mysql]和[client] 下加上</li>
</ol>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">default</span><span class="operator">-</span><span class="type">character</span><span class="operator">-</span><span class="keyword">set</span> <span class="operator">=</span> utf8</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>在[mysqld]下加上</li>
</ol>
  <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">character</span>-<span class="keyword">set</span>-<span class="keyword">server</span> = utf8</span><br><span class="line"><span class="keyword">collation</span>-<span class="keyword">server</span> = utf8_general_ci</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>保存退出my.cnf文件，重启mysql服务，再次输入show variables like ‘character%’验证是否已经修改完成。</li>
</ol>
<ul>
<li>注1：如果使用set names utf8，貌似只能临时修改，一旦服务重启可能就失效，所以建议采用前6步一劳永逸。</li>
<li>注2：在 mysqld 中使用 default-character-set 设置， mysql 启动会报错而无法启动。<br>其他信息可以参考<a href="http://www.jb51.net/article/92802.htm">mysql通过my.cnf修改默认字符集为utf-8的方法和注意事项</a></li>
</ul>
]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SocketDemo学习笔记</title>
    <url>/2018/12/16/SocketDemo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>一个简易的实现全双工通信的 Socket  Demo 程序。</p>
<p>推荐阅读：<br><a href="http://java2s.com/Tutorials/Java/Socket/How_to_make_connection_to_a_Java_ServerSocket.htm">ServerSocket connection</a><br><a href="http://expert.51cto.com/art/200702/40196_all.htm">Java 网络编程精解之 ServerSocket 用法详解一</a></p>
<span id="more"></span>

<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>先看两个封装类 <code>Reader</code> 、 <code>Writer</code>。</p>
<ul>
<li><code>Reader</code>接收输入值，生成<code>OutputStream</code>。</li>
<li><code>Writer</code>读入<code>InputStream</code>的值，打印到<code>console</code>上。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aeadt.learn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reader</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	OutputStream out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Reader</span><span class="params">(OutputStream out)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.out = out;</span><br><span class="line">		setDaemon(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.nextLine();</span><br><span class="line">				out.write(str.getBytes());</span><br><span class="line">				out.write(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">				out.flush();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aeadt.learn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Writer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	InputStream in;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Writer</span><span class="params">(InputStream in)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.in = in;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="type">int</span> b;</span><br><span class="line">				<span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">					System.out.write(b);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是模拟服务器和客户机的<code>ServerDemo</code> 和 <code>ClientDemo</code>了。</p>
<ul>
<li>首先建立 Socket 连接，服务端创建监听接口：<code>new ServerSocket(8000);</code>，表示绑定接口 8000，如果绑定失败会抛出<code>IOException</code>。如果设为 0，则由 OS 任意分配端口（很少这么做）。</li>
<li>可能会有多个 Client 向 Server 发送连接请求，即执行<code>Socket s = new Socket(&quot;localhost&quot;, 8000);</code>的程序。所以服务器会将请求先放入一个队列中（通常容量为 50，超过 50 后将拒绝连接）。</li>
<li>如果 Client 的请求被加入队列中，此时<code>new Socket()</code>将会正常返回。</li>
<li>Server 调用<code>accept()</code>方法，从队列中取出连接请求，建立连接完成。</li>
<li>之后 Client 和 Server 可以通过 <code>Reader</code>和<code>Writer</code>工具完成细节通信。</li>
<li>此处还缺一个<code>close()</code>的操作，略去不提。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aeadt.learn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">ServerDemo</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerDemo</span>();</span><br><span class="line">		server.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待客户的连接&quot;</span>);</span><br><span class="line">		<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">		System.out.println(<span class="string">&quot;客户连接成功:&quot;</span> + s.getInetAddress());</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">		<span class="type">Reader</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reader</span>(out);</span><br><span class="line">		r.start();</span><br><span class="line">		<span class="type">Writer</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Writer</span>(in);</span><br><span class="line">		w.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.aeadt.learn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">ClientDemo</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientDemo</span>();</span><br><span class="line">		client.open();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">		<span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> s.getOutputStream();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Reader</span>(out).start();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Writer</span>(in).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>UML(1)</title>
    <url>/2018/10/31/UML-1/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（1）"><a href="#面向对象系统分析与设计（1）" class="headerlink" title="面向对象系统分析与设计（1）"></a>面向对象系统分析与设计（1）</h1><h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><ul>
<li><p>分析：建立模型，收集需求</p>
<ul>
<li>专业定义：探索问题和需求，而不是解决方案。涉及的词汇：需求、用例、约束。</li>
</ul>
</li>
<li><p>设计：模型的实现</p>
<ul>
<li>专业定义：对能够满足需求的解决方案的概念性的描述，而不是具体的实现。涉及的词汇：对象、结构、部署、UI。</li>
</ul>
</li>
<li><p>面向对象系统分析与设计：</p>
<ol>
<li>面向对象分析：强调对问题相关的<strong>对象或者概念的描述</strong>；</li>
<li><pre><code>面向对象设计：强调**对象的定义**，以及为了满足需求对象之间的进行的**合作**
</code></pre>
</li>
</ol>
</li>
<li><p>面向对象模型 OO 的作用：</p>
<ol>
<li>便于找到解决关键问题的答案；</li>
<li>便于将现实世界的实体建模成软件对象，完成复杂管理；</li>
</ol>
</li>
</ul>
<span id="more"></span>

<ul>
<li>抽象数据类型 ADT：例：将后进先出的序列抽象为栈</li>
<li>面向过程设计（设计思维：做某些事的规范、方法、理论等）：<ol>
<li>对<strong>过程</strong>做选择；</li>
<li>选择过程实现的最好的<strong>算法</strong>，专注于 action 而不是 data；</li>
</ol>
</li>
<li>模块开发：<ol>
<li>划分成细小的彼此关联的模块；</li>
<li>概括 + 抽象 &#x3D; 信息隐藏</li>
<li>使用接口，接口的作用：<ol>
<li>概括模块的内容，外部开发者无法获取到内部信息；</li>
<li>模块内部的改变不会改变接口，更不会影响到外部其他模块；</li>
</ol>
</li>
<li>挑战点：<ul>
<li>定义好的模型；</li>
<li>选择合适的软件结构；</li>
<li>仅凭模块化并不足够；</li>
</ul>
</li>
</ol>
</li>
<li>面向对象模型的 4 个元素：<strong>数据抽象，概括、继承、多态。</strong></li>
<li>Programming 经历的几个阶段：<ol>
<li>面向过程；</li>
<li>模块化编程</li>
<li>ADT 编程；</li>
<li>面向对象编程；</li>
</ol>
</li>
<li>面向对象编程的优势：<ol>
<li>编程人员精力偏向于软件接口和数据类型的设计，而不是底层实现；</li>
<li>提供增量的、迭代性软件开发，尽早发现 error，能够快速开发；</li>
<li>合适的接口，让软件稳定性提升；</li>
<li>能够更多思考将来的需要；</li>
</ol>
</li>
<li>面向对象编程的步骤： dice game 为例<ol>
<li>定义用例——play a dice game；</li>
<li>定义主要模型——拆解概念、属性、关联，构成<strong>可视化的概念</strong></li>
<li>定义关系图——描述关系，而非对现实世界的模仿</li>
<li>定义设计类图——阐述属性和方法，展示类 class，而不是现实世界的概念。</li>
</ol>
</li>
<li>SDLC 系统开发生命周期，是理解信息系统如何支持业务需求，如何设计、此系统如何构建和如何移交给用户的过程。<ul>
<li>步骤分为：<ol>
<li>项目设计阶段：识别问题；</li>
<li>分析阶段：调查、理解问题和需求；</li>
<li>设计阶段：详细描述解决方案；</li>
<li>实现阶段：建立解决问题的系统；</li>
<li>支持阶段：系统使用、维护、功能扩展</li>
</ol>
</li>
<li>有瀑布流、分步开发、并行开发、模板、即时模板等等表现形式</li>
</ul>
</li>
<li>方法、模型、工具、技术<ul>
<li>方法：综合性的指导，是模型、工具、技术的集合。</li>
<li>模型：代表真实世界的某一面，但不完全等同于真实世界。举例：图表、项目计划。</li>
<li>工具：创建模型等时的<strong>软件支持</strong>，从小的画图代码到大的软件工具都属于此类。</li>
<li>技术：指南的集合，一步步的精准指示、或者简单的建议都属于此类。</li>
</ul>
</li>
<li>其他趋势：UP、XP、Scrum、Crystal Methods、TDD、FDD等，不详述</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC</title>
    <url>/2018/11/06/Spring-IOC/</url>
    <content><![CDATA[<h1 id="Spring-源码学习之-IOC"><a href="#Spring-源码学习之-IOC" class="headerlink" title="Spring 源码学习之 IOC"></a>Spring 源码学习之 IOC</h1><h2 id="一、源码说明"><a href="#一、源码说明" class="headerlink" title="一、源码说明"></a>一、源码说明</h2><p>说明：本文分析的是 SpringFrameWork（5.0.5.RELEASE）IOC 部分的源码。</p>
<p>IOC：inversion of control，控制反转。应用程序将对象的控制权移交给第三方容器，并通过容器来管理这些被依赖的对象，完成了应用程序与被依赖对象的解耦。</p>
<span id="more"></span>

<p>以下就是使用 Spring 进行控制反转的经典案例：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">	ApplicationContext context = <span class="keyword">new</span> <span class="built_in">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationfile.xml&quot;</span>);</span><br><span class="line">	MessageService messageService = context.<span class="built_in">getBean</span>(MessageService.<span class="keyword">class</span>);</span><br><span class="line">	messageService.<span class="built_in">getMessage</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、设计模式"><a href="#二、设计模式" class="headerlink" title="二、设计模式"></a>二、设计模式</h2><p>Spring IOC 主要用到了三种设计模式：</p>
<ol>
<li><p>工厂模式：<code>ApplicationContext</code>构建的<code>DefaultListableBeanFactory</code>类型的 BeanFactory，范例参见下文步骤拆解。</p>
</li>
<li><p>单例模式：如果是单例 bean，将在<code>AbstractBeanFactory.java</code>的<br><code>doGetBean()</code>方法中进行实例化，见下代码：</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅展示部分代码</span></span><br><span class="line"><span class="keyword">if</span> (mbd.is<span class="constructor">Singleton()</span>) &#123;</span><br><span class="line">    sharedInstance = get<span class="constructor">Singleton(<span class="params">beanName</span>, ()</span> -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            return create<span class="constructor">Bean(<span class="params">beanName</span>, <span class="params">mbd</span>, <span class="params">args</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeansException ex) &#123;</span><br><span class="line">            destroy<span class="constructor">Singleton(<span class="params">beanName</span>)</span>;</span><br><span class="line">            throw ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    bean = get<span class="constructor">ObjectForBeanInstance(<span class="params">sharedInstance</span>, <span class="params">name</span>, <span class="params">beanName</span>, <span class="params">mbd</span>)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>将<code>beanName</code>和<code>RootBeanDefinition</code>拿到创建 bean 并初始化 bean。</p>
<ol start="3">
<li>策略模式：Spring 会调用 ApplicationContext 来获取 Resource 的实例，但 Resource 接口封装了多种资源类型，见下图：</li>
</ol>
<p><img src="/2018/11/06/Spring-IOC/Resource.png" alt="ApplicationContext"></p>
<p>Spring 采用策略模式，选择恰当的资源访问方式，用以适应不同的资源类型。本文的 xml 配置文件，就是由 Spring 调用<code>ClassPathXmlApplicationContext </code>类来读取的。</p>
<h2 id="三、步骤拆解"><a href="#三、步骤拆解" class="headerlink" title="三、步骤拆解"></a>三、步骤拆解</h2><p>首先<code>ApplicationContext </code>的继承关系如下图：</p>
<p><img src="/2018/11/06/Spring-IOC/ApplicationContext.png" alt="ApplicationContext"></p>
<p>其中<code>ClassPathXmlApplicationContext</code>是通过读取 xml 文件来构建<code>ApplicationContext</code>。另外一种通过注解实现的方式，本文暂不涉及。</p>
<h3 id="（1）创建beanFactory"><a href="#（1）创建beanFactory" class="headerlink" title="（1）创建beanFactory"></a>（1）创建<code>beanFactory</code></h3><h4 id="1-处理路径信息"><a href="#1-处理路径信息" class="headerlink" title="1. 处理路径信息"></a>1. 处理路径信息</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Class: ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: ClassPathXmlApplicationContext</span></span><br><span class="line"><span class="comment">*  Line: 142、144</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">		<span class="built_in">setConfigLocations</span>(configLocations);<span class="comment">// 处理路径信息</span></span><br><span class="line">		...</span><br><span class="line">		<span class="built_in">refresh</span>(); <span class="comment">// （1）、（2）节内容都在此方法栈之上</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>refresh()</code>执行的是初始化<code>ApplicationContext</code>的工作</p>
<h4 id="2-创建BeanFactory"><a href="#2-创建BeanFactory" class="headerlink" title="2. 创建BeanFactory"></a>2. 创建<code>BeanFactory</code></h4><ul>
<li>创建<code>DefaultListableBeanFactory</code>类型的 <code>BeanFactory </code></li>
</ul>
<p><img src="/2018/11/06/Spring-IOC/DefaultListableBeanFactory.png" alt="DefaultListableBeanFactory"></p>
<p>上图为<code>DefaultListableBeanFactory</code>的继承关系图，它继承了<code>BeanDefinitionRegistry</code>和<code>ListableBeanFactory</code>，是绝佳的<code>BeanFactory</code>。</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><span class="line"><span class="attribute">/* Class</span><span class="punctuation">:</span> <span class="string">AbstractApplicationContext</span></span><br><span class="line"><span class="attribute">*  Method</span><span class="punctuation">:</span> <span class="string">obtainFreshBeanFactory()</span></span><br><span class="line"><span class="attribute">*  Line</span><span class="punctuation">:</span> <span class="string">522</span></span><br><span class="line"><span class="attribute">*/</span></span><br><span class="line"><span class="attribute">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();// 以下开始到步骤4末都在此方法栈之上</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">/* Class</span><span class="punctuation">:</span> <span class="string">AbstractApplicationContext</span></span><br><span class="line"><span class="attribute">*  Method</span><span class="punctuation">:</span> <span class="string">obtainFreshBeanFactory()</span></span><br><span class="line"><span class="attribute">*  Line</span><span class="punctuation">:</span> <span class="string">621</span></span><br><span class="line"><span class="attribute">*/</span></span><br><span class="line"><span class="attribute">refreshBeanFactory(); </span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">/* Class</span><span class="punctuation">:</span> <span class="string">AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="attribute">*  Method</span><span class="punctuation">:</span> <span class="string">refreshBeanFactory()</span></span><br><span class="line"><span class="attribute">*  Line</span><span class="punctuation">:</span> <span class="string">130</span></span><br><span class="line"><span class="attribute">*/</span></span><br><span class="line"><span class="attribute">DefaultListableBeanFactory beanFactory = createBeanFactory();</span></span><br><span class="line"><span class="attribute"></span></span><br><span class="line"><span class="attribute">/* Class</span><span class="punctuation">:</span> <span class="string">AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="attribute">*  Method</span><span class="punctuation">:</span> <span class="string">createBeanFactory()</span></span><br><span class="line"><span class="attribute">*  Line</span><span class="punctuation">:</span> <span class="string">206</span></span><br><span class="line">*/</span><br><span class="line">return new DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br></pre></td></tr></table></figure>

<h3 id="（2）bean-的配置、加载、注册"><a href="#（2）bean-的配置、加载、注册" class="headerlink" title="（2）bean 的配置、加载、注册"></a>（2）bean 的配置、加载、注册</h3><h4 id="3-配置是否允许循环依赖和是否允许-Bean-定义的覆盖"><a href="#3-配置是否允许循环依赖和是否允许-Bean-定义的覆盖" class="headerlink" title="3. 配置是否允许循环依赖和是否允许 Bean 定义的覆盖"></a>3. 配置是否允许循环依赖和是否允许 Bean 定义的覆盖</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Class: AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: refreshBeanFactory()</span></span><br><span class="line"><span class="comment">*  Line: 132</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: customizeBeanFactory()</span></span><br><span class="line"><span class="comment">*  Line: 224 ~ 228</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="literal">null</span>) &#123;</span><br><span class="line">	beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="literal">null</span>) &#123;</span><br><span class="line">	beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-根据配置信息加载-Bean，并放入-BeanFactory-中"><a href="#4-根据配置信息加载-Bean，并放入-BeanFactory-中" class="headerlink" title="4. 根据配置信息加载 Bean，并放入 BeanFactory 中"></a>4. 根据配置信息加载 Bean，并放入 BeanFactory 中</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Class: AbstractRefreshableApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: refreshBeanFactory()</span></span><br><span class="line"><span class="comment">*  Line: 133</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load<span class="constructor">BeanDefinitions(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractXmlApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: loadBeanDefinitions()</span></span><br><span class="line"><span class="comment">*  Line: 83、94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> <span class="constructor">XmlBeanDefinitionReader(<span class="params">beanFactory</span>)</span>; </span><br><span class="line">load<span class="constructor">BeanDefinitions(<span class="params">beanDefinitionReader</span>)</span>; </span><br></pre></td></tr></table></figure>

<p>由<code>XmlBeanDefinitionReader</code>对象完成 xml 文件的读取，如果有多个 xml 文件，会一并获取。</p>
<h4 id="5-将配置信息中的资源（非懒加载的-bean）注册入-beanFactory-中。"><a href="#5-将配置信息中的资源（非懒加载的-bean）注册入-beanFactory-中。" class="headerlink" title="5. 将配置信息中的资源（非懒加载的 bean）注册入 beanFactory 中。"></a>5. 将配置信息中的资源（非懒加载的 bean）注册入 beanFactory 中。</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Class: AbstractApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: refresh()</span></span><br><span class="line"><span class="comment">*  Line: 550</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">finish<span class="constructor">BeanFactoryInitialization(<span class="params">beanFactory</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractApplicationContext</span></span><br><span class="line"><span class="comment">*  Method: finishBeanFactoryInitialization()</span></span><br><span class="line"><span class="comment">*  Line: 869</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">beanFactory.pre<span class="constructor">InstantiateSingletons()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: DefaultListableBeanFactory</span></span><br><span class="line"><span class="comment">*  Method: preInstantiateSingletons()</span></span><br><span class="line"><span class="comment">*  Line: 760</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">get<span class="constructor">Bean(<span class="params">beanName</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*  Method: doGetBean()</span></span><br><span class="line"><span class="comment">*  Line: 246、268、295、327、314~367</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object sharedInstance = get<span class="constructor">Singleton(<span class="params">beanName</span>)</span>;</span><br><span class="line">BeanFactory parentBeanFactory = get<span class="constructor">ParentBeanFactory()</span>;</span><br><span class="line">final RootBeanDefinition mbd = get<span class="constructor">MergedLocalBeanDefinition(<span class="params">beanName</span>)</span>;</span><br><span class="line">String<span class="literal">[]</span> dependsOn = mbd.get<span class="constructor">DependsOn()</span>;</span><br><span class="line">bean = get<span class="constructor">ObjectForBeanInstance(<span class="params">sharedInstance</span>, <span class="params">name</span>, <span class="params">beanName</span>, <span class="params">mbd</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*  Method: getObjectForBeanInstance()</span></span><br><span class="line"><span class="comment">*  Line:1629~1631</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!(beanInstance instanceof FactoryBean)<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">BeanFactoryUtils</span>.</span></span>is<span class="constructor">FactoryDereference(<span class="params">name</span>)</span>) &#123;</span><br><span class="line">	return beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><code>preInstantiateSingletons()</code>方法将所有 bean 标签属性取出，先判断非 abstract、非懒加载、单例模式，再判断非 FactoryBean 对象后，执行 <code>getBean(beanName)</code>方法。</li>
<li>然后调用<code>getSingleton(beanName)</code>方法检查是否已创建，调用<code>getParentBeanFactory()</code>方法检查此 BeanDefinition 是否已经存在于容器中。</li>
<li>调用<code>mbd.getDependsOn()</code>初始化所有依赖，并检查是否有依赖关系。<br>从 314 行到 367 行，是根据是否 singleton、Prototype等调用<code>getObjectForBeanInstance</code>方法创建出 bean instance。</li>
</ol>
<p>到此，所有非懒加载的 singleton beans 都已经完成初始化。</p>
<h3 id="（3）getBean-拿到实例完成方法调用"><a href="#（3）getBean-拿到实例完成方法调用" class="headerlink" title="（3）getBean()拿到实例完成方法调用"></a>（3）<code>getBean()</code>拿到实例完成方法调用</h3><h4 id="6-拿到上面生成的-bean-instance"><a href="#6-拿到上面生成的-bean-instance" class="headerlink" title="6. 拿到上面生成的 bean instance"></a>6. 拿到上面生成的 bean instance</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">MessageService messageService = context.get<span class="constructor">Bean(MessageService.<span class="params">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Class: AbstractBeanFactory</span></span><br><span class="line"><span class="comment">*  Method: doGetBean()</span></span><br><span class="line"><span class="comment">*  Line: 246</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Object sharedInstance = get<span class="constructor">Singleton(<span class="params">beanName</span>)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用<code>context.getBean()</code>方法后，会进入<code>AbstractBeanFactory</code>类中的<code>doGetBean()</code>方法中，在上一节步骤 5 中已经通过此方法创建了 bean 的实例，所以此处可以直接拿到此实例</li>
<li>然后完成实例方法的调用</li>
</ol>
<!--## 四、质量代码的案例

### 4.1 符合高质量代码的案例

1. 覆盖 equals 时总要覆盖 hashCode。而且总是要覆盖 toString()。而且覆盖后的 equals 方法保持了对称、传递和一致性。

    <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* package: org.springframework.beans.factory.config</span></span><br><span class="line"><span class="comment">*  class: BeanDefinitionHolder</span></span><br><span class="line"><span class="comment">*  Line: 165~190</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String toString() &#123;</span><br><span class="line">	<span class="keyword">return</span> getLongDescription();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> boolean equals(Object other) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> == other) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(other instanceof BeanDefinitionHolder)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	BeanDefinitionHolder otherHolder = (BeanDefinitionHolder) other;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.beanDefinition.equals(otherHolder.beanDefinition) &amp;&amp;</span><br><span class="line">			<span class="keyword">this</span>.beanName.equals(otherHolder.beanName) &amp;&amp;</span><br><span class="line">			ObjectUtils.nullSafeEquals(<span class="keyword">this</span>.aliases, otherHolder.aliases);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> int hashCode() &#123;</span><br><span class="line">	int hashCode = <span class="keyword">this</span>.beanDefinition.hashCode();</span><br><span class="line">	hashCode = <span class="number">29</span> * hashCode + <span class="keyword">this</span>.beanName.hashCode();</span><br><span class="line">	hashCode = <span class="number">29</span> * hashCode + ObjectUtils.nullSafeHashCode(<span class="keyword">this</span>.aliases);</span><br><span class="line">	<span class="keyword">return</span> hashCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>优先创建列表，而且在预知长度时，设置默认长度。</p>
 <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package: org.springframework.beans.factory.annotation</span></span><br><span class="line"><span class="comment">*  class: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">*  Line: 283</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">List</span>&lt;<span class="type">Constructor</span>&lt;?&gt;&gt; candidates <span class="operator">=</span> new <span class="type">ArrayList</span>&lt;&gt;(rawCandidates.length);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在频繁增删的情况下，优先选择 LinkedList，而且使用 foreach 进行迭代。</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package: org.springframework.beans.factory.serviceloader</span></span><br><span class="line"><span class="comment">*  class: ServiceListFactoryBean</span></span><br><span class="line"><span class="comment">*  Line: 37~43</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title class_">Object</span> <span class="title function_">getObjectToExpose</span>(<span class="params">ServiceLoader&lt;?&gt; serviceLoader</span>) &#123;</span><br><span class="line">	<span class="title class_">List</span>&lt;<span class="title class_">Object</span>&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (<span class="title class_">Object</span> loaderObject : serviceLoader) &#123;</span><br><span class="line">		result.<span class="title function_">add</span>(loaderObject);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>将 createBean 方法泛型化，避免需要代码进行类型转换的情况。</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/* package: org.springframework.beans.factory.support</span></span><br><span class="line"><span class="comment">	*  class: createBean</span></span><br><span class="line"><span class="comment">	*  Line: 296~304</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">public &lt;T&gt; T create<span class="constructor">Bean(Class&lt;T&gt; <span class="params">beanClass</span>)</span> throws BeansException &#123;</span><br><span class="line">		RootBeanDefinition bd = <span class="keyword">new</span> <span class="constructor">RootBeanDefinition(<span class="params">beanClass</span>)</span>;</span><br><span class="line">		bd.set<span class="constructor">Scope(SCOPE_PROTOTYPE)</span>;</span><br><span class="line">		bd.allowCaching = <span class="module-access"><span class="module"><span class="identifier">ClassUtils</span>.</span></span>is<span class="constructor">CacheSafe(<span class="params">beanClass</span>, <span class="params">getBeanClassLoader</span>()</span>);</span><br><span class="line">		return (T) create<span class="constructor">Bean(<span class="params">beanClass</span>.<span class="params">getName</span>()</span>, bd, null);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型强转前，使用 instanceof 进行父类、子类判断。</p>
 <figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package: org.springframework.beans.factory.config</span></span><br><span class="line"><span class="comment">*  class: ServiceLocatorFactoryBean</span></span><br><span class="line"><span class="comment">*  Line: 252~257</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">if</span> (!(beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(</span><br><span class="line">			<span class="string">&quot;ServiceLocatorFactoryBean needs to run in a BeanFactory that is a ListableBeanFactory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.beanFactory = (ListableBeanFactory) beanFactory;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举类<code>Autowire</code>，为参数提供编译时安全。</p>
 <figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Autowire</span> &#123;</span><br><span class="line">	<span class="built_in">NO</span>(AutowireCapableBeanFactory.AUTOWIRE_NO),</span><br><span class="line">	<span class="built_in">BY_NAME</span>(AutowireCapableBeanFactory.AUTOWIRE_BY_NAME),</span><br><span class="line">	<span class="built_in">BY_TYPE</span>(AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">Autowire</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title">isAutowire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span> == BY_NAME || <span class="keyword">this</span> == BY_TYPE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-2-违反高质量代码的案例"><a href="#4-2-违反高质量代码的案例" class="headerlink" title="4.2 违反高质量代码的案例"></a>4.2 违反高质量代码的案例</h3><ol>
<li><p>try-catch 捕获异常后，未作任何处理。</p>
 <figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* package: org.springframework.beans.factory.annotation</span></span><br><span class="line"><span class="comment">*  class: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment">*  Line: 151~158</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">this</span>.autowiredAnnotationTypes.add((<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Annotation&gt;)</span><br><span class="line">			ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.<span class="keyword">class</span>.getClassLoader()));</span><br><span class="line">	logger.info(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">	<span class="comment">// JSR-330 API not available - simply skip.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为此方法为构造方法，所以不可抛异常。此时考虑到“JSR-330 API not available”，所以将 try-catch 删去。改后代码</p>
<pre><code><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.autowiredAnnotationTypes.add((<span class="keyword">Class</span>&lt;? <span class="keyword">extends</span> Annotation&gt;)</span><br><span class="line">		ClassUtils.forName(<span class="string">&quot;javax.inject.Inject&quot;</span>, AutowiredAnnotationBeanPostProcessor.<span class="keyword">class</span>.getClassLoader()));</span><br><span class="line">logger.info(<span class="string">&quot;JSR-330 &#x27;javax.inject.Inject&#x27; annotation found and supported for autowiring&quot;</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="2">
<li><p>List 数组仍然使用 Iterate 进行迭代</p>
 <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">/* package: org.springframework.beans.factory.config</span><br><span class="line">*  <span class="built_in">class</span>: ConstructorArgumentValues</span><br><span class="line">*  Line: <span class="number">230</span></span><br><span class="line">*/</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;ValueHolder&gt; <span class="keyword">it</span> = this.genericArgumentValues.iterator(); <span class="keyword">it</span>.hasNext();)&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>在 JDK 1.5 之后，建议采用 for-each 取代迭代器，以减少出错的可能性。改后代码为：</p>
<pre><code><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(ValueHolder holder : this.genericArgumentValues)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>在 com.sun.glass.ui 的 <code>GestureSupport</code>类中，第 94 行</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">multiplicativeDelta</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">from</span>, <span class="built_in">double</span> to</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">from</span> == <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> View.GESTURE_NO_DOUBLE_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (to / <span class="keyword">from</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>double 类型数据的比较不应该使用<code>==</code>。更改后的代码：</p>
<pre><code><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">private static <span class="type">double</span> multiplicativeDelta(<span class="type">double</span> <span class="keyword">from</span>, <span class="type">double</span> <span class="keyword">to</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">Double</span>.doubleToLongBits(<span class="keyword">from</span>) == <span class="type">Double</span>.doubleToLongBits(<span class="number">0.0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">View</span>.GESTURE_NO_DOUBLE_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">to</span> / <span class="keyword">from</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="4">
<li><p>在 com.sun.java.swing.plaf.windows 的<code>WindowsIconFactory</code>类中，第 226 行</p>
 <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (w % <span class="number">2</span> == <span class="number">1</span>) &#123; x++; w++; &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>使用了奇判断，建议更换成偶判断。更改后的代码：</p>
<pre><code><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">if</span> (w % <span class="number">2</span> != <span class="number">0</span>) &#123; x++; w++; &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="5">
<li><p>在 com.sun.imageio.plugins.png 的 <code>PNGMetadata</code>类中，</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">equals</span>(<span class="params"><span class="built_in">Object</span> o</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || <span class="title function_">getClass</span>() != o.<span class="title function_">getClass</span>()) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>变量名应该避开“0”、“o”、“1”、“l”这些易混淆的字符。更改后的代码：</p>
<pre><code><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">equals</span>(<span class="params"><span class="built_in">Object</span> <span class="built_in">object</span></span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="built_in">object</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">object</span> == <span class="literal">null</span> || <span class="title function_">getClass</span>() != <span class="built_in">object</span>.<span class="title function_">getClass</span>()) </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="6">
<li><p>在 com.sun.glass.ui.win 的<code>WinMenuItemDelegate</code>类中，第42行</p>
 <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">private int cmdID <span class="operator">=</span> -<span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>变量名没有遵循驼峰命名法。更改后的代码：</p>
 <figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">private int cmdId <span class="operator">=</span> -<span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 com.sun.glass.ui.win 的<code>WinMenuItemDelegate</code>类中，第84行</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">setPixels</span>(<span class="params">Pixels pixels</span>) &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement images in menuItem</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>无用的传参，以及不需要实现的功能及注释需要清理。更改后的代码：</p>
<pre><code><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">setPixels</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>–&gt;</p>
-->]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>UML(2)</title>
    <url>/2018/11/01/UML-2/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（2）"><a href="#面向对象系统分析与设计（2）" class="headerlink" title="面向对象系统分析与设计（2）"></a>面向对象系统分析与设计（2）</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><h4 id="统一建模语言-UML："><a href="#统一建模语言-UML：" class="headerlink" title="统一建模语言 UML："></a>统一建模语言 UML：</h4><pre><code>- 特点：可视化、实践性强、面向对象的工业标准、多视角多结论、
- 前提：软件系统能被视为相互关联对象的集合
- 误解：
    1. 被认为等同于过程或者理论
    2. 被认为等同于面向对象的分析与设计
    3. 被认为等同于设计指南
- 结构：
    1. 基础模块（Building blocks）：物、表、关系等
    2. 相同的机理（Common mechanisms）：要求、修饰、划分、可扩展性
    3. 体系（Architecture）：用例、过程、实现、部署等
- 使用 UML 的优势：提高质量、更高效。
</code></pre>
<h4 id="为什么建模？"><a href="#为什么建模？" class="headerlink" title="为什么建模？"></a>为什么建模？</h4><pre><code>- 从现实中抽象：获得必要的细节，过滤掉非必要的细节
- 有助于设计人员处理复杂问题：人类在处理复杂问题时存在局限性
- 集中在关键问题上
- 有助于理解需求、简捷设计、稳定系统的提升
</code></pre>
<h4 id="为什么面向对象？"><a href="#为什么面向对象？" class="headerlink" title="为什么面向对象？"></a>为什么面向对象？</h4><pre><code>- 更精准地反映现实
- 缩小现实与模型之间的语言鸿沟
- 定位现实的改变
</code></pre>
<ul>
<li><strong>可以将现实建模成一系列相互关联的对象。</strong></li>
</ul>
<span id="more"></span>

<h2 id="关键词区分"><a href="#关键词区分" class="headerlink" title="关键词区分"></a>关键词区分</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>建模就是从<strong>概念</strong>到<strong>实现</strong>的过程</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>conceptual</li>
<li>关注与问题相关的对象的定义</li>
<li>不关心对象的任何实现</li>
</ul>
<h4 id="规范-x2F-特定化-x2F-专业化"><a href="#规范-x2F-特定化-x2F-专业化" class="headerlink" title="规范&#x2F;特定化&#x2F;专业化"></a>规范&#x2F;特定化&#x2F;专业化</h4><ul>
<li>specification</li>
<li>关注对象是如何促进问题的解决的</li>
<li>关注对象的相互关系</li>
<li>不关注对象内部的关系</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul>
<li>implementation</li>
<li>关注怎么为一个对象写 code </li>
<li>关注对象内部、对象之间的方方面面</li>
</ul>
<h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li>是一个物理过程，选择一些属性或特点，排除掉一些不相关的属性。</li>
</ul>
<p>特点：</p>
<ul>
<li>抽象总是基于某种目的</li>
<li>一件事物可以有不同种的抽象</li>
<li>任何抽象，都无法完全描述现实</li>
</ul>
<p>不追求完美描述，建模够用就行</p>
<p>抽象也有几种类型，分类、聚合、概括等</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>classification</li>
<li>按照相同属性的对象实例，分成组</li>
<li>具有 <strong>member</strong> 的关系</li>
</ul>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><ul>
<li>aggregation</li>
<li>忽略 parts 之间的差异，组成一个整体，类图中父类一侧采用<strong>空心菱形</strong></li>
<li>具有 <strong>part</strong> 的关系</li>
<li>如果两者存在<strong>同生共死</strong>的关系，称为 <strong>composition</strong>，用<strong>实心菱形</strong>表示</li>
<li>当在 aggregation 和 association 之间难以抉择时，选 association</li>
</ul>
<h4 id="概括-x2F-泛化"><a href="#概括-x2F-泛化" class="headerlink" title="概括&#x2F;泛化"></a>概括&#x2F;泛化</h4><ul>
<li>generalization</li>
<li>反义词：specialization 专业化</li>
<li>按照对象的某种相同属性（discriminator 有侧重的、片面的、非全面的），分组</li>
<li>Van、Car、Truck 可以根据 vehicle-type 泛化成 Vehicle。<ul>
<li>前者是 subclass，后者是 superclass，根据 discriminator</li>
</ul>
</li>
<li>具有 <strong>sub&#x2F;super</strong> 的关系</li>
</ul>
<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><ul>
<li>通常对一些相似的属性或操作进行<strong>继承</strong>，可以减少不必要的描述，提升描述的使用率，但要注意：<ul>
<li>只在一个地方对属性和行为下定义（理解：子类多次定义，不如父类一次解决）</li>
<li>允许子类对象替代父类对象</li>
</ul>
</li>
</ul>
<h5 id="继承以外"><a href="#继承以外" class="headerlink" title="继承以外"></a>继承以外</h5><ul>
<li>子类可以增加新的属性、覆盖父类方法</li>
<li>继承时（比如多重继承）如果出现冲突（比如两栖车同时继承了陆车的size和水车的size，但含义分别是载重量和排水量，此时就是 name conflict），可以采用多种办法解决：<ol>
<li>用户自定义命令；</li>
<li>预定义命令；</li>
<li>重定义名称（only 属性）</li>
</ol>
</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul>
<li>abstract class</li>
<li>没有自身的实例</li>
<li>在 UML 中用斜体表示</li>
</ul>
<h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul>
<li>coverage</li>
<li>有以下几种情况：<ul>
<li>部分重叠 overlapping：比如父类：运动员，子类：网球运动员、足球运动员。父类实例可以属于多个子类。</li>
<li>互斥 disjoint：比如父类：人，子类：男人、女人。父类实例最多只能属于一个子类。</li>
<li>完全 complete：任一父类都能在子类中找到归属。</li>
<li>不完全 incomplete：存在某些父类，在子类中无法找到归属。</li>
</ul>
</li>
<li>重叠且不完全，比如上面运动员的例子。</li>
<li>重叠且完全，比如父类：课程，子类：毕业生课程、在校生课程。</li>
<li>互斥且完全，比如父类：大学生，子类：毕业生和在校生。</li>
<li>互斥且不完全，比如父类：树，子类：橡树、椰子树等。</li>
</ul>
<p><img src="/2018/11/01/UML-2/1.png" alt="1"></p>
<p>上文是抽象，下文是实现</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>object</li>
<li>是一种概念&#x2F;抽象&#x2F;事物，具有鲜明的边界和行为（来自别处的 request，要做出的某些操作）。</li>
<li>例如：张三的银行账户</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>interface</li>
<li>描述对象能表现出的操作</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>properties</li>
<li>对象具有 identity、state、behavior 三种特性</li>
</ul>
<h3 id="对象的抽象"><a href="#对象的抽象" class="headerlink" title="对象的抽象"></a>对象的抽象</h3><ul>
<li>encapsulation</li>
<li>在外部接口和内部实现之间，划分了一个明显的界线<ul>
<li>隐藏不必要的实现、确保模块化；</li>
<li>具有可见的 public 接口和隐藏的 private 实现</li>
<li>public 接口对外提供服务</li>
</ul>
</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>class</li>
<li>定义：一系列具有共同点的对象的描述<ul>
<li>共同点：state、behavior、relationships、semantics（语义）</li>
</ul>
</li>
<li>提供了一个创建对象的 template。</li>
<li>class 是一个工厂，object 是一个实例。</li>
<li>class 可以理解为一种松耦合、高内聚的模块</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>attribute</li>
<li>数据的一种描述</li>
<li>基础属性和衍生属性：出生日期和年龄（后者可以通过前者计算得到）</li>
</ul>
<!--+ UML 的方式：
    - <\<sterotype>> visibility name[multiplicity]:typeExpression = initialValue{propertyString}
    - 举例：+size:Area = (100,000){frozen}
    - 只有 name 是必须的-->

<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ul>
<li>operation</li>
<li>对象在 class 中可能会用到的操作</li>
<li>副作用：方法的执行可能会改变某个类的状态（read 操作不会产生副作用）</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>method</li>
<li>是 operation 的实现</li>
<li>一个 operation 可以有多种 method</li>
</ul>
<h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><ul>
<li>scope</li>
<li>一般的属性或操作是单对象实例作用范围的</li>
<li>有一些属性或操作可以被类的所有对象所共享，称为类属性，在 UML 中带下划线</li>
</ul>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><ul>
<li>link</li>
<li>对象实例们之间的物理或理论上的联系</li>
<li>link 允许彼此间的通信</li>
<li>例如：Person worksFor one Organization，Person teaches one Course</li>
</ul>
<h3 id="联结"><a href="#联结" class="headerlink" title="联结"></a>联结</h3><ul>
<li>association</li>
<li>具有相同语义的一系列 links 集合的描述</li>
<li>类图中用直线或带箭头的直线表示<ul>
<li>能显示<strong>连通性</strong></li>
<li>能显示<strong>清晰、可读性</strong></li>
</ul>
</li>
<li>class 之间或者 class 与自身，都有多种不同的联结方式</li>
<li>度：存在一元（一元联结时建议赋予不同角色）、二元（应用最多）、多元联结</li>
<li>具有多重性</li>
</ul>
<h4 id="qualifier"><a href="#qualifier" class="headerlink" title="qualifier"></a>qualifier</h4><ul>
<li>qualifier</li>
<li>将 N-M 关系浓缩成 1-N 的关系</li>
</ul>
<p><img src="/2018/11/01/UML-2/2.png" alt="2"></p>
<h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><ul>
<li>constraints</li>
<li>有：ordering、subset、general 三类<ul>
<li>ordering：顺序的，如has</li>
<li>subset：自己的，比如：Chair-of 是 1-N 关系，但 Member-of 是 M-N 关系，Chair-of 是 Member-of 的子集。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（3）</title>
    <url>/2018/11/10/UML%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（3）"><a href="#面向对象系统分析与设计（3）" class="headerlink" title="面向对象系统分析与设计（3）"></a>面向对象系统分析与设计（3）</h1><h2 id="晦涩的概念"><a href="#晦涩的概念" class="headerlink" title="晦涩的概念"></a>晦涩的概念</h2><ul>
<li>做系统分析的目的：理解既有系统的功能、更好地满足未来的需求。</li>
<li>做分析的几个阶段：收集相关信息；确定需求；为需求制定优先级；需求间的取舍；审核。</li>
<li>做分析的技巧：从调查中发现本质；分析员应当了解业务细节和日常操作的流程；分析员要表现得像业务员一样尽可能地了解业务；分析员对问题要有独特的视角；从需求出发为业务过程建模。</li>
<li>新系统需要具备什么特性？<ul>
<li>功能性需求（需要展示出必备的功能、需要建立在业务的基础上、需要有分析建模的记录文档）；</li>
<li>非功能性需求（技术性的环境、可用性、可靠性、安全性需求）。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<ul>
<li>做<strong>系统分析</strong>所涉及的人员有三类：用户（消费者）、商家、技术人员。<ul>
<li>意思是，这三类人是某个业务的直接使用者（比如每天都在使用这个业务）。</li>
<li>用户 user：横向延伸：可以按照部门、机构划分；纵向延伸：可以按照收银员（负责每日的业务操作）、中层管理者（负责提炼出必要信息）、高管（负责策略问题）等身份划分。</li>
<li>技术人员 techniques 可以分为三类：<ul>
<li>Business Process Automation（BPA）。工作内容：维持系统日常运行（[理解]类似运维人员，轻微的技术变动）</li>
<li>Business Process Improvement（BPI）。工作内容：改进系统（[理解]类似开发人员，技术小改）</li>
<li>Business Process Reengineering(BPR)。工作内容：为系统进行规模性的改造（[理解]类似于架构师，技术大改）</li>
</ul>
</li>
<li>对技术人员的要求：<ul>
<li>会收集资料；</li>
<li>理解既有业务；</li>
<li>找到业务的缺陷点；</li>
<li>提出改进的设想；</li>
<li>改代码；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="技术人员之-BPA"><a href="#技术人员之-BPA" class="headerlink" title="技术人员之 BPA"></a>技术人员之 BPA</h3><ul>
<li>目标：让用户（user）有更好的使用体验</li>
<li>工作内容：<ol>
<li>理解既有系统。（对既有系统：收集信息、过程建模、数据建模）。</li>
<li>找到业务的缺陷点。<ul>
<li>分析问题：直接问 user 哪里有问题；尽量做简捷地、增量性的改动；尽量寻找一些小改动（但能够给系统带来巨大的提升）</li>
<li>问题溯源：对于问题的来源，要大胆假设、小心论证。</li>
</ul>
</li>
<li>提出改进的设想。<ul>
<li>少量信息收集</li>
<li>按照设想改进当前系统</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="技术人员之-BPI"><a href="#技术人员之-BPI" class="headerlink" title="技术人员之 BPI"></a>技术人员之 BPI</h3><ul>
<li>目标：保证系统的效率</li>
<li>工作内容：<ol>
<li>理解既有系统（同 BPA，不赘述）</li>
<li>找到业务的缺陷点。<ul>
<li>对业务时长的管控：分析业务中每一个子过程的时长和总时长（如果两者有巨大的差异，可能说明进度拆分得过于细碎），解决办法：<ul>
<li>将进度整合起来，用更少的人、负责更多的工作；</li>
<li>并行化，让某些步骤能够同步发生。</li>
</ul>
</li>
<li>具体行为的开销：计算每个步骤的开销（考虑直接开销和间接开销）；找到<strong>开销最大</strong>的地方并采取措施尽量改善它。</li>
<li>标准化：从其他优秀的企业借鉴（学习如何处理类似业务的经验）；</li>
</ul>
</li>
<li>提出改进的设想。<ul>
<li>收集一定量的信息（moderate）</li>
<li>按照设想改进当前系统</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="技术人员之-BPR"><a href="#技术人员之-BPR" class="headerlink" title="技术人员之 BPR"></a>技术人员之 BPR</h3><ul>
<li>目标：对于业务进行大幅度改进</li>
<li>工作内容：<ol>
<li>理解既有系统<ul>
<li>对业务整体建模</li>
</ul>
</li>
<li>找到业务的缺陷点<ul>
<li>当前使用效果分析（以用户的视角、并考虑系统能为用户提供什么功能）</li>
<li>技术分析。列出重要的技术（分析员和管理员的工作）、并确定技术是如何发挥效用的。</li>
<li>业务精简。测试：如果强行去除某些业务会不会有不好的影响</li>
</ul>
</li>
<li>提出改进的设想<ul>
<li>收集大量信息</li>
<li>按照设想改进当前系统</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="以多个维度比较-BPA-x2F-BPI-x2F-BPR"><a href="#以多个维度比较-BPA-x2F-BPI-x2F-BPR" class="headerlink" title="以多个维度比较 BPA&#x2F;BPI&#x2F;BPR"></a>以多个维度比较 BPA&#x2F;BPI&#x2F;BPR</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">BPA</th>
<th align="center">BPI</th>
<th align="center">BPR</th>
</tr>
</thead>
<tbody><tr>
<td align="center">商业价值</td>
<td align="center">低</td>
<td align="center">中</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">项目开销</td>
<td align="center">低</td>
<td align="center">中</td>
<td align="center">高</td>
</tr>
<tr>
<td align="center">分析的范围</td>
<td align="center">窄</td>
<td align="center">较窄</td>
<td align="center">宽</td>
</tr>
<tr>
<td align="center">风险</td>
<td align="center">中低</td>
<td align="center">中低</td>
<td align="center">高</td>
</tr>
</tbody></table>
<h2 id="收集信息的技术"><a href="#收集信息的技术" class="headerlink" title="收集信息的技术"></a>收集信息的技术</h2><ul>
<li>以前的套路是：为既有系统建模，然后从模型中获得需求。</li>
<li>现在的办法是：为新系统确定有条理性的需求，然后平衡已有功能和新需求的关系。</li>
<li>收集技术有：<ol>
<li>问卷调查；<ul>
<li>你做的是什么？（潜台词：业务是怎样的流程）</li>
<li>下一步做什么？（潜台词：这些操作有什么表现）</li>
<li>[理解]把核心问题，以口语化的形式向 user 咨询。（阿辉注：这种内容也能当课件？手动黑人问号脸。后面还有着正装、不要迟到，说谢谢。。。太傻了，略略略）</li>
<li>tips：避免带有引导性的问题</li>
</ul>
</li>
<li>对用户进行调研；<ul>
<li>分成开放性问题和固定答案性问题两种。</li>
</ul>
</li>
<li>研究旧系统的文档资料；（来自专业组织、出版商等）</li>
<li>观察实际的业务过程；</li>
<li>借鉴商家&#x2F;同行的解决办法；</li>
<li>构建模板类型；（注重简约、可操作性、敏捷）<ul>
<li>模板的优点：易修改、开发者体验好、对 user 体验好</li>
<li>模板的缺点：扩展较难，有些时候使用模板会让事情变得更糟</li>
</ul>
</li>
</ol>
</li>
<li>提问问题的逻辑关系：<ol>
<li>金字塔型：以单个、具体问题入手，询问对某一大类问题的看法。特殊-普通。</li>
<li>漏斗形：从普遍性问题入手，询问对某一具体细节问题的看法。普通-特殊。</li>
<li>纺锤型：特殊-普通-特殊。</li>
</ol>
</li>
</ul>
<h2 id="信息系统"><a href="#信息系统" class="headerlink" title="信息系统"></a>信息系统</h2><ul>
<li>分类：<ol>
<li>Transaction processing systems TPS，交易系统。</li>
<li>Management information systems MIS，信息管理系统。评价：中级。</li>
<li>Decision support &#x2F; knowledge-based systems DSS&#x2F;KBS，知识系统&#x2F;决策支持系统。评价：中级。</li>
<li>Enterprise applications，企业级应用</li>
<li>Communication support systems，沟通系统</li>
<li>Office support systems，办公系统</li>
</ol>
</li>
</ul>
<p>剩下的都是低级系统。<br>最高级是可执行性的信息系统和 DSS 集团系统（上文未列出）</p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（4）</title>
    <url>/2018/11/10/UML%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（4）"><a href="#面向对象系统分析与设计（4）" class="headerlink" title="面向对象系统分析与设计（4）"></a>面向对象系统分析与设计（4）</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><ul>
<li>为了让具有不同背景的角色（比如 user、customer 等）能够准确地获取需求，引入了类图、用例图、时序图、状态机图等等手段</li>
</ul>
<h2 id="UP建模"><a href="#UP建模" class="headerlink" title="UP建模"></a>UP建模</h2><p>UP建模的四大阶段：</p>
<ol>
<li>初始阶段：<strong>主要从此阶段拿到需求</strong>。搞定最关键部分的元素。占比10%。</li>
<li>详述阶段：填充细节，占比约80%。</li>
<li>construction 阶段：补充剩下的。（不理会）</li>
<li>transition 阶段：需求变更时进入此阶段。（不理会）</li>
</ol>
<span id="more"></span>

<h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><ul>
<li>domain model：针对一些全局的类和类之间的关系建模。静态的。关键词：<strong>数据</strong>。</li>
<li>use-case model：针对角色、用例和他们之间的关系建模。动态的。关键词：<strong>功能性</strong>。</li>
<li>domain specification：对 domain model 的描述。</li>
<li>use case specification：对 use-case model 的描述。</li>
<li>user-interface specification &amp; prototyping：对 actors 和 system 之间的接口标准的描述。</li>
<li>actors：指的是 users，代表外部的主体。</li>
<li>glossary 术语表：分析员、开发者用的专业术语。</li>
<li>architecture description：对 use-cases 中的主干（核心，仅占 5~10%）的描述</li>
</ul>
<h2 id="身份"><a href="#身份" class="headerlink" title="身份"></a>身份</h2><ol>
<li>system analyst：负责整个需求、精简系统、确定类、类间的联系、确定 actors 和用例。（任务最重，几乎什么都做）</li>
<li>domain analyst：分析全局的特性。</li>
<li>architect：以<strong>整体视角</strong>对用例模型进行描述。</li>
<li>use-case 举例者：对用例进行详细阐述。</li>
<li>user-interface 设计者：设计接口。</li>
</ol>
<p><img src="/2018/11/10/UML%EF%BC%884%EF%BC%89/1.png"></p>
<p><img src="/2018/11/10/UML%EF%BC%884%EF%BC%89/2.png"></p>
<h2 id="获取需求的正确步骤"><a href="#获取需求的正确步骤" class="headerlink" title="获取需求的正确步骤"></a>获取需求的正确步骤</h2><ol>
<li>拿到 user 的 needs：目标 + 约束（哪些能做、哪些不能做）</li>
<li>确定可行性：从经济、技术、可操作性、合法性等方面考虑</li>
<li>记录需求。</li>
<li>实现需求。</li>
</ol>
<h3 id="什么是有效的需求？"><a href="#什么是有效的需求？" class="headerlink" title="什么是有效的需求？"></a>什么是有效的需求？</h3><p>正确、完整、一致、无二义、真实。</p>
<h2 id="Domain-建模"><a href="#Domain-建模" class="headerlink" title="Domain 建模"></a>Domain 建模</h2><p>【important】拿到系统中最核心的 classes 和它们的 associations<br>要求：这种建模要尽可能的准确，保证后期不再修改、系统可以重用。</p>
<ul>
<li>classes 有哪些？<ul>
<li>业务对象（比如订单、账户这种）；</li>
<li>真实世界的对象（比如消费者、供应商）；</li>
<li>事件（买卖）</li>
</ul>
</li>
<li>classes 用名词表示，associations 用动词表示。</li>
<li>阿辉注：如果题目列出一大段文字，那么我们要做的是：<ol>
<li>首先将名词圈出来，这些名词都可能是 classes；</li>
<li>然后剔除多余、不相关的名词。</li>
<li>同时存在一些名词，很明显是附属于其他名词的（比如 name、age 等名词，明显归属于 Person 的名下），可以当做属性看待，不能作为独立的 classes。</li>
<li>剔除这些名词后，幸存下来的差不多就是合格的 classes 了。</li>
<li>之后将动词圈出来，这些动词很可能就是 associations；</li>
<li>按照前两步骤幸存下来的名词连线，将不合格的动词剔除。</li>
<li>剩下的动词大概就是合格的 associations 了。</li>
<li>以上步骤主要靠练习，没有特别有效的技巧。</li>
</ol>
</li>
<li>对于属性的命名，注重简短、有内涵等等。</li>
<li>generalization（泛化、父类&#x2F;子类的关系）的层次选择 2~3 层最合适。</li>
</ul>
<h2 id="use-case-建模"><a href="#use-case-建模" class="headerlink" title="use-case 建模"></a>use-case 建模</h2><p>【important】看重功能性 functionality。</p>
<ul>
<li>开始使用 use-case：<ol>
<li>使用事件表；</li>
<li>确定 actors；</li>
<li>确定 functions；</li>
</ol>
</li>
<li>为不同的场景创建 Activities flow。</li>
<li>一些内部用例可以重用。</li>
</ul>
<h3 id="actors"><a href="#actors" class="headerlink" title="actors"></a>actors</h3><ul>
<li>定义：system 外界的一些直接接触者（实体），对系统输入，获得输出。<ul>
<li>举例：学生、教师、注册员、以及非人的事物（如第三方系统：账单系统）</li>
</ul>
</li>
<li>理解：actor 是一个 object，user 则是这个 object 的 instance。</li>
</ul>
<h3 id="use-case"><a href="#use-case" class="headerlink" title="use case"></a>use case</h3><ul>
<li>定义：运用 system 的一种方式。代表一系列 events。</li>
<li>理解：use case 是一个类的容器，scenario 是一个 instance。</li>
<li>use case 的命名应当是动宾短语，语态是现在时。</li>
<li>举例：一个注册员 registrar，对应的用例有：维护学生信息、维护教师信息、维护课程信息、提供课程清单。</li>
</ul>
<h3 id="Scenario"><a href="#Scenario" class="headerlink" title="Scenario"></a>Scenario</h3><ul>
<li>理解：以 actor 的视角，对 system 的描述。这种描述仅建立在部分功能的基础上，所以一定是不全面、带有偏见的。</li>
<li>用处：多用在 error 和非主要流程的描述上。</li>
<li>scenario 的分类：<ul>
<li>既有场景：描述当下。</li>
<li>预想的场景：描述将来。</li>
<li>evaluation：比如：acceptance tests（对功能进行检测）。</li>
<li>training：给新人培训。</li>
</ul>
</li>
<li>use-case 建模的两种观点：<ol>
<li>top-down：从 use-case 开始，到 scenario 结束。</li>
<li>bottom-up：从 scenario 开始，到 use-case 结束。</li>
</ol>
</li>
</ul>
<h2 id="怎么算是一个好的用例"><a href="#怎么算是一个好的用例" class="headerlink" title="怎么算是一个好的用例"></a>怎么算是一个好的用例</h2><ul>
<li>主要体现功能性；</li>
<li>传递一些有价值的东西交给 actor；</li>
<li>范围要大，够清晰，最好列出细节。</li>
<li>不仅显示正常的流程，还要考虑异常的流程。</li>
<li>规格：<ol>
<li>name；</li>
<li>actors；</li>
<li>一些先决条件：preconditions；</li>
<li>事件流：flow of events；</li>
<li>一些后决条件：postconditions；</li>
<li>其他需求（按需，可选）</li>
<li>分支、异常流程（按需，可选）</li>
</ol>
</li>
</ul>
<h3 id="flow-of-events"><a href="#flow-of-events" class="headerlink" title="flow of events"></a>flow of events</h3><ul>
<li>定义：一系列的事件序列。要求有序、有条理、事件明确。</li>
<li>要求：尽可能简单、避免循环。</li>
</ul>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ul>
<li>将若干个 use-cases 中的相同功能剥离开，作为独立的 use-case，然后让这些 use-cases 都包含（include）它。</li>
<li>在 use case 图中，通常是虚线箭头指向独立 use-case，而且附上<code>&lt;&lt;include&gt;&gt;</code>的记号。</li>
</ul>
<h3 id="extend"><a href="#extend" class="headerlink" title="extend"></a>extend</h3><ul>
<li>新的 use-case 继承旧的 use-case。</li>
<li>在 use case 图中，通常是子类用虚线箭头指向父类，而且附上<code>&lt;&lt;extend&gt;&gt;</code>的记号。</li>
</ul>
<h2 id="十种-use-case-建模的-errors"><a href="#十种-use-case-建模的-errors" class="headerlink" title="十种 use-case 建模的 errors"></a>十种 use-case 建模的 errors</h2><ol>
<li>不写 usage scenario text。</li>
<li>只描述属性和方法不解释用法（usage）。（阿辉注：理解不能吧，我也看不懂，记住好了）</li>
<li>use case 太简短。</li>
<li>遗漏 user interface。</li>
<li>给 use-case 取名太晦涩。</li>
<li>没有从 user 视角看待用例。</li>
<li>忽略 system 的响应。</li>
<li>忽略分支流程。</li>
<li>忽略前置、后置条件。</li>
<li>对采用 include 或 extends 难以抉择。</li>
</ol>
<h2 id="user-interface"><a href="#user-interface" class="headerlink" title="user-interface"></a>user-interface</h2><p>逻辑上：需要确定哪些数据是 user 可以操作的，以及这些数据是用什么方式呈现给 user 的。<br>实际上：sketch -&gt; prototype -&gt; verify。<br>    - [理解]先写个草稿、然后写个模板，最后套用并适当修改。</p>
<h2 id="acceptance-tests"><a href="#acceptance-tests" class="headerlink" title="acceptance tests"></a>acceptance tests</h2><ul>
<li>定义：通过测试的方式，告知消费者，system 的功能、限制等等有效可用。</li>
<li>目标：确保功能性、接口可用、消息正确、以及界面正常。</li>
<li>步骤：<ol>
<li>检查之前的需求，剔除冗余；</li>
<li>收集 users 新增的需求；</li>
<li>为每个需求，构建一个独立的评价场景。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（5）</title>
    <url>/2018/11/11/UML%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（5）"><a href="#面向对象系统分析与设计（5）" class="headerlink" title="面向对象系统分析与设计（5）"></a>面向对象系统分析与设计（5）</h1><ul>
<li>为什么要对系统进行分析：<ol>
<li>因为需求的特殊性；</li>
<li>用开发语言描述出来，更加正规且准确；</li>
<li>理解上的需要；</li>
<li>设计的需要。</li>
</ol>
</li>
<li>系统分析的过程：<ol>
<li>分析结构；</li>
<li>分析用例；</li>
<li>分析 classes；</li>
<li>分析 packages；</li>
</ol>
</li>
</ul>
<span id="more"></span>

<h2 id="1-analyze-classes"><a href="#1-analyze-classes" class="headerlink" title="1. analyze classes"></a>1. analyze classes</h2><ul>
<li>致力于解决功能性需求。</li>
<li>对 class 的描述仍是概念上的，不涉及具体实现。</li>
<li>分类：Boundary class、entity class、control class。</li>
<li>理解：将一个 use-case 分为三类，相当于细节化这个 use-case。如下图：</li>
</ul>
<p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/3.png"></p>
<h3 id="1-1-boundary-class"><a href="#1-1-boundary-class" class="headerlink" title="1.1 boundary class"></a>1.1 boundary class</h3><ul>
<li>边界类。</li>
<li>定义：将 system 和 actors 之间的交互模型化，主要是界面。</li>
<li>是对 UI 元素或者设备的抽象。举例：窗口、表格、控件、打印页面、传感器、终端等。不应太过细节，比如按钮、菜单项等是不合适的。</li>
</ul>
<p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/1.png"></p>
<h3 id="1-2-entity-class"><a href="#1-2-entity-class" class="headerlink" title="1.2 entity class"></a>1.2 entity class</h3><ul>
<li>实体类。<br>太常见了，略</li>
</ul>
<h3 id="1-3-control-class"><a href="#1-3-control-class" class="headerlink" title="1.3 control class"></a>1.3 control class</h3><ul>
<li>控制类。</li>
<li>定义：体现应用程序的执行逻辑。</li>
<li>举例：增加商品的行为，对应一个“增加商品类”。</li>
<li>tips：一个 control class 最多与一个 actor 相关联。</li>
</ul>
<p>哪些可以直接相连：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">actors</th>
<th align="center">boundary class</th>
<th align="center">entity class</th>
<th align="center">control class</th>
</tr>
</thead>
<tbody><tr>
<td align="center">actors</td>
<td align="center">×</td>
<td align="center">✔️</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">boundary class</td>
<td align="center">✔️</td>
<td align="center">×</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">entity class</td>
<td align="center">×</td>
<td align="center">✔️</td>
<td align="center">×</td>
<td align="center">✔️</td>
</tr>
<tr>
<td align="center">control class</td>
<td align="center">×</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
</tbody></table>
<p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/2.png"></p>
<h3 id="1-4-CRC-cards-概念模型"><a href="#1-4-CRC-cards-概念模型" class="headerlink" title="1.4 CRC cards 概念模型"></a>1.4 CRC cards 概念模型</h3><table>
<thead>
<tr>
<th align="center">Class name</th>
<th align="center">Class name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Responsibililities</td>
<td align="center">Collaborators</td>
</tr>
<tr>
<td align="center">this class knows or does</td>
<td align="center">anothor class(this class interacts with) to fulfill its responsibilities</td>
</tr>
</tbody></table>
<p>Tips: </p>
<ol>
<li>有助于理解“面向对象”</li>
<li>如果 responsibilities 过多，会造成低内聚；</li>
<li>如果collaborators 过多，会造成高耦合。</li>
<li>以 3~5 个responsibilities 为宜。</li>
</ol>
<h2 id="2-statechart-diagram"><a href="#2-statechart-diagram" class="headerlink" title="2. statechart diagram"></a>2. statechart diagram</h2><ul>
<li>推荐阅读：<a href="http://www.michael-richardson.com/processes/rup_for_sqa/core.base_rup/guidances/guidelines/statechart_diagram_640B5D0B.html">Guideline: Statechart Diagram</a></li>
<li>定义：描述对象内部行为的图表，比如：当外界传来 message 时，这个对象内部会作出的反应。</li>
<li>这个图表需要展示的信息：<ol>
<li>以<strong>结点</strong>的形式，表示单个对象的<strong>状态</strong>；</li>
<li>以<strong>连线</strong>的形式，表示造成改变的<strong>原因</strong>；</li>
<li>如果 state 发生变化，会导致的 <strong>actions</strong> 要表现出来。</li>
<li>展示出这个 object 收发的所有 messages；</li>
<li>展示这个 object 生命周期内的所有 states；</li>
</ol>
</li>
</ul>
<p>什么是states？</p>
<h3 id="2-1-states"><a href="#2-1-states" class="headerlink" title="2.1 states"></a>2.1 states</h3><ul>
<li>定义：一个 object 在其生命周期的某一刻的状态，具有 duration 的特点（指一段时间）。</li>
<li>判定 object 是否处于某个 state，可以根据 ① 这个类的某些 attribute（有时属性的改变会触发 state 的变化）、② 这个类与其他类的 link（有时 link 的改变会触发 state 的变化）。</li>
</ul>
<h3 id="2-2-start-state-和-stop-state"><a href="#2-2-start-state-和-stop-state" class="headerlink" title="2.2 start state 和 stop state"></a>2.2 start state 和 stop state</h3><ul>
<li>start state：每个状态图，有且仅有一个 start state。在 UML 中用黑色实心圆表示。</li>
<li>stop state：每个状态图，可以有多个 stop state。在 UML 中用同心圆表示（内圆黑色实心，外圆环空心）。</li>
<li>注：states 必须命名，未命名的将被当作匿名状态。</li>
</ul>
<h3 id="2-3-transitions"><a href="#2-3-transitions" class="headerlink" title="2.3 transitions"></a>2.3 transitions</h3><blockquote>
<p>A state machine consists of states, linked by transitions. </p>
</blockquote>
<ul>
<li>过渡态，在 UML 中用带箭头的实线表示，通常从一个 state 指向另一个 state（也可以指回自己 self-transition）。</li>
<li>特点：<ul>
<li>过渡态通常在一瞬间完成，不会被打断。</li>
<li>一个状态图中，某一时间点，只会有一个 transition 在发生。</li>
</ul>
</li>
<li>transitions 的发生条件：<ol>
<li>当一个 state activity 完成时，将会自动进入 transitions，进而进入下一个 state。关键词：自动。</li>
<li>被某 event 触发。关键词：非自动。</li>
</ol>
</li>
<li>transitions 的伴随现象（可选）：<ol>
<li>event signature：[理解]transitions 一定程度上跟 event 是同一件事，所以要有自己的命名。</li>
<li>guard condition：相当于先决条件</li>
<li>action：当 transitions 发生时执行的一系列 actions</li>
<li>message sending：给其他 objects 发消息</li>
</ol>
</li>
</ul>
<h3 id="2-4-events"><a href="#2-4-events" class="headerlink" title="2.4 events"></a>2.4 events</h3><ul>
<li>瞬时发生的事件。</li>
<li>两个事件之间，可能无关，可能相关（比如有时间先后关系等）</li>
<li>分类：<ol>
<li>call event：做出某些操作，作为某 message 的回应；</li>
<li>signal event：objects 之间的实时 signal；</li>
<li>change event：判定事件，类似 if 语句。</li>
<li>time event：定时&#x2F;周期性的事件。</li>
</ol>
</li>
</ul>
<h3 id="2-5-actions-amp-activities"><a href="#2-5-actions-amp-activities" class="headerlink" title="2.5 actions &amp; activities"></a>2.5 actions &amp; activities</h3><ul>
<li>actions：瞬时、不会被中断；</li>
<li>activities：花时间才能完成，具有时间段的特性，可以被打断。</li>
</ul>
<p>state 的五种 behavior：</p>
<ol>
<li>no behavior: 静等 event 发生后离开这个 state。</li>
<li>event name[guard condition]&#x2F;action: 等某 event 发生后，满足设定的条件后，执行 action。</li>
<li>do&#x2F;activity: 执行某个 operation。</li>
<li>entry&#x2F;action: 进入此 state 时会发生的 atomic action。</li>
<li>exit&#x2F;action: 离开此 state 时会发生的 atomic action。</li>
</ol>
<h2 id="3-composite-statechart-diagrams"><a href="#3-composite-statechart-diagrams" class="headerlink" title="3. composite statechart diagrams"></a>3. composite statechart diagrams</h2><ul>
<li>定义：有一个或多个重叠 statecharts 的状态图。</li>
</ul>
<h3 id="3-1-sequential-composite-statechart-diagram"><a href="#3-1-sequential-composite-statechart-diagram" class="headerlink" title="3.1 sequential composite statechart diagram"></a>3.1 sequential composite statechart diagram</h3><p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/4.png"></p>
<p>[理解]：上图的 substate 明显具有时序性。主要体现：abstract&#x2F;generalize states。</p>
<h3 id="3-2-concurrent-composite-statechart-diagram"><a href="#3-2-concurrent-composite-statechart-diagram" class="headerlink" title="3.2 concurrent composite statechart diagram"></a>3.2 concurrent composite statechart diagram</h3><p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/5.png"></p>
<p>主要用来体现多线程的行为。</p>
<h3 id="3-3-从-UML-上看-composite-状态图"><a href="#3-3-从-UML-上看-composite-状态图" class="headerlink" title="3.3 从 UML 上看 composite 状态图"></a>3.3 从 UML 上看 composite 状态图</h3><ol>
<li>（从外界）指向状态图的边框，意味着进入 initial state。</li>
<li>自状态图的边框指向（外界），意味着触发 exit actions。</li>
</ol>
<p><strong>上面是状态图，下面是活动图</strong></p>
<h2 id="4-activity-diagram"><a href="#4-activity-diagram" class="headerlink" title="4. activity diagram"></a>4. activity diagram</h2><p>与状态图的区别：推荐阅读：<a href="https://blog.csdn.net/u013201439/article/details/49821467">状态图与活动图的联系和区别</a></p>
<blockquote>
<p>状态图是描述某一对象的状态转化的，它主要展示的是对象的状态。描述的是一个对象的事情。从状态图中我们可以看出，对象在接受了事件刺激后，会做出什么样的反应。</p>
</blockquote>
<blockquote>
<p>活动图是描述系统在执行某一用例时的具体步骤的，它主要表现的是系统的动作，描述的是整个系统的事情。</p>
</blockquote>
<h3 id="4-0-活动图的应用场景"><a href="#4-0-活动图的应用场景" class="headerlink" title="4.0 活动图的应用场景"></a>4.0 活动图的应用场景</h3><ol>
<li>需要展示系统活动规律的场景。</li>
<li>并行工作流的建模中。</li>
</ol>
<h3 id="4-1-activity-x2F-action"><a href="#4-1-activity-x2F-action" class="headerlink" title="4.1 activity&#x2F;action"></a>4.1 activity&#x2F;action</h3><p>与状态图中 activities&#x2F;actions 的概念类似。</p>
<h3 id="4-2-transitions"><a href="#4-2-transitions" class="headerlink" title="4.2 transitions"></a>4.2 transitions</h3><ol>
<li>与状态图的 transitions 概念类似。</li>
<li>没有 internal transitions；</li>
<li>没有事件驱动的 actions；</li>
</ol>
<h3 id="4-3-一些特殊的-activities"><a href="#4-3-一些特殊的-activities" class="headerlink" title="4.3 一些特殊的 activities"></a>4.3 一些特殊的 activities</h3><ol>
<li>decision：多分支，每条分支都有自己的 guard condition；而且必须进入子分支中。</li>
<li>dead end activity：允许 non-terminating 的活动图。</li>
</ol>
<h3 id="4-4-synchronization-bar"><a href="#4-4-synchronization-bar" class="headerlink" title="4.4 synchronization bar"></a>4.4 synchronization bar</h3><blockquote>
<p>Combines two concurrent activities and re-introduces them to a flow where only one activity occurs at a time. Represented with a thick vertical or horizontal line.</p>
</blockquote>
<p><img src="/2018/11/11/UML%EF%BC%885%EF%BC%89/6.png"></p>
<ul>
<li>不指定同步条件时，默认要等所有进入的 transitions 发生后，才能进入。</li>
</ul>
<h2 id="5-package"><a href="#5-package" class="headerlink" title="5. package"></a>5. package</h2><ul>
<li>为了使用的方便，将 analysis classes 等打包的一种机制。</li>
<li>可以包含：<ol>
<li>analysis classes；</li>
<li>use-case realizations；</li>
<li>其他 package，建议 2~3 层即可。</li>
</ol>
</li>
<li>包依赖：简单、不解释。</li>
<li>shared classes：将此 classes 独立打包，让其他 package 依赖它。</li>
<li>命名空间：一个 package 对应一个命名空间。包内元素命名唯一。跨包访问时，要带上路径，举例：Package1::classname。</li>
<li>使用 <code>&lt;&lt;access&gt;&gt;</code>和<code>&lt;&lt;import&gt;&gt;</code>标记。</li>
<li>包可视化，同类，不赘述。</li>
<li>包的设计原则：高内聚、低耦合。</li>
<li>按照用途分类（分层或分区）：<ol>
<li>application-specific：不被其他包使用。</li>
<li>application-general：能被其他包共享。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（7）</title>
    <url>/2018/11/13/UML%EF%BC%887%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（7）"><a href="#面向对象系统分析与设计（7）" class="headerlink" title="面向对象系统分析与设计（7）"></a>面向对象系统分析与设计（7）</h1><h2 id="1-面向对象的六大设计原则"><a href="#1-面向对象的六大设计原则" class="headerlink" title="1. 面向对象的六大设计原则"></a>1. 面向对象的六大设计原则</h2><ol>
<li>单一职责，single responsibility principle,SRP<ul>
<li>一个类，只做一件事。</li>
</ul>
</li>
<li>开闭原则，open close principle，OCP<ul>
<li>对扩展开放，对修改封闭，保护既有系统。</li>
<li><strong>是 OO 设计的真正核心。</strong></li>
</ul>
</li>
<li>里氏替换原则，liskov substitution principle，LSP<ul>
<li>子类可以拓展父类的功能，但不能修改父类原有的功能。</li>
</ul>
</li>
<li>接口隔离原则，interface segregation principle，ISP<ul>
<li>接口间的依赖性要小；比如一个类要实现某功能时，如果接入接口 A 和接口 B，然而只有 A 的功能是必须的，但因为 A 和 B 的依赖性，接入 B 是完全没有必要的，修改的办法就是降低 A、B 间的依赖。</li>
</ul>
</li>
<li>迪米特原则，law of demeter，LOD<ul>
<li>陌生的类不要作为局部变量的形式出现在类的内部，耦合性会变高。</li>
</ul>
</li>
<li>DIP原则，dependency inversion principle。<ul>
<li>模块设计、细节和策略应该依赖于抽象，抽象的稳定性决定了系统的稳定性。</li>
<li>变量不应该持有指向具体类的指针或引用。</li>
<li>类不应该从具体类派生。</li>
<li>任何方法都不应该覆写它的任何基类中已经实现了的方法。</li>
</ul>
</li>
</ol>
<span id="more"></span>

<h2 id="2-用户界面设计"><a href="#2-用户界面设计" class="headerlink" title="2. 用户界面设计"></a>2. 用户界面设计</h2><h3 id="2-1-用户界面设计原则"><a href="#2-1-用户界面设计原则" class="headerlink" title="2.1 用户界面设计原则"></a>2.1 用户界面设计原则</h3><ol>
<li>布局：主要有 top、bottom、middle，要考虑 size、shape、输入框等</li>
<li>content awareness：大概指主题、信息之类的。</li>
<li>审美。</li>
<li>用户体验。</li>
<li>连贯性：满足用户期待、降低学习曲线等</li>
<li>不费力：从进入主页面到功能页面，建议不超过三层。</li>
</ol>
<h3 id="2-2-用户界面设计过程"><a href="#2-2-用户界面设计过程" class="headerlink" title="2.2 用户界面设计过程"></a>2.2 用户界面设计过程</h3><ol>
<li>应用场景开发<ul>
<li>考虑哪些步骤、UI、模板、information 等。</li>
</ul>
</li>
<li>接口结构的设计<ul>
<li>列出树状 menu 之类的工作。</li>
</ul>
</li>
<li>接口标准的设计<ul>
<li>列出 interface 的细节，包括 objects、actions、icons 等。</li>
</ul>
</li>
<li>接口模板设计<ul>
<li>包括 HTML 模板等。</li>
</ul>
</li>
<li>接口评估<ul>
<li>交互评估、使用测试等。</li>
</ul>
</li>
</ol>
<h3 id="2-3-设计使用指南"><a href="#2-3-设计使用指南" class="headerlink" title="2.3 设计使用指南"></a>2.3 设计使用指南</h3><ol>
<li>首先假设用户没有读过手册、没有经过培训等。</li>
<li>控制流程要清晰、便于理解。</li>
<li>避免错误。</li>
<li>保持语法一致性。</li>
<li>考虑添加快捷键。</li>
<li>图形化操作。</li>
</ol>
<h3 id="2-4-设计-input-和-output"><a href="#2-4-设计-input-和-output" class="headerlink" title="2.4 设计 input 和 output"></a>2.4 设计 input 和 output</h3><p>input 目标：尽可能简单地将信息传递到系统中。<br>output 目标：仅将 needed 的信息导出，考虑 report 的使用场景等。</p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>UML（6）</title>
    <url>/2018/11/12/UML%EF%BC%886%EF%BC%89/</url>
    <content><![CDATA[<h1 id="面向对象系统分析与设计（6）"><a href="#面向对象系统分析与设计（6）" class="headerlink" title="面向对象系统分析与设计（6）"></a>面向对象系统分析与设计（6）</h1><h2 id="1-系统设计"><a href="#1-系统设计" class="headerlink" title="1. 系统设计"></a>1. 系统设计</h2><ul>
<li>定义：将分析模型的逻辑结构加以实现前的准备过程。</li>
</ul>
<p>哪些工作内容：</p>
<ol>
<li>考虑非功能性需求的弊端；</li>
<li>考虑全局设计问题；</li>
<li>考虑实现的环境 —— implement environment；</li>
<li>补充 classes 的所有属性和操作；</li>
<li>将 implementation 的工作分成可执行的小块；</li>
<li>为 subsystems 间建立接口。</li>
</ol>
<p>当可以从“分析模式”平滑过渡到“设计模式”时（即无需大改时），就是开始系统设计的最佳时刻。</p>
<span id="more"></span>

<h3 id="1-1-设计的意义和标准"><a href="#1-1-设计的意义和标准" class="headerlink" title="1.1 设计的意义和标准"></a>1.1 设计的意义和标准</h3><p>上文列出的 6 项工作必须要在 implementation 前完成，所以不能跳过设计这一步骤。</p>
<ol>
<li>研究非功能性需求提高质量；</li>
<li>看重<strong>设计目标</strong>和<strong>扩展功能</strong>，而不是管理目标。</li>
<li>遵循的标准：外观标准、依赖标准、维护标准、开销标准等等。</li>
<li>考虑的范畴：<ul>
<li>数据的管理；</li>
<li>访问权限管理；</li>
<li>流程控制；</li>
<li>边界条件；</li>
</ul>
</li>
</ol>
<h3 id="1-2-设计-Tips："><a href="#1-2-设计-Tips：" class="headerlink" title="1.2 设计 Tips："></a>1.2 设计 Tips：</h3><ol>
<li>指定 admin 的用例，作为 start-up 和 shutdown。</li>
<li>指定 errors 的异常处理机制。</li>
</ol>
<h3 id="1-3-implement-environment"><a href="#1-3-implement-environment" class="headerlink" title="1.3 implement environment"></a>1.3 implement environment</h3><ul>
<li>要考虑在构建一个 system 时，技术和管理上所受到的限制。<ul>
<li>比如：系统运行环境问题、硬件&#x2F;软件问题、编程语言选择问题、参与人员问题等。</li>
</ul>
</li>
<li>策略：定位对 implement environment 的依赖，然后可以创建代理的方式（类似 JVM 的跨平台）来解决。</li>
</ul>
<h2 id="2-UP-设计过程"><a href="#2-UP-设计过程" class="headerlink" title="2. UP 设计过程"></a>2. UP 设计过程</h2><ol>
<li>设计 use-cases（PPT P21）</li>
<li>设计 classes（PPT P57）</li>
<li>设计 subsystems（PPT P75）</li>
</ol>
<h3 id="2-1-use-case-设计"><a href="#2-1-use-case-设计" class="headerlink" title="2.1 use-case 设计"></a>2.1 use-case 设计</h3><ol>
<li>确定要设计哪些类<ul>
<li>保持可追溯性：use-case 设计的实现 -&gt; use-case 分析的实现 -&gt; use-case</li>
</ul>
</li>
<li>增加说明：使用类图、非功能性的需求。</li>
</ol>
<p>其中 OO Design 的迭代过程：</p>
<ol>
<li>设计初步类图模型；</li>
<li>为每个用例设计一个 sequence diagram。<ul>
<li>开发初步的 sequence diagrams；</li>
<li>开发多层的 sequence diagrams。</li>
</ul>
</li>
<li>修改类图；<ul>
<li>修改方法名；</li>
<li>修改属性等；</li>
</ul>
</li>
<li>用 package 打包（或者分 subsystem、分层）等方式，按功能将类图设计分区。</li>
</ol>
<h4 id="2-1-1-设计初步类图模型"><a href="#2-1-1-设计初步类图模型" class="headerlink" title="2.1.1 设计初步类图模型"></a>2.1.1 设计初步类图模型</h4><ol>
<li>扩展 domain model class diagram。<ul>
<li>注：domain model 是指缩略版的类图，只有类名、属性名两种信息。不含 method、没有<code>+、-、#</code>等符号。</li>
<li>1）增加属性的 type 和初值。</li>
<li>2）增加可见性标识。</li>
</ul>
</li>
<li>详细设计。<ul>
<li>1）交互图实现指向性。</li>
<li>2）补足箭头，让其连贯起来。</li>
<li>3）每个类增加 method。</li>
</ul>
</li>
</ol>
<h4 id="2-1-2-设计初步-sequence-diagram"><a href="#2-1-2-设计初步-sequence-diagram" class="headerlink" title="2.1.2 设计初步 sequence diagram"></a>2.1.2 设计初步 sequence diagram</h4><p>初步 sequence diagram 的假设：</p>
<pre><code>1. perfect technology assumption。比如不考虑登录注销功能。
2. perfect memory assumption。比如不考虑存储问题。
3. perfect solution assumption。比如不考虑 Exception 分支。
</code></pre>
<h4 id="2-1-3-设计-multilayer-sequence"><a href="#2-1-3-设计-multilayer-sequence" class="headerlink" title="2.1.3 设计 multilayer sequence"></a>2.1.3 设计 multilayer sequence</h4><ol>
<li>修改 domain layer，其中加入 use-case controller 和 classes；</li>
<li>增加 data access layer。<ul>
<li>增加额外的数据访问类，作为外界数据库交互用途；</li>
<li>取消掉 perfect memory 假设。</li>
<li>职责分离。（以前是 controller 要实例化一个实体类，这个 instance 要求 DA 类去操作 instance 的属性去读数据库；增加 data access layer后：controller 可以直接要求 DA 类去实例化那个实体类，而且由 DA 类来完成读库，传初始值给 instance 等操作）</li>
</ul>
</li>
<li>增加 view layer。<ul>
<li>增加额外的 user-interface 类。比如增加 windows 类用来实现 actor 和 controller 之间的交互。</li>
<li>为每个用例增加 GUI 表格或者 Web 网页。</li>
</ul>
</li>
</ol>
<h4 id="2-1-4-修改类图"><a href="#2-1-4-修改类图" class="headerlink" title="2.1.4 修改类图"></a>2.1.4 修改类图</h4><ol>
<li>做到每层一个类图：<ul>
<li>view 层和 data access 层增加新类；</li>
<li>domain 层的 use-case controller 增加新类。</li>
</ul>
</li>
<li>时序图的 messages 增加 methods：<ul>
<li>构造方法；</li>
<li>getter 和 setter 方法；</li>
<li>用例特有的方法。</li>
</ul>
</li>
</ol>
<h4 id="2-1-5-打包分区"><a href="#2-1-5-打包分区" class="headerlink" title="2.1.5 打包分区"></a>2.1.5 打包分区</h4><ol>
<li>高级的 UML 图会将相关的类联系起来；</li>
<li>确认一个 system 的主要组成和依赖。</li>
<li>为每层确定最终的分区情况。</li>
<li>划分子系统、在 packages 中体现出层次性。</li>
</ol>
<h3 id="2-2-classes-设计"><a href="#2-2-classes-设计" class="headerlink" title="2.2 classes 设计"></a>2.2 classes 设计</h3><ul>
<li>前提：要设计的类，必须是能够被实现的类才行。</li>
<li>这些类出自两个地方：<ol>
<li>the problem domain：改进之前对类的分析；如果必要，可以将类划分为多个设计类。</li>
<li>the solution domain：一般的公用类库、框架等；实现一个系统的技术工具等。</li>
</ol>
</li>
</ul>
<h4 id="2-2-1-solution-domain"><a href="#2-2-1-solution-domain" class="headerlink" title="2.2.1 solution domain"></a>2.2.1 solution domain</h4><ol>
<li>如果是 boundary classes，要考虑指定的 user interface technologies。</li>
<li>如果是 entity classes，要考虑指定的 data management technologies。</li>
<li>如果是 control classes，要考虑：<ol>
<li>distribution issues：看需不需要分布式吧。</li>
<li>performance issues：考虑跟 boundary class 和 entity class 的兼容问题。</li>
<li>transaction issues：考虑是否需要事务管理技术。</li>
</ol>
</li>
</ol>
<h4 id="2-2-2-activities"><a href="#2-2-2-activities" class="headerlink" title="2.2.2 activities"></a>2.2.2 activities</h4><ol>
<li>完善 activities 的规格：<ol>
<li>补足属性、联结、操作等；</li>
<li>补足可见性等；</li>
<li>对操作增加约束，比如先决条件、后发动作等。</li>
<li>异常等。</li>
</ol>
</li>
<li>选出可重用的组件：<ol>
<li>类库；</li>
<li>对非功能性需求的一般设计机制（generic design mechanisms）：持久性、分布式、安全性、事务管理等。</li>
</ol>
</li>
<li>重建设计模式：<ol>
<li>realize associations：[理解]大概指可变性、适应性。</li>
<li>利用继承、代理等实现重用。</li>
</ol>
</li>
<li>优化设计模式：<ol>
<li>修改访问路径；</li>
<li>拆分 classes；</li>
<li>缓存；</li>
<li>延迟计算。</li>
</ol>
</li>
</ol>
<h4 id="2-2-3-优秀的类的设计"><a href="#2-2-3-优秀的类的设计" class="headerlink" title="2.2.3 优秀的类的设计"></a>2.2.3 优秀的类的设计</h4><ol>
<li>完整、充足：无论什么 users 想做的都能满足；</li>
<li>primitiveness：operations 采用最简单最省力的方式；</li>
<li>高内聚</li>
<li>低耦合</li>
</ol>
<h4 id="2-2-4-generic-design-mechanisms"><a href="#2-2-4-generic-design-mechanisms" class="headerlink" title="2.2.4 generic design mechanisms"></a>2.2.4 generic design mechanisms</h4><p>针对常见的需求，一些好的实践。</p>
<ol>
<li>设计模型，同义词：example。<ul>
<li>针对 object 和 RDBMS 对应的情况，优秀的做法是：<ol>
<li>一个 class 对应一张表；</li>
<li>一个 属性对应表中一个字段；</li>
<li>主键对应 objectId；</li>
<li>每个 object 对应表中一行；</li>
<li>classes 间的 association 与表中关系对应；</li>
<li>继承关系，也在表中对应。</li>
</ol>
</li>
</ul>
</li>
<li>框架，不解释。</li>
</ol>
<h3 id="2-3-subsystems-设计"><a href="#2-3-subsystems-设计" class="headerlink" title="2.3 subsystems 设计"></a>2.3 subsystems 设计</h3><p>将系统拆分成子系统，便于更好的管理。</p>
<p>子系统中可以包括：</p>
<ol>
<li>设计类；</li>
<li>用例的实现；</li>
<li>其他子系统；</li>
<li>接口。</li>
</ol>
<p>Tips：用例可以设计成子系统；子系统可以被当做交互图。</p>
<h4 id="2-3-1-子系统的分区-x2F-分层"><a href="#2-3-1-子系统的分区-x2F-分层" class="headerlink" title="2.3.1 子系统的分区&#x2F;分层"></a>2.3.1 子系统的分区&#x2F;分层</h4><ol>
<li>可以递归的划分子系统；</li>
<li>每层为高层提供服务，以及使用下层的服务；</li>
<li>层次结构：<ol>
<li>closed layered architecture: 一般指上下层的调用，不可以跨层。较常见。</li>
<li>open layered architecture: 可跨层调用。耦合度高，较少见。</li>
</ol>
</li>
<li>子系统分区：<ul>
<li>一层可分多个子系统；</li>
<li>层间存在 peer to peer 的服务。</li>
</ul>
</li>
</ol>
<h4 id="2-3-2-子系统接口"><a href="#2-3-2-子系统接口" class="headerlink" title="2.3.2 子系统接口"></a>2.3.2 子系统接口</h4><ul>
<li>通常叫做 API</li>
<li>包括：操作名、参数及参数类型、返回值；</li>
<li>Tips：	<ol>
<li>如果有一个依赖指向这个子系统，那么这个子系统有必要提供一个接口。</li>
<li>使用接口的 client，与这个子系统的实现是 independent 的。</li>
</ol>
</li>
</ul>
<h3 id="2-4-deployment-model"><a href="#2-4-deployment-model" class="headerlink" title="2.4 deployment model"></a>2.4 deployment model</h3><ul>
<li>定义：描述一个 system 是如果在物理上部署&#x2F;安排的。</li>
<li>deployment diagram 要展示的有：<ol>
<li>nodes：一般指计算资源（处理器等）；</li>
<li>relationships：一般指 nodes 的连接方式。</li>
</ol>
</li>
<li>一般的分布式部署采用三层结构。<ol>
<li>1）clients：用户接口。</li>
<li>2）database functionality：数据库的功能。</li>
<li>3）business&#x2F;application logic：业务逻辑。</li>
<li>[理解]其实是一种 server&#x2F;client 结构，可以当做 view 层、业务层、DAO 层来看待，每层都可独立替代。</li>
</ol>
</li>
</ul>
<h3 id="2-5-检查设计"><a href="#2-5-检查设计" class="headerlink" title="2.5 检查设计"></a>2.5 检查设计</h3><p>一个大型 project 的开发会涉及很多人员甚至团队，所以要在设计的最后统一命名风格、统一 OO 的规矩、消除冗余类等等。检查工作要持续到 project 的始末。</p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>ZGC 特性解读</title>
    <url>/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<h1 id="ZGC-特性解读"><a href="#ZGC-特性解读" class="headerlink" title="ZGC 特性解读"></a>ZGC 特性解读</h1><p>英文原文地址：<a href="http://dinfuehr.github.io/blog/a-first-look-into-zgc/">A FIRST LOOK INTO ZGC</a></p>
<p>网友译文：<a href="https://blog.csdn.net/ly262173911/article/details/83510307">ZGC窥探</a></p>
<p> ZGC好文推荐: <a href="http://www.dataguru.cn/article-14107-1.html">Oracle 发布全新的 Java 垃圾收集器 ZGC</a> </p>
<p><a href="https://blog.csdn.net/qq_42882671/article/details/82622328">一语道破Java 11的ZGC为何如此高效</a></p>
<p><a href="https://www.liangzl.com/get-article-detail-27041.html">The Z Garbage Collector (ZGC) 【2】</a></p>
<p>Per 大大写的官方 PPT：<a href="http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf">The Z Garbage Collector An Introduction</a></p>
<span id="more"></span>



<p>总结如下：</p>
<ol>
<li>ZGC 目标：减少停顿时间（号称10ms 以下）、压缩堆（移动存活对象，可能伴随 STW）</li>
<li>针对 STW 问题，可以采取以下措施：</li>
<li>多线程执行压缩（整理）——parallel compaction</li>
<li>整理分阶段进行，增量式——incremental compaction</li>
<li>并行整理，不进行 STW 或仅停顿少量时间——concurrent compaction</li>
<li>不整理</li>
<li>ZGC 采用 concurrent compaction 的方式减少 STW，但 GC 线程与 app 线程并发的方式又存在很多问题：① 刚整理过的内存地址，可能又被别的线程读写；② 大量指向老地址的引用需要更新到新地址。</li>
</ol>
<h3 id="ZGC-全过程速览"><a href="#ZGC-全过程速览" class="headerlink" title="ZGC 全过程速览"></a>ZGC 全过程速览</h3><p><img src="/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/1.png"></p>
<p>有不懂的名词，后文会解释，速览的内容参考自 <a href="https://cloud.tencent.com/developer/article/1185162">ZGC回收器到底有多变态？</a>。</p>
<ol>
<li><p>第一处 STW，只标记 GC Roots 直接连通的对象（为方便理解，笔者把它们记为 direct objects）。</p>
</li>
<li><p>第一处 Concurrent，把全部可达的对象全部标记出来（为方便理解，笔者把它们记为active objects）。</p>
</li>
<li><p>第二处 STW，也就是 Pause mark end，主要用来处理一些边缘 case，比如弱引用等。</p>
</li>
<li><p>第二处 Concurrent， 也就是 Concurrent prepare for reloc，会选择出pages 放入 Relocation Set中，这些 pages 会对应自己的 Forwarding table。</p>
</li>
<li><p>第三处 STW，也就是 Pause Relocate Start，会扫描direct objects，一旦发现其中某对象是属于Relocation set 中时，会将该对象转移到新的 Region 中，并在 Forwarding table 中做个记录。</p>
</li>
<li><p>第三处 Concurrent，也就是 Concurrent Relocate，会将除 direct objects 以外的剩余 active objects 存入新的 Region 中，完成后，Relocation set 中的 pages 就被腾空了。至于对应的 Forwarding table ，会在下一次 GC cycle 时被删。</p>
</li>
</ol>
<h3 id="ZGC-的特性解读"><a href="#ZGC-的特性解读" class="headerlink" title="ZGC 的特性解读"></a>ZGC 的特性解读</h3><ol>
<li>GC barriers，通常是读屏障，不同于 CPU 的内存屏障</li>
</ol>
<ul>
<li>一般的 GC 需要的是写屏障，但是 ZGC 仅需要读屏障。</li>
<li>写屏障目的是为了记录新引用（一个引用指向新生代对象，并该引用存储在老年代对象中，这个老年代对象叫 remebered sets，数据结构中由卡表实现，使用卡表减少老年代的全堆内存扫描）。写屏障发现了类似<code>someObject.field = otherObject</code>类似的声明时，就会在该老年代对象中存储引用。minor GC时，垃圾收集器会检查卡表，从而找到存活的新生代对象。参考：<a href="https://segmentfault.com/a/1190000007726689">卡表、写屏障、脏卡</a></li>
<li>读屏障：跟写屏障类似，但在 GC 算法中很少被采用。读屏障的触发条件：仅发生在从堆上加载一个对象引用时，后续使用该引用不会触发读屏障。读屏障的任务是① 检查引用的状态，② 并在将引用返回给 app 之前执行一些任务。<ul>
<li>比如在 ZGC 中，会对加载的引用进行测试，② 查看是否设置了某些位（查看着色指针，是“bad color”还是“good color”），② 如果是“bad color”，要走“slow path”，并执行特定的操作（比如mark、relocate、remap 等操作），将“bad color ”转变为“good color”，这样一来，下次load 时就可以走“fast path”了。下文有对读屏障较详细的介绍。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【扩展知识】卡表：大致的标出可能存在老年代到新生代引用的内存区域。减少老年代的全堆内存扫描。该技术将整个堆划分为512字节的卡，维护一个卡表用来存储每张卡的标识位。如果某个标识位存在有指向新生代对象的引用，就认为这张卡是脏的。进行 Minor GC 的时候，就不用扫描整个老年代，在卡表中寻找脏卡，将脏卡中的对象加入 Minor GC 的 GC Roots 中。完成所有脏卡的扫描后，JVM 会将所有的脏卡标识位清零。</p>
</blockquote>
<ol start="2">
<li>Reference coloring 指针着色</li>
</ol>
<p>	</p>
<ul>
<li><p>这个技术就是为了让指针上携带一些信息(Java 的引用信息)。</p>
</li>
<li><p>64位系统（ZGC 仅支持64位）中一个引用通常是64位的，但只有47位用来表示“虚拟内存的地址”（因为硬件的限制，目前最多支持48位），前42位是对象的内存地址（一般指相对于 source code 的一个 offset，理论上可以指示4TB的物理空间），剩下分别代表：<code>finalizable</code>、<code>remapped</code>、<code>marked1</code>、<code>marked0</code>（这四位被称为 metadata），然后再保留1位待用。</p>
</li>
<li><p>metadata 放在引用中会造成引用及解引用时开销变大，所以 ZGC 使用一种小技巧来避免这种开销（以及平台兼容问题）：称为<strong>multi-mapping</strong>的过程（这个 multi-mapping 就是用来清理颜色的，相当于给 ZGC 清理小尾巴，在 ZGC 的核心流程中不起作用），参考：<a href="https://www.jianshu.com/p/6ba7f46c7991">使用ZGC的时候，为什么JVM堆内存地址空间被限制在42位</a>，即使用 marked0、marked1、remapped，计算方法为：</p>
<blockquote>
<p>for marked0 : (0b0001 &lt;&lt; 42) | x</p>
<p>for marked1 : (0b0010 &lt;&lt; 42) | x</p>
<p>for remapped : (0b0100 &lt;&lt; 42) | x</p>
</blockquote>
<ul>
<li>简单说就是，分别取 逻辑地址 x 的第43、44、45位的数字赋给 marked0、marked1、remapped（三个只有一个被置位）。(注： 这么理解可能有点问题？)</li>
<li>分别代表[4TB,8TB],[8TB,12TB],[16TB,20TB]三个逻辑地址区间，这三个区间的逻辑地址都可以映射到同一个物理地址上（只要表示物理地址的42位相同）。</li>
<li>四位分别表示对象在 ZGC 中的四种状态：<ul>
<li>如果是 finalizable，说明只能通过Finalizer来访问到，其他的途径已无法访问。</li>
<li>如果是 remapped，说明不要指向 relocation set。</li>
<li>marked0、marked1表示已被标记。</li>
<li>mark、relocate、remap属于”bad color”，分别对应标记阶段、重分配阶段、读屏障更新地址阶段。</li>
<li>repair、heal 属于”good color”。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>ZGC pages、物理内存、虚拟内存</p>
<ol>
<li>ZGC 将内存分为小的 regions ，称为 pages，特点：<ol>
<li>pages 大小不一，一般都是2MB 的倍数。</li>
<li>有常规的 pages type，：small(2MB，进入对象限制256KB),medium(32MB，进入对象限制4MB),large(2MB 的若干倍，大于4MB 对象进入，实际上允许比 medium 还小)。</li>
</ol>
</li>
<li>ZGC 的虚拟内存最大能到4TB，但是物理内存受限于 JVM 的 maximum heap size 大小，ZGC 上一个固定大小的页，要同时确定物理内存跟虚拟内存。</li>
<li>ZGC 使用<code>memfd_create</code>创建物理内存；使用<code>ftruncate</code>扩展物理内存(最多可到最大堆尺寸)，使用<code>mmap</code>与虚拟内存地址相连。</li>
</ol>
</li>
<li><p>ZGC 的标记过程和对象重分配过程(统称 GC 循环)</p>
<ol>
<li>首先标记所有的可达对象（使用 mark0 和 mark1 着色）：每个 page 上有一个 live map(使用 bitmap 数据结构)，记录 page 中的各个对象是否可达，以及记录是否为 final-reachable(带有 finalize 方法的对象)。</li>
<li>标记时，使用读屏障(load-barrier in application-threads)，将未标记的引用放入此 thread-local 的标记缓存区中（只负责 push，不负责遍历）。<ol>
<li>标记后会得到什么？会拿到一个 relocation set，里面是一系列的 page，这些 page 会包含最多的垃圾(经过一系列复杂算法选出的)。relocation set 中的每个 page 会对应一个 forwarding table(hashmap数据结构)。其实就是新旧地址的映射，key 是原 addr，value 是新 addr。</li>
<li>当此标记缓存区满了时，被 GC 线程接管，GC 线程会① 负责遍历缓存区中所有的引用（遍历结束，意味着重分配过程也已完成），② 更新 bitmap。</li>
</ol>
</li>
<li>标记完成后，我们已经知道了哪些对象是可达的了。之后，ZGC 会① 遍历relocation set，②重分配其中的对象们。重分配可以由用户线程或者由 GC 线程进行，若发生这两种线程对同一个对象同时重分配，那么先到先得，会通过 CAS 方式进行抢占。<ol>
<li>为什么要重分配？因为要移动部分活动对象（从上文中的 relocation set中找，因为里面的存活对象少，所以移动成本低），用来释放部分堆内存。</li>
<li>用户线程为什么会参与重分配？解释：发生读屏障堆加载引用时触发，用户线程试图在 GC 重分配前加载它们，这样应用程序看到的所有引用都是更新后的，查看文末的逻辑图更容易看懂。</li>
<li>GC 线程则扫描哪些存活对象，并开始标记。</li>
<li>GC 线程遍历之后，可能仍有某些对象需要重分配，这些对象可能会在触发读屏障时被处理，也可能留待下次标记时再处理。<ol>
<li>下次标记时，如果发现了没有重分配的引用，那么会先将它重分配，然后标记为活动状态。</li>
<li>使用两个 mark 位来实现上面的说法</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>读屏障。java 进行<code>obj.field</code>时都会触发读屏障（field 不是基础数据类型），在 ZGC 中，读屏障用来① 标记对象，② 重分配引用地址。</p>
<ol>
<li><p>GC 所处阶段被保存在一个全局变量<code>ZGlobalPhase</code>中。</p>
</li>
<li><p><code>ZAddressGoodMask</code>和<code>ZAddressBadMask</code>两个全局变量是同时被修改的，一般在刚进入标记阶段时，或者刚进入重分配阶段时。前者含义是当前对象已被 marked&#x2F;remapped&#x2F;relocated，无需额外操作，后者含义是需要额外的操作。</p>
</li>
<li><pre><code class="java">               GoodMask         BadMask          WeakGoodMask     WeakBadMask
             --------------------------------------------------------------
Marked0        001              110              101              010
Marked1        010              101              110              001
Remapped       100              011              100              011
</code></pre>
</li>
</ol>
</li>
<li><p>STW，ZGC 也伴随着少量的 STW 过程：</p>
<ol>
<li>初始标记时，需要标记所有的 root set，此时进行短暂的 STW。</li>
<li>标记结束时，GC 需要清空所有的 thread-local 的标记缓存区，如果 GC 发现一个大的未标记的子图，那么将 STW（中断”标记结束阶段”），返回并发标记阶段，直到整个图被遍历，然后重新开始”标记结束阶段”。</li>
<li>刚进入重分配阶段时，因为要重新分配根节点，所以需要 STW。</li>
</ol>
</li>
</ol>
<blockquote>
<p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p>
<p>———— <a href="https://blog.csdn.net/qq_41790443/article/details/82953853">R 大</a></p>
</blockquote>
<hr>
<p><img src="/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/2.png"></p>
<p>看该图，当应用程序访问一个引用，并触发了load barrier时，参考<a href="https://www.jqhtml.com/33435.html">网友介绍 ZGC</a>：</p>
<ol>
<li>首先检查着色指针的Remap位置</li>
<li>如果Remap &#x3D; 1，不用做任何事，返回引用</li>
<li>如果Remap &#x3D; 0，判断该引用是否在relocation set中</li>
<li>Remap &#x3D; 0，不在relocation set中：直接返回引用</li>
<li>Remap &#x3D; 0，在relocation set中，判断是否已经relocate</li>
<li>Remap &#x3D; 0，在relocation set中，已经relocate：更新引用至新地址，返回</li>
<li>Remap &#x3D; 0，在relocation set中，还未relocate：relocate该对象，返回更新过的reference</li>
<li>以上逻辑都完成后，应用程序才会拿到引用，此时的引用是更新之后的。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>ZGC</tag>
      </tags>
  </entry>
  <entry>
    <title>akka 核心知识梳理</title>
    <url>/2019/09/05/akka-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="Akka-核心知识梳理"><a href="#Akka-核心知识梳理" class="headerlink" title="Akka 核心知识梳理"></a>Akka 核心知识梳理</h1><p>本文参考自 segmentfault 中的 <a href="https://segmentfault.com/blog/akka">JVM 并发框架 Akka 专栏</a>，此专栏质量非常高，推荐！</p>
<p>以下是我对核心知识的梳理：</p>
<span id="more"></span>



<h2 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h2><ol>
<li><p>Actor 模型</p>
<ol>
<li><p><strong>是一种比线程还要轻量级的时间处理模型</strong>，文中说 1GB 可以容纳百万级别个 Actor，算了一下，一个 Actor 占 1KB 内存？</p>
</li>
<li><p><strong>是一种异步、非阻塞、高性能的事件驱动的编程模型</strong>。</p>
<ol>
<li><strong>异步</strong>：每一个 Actor 都有一个 MailBox 用来收件，假设存在ActorA、ActorB，A 向 B 的 mailBox 发了条 message，然后 A 就不管了，也不需要等回复；B 对 mailBox 中来自 A 的 message 进行处理后，B 会向 A 的 mailBox 发一条消息，这条消息就相当于 response 了。这么看来，Actor 的 send 和 receive 消息就是异步的了。</li>
<li><strong>非阻塞</strong>：MailBox 接收消息允许并发，对消息的 response 也是异步进行的，所以非阻塞。</li>
<li><strong>高性能</strong>：第一：每个 Actor 对自己的 MailBox 中消息的处理是串行的（虽然接收消息允许并发，MailBox 的数据结构见下文），所以没有共享数据的困扰（共享数据可能涉及到锁形式、锁粒度选取等各种问题，初学程序员往往不能很好解决这些问题）。第二：Actor 是非常轻量级的，程序中允许有许多个 Actor，所以我们要做的就是将相应的并发事件尽可能拆分成一个小的事件，再配合 Actor 的异步特性，实现高性能。</li>
</ol>
</li>
<li><p><strong>是一种并发模型的封装，更高层面的抽象</strong>。</p>
<ol>
<li><p>可以看一这篇详细理解Actor：<a href="https://segmentfault.com/a/1190000010112122">Actor解决了什么问题？</a>，精华：</p>
</li>
<li><blockquote>
<p>java 中，两个线程调用同一个方法，但被调用的对象并不能保证其封装的数据发生了什么，两个调用的方法指令可以任意方式的交织，无法保证共享变量的一致性。</p>
<p>所以一般的解决办法是给方法加锁，但是加锁代价昂贵而且容易出现死锁。本地加锁已经很慢了，如果是分布式环境，加上分布式锁效率又要低上几个量级。</p>
</blockquote>
</li>
<li><blockquote>
<p>java 中调用堆栈来进行任务的执行，比如线程将任务委托给后台，并把任务添加到一个内存位置，然后后台起另外一个线程进行任务执行，从该内存位置上选取任务执行。这个过程涉及到两个线程，一个是调用者线程，另一个是执行者线程。那么问题来了，执行者线程完成任务的通知该怎么告知调用者线程呢？如果任务发生了异常，由执行者线程处理异常合理不合理呢？不合理，因为当执行者线程出现异常时，不确定该由谁来重新线程并保存线程之前的状态。而且可能因执行者线程的异常，异常逐级上传时导致调用者线程所共享的任务队列状态全部丢失。</p>
</blockquote>
</li>
<li><blockquote>
<p>如果想实现高并发且高效性能的系统，线程必须将任务有效率的委托给别的线程执行以至不会阻塞，这种任务委托的并发方式在分布式的环境也适用。所以 java 中的高并发模型需要引入错误处理和失败通知机制。</p>
</blockquote>
</li>
<li><blockquote>
<p>Actor 模型采用消息机制，发送消息的方式不会将发送消息方的执行线程转换为具体的任务执行线程。Actor可以不断的发送和接收消息但不会阻塞。这种方式与方法调用方式最大的区别就是没有返回值。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
</li>
<li><p>ActorSystem</p>
<ol>
<li>对 Actor 进行统一调度，主要做<strong>①管理调度、②配置相关参数、③日志</strong><ol>
<li><strong>管理调度</strong>：ActorSystem 做的就是分拆任务，直到一个任务小到可以被完整处理，然后交给 Actor。Actor 就像多叉树一样（也类似文件系统，很容易确认 Actor 具体位置，所以是天生的分布式），有父 Actor，有子 Actor。父 Actor 负责给子级 Actor 分配<strong>资源、任务，并管理其生命状态</strong>。最下层 Actor，也就是叶子节点的 Actor 就是执行具体逻辑的单元。</li>
<li><strong>配置相关参数</strong>：根据配置文件的内容，加载相应的环境（比如日志输出级别等），并应用到<strong>整个 ActorSystem</strong> 中（lee 理解：配置单位是 ActorSystem 级别的）。</li>
<li><strong>日志功能</strong>：因为 Akka 的高容错性、以及持久化的需求，所以 ActorSystem 拥有完善的日志记录。</li>
</ol>
</li>
</ol>
</li>
<li><p>ActorRef，别名：Actor 引用（lee 注：这两个概念并不一样，但在这里本人不做区别，因为没必要）</p>
<ol>
<li>每一个 Actor 都有自己唯一的 ActorRef，ActorRef 可以看做是 Actor 的代理，接收发送消息其实都是由 ActorRef 代劳的。</li>
</ol>
<p>  <img src="/2019/09/05/akka-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/actorRef.png"></p>
<ol start="2">
<li><p>新建 ActorRef &#x2F; 拿到已存在 ActorRef 的方式</p>
<ol>
<li>用 ActorSystem.actorOf</li>
<li>用 ActorContext.actorOf</li>
<li>路径拿到已存在的 ActorRef</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Message</span></span>&#123;<span class="keyword">val</span> content: <span class="type">String</span>&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Business</span>(<span class="params">content: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Message</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  方法一：ActorSystem.actorOf 创建 ActorRef</span></span><br><span class="line"><span class="comment">// 注： 需要提前定义好 BossActor</span></span><br><span class="line"><span class="keyword">val</span> actorSystem = <span class="type">ActorSystem</span>(<span class="string">&quot;company-system&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> bossActor = actorSystem.actorOf(<span class="type">Props</span>[<span class="type">BossActor</span>],<span class="string">&quot;boss&quot;</span>)</span><br><span class="line">bossActor ! <span class="type">Business</span>(<span class="string">&quot;Fitness industry has great prospects&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：ActorContext.actorOf 创建 ActorRef</span></span><br><span class="line"><span class="comment">// 注： 需要提前定义好 ManagerActor</span></span><br><span class="line"><span class="keyword">val</span> managerActors = (<span class="number">1</span> to <span class="number">3</span>).map(i =&gt; context.actorOf(<span class="type">Props</span>[<span class="type">ManagerActor</span>],<span class="string">s&quot;manager<span class="subst">$&#123;i&#125;</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：由路径取得已存在的 ActorRef，甚至父 Actor：*Actor.actorPath </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>路径</strong>：示例<code>/user/boss</code>，根守护者<code>/</code>，然后是下级 Actor：user，再下级 Actor：boss。</p>
<ol>
<li>由路径可以找到具体 Actor 的位置，上面示例的完整位置是：<code>akka://company-system/user/boss</code>，如果是远程 akka，那么地址就会变成<code>akka.tcp://company-system/user/boss</code>，或者是 akka.udp 开头等。</li>
<li>如果使用了第三方插件，远程调用地址会有另外的写法。</li>
</ol>
</li>
</ol>
</li>
<li><p>监管：就是容错，主要对系统环境错误、异常时的错误恢复</p>
<ol>
<li><p>监管者：Actor 都是监管者（甚至<code>/</code>是顶级 Actor 的监管者）</p>
</li>
<li><p>主要执行“父监管”的形式</p>
</li>
<li><p>系统创建时会至少启动三个 Actor：<code>/</code>、<code>/user</code>、<code>/system</code>。user、system 都是顶级 Actor，顶级 Actor 还有：deadLetters、temp、remote</p>
<ol>
<li>user：用户创建的actor 放在此子树下，比如<code>ActorSystem.actorOf</code>创建的</li>
<li>system：系统创建的 actor 放在此子树下，比如日志 actor<ol>
<li>对除了<code>ActorInitializationException</code>和<code>ActorKilledException</code>之外的 Exception 无限执行重启。</li>
</ol>
</li>
<li>deadLetters：死信 actor，发往不存在或不存活的 actor 的<strong>信息</strong>会被重定向到这里</li>
<li>temp：短时 actor，比如<code>ActorRef.ask</code>用到的</li>
<li>remote：存放一些 actor，这些 actor 的监管者是远程 actorRef</li>
</ol>
</li>
<li><p>监管策略：恢复下属、重启下属、永久停用下属、升级失败（沿监管树向上传递失败，由此失败自己），比如下面自定义的策略：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> supervisorStrategy =</span><br><span class="line">   <span class="type">OneForOneStrategy</span>(maxNrOfRetries = <span class="number">10</span>, withinTimeRange = <span class="number">1</span> minute) &#123;</span><br><span class="line">     <span class="keyword">case</span> _: <span class="type">ArithmeticException</span> =&gt; <span class="type">Resume</span>  <span class="comment">//恢复</span></span><br><span class="line">     <span class="keyword">case</span> _: <span class="type">NullPointerException</span> =&gt; <span class="type">Restart</span> <span class="comment">//重启</span></span><br><span class="line">     <span class="keyword">case</span> _: <span class="type">IllegalArgumentException</span> =&gt; <span class="type">Stop</span> <span class="comment">//停止</span></span><br><span class="line">     <span class="keyword">case</span> _: <span class="type">Exception</span> =&gt; <span class="type">Escalate</span>  <span class="comment">//向上级传递</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>自定义监管策略时，需要重写<code>supervisorStrategy</code>方法，而且需要指定采用策略应用范围：<code>OneForOneStrategy</code>或<code>AllForOneStrategy</code>，前者策略只会用在发生故障的子 actor 上，后者策略应用到所有的子 actor 上，<strong>一般都会用前者</strong>。</li>
</ul>
</li>
</ol>
</li>
<li><p>Akka 共享内存</p>
<ol>
<li>通过通讯实现共享内存，而不是通过共享内存实现通讯<ol>
<li>java 的共享内存是多个线程经历获取锁、操作内存，释放锁的过程，内存值就是多线程的通讯信息。</li>
<li>akka 的 actor 机制，就是将操作内存的机制进行了一层封装，操作共享内存的动作变成了消息的接收和发送，actor 利用本身串行处理消息的机制来保证内存的一致性。</li>
</ol>
</li>
<li>Akka 的这种机制还需要满足：消息的发送必须先于消息的接收。<ol>
<li>如果消息对象未初始化完整，Actor 收到的消息会不完整，接收者可能接受到不正确的消息，导致发生奇怪的异常。</li>
</ol>
</li>
</ol>
</li>
<li><p>Actor 的 Mailbox</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mailbox 的数据结构</span></span><br><span class="line"><span class="keyword">private</span>[akka] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mailbox</span>(<span class="params">val messageQueue: <span class="type">MessageQueue</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">ForkJoinTask</span>[<span class="type">Unit</span>] <span class="keyword">with</span> <span class="type">SystemMessageQueue</span> <span class="keyword">with</span> <span class="type">Runnable</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mailbox 内部的 run 方法</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isClosed) &#123; <span class="comment">//Volatile read, needed here</span></span><br><span class="line">        processAllSystemMessages() <span class="comment">//First, deal with any system messages</span></span><br><span class="line">        processMailbox() <span class="comment">//Then deal with messages</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      setAsIdle() <span class="comment">//Volatile write, needed here</span></span><br><span class="line">      dispatcher.registerForExecution(<span class="keyword">this</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mailbox.Status ,由 volatie 保证可见性的 int 变量，使用 CAS 方法修改</span></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">currentStatus</span></span>: <span class="type">Mailbox</span>.<span class="type">Status</span> = <span class="type">Unsafe</span>.instance.getIntVolatile(<span class="keyword">this</span>, <span class="type">AbstractMailbox</span>.mailboxStatusOffset)</span><br><span class="line"></span><br><span class="line"><span class="comment">// processMailbox() 方法</span></span><br><span class="line"><span class="meta">@tailrec</span> <span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">processMailbox</span></span>(</span><br><span class="line">    left:       <span class="type">Int</span>  = java.lang.<span class="type">Math</span>.max(dispatcher.throughput, <span class="number">1</span>),</span><br><span class="line">    deadlineNs: <span class="type">Long</span> = <span class="keyword">if</span> (dispatcher.isThroughputDeadlineTimeDefined == <span class="literal">true</span>) <span class="type">System</span>.nanoTime + dispatcher.throughputDeadlineTime.toNanos <span class="keyword">else</span> <span class="number">0</span>L): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span> (shouldProcessMessage) &#123;</span><br><span class="line">      <span class="keyword">val</span> next = dequeue()  <span class="comment">//取出下一条消息</span></span><br><span class="line">      <span class="keyword">if</span> (next ne <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">Mailbox</span>.debug) println(actor.self + <span class="string">&quot; processing message &quot;</span> + next)</span><br><span class="line">        actor invoke next</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">Thread</span>.interrupted())</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">InterruptedException</span>(<span class="string">&quot;Interrupted while processing actor messages&quot;</span>)</span><br><span class="line">        processAllSystemMessages()</span><br><span class="line">        <span class="keyword">if</span> ((left &gt; <span class="number">1</span>) &amp;&amp; ((dispatcher.isThroughputDeadlineTimeDefined == <span class="literal">false</span>) || (<span class="type">System</span>.nanoTime - deadlineNs) &lt; <span class="number">0</span>))</span><br><span class="line">          processMailbox(left - <span class="number">1</span>, deadlineNs) <span class="comment">//递归处理下一条消息</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol>
<li><p>mailBox 中维护了一个messageQueue 的消息队列，并继承了 ForkJoinTask 任务执行类，以及 Runnable 接口。</p>
</li>
<li><p>消息队列保证了消息执行的异步性</p>
</li>
<li><p>processMailbox 方法采用递归的方式逐条取消息并处理。</p>
</li>
<li><p>再深入理解一下下面这张图：</p>
<p><img src="/2019/09/05/akka-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/processMailbox.png"></p>
</li>
</ol>
</li>
<li><p>Scala 中的 Future</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Future 基础用法</span></span><br><span class="line"><span class="keyword">val</span> fut = <span class="type">Future</span> &#123;</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fut onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>(r) =&gt; println(<span class="string">s&quot;the result is <span class="subst">$&#123;r&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">&quot;some Exception&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(<span class="string">&quot;I am working&quot;</span>)</span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//console:</span></span><br><span class="line">  <span class="comment">// I am working</span></span><br><span class="line">  <span class="comment">// the result is 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Future 高级用法：多个 Future 组合</span></span><br><span class="line"><span class="keyword">val</span> fut1 = <span class="type">Future</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;enter task1&quot;</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">2000</span>)</span><br><span class="line">    <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> fut2 = <span class="type">Future</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;enter task2&quot;</span>)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">1000</span>)</span><br><span class="line">    <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    v1 &lt;- fut1</span><br><span class="line">    v2 &lt;- fut2</span><br><span class="line">&#125; <span class="keyword">yield</span> println(<span class="string">s&quot;the result is <span class="subst">$&#123;v1 + v2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//console:</span></span><br><span class="line">	<span class="comment">//enter task1</span></span><br><span class="line">  <span class="comment">//enter task2</span></span><br><span class="line">  <span class="comment">//the result is 6</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>Akka persistence.</p>
<ol>
<li><p>需要持久化的 Actor 都要继承<code>PersistentActor</code>并实现三个属性：<code>persistenceId</code>、<code>receiveCommand</code>、<code>receiveRecover</code>。</p>
<ol>
<li>唯一 id。</li>
<li>正常处理消息逻辑（跟普通 actor 相似）：可以在这里实现 persist 方法，做出<code>saveSnapshot</code>或者别的持久化动作。</li>
<li>重启恢复时的执行逻辑：更新状态、或者快照恢复 actor 等动作。</li>
</ol>
</li>
<li><p>持久化方法：<code>persist</code>和<code>persistAll</code>，参数都是持久化事件，以及持久化的后续处理逻辑。</p>
</li>
<li><p>还有两个关键概念：<code>Journal</code>,<code>Snapshot</code>，前者是持久化事件，后者是 actor 快照。</p>
</li>
<li><p>Akka persistence 使用了CQRS（Command Query Responsibility Segregation）架构设计的理念。核心：</p>
<ol>
<li><p>写操作经系统初步处理后生成一个事件 event，会立刻发起 response，但真正执行的写动作是异步的。</p>
</li>
<li><p>事件 event 会先进行持久化，所以一旦执行写动作发生异常时，可以根据 event 进行恢复。</p>
</li>
<li><p>实现的是最终一致性，可能对某些场景不适用。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/2019/09/05/akka-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/luckymoney.png"></p>
<pre><code>  4. 系统在持久化相应的领域事件后和修改内存中的库存（这个处理非常迅速）后便可马上向用户做出反应，真正的具体信息持久可以异步进行。
</code></pre>
<ol start="9">
<li><p>Akka Remote</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通信双方都要进行配置（remote、client）：</span></span><br><span class="line">akka &#123;</span><br><span class="line">  actor &#123;</span><br><span class="line">    provider = <span class="string">&quot;akka.remote.RemoteActorRefProvider&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  remote &#123;</span><br><span class="line">    enabled-transports = [<span class="string">&quot;akka.remote.netty.tcp&quot;</span>]</span><br><span class="line">    netty.tcp &#123;</span><br><span class="line">      hostname = $localIp  <span class="comment">//比如127.0.0.1</span></span><br><span class="line">      port = $port <span class="comment">//比如2552</span></span><br><span class="line">    &#125;</span><br><span class="line">    log-sent-messages = on</span><br><span class="line">    log-received-messages = on</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程服务器上创建 RemoteActor，接收 msg，并打印 response 到 console</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span> </span>= &#123;</span><br><span class="line">    <span class="keyword">case</span> msg: <span class="type">String</span> =&gt;</span><br><span class="line">      println(<span class="string">s&quot;RemoteActor received message &#x27;<span class="subst">$msg</span>&#x27;&quot;</span>)</span><br><span class="line">      sender ! <span class="string">&quot;Hello from the RemoteActor&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;RemoteDemoSystem&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> remoteActor = system.actorOf(<span class="type">Props</span>[<span class="type">RemoteActor</span>], name = <span class="string">&quot;RemoteActor&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地 client 端：</span></span><br><span class="line"><span class="comment">// 配置文件中 remote.actor.name.test值为：akka.tcp://RemoteDemoSystem@127.0.0.1:4444/user/RemoteActor</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Init</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendNoReturn</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalActor</span> <span class="keyword">extends</span> <span class="title">Actor</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> path = <span class="type">ConfigFactory</span>.defaultApplication().getString(<span class="string">&quot;remote.actor.name.test&quot;</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> timeout = <span class="type">Timeout</span>(<span class="number">4.</span>seconds)</span><br><span class="line">  <span class="keyword">val</span> remoteActor = context.actorSelection(path) <span class="comment">// 获取 remote actor</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Init</span> =&gt; <span class="string">&quot;init local actor&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">SendNoReturn</span> =&gt; remoteActor ! <span class="string">&quot;hello remote actor&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先启动 remoteActor，再启动 localActor：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RemoteDemo</span> <span class="keyword">extends</span> <span class="title">App</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;RemoteDemoSystem&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> remoteActor = system.actorOf(<span class="type">Props</span>[<span class="type">RemoteActor</span>], name = <span class="string">&quot;RemoteActor&quot;</span>)</span><br><span class="line">  remoteActor ! <span class="string">&quot;The RemoteActor is alive&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LocalDemo</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">&quot;LocalDemoSystem&quot;</span>)</span><br><span class="line">  <span class="keyword">val</span> localActor = system.actorOf(<span class="type">Props</span>[<span class="type">LocalActor</span>], name = <span class="string">&quot;LocalActor&quot;</span>)</span><br><span class="line">  localActor ! <span class="type">Init</span></span><br><span class="line">  localActor ! <span class="type">SendNoReturn</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 RemoteActor 的 console 会打印两条消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteActor received message <span class="string">&#x27;The RemoteActor is alive&#x27;</span></span><br><span class="line">RemoteActor received message <span class="string">&#x27;hello remote actor&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注：此 RemoteActor 收到消息并进行回复，但 localActor 并未接收回复消息，如果需要接收回复，可以在 localActor 创建一个消息<code>SendHasReturn</code>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendHasReturn</span></span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SendHasReturn</span> =&gt;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        r &lt;- remoteActor.ask(<span class="string">&quot;hello remote actor&quot;</span>)</span><br><span class="line">      &#125; <span class="keyword">yield</span> r</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>重新运行 localActor，就能在 local 处收到回复：<code>Hello from the RemoteActor</code></p>
</li>
<li><p>Akka Serialization</p>
</li>
<li><p>Akka 原生序列化（即采用 java 中的 java.io.Serializable）：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改 9 Akka Remote 中 localActor 的 Receive 方法，</span></span><br><span class="line"><span class="comment">// joinEvt 会被序列化(Akka 底层做的)，传输到 remoteActor 上</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">SendSerialization</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinEvt</span>(<span class="params">id: <span class="type">Long</span>,name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">SendSerialization</span> =&gt;</span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">        r &lt;- remoteActor.ask(<span class="type">JoinEvt</span>(<span class="number">1</span>L,<span class="string">&quot;godpan&quot;</span>))</span><br><span class="line">      &#125; <span class="keyword">yield</span> println(r)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>第三方序列化工具——kryo：</p>
<ol>
<li><p>使用 Kryo 时，先导入 Kryo 的依赖，然后只需要在<code>application.conf</code>中配置即可完成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actor &#123;</span><br><span class="line">    provider = <span class="string">&quot;akka.remote.RemoteActorRefProvider&quot;</span></span><br><span class="line">    serializers &#123;</span><br><span class="line">      kryo = <span class="string">&quot;com.twitter.chill.akka.AkkaSerializer&quot;</span>  <span class="comment">// 地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    serialization-bindings &#123;</span><br><span class="line">      <span class="string">&quot;java.io.Serializable&quot;</span> = none</span><br><span class="line">      <span class="string">&quot;scala.Product&quot;</span> = kryo   <span class="comment">//使用 kryo 作为序列化工具</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>Akka cluster</p>
<ol>
<li><blockquote>
<p>就是一些相同的ActorSystem的组合，它们具有着相同的功能。待执行的任务可以随机的分配到目前可用的 ActorSystem 上。基于 gossip 协议，将请求转发给运行正常的服务器去。</p>
</blockquote>
</li>
<li><p>Seed Node，用于可以自动接收新加入集群的节点的信息，并与之通信。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Seed Node 的配置文件，第一个会在集群启动时初始化，后面的用到时初始化</span></span><br><span class="line"><span class="comment">// 配在这里的机器，相当于加入了 akka 的集群中</span></span><br><span class="line">akka.cluster.seed-nodes = [</span><br><span class="line">  <span class="string">&quot;akka.tcp://ClusterSystem@host1:2552&quot;</span>,</span><br><span class="line">  <span class="string">&quot;akka.tcp://ClusterSystem@host2:2552&quot;</span>]</span><br></pre></td></tr></table></figure>


</li>
<li><p>cluster events。节点对于集群可能存在六种动作（正在加入，加入，正在离开、离开、可触达、不可触达）。</p>
</li>
<li><p>集群中各节点的功能允许有所不同，即拥有不同的 Roles，比如 request、compute、store 等等。</p>
</li>
<li><p>cluster client，可以将集群中某一个节点作为集群客户端，作为外部通信的接入口，此节点按以下配置：</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">akka.extensions = [<span class="string">&quot;akka.cluster.client.ClusterClientReceptionist&quot;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java+</category>
      </categories>
      <tags>
        <tag>akka</tag>
      </tags>
  </entry>
  <entry>
    <title>ali PAI(1)</title>
    <url>/2019/05/09/ali-PAI-1/</url>
    <content><![CDATA[<h1 id="初识机器学习平台-PAI"><a href="#初识机器学习平台-PAI" class="headerlink" title="初识机器学习平台 PAI"></a>初识机器学习平台 PAI</h1><p>参考网站：<a href="https://help.aliyun.com/document_detail/69223.html?spm=a2c0j.103967.1350600..49fe32b2tW4KpI">阿里云 机器学习 PAI</a></p>
<h2 id="1-抽象概念"><a href="#1-抽象概念" class="headerlink" title="1. 抽象概念"></a>1. 抽象概念</h2><ol>
<li>机器学习（笼统说法）：机器通过统计学算法，对大量的历史数据进行学习从而生成经验模型，利用经验模型指导业务。<ol>
<li>常见营销类业务举例：商品推荐、用户群体画像、广告精准投放等。</li>
<li>其他业务：文本类、非结构化类(如图片等)，金融预测、比赛预测……</li>
</ol>
</li>
<li>PAI 平台，具有数据处理、建模、离线预测、在线预测等功能。</li>
<li>有监督学习（含目标列）、无监督学习（无目标列，只有特征列）、半监督学习（仅有部分目标数据）。</li>
</ol>
<span id="more"></span>

<pre><code> 4.  其他重要概念如下，参考：[PAI基本概念](https://help.aliyun.com/document_detail/114445.html?spm=a2c4g.11186623.6.548.32ea7d03DKKmDg)
       1.  分区：
       2.  生命周期：
       3.  稀疏数据格式：
       4.  特征：
       5.  降维：
    9.  归一化：去除量纲对数据计算的影响。例如把不同跨度的计算结果归一化到 0~1 之间。
    + y = (x - MinValue) / (MaxValue - MinValue).
</code></pre>
<p>​	</p>
<p><img src="/2019/05/09/ali-PAI-1/pai.png"></p>
<h2 id="2-宏观一览"><a href="#2-宏观一览" class="headerlink" title="2. 宏观一览"></a>2. 宏观一览</h2><ol>
<li>PAI 平台分成三层：<ol>
<li>顶层：Web UI 界面；</li>
<li>中层：算法层；</li>
<li>底层：MAXCOMPUTE 平台层。</li>
</ol>
</li>
<li>阿里云的算法库：</li>
</ol>
<p>​	<img src="/2019/05/09/ali-PAI-1/PAI_algorithm.emf.png"></p>
<ol start="3">
<li>PAI 的目的：一站式开发环境，避免工具间的频繁切换。<ol>
<li>以往，一个数据智能应用的链路很长，从数据的 ETL、到预处理、特征工程、模型训练、评估和服务。</li>
</ol>
</li>
<li>PAI 的机器学习框架有：Tensorflow、Caffe、MXNet，底层提供 M40 型号的 GPU卡进行训练</li>
<li>业务架构：</li>
</ol>
<p>​	<img src="/2019/05/09/ali-PAI-1/MLpai8.png"></p>
<pre><code> 6. 协同过滤算法，collaborative filtering ，即 CF，基于类别的推荐算法。
       1. 挑选出爱好/属性相似的人或物，他们通常有相似的购物癖好。
       2. 啤酒和尿布的故事。
  7. 逻辑回归算法，Logistic regression,LR，广义的现行回归分析模型，属于监督学习算法。最常用的二分类。
        1. Sigmoid 函数，目的是将值域控制在 0~1 之间。
        2.  梯度下降算法进行拟合 。
</code></pre>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>PAI</tag>
      </tags>
  </entry>
  <entry>
    <title>chatGPT,Midjourney,Stable Diffusion 常用模板</title>
    <url>/2023/05/07/chatGPT-Midjourney-Stable-Diffusion-%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><a href="https://chat.openai.com/">chatGPT官网</a><br><a href="https://discord.com/">discord官网</a><br><a href="https://www.midjourney.com/app/">midjourney官网</a></p>
<span id="more"></span>

<h1 id="promt"><a href="#promt" class="headerlink" title="promt"></a>promt</h1><h2 id="chatGPT"><a href="#chatGPT" class="headerlink" title="chatGPT"></a>chatGPT</h2><h3 id="找网图"><a href="#找网图" class="headerlink" title="找网图"></a>找网图</h3><ol>
<li>默认chatgpt不支持图片生成，我们可以接用markdown以及unsplash来辅助完成。</li>
<li>unsplash 是全球最大的免费图库，图片都可以商用</li>
<li>markdown 是一个文本标记语言。类似html</li>
</ol>
<blockquote>
<p>prompt:</p>
</blockquote>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">接下来我会给你指令，生成相应的图片，我希望你用Markdown语言生成，不要用反引号，不要用代码框，你需要用Unsplash API，遵循以下的格式：<span class="keyword">source</span>.unsplash.com<span class="regexp">/1600x900/</span>?&lt; PUT YOUR QUERY HERE &gt;。你明白了吗？</span><br><span class="line"></span><br><span class="line"># out:</span><br><span class="line">明白了！你想要我使用 Markdown 语言生成图片，而不是使用反引号或代码框。我将使用 Unsplash API，并按照以下格式生成图片链接：<span class="keyword">source</span>.unsplash.com<span class="regexp">/1600x900/</span>?&lt;在此处放置你的查询内容&gt;。</span><br><span class="line"></span><br><span class="line">请提供你希望使用的查询内容，我将根据你的指令生成相应的图片链接。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>猴子<br><img src="/2023/05/07/chatGPT-Midjourney-Stable-Diffusion-%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/monkey.jpeg"></p>
</blockquote>
<h3 id="生成活动图"><a href="#生成活动图" class="headerlink" title="生成活动图"></a>生成活动图</h3><ol>
<li>根据chatGPT生成PlantUML的代码</li>
<li>进入<a href="www.yuque.com">语雀笔记</a>，页面空白处新增文本绘图（或者直接写 &#x2F;wbht） ，回车</li>
<li>生成的UML直接右键复制或保存即可</li>
</ol>
<blockquote>
<p>prompt：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">作为一个PlantUML活动图生成器，你需要根据我的提示内容生成一个上位机DNC与PLC交互的活动图，并输出相应的PlantUML代码。这个流程图需要包括操作工人、PLC、上位机等角色扮演的活动步骤，流程如下:</span><br><span class="line"><span class="number">1.</span><span class="built_in">CNC</span>加工完成后，向PLC申请上下料。</span><br><span class="line"><span class="number">2.</span>PLC完成自主下料动作</span><br><span class="line"><span class="number">3.</span>等待工人装卸料完成</span><br><span class="line"><span class="number">4.</span>工人在【中转区】通过上位机系统对新料完成扫码，并进行确认</span><br><span class="line"><span class="number">5.</span>此时物料数据由上位机传递给PLC，PLC自主调度工作台发往空闲加工中心完成上料。</span><br><span class="line"><span class="number">6.</span>PLC上下料完成后，将产品条码和机床号传给上位机，请求下发<span class="built_in">CNC</span>代码</span><br><span class="line"><span class="number">7.</span>上位机根据工件条码下发机床对应的<span class="built_in">CNC</span>代码</span><br><span class="line"><span class="number">8.</span>上位机通知PLC代码下发完成</span><br><span class="line"><span class="number">9.</span>最后人工在机床操作面板审核<span class="built_in">CNC</span>代码准确性</span><br><span class="line"><span class="number">9.2</span>异常流程备注：<span class="built_in">CNC</span>程序由人工拷贝到机床</span><br><span class="line"><span class="number">10.</span>PLC启动机床加工</span><br></pre></td></tr></table></figure>

<h5 id="补充PlantUML小语法："><a href="#补充PlantUML小语法：" class="headerlink" title="补充PlantUML小语法："></a>补充PlantUML小语法：</h5><p>在“@startuml”后添加以下内容，修改文字大小，添加”&#x2F;n”帮文字换行。</p>
<figure class="highlight puppet"><table><tr><td class="code"><pre><span class="line">skinparam <span class="keyword">activity</span>  &#123;</span><br><span class="line"></span><br><span class="line">	<span class="string">&#x27;菱形图字体大小</span></span><br><span class="line"><span class="string">	DiamondFontSize 20</span></span><br><span class="line"><span class="string">	&#x27;</span>箭头上的字体大小</span><br><span class="line">	ArrowFontSize <span class="number">20</span></span><br><span class="line">	<span class="string">&#x27;框图内字体大小</span></span><br><span class="line"><span class="string">	FontSize 20</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="生成PPT"><a href="#生成PPT" class="headerlink" title="生成PPT"></a>生成PPT</h3><ol>
<li>根据chatGPT生成符合闪击PPT格式的文本</li>
<li>进入<a href="https://ppt.sankki.com/">闪击PPT官网</a>，粘贴文本 ，回车</li>
<li>修改你的PPT，导出即可。</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/607583650">文本转PPT——闪击教程</a></p>
<blockquote>
<p>prompt:</p>
</blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">我的名字叫做XXXX，帮我制作一篇内容为《XXXXXXXXXX》PPT，要求如下：</span><br><span class="line">第一、一定要使用中文。</span><br><span class="line">第二、页面形式有<span class="number">3</span>种，封面、目录、列表。</span><br><span class="line">第三、目录页要列出内容大纲。</span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页使用=====列表=====开头。</span><br><span class="line">第五、封面页格式如下：</span><br><span class="line">=====封面=====</span><br><span class="line"># 主标题</span><br><span class="line">## 副标题</span><br><span class="line">演讲人：我的名字</span><br><span class="line">第六、目录页格式如下：</span><br><span class="line">=====目录=====</span><br><span class="line"># 目录</span><br><span class="line">## CONTENT</span><br><span class="line"><span class="number">1</span>、内容</span><br><span class="line"><span class="number">2</span>、内容</span><br><span class="line">第七、列表页格式如下：</span><br><span class="line">=====列表=====</span><br><span class="line"># 页面主标题</span><br><span class="line"><span class="number">1</span>、要点<span class="number">1</span></span><br><span class="line">要点描述内容</span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，<span class="number">10</span>个字以上，<span class="number">50</span>个字以内。</span><br><span class="line">最后，一定要使用代码块回复你生成的内容，切记切记。</span><br></pre></td></tr></table></figure>

<p>其中多列表页格式如下，可按需使用：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">=====多列表=====</span><br><span class="line"># 页面主标题</span><br><span class="line">## 页面副标题</span><br><span class="line"><span class="number">1</span>、一级小标题</span><br><span class="line"><span class="number">1.1</span>、 二级小标题</span><br><span class="line">二级小标题描述内容</span><br><span class="line"><span class="number">1.2</span>、 二级小标题</span><br><span class="line">二级小标题描述内容</span><br><span class="line"><span class="number">2</span>、一级小标题</span><br><span class="line"><span class="number">2.1</span>、 二级小标题</span><br><span class="line">二级小标题描述内容</span><br><span class="line"><span class="number">2.2</span>、 二级小标题</span><br><span class="line">二级小标题描述内容</span><br></pre></td></tr></table></figure>


<h2 id="Midjourney"><a href="#Midjourney" class="headerlink" title="Midjourney"></a>Midjourney</h2><ol>
<li>进入<a href="discord.com">discord官网</a>，自己的服务器中，前置条件为已邀请过Midjourney Bot到自己的服务器中</li>
<li>开始绘画</li>
</ol>
<p><a href="https://docs.midjourney.com/docs/parameter-list">Midjourney 指令官网</a><br><a href="https://github.com/willwulfken/MidJourney-Styles-and-Keywords-Reference">lee推荐：指令参考</a></p>
<blockquote>
<p>prompt:</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># 调整Bot设置</span><br><span class="line">/settings</span><br><span class="line"></span><br><span class="line"># 由已知图，生成可描述图片的prompt</span><br><span class="line">/describe</span><br><span class="line"></span><br><span class="line"># 开始绘画 <span class="attr">--v</span> 指定参数， <span class="attr">--q</span> &lt;.<span class="number">25</span>, .<span class="number">5</span>, <span class="number">1</span>, or <span class="number">2</span>&gt; 调节画面质量， <span class="attr">--s</span> 调节匹配度</span><br><span class="line">/imagine prompt <span class="selector-tag">a</span> cat <span class="attr">--v</span> <span class="number">5</span> <span class="attr">--q</span> <span class="number">2</span> -s <span class="number">750</span></span><br><span class="line"></span><br><span class="line"># 更多参数  <span class="attr">--ar</span> 横纵比， <span class="attr">--chaos</span> &lt;number <span class="number">0</span>–<span class="number">100</span>&gt; 混乱程度， <span class="attr">--no</span> 去掉元素，<span class="attr">--r</span> &lt;<span class="number">1</span>–<span class="number">40</span>&gt; 重复创建，</span><br><span class="line"># <span class="attr">--seed</span> &lt;integer between <span class="number">0</span>–<span class="number">4294967295</span>&gt; 随机种子， <span class="attr">--stop</span> &lt;integer between <span class="number">10</span>–<span class="number">100</span>&gt; 提前停止，</span><br><span class="line"># <span class="attr">--style</span> &lt;cute, expressive, or scenic&gt; 改变风格，适合version5，<span class="attr">--s</span> &lt;number&gt; Midjourney默认风格的影响程度</span><br><span class="line"># <span class="attr">--tile</span> 指定标题用以延续同title的风格，<span class="attr">--uplight</span>  待补充，<span class="attr">--upbeta</span> 待补充</span><br><span class="line"></span><br><span class="line"># 风格参数（改变模型）  <span class="attr">--niji</span> 动漫风，<span class="attr">--test</span> 特殊测试模型</span><br></pre></td></tr></table></figure>


<h3 id="生成表情包"><a href="#生成表情包" class="headerlink" title="生成表情包"></a>生成表情包</h3><p>主角是卡通手绘的全身照小熊猫，画一个有9张图的矩阵，每张图上小熊猫分别做着喜悦、害怕、愤怒、厌恶、伤心、贪吃、感激、害羞、惊讶、难过的表情，要求使用白色背景</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">/imagine prompt </span><br><span class="line">The protagonist <span class="keyword">of</span> the story <span class="keyword">is</span> a cute hand-drawn cartoon <span class="keyword">full</span> body Ailurus. A <span class="number">9</span>-frame matrix <span class="keyword">is</span> drawn, <span class="keyword">with</span> the Ailurus depicting expressions <span class="keyword">of</span> joy, fear, anger, disgust, sadness, greed, gratitude, shyness, surprise <span class="keyword">and</span> sorrow respectively <span class="keyword">on</span> <span class="keyword">each</span> frame, <span class="keyword">all</span> <span class="keyword">set</span> against a white background. </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/2023/05/07/chatGPT-Midjourney-Stable-Diffusion-%E5%B8%B8%E7%94%A8%E6%A8%A1%E6%9D%BF/p1.png" alt="Midjourney生成表情包"></p>
<h2 id="stable-diffusion"><a href="#stable-diffusion" class="headerlink" title="stable diffusion"></a>stable diffusion</h2><h3 id="autoDL"><a href="#autoDL" class="headerlink" title="autoDL"></a>autoDL</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> 连接阿里云，下载模型，并移动到指定位置</span><br><span class="line"></span><br><span class="line">cd <span class="regexp">/root/</span>autodl-tmp</span><br><span class="line">mv *.safetensors stable-diffusion-webui<span class="regexp">/models/</span>Stable-diffusion/</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> ssh隧道(A,B分别是autodl开放的域名和端口，命令执行后再输入密码)</span><br><span class="line">ssh -CNg -L <span class="number">6006</span>:<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6006</span> root@www.AAA.com -p BBBB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>chatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo important papers</title>
    <url>/2023/05/09/hexo-important-papers/</url>
    <content><![CDATA[<p><a href="https://yutouwd.github.io/posts/87e6cb09/">博客折腾记录</a><br><a href="https://notes.doublemine.me/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html">自动备份Hexo博客源文件</a><br><a href="https://hexo.io/zh-cn/api/events.html">hexo 事件</a></p>
<span id="more"></span>

<p><a href="https://wungjyan.github.io/2018/08/17/move-hexo/">hexo博客迁移到另一台电脑</a><br><a href="https://leimingshan.com/posts/d9017f30/">Hexo升级指南</a><br><a href="%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2">https://cccshuang.github.io/2018/09/28/%E4%BD%BF%E7%94%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E5%86%99Hexo%E5%8D%9A%E5%AE%A2/</a></p>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>interview（1）</title>
    <url>/2018/12/07/interview%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/discuss/97738">网易考拉 java 凉面面经</a></p>
<h3 id="1-同步-异步-非阻塞-阻塞-bio-nio-aio"><a href="#1-同步-异步-非阻塞-阻塞-bio-nio-aio" class="headerlink" title="1. 同步 异步 非阻塞 阻塞 bio nio aio"></a>1. 同步 异步 非阻塞 阻塞 bio nio aio</h3><p>这题问的是网络 IO 模型。</p>
<p>以 IO 的读数据（read）举例，会经历两个阶段：<br>1）等待数据准备。<br>2）将数据从内核拷贝到进程中。</p>
<p>IO 模型主要分为五种：</p>
<span id="more"></span>

<ol>
<li>阻塞 IO<br>1. 第一阶段，进程发起 recvfrom，Kernel 开始准备数据（同时用户进程被 block）。<br>2. 数据准备好了之后，进入第二阶段，Kernel 开始负责拷贝数据到用户内存（完成之前，用户进程被 block）。<br>3. Kernel 返回一个 ok 告知用户进程拷贝完毕。</li>
<li>非阻塞 IO<br>1. 第一阶段，进程发起轮询 recvfrom（并立即返回），询问数据是否准备好。<br>2. 第二阶段，当 recvfrom 时发现数据已准备好后，不再立即返回，而是将用户进程 block，同时 Kernel 开始拷贝数据。<br>3. Kernel 返回一个 ok 告知用户进程拷贝完毕。<br>4. 【墙裂推荐阅读】：<a href="https://www.cnblogs.com/geason/p/5774096.html">深入理解Java NIO</a></li>
<li>IO 复用<br>1. 第一阶段，进程发起 select，Kernel 开始准备数据（同时用户进程被 block，其实是进程等待多个 socket，一旦有一个 socket 准备好了，就可以变成就绪态完成业务，业务结束重新进入阻塞态）。<br>2. 第二阶段，当数据准备好后，select 就会返回用户进程，之后，用户进程发起 recvfrom，等待 Kernel 拷贝数据（同时用户进程被 block）。<br>3. Kernel 返回一个 ok 告知用户进程拷贝完毕。<br>4. 跟<code>阻塞 IO</code>很像，但 select 的优势是<strong>能处理更多的连接</strong>，参考解释：<a href="https://segmentfault.com/q/1010000010394268?sort=created">IO多路复用 到底是阻塞还是非阻塞</a></li>
<li>信号驱动 IO<br>1. 第一阶段，进程发出 sigaction 信号并立即返回，Kernel 开始准备数据（用户进程不被 block）。<br>2. 第二阶段，Kernel 发出 sigio 信号告知进程数据已准备完毕，用户进程发出 recvfrom 给 Kernel（同时对自身 block）。等待 Kernel 拷贝数据。<br>3. Kernel 返回一个 ok 告知用户进程拷贝完毕。</li>
<li>异步 IO<br>1. 第一阶段：用户进程发起 aio_read 并立即返回，Kernel 开始准备数据（进程不被 block）。<br>2. 第二阶段：Kernel 在数据准备完成后，会立即开始拷贝数据。<br>3. 等一切完成后，Kernel 发出一个 signal 告知进程 read 完毕。</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/findumars/p/6361627.html">5种网络 IO 模型</a><br>github 代码实例：<a href="https://github.com/waylau/distributed-systems-technologies-and-cases-analysis/tree/master/samples/chapter1/distributed-systems-technologies-and-cases-analysis/src/com/waylau/essentialjava/iomode">iomode</a></p>
<h3 id="2-java异常机制类图手写"><a href="#2-java异常机制类图手写" class="headerlink" title="2. java异常机制类图手写"></a>2. java异常机制类图手写</h3><p><img src="/2018/12/07/interview%EF%BC%881%EF%BC%89/ExceptionTree.png" alt="ExceptionTree.png"></p>
<p>RuntimeException &#x3D;&#x3D; UncheckedException</p>
<h3 id="3-spring事务传播机制"><a href="#3-spring事务传播机制" class="headerlink" title="3. spring事务传播机制"></a>3. spring事务传播机制</h3><p>spring 定义了七种事务传播行为</p>
<blockquote>
<p>PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。<br>PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。<br>PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。（没有事务直接报错）<br>PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。（无论什么时候都新建事务）<br>PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br>PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。（若有事务直接报错）<br>PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">ServiceA &#123;</span><br><span class="line">     void <span class="keyword">method</span><span class="constructor">A()</span> &#123;</span><br><span class="line">         <span class="module-access"><span class="module"><span class="identifier">ServiceB</span>.</span></span><span class="keyword">method</span><span class="constructor">B()</span>; <span class="comment">// 运行到此处了</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">ServiceB &#123;</span><br><span class="line">     void <span class="keyword">method</span><span class="constructor">B()</span> &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例理解：以上事务传播级别都是指<code>ServiceB#methodB()</code>，先看 A 有没有事务，再看 B 的级别是否需要起事务。加深理解：</p>
<table>
<thead>
<tr>
<th align="center">B的事务传播级别</th>
<th align="center">A 有事务</th>
<th align="center">A 无事务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">required</td>
<td align="center">支持A</td>
<td align="center">新建事务</td>
</tr>
<tr>
<td align="center">supports</td>
<td align="center">支持A</td>
<td align="center">非事务方式执行</td>
</tr>
<tr>
<td align="center">mandatory</td>
<td align="center">支持A</td>
<td align="center">抛异常</td>
</tr>
<tr>
<td align="center">required_new</td>
<td align="center">事务A挂起，再新建事务</td>
<td align="center">新建事务</td>
</tr>
<tr>
<td align="center">not_supported</td>
<td align="center">事务A挂起，非事务方式执行</td>
<td align="center">非事务方式执行</td>
</tr>
<tr>
<td align="center">never</td>
<td align="center">抛异常</td>
<td align="center">非事务方式执行</td>
</tr>
<tr>
<td align="center">nested</td>
<td align="center">嵌套事务A内执行</td>
<td align="center">新建事务</td>
</tr>
</tbody></table>
<p>解释：</p>
<ul>
<li>创建一个新事务：新事务跟原来事务没有任何关系；</li>
<li>嵌套事务：A、B 两个事务有父子关系，父事务提交或回滚时，子事务也会提交或回滚；</li>
</ul>
<p>PS：nested 方式并不是专门为方法嵌套使用的，默认的 required 方式足够满足我们的需要了。</p>
<p>事务的一些小功能：</p>
<p>推荐阅读：<a href="https://blog.csdn.net/u010383937/article/details/80865741">深入理解事务–Spring 事务的传播机制</a></p>
<h3 id="4-数据库有-2000w-条记录，复制到另一个服务器内，保证无重复，速度快"><a href="#4-数据库有-2000w-条记录，复制到另一个服务器内，保证无重复，速度快" class="headerlink" title="4. 数据库有 2000w 条记录，复制到另一个服务器内，保证无重复，速度快"></a>4. 数据库有 2000w 条记录，复制到另一个服务器内，保证无重复，速度快</h3><p>2000w 记录大概有 2G（估算）<br>方案：</p>
<ol>
<li>定点停机迁移方案。</li>
<li>MySQL 的 binlog方案。解析主服务器的 binlog 日志，把数据写入从服务器中；</li>
<li>触发器方案。创建触发器，在数据写入时，同时写入新的服务器中。</li>
<li>memcached 协议方案。在数据写入时，同时让 Memcached 服务器接收，然后解析 json 到新的数据库。</li>
<li>中间件方案。</li>
</ol>
<p>Tips：</p>
<ol>
<li>先 select into outfile 然后再 load data infile 。</li>
<li>考虑先把索引删除，迁移后再重新建立。</li>
<li>考虑先把引擎改成 MyISAM。因为在数据量比较大的情况MyISAM的插入速度比Innodb高，这里也是当数据导入完成后再将存储引擎修改为InnoDB。</li>
<li>导出语句的 insert 语句写成多值形式。</li>
<li>如果发送的SQL语句太长，以致超过了max_allowed_packet的大小，可以合适地修改这个值。</li>
<li>增加bulk_insert_buffer_size。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/qq_26334813/article/details/80503973">MySQL-大批量数据如何快速的数据迁移</a><br><a href="https://blog.csdn.net/ronmy/article/details/65651713">MySQL数据库的无缝迁移问题：binlog方案、触发器方案</a><br><a href="https://my.oschina.net/sansom/blog/153433">mysql 中如何提高大表之间复制效率</a></p>
<h3 id="5-redis-事务实现，集群实现"><a href="#5-redis-事务实现，集群实现" class="headerlink" title="5. redis 事务实现，集群实现"></a>5. redis 事务实现，集群实现</h3><p>以 MULTI 开始一个事务，然后将多个命令入队到事务中，最后由 EXEC 命令触发事务，一并执行事务中的所有命令。</p>
<p>Tips: redis 命令是原子性的，但是 Redis 事务并不是原子性的。</p>
<p>推荐阅读：<a href="http://www.runoob.com/redis/redis-transactions.html">Redis 事务-Runoob.com</a>,<a href="https://www.jianshu.com/p/ae4c52af3390">Redis之事务实现</a>,<a href="https://www.cnblogs.com/wuxl360/p/5920330.html">Redis集群搭建与简单使用</a></p>
<p>墙裂推荐阅读：<a href="http://www.cnblogs.com/shamo89/p/8376907.html">Redis(十一):Redis 的事务功能详解</a></p>
<p>Redis 集群方案：</p>
<ol>
<li>客户端分片：在客户端进行路由选择，把对 Key 的访问转发到不同的 Redis 实例中，最后把返回结果汇集。</li>
<li>代理层：Redis 客户端把请求发送给代理，由代理按照路由规则发送正确的 Redis 实例，并将结果汇集返回给客户端。</li>
<li>P2P 模式：使用 Hash Slot 进行数据拆分。Redis 客户端发送请求到某个 Redis 实例，如果数据不在此实例时，实例返回重定向指定给客户端，客户端进行对目标实例进行访问请求。</li>
<li>使用云服务器上的集群服务。</li>
</ol>
<blockquote>
<p>redis cluster在设计的时候，就考虑到了去中心化，去中间件，也就是说，集群中的每个节点都是平等的关系，都是对等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了<strong>我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据</strong>。</p>
</blockquote>
<blockquote>
<p>Redis 集群没有并使用传统的一致性哈希来分配数据，而是采用另外一种叫做<strong>哈希槽</strong> (hash slot)的方式来分配的。redis cluster 默认分配了 16384 个slot，当我们set一个key 时，会用<strong>CRC16算法</strong>来取模得到所属的slot，然后将这个key 分到哈希槽区间的节点上，具体算法就是：CRC16(key) % 16384。所以我们在测试的时候看到set 和 get 的时候，直接跳转到了7000端口的节点。</p>
</blockquote>
<blockquote>
<p>Redis 集群会把数据存在一个 master 节点，然后在这个 master 和其对应的salve 之间进行数据同步。当读取数据时，也根据一致性哈希算法到对应的 master 节点获取数据。只有当一个master 挂掉之后，才会启动一个对应的 salve 节点，充当 master 。</p>
</blockquote>
<blockquote>
<p>需要注意的是：必须要3个或以上的主节点，否则在创建集群时会失败，并且当存活的主节点数小于总节点数的一半时，整个集群就无法提供服务了。</p>
</blockquote>
<h3 id="6-数据库哈希索引、B-树索引，原理，优缺点"><a href="#6-数据库哈希索引、B-树索引，原理，优缺点" class="headerlink" title="6. 数据库哈希索引、B+树索引，原理，优缺点"></a>6. 数据库哈希索引、B+树索引，原理，优缺点</h3><p>推荐阅读：<a href="https://www.cnblogs.com/heiming/p/5865101.html">MySQL B+树索引和哈希索引的区别</a><br>原理：<br>哈希索引：采用一定的哈希算法，把键值换算成新的哈希值，只需要一次哈希算法即可立刻定位到相应的位置。<br>B+ 树索引：使用平衡的多叉树，非叶节点做索引，关键字都放在叶子节点中，叶子节点间通过双向指针快速左右移动，效率非常高。 </p>
<p>区别：</p>
<ol>
<li>哈希索引适用于等值查询，一般一次算法就能找到键值，比 B+ 树更好快。</li>
<li>哈希索引不适用于范围查询（包括部分模糊查询等）。</li>
<li>哈希索引不适用于联合索引最左规则（最左规则：多列联合查询时，把最常用的放在最左能加快索引速度）。</li>
<li>如果有大量重复键值的情况，哈希索引效率极低。</li>
<li>B+ 树可以很好地利用局部性原理（3 层 B+ 树可以表示上百万的数据，只需要三次 IO）。</li>
</ol>
<h3 id="7-java线程池有哪些参数，分别有什么作用"><a href="#7-java线程池有哪些参数，分别有什么作用" class="headerlink" title="7. java线程池有哪些参数，分别有什么作用"></a>7. java线程池有哪些参数，分别有什么作用</h3><p>线程池正是为了解决多线程效率低的问题而产生的，它使得线程可以被复用。<br>线程池参数有七个：<br>（lee 记忆：两个数、两个时间、一个队列一个工厂、一个拒绝策略）</p>
<ol>
<li>corePollSize：核心线程数。当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。通常不会被回收，除非主动设置。</li>
<li>maximumPoolSize：最大线程数。表明线程中最多能够创建的线程数量。</li>
<li>keepAliveTime：空闲的线程保留的时间。</li>
<li>TimeUnit：时间单位。</li>
<li>BlockingQueue<Runnable>：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选。</Runnable></li>
<li>ThreadFactory：线程工厂，用来创建线程</li>
<li>RejectedExecutionHandler：队列已满，而且任务量大于最大线程的异常处理策略（lee 注：可理解为<strong>拒绝策略</strong>）。有以下取值</li>
</ol>
<ul>
<li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 </li>
<li>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 </li>
<li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li>
</ul>
<h3 id="8-重入锁有哪些，底层实现方式"><a href="#8-重入锁有哪些，底层实现方式" class="headerlink" title="8. 重入锁有哪些，底层实现方式"></a>8. 重入锁有哪些，底层实现方式</h3><p>可重入锁（ReentrantLock）：一个线程在获取了锁之后，再次去获取了同一个锁，这时候仅仅是把状态值进行累加，并不会互斥（即允许重入）。像 synchronized 和 ReentrantLock 都是可重入锁。 推荐阅读：<a href="https://blog.csdn.net/yanyan19880509/article/details/52345422">轻松学习 java 可重入锁(ReentrantLock)</a><br>实现代码参考：<a href="https://blog.csdn.net/qq_36520235/article/details/81669831">可重入锁 ReentrantLock 的底层原理实现？</a></p>
<p>扩展知识：<br>可重入锁分为：公平锁和非公平锁两类。</p>
<blockquote>
<p>公平锁保证等待时间最长的线程将优先获得锁，而非公平锁并不会保证多个线程获得锁的顺序，但是非公平锁的并发性能表现更好，ReentrantLock默认使用非公平锁。</p>
</blockquote>
<p>以非公平锁举例，大意是指：</p>
<ol>
<li>首先在 <code>lock()</code>方法中用 CAS 进行抢占锁（或设置 state 变量），如果抢占失败，会调用 <code>acquire()</code>方法。</li>
<li>方法中继续调用<code>tryAcquire()</code>方法再次去获取锁，先判断是否有锁，再判断这个锁是不是本线程持有，若是则修改 state 值。</li>
<li>若<code>tryAcquire()</code>方法失败，则将线程置于列尾进行排队。</li>
</ol>
<p>除了可重入锁外，还有中断锁（Lock）、读写锁（ReadWriteLock）、偏向锁、自旋锁等。</p>
<ul>
<li>偏向锁：适用于无竞争的情况下，偏向于第一个访问锁的线程，引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行。一旦出现竞争，就撤掉偏向锁，升级为轻量级锁。</li>
</ul>
<p><strong>锁的 3 种优化</strong>：、</p>
<ol>
<li>自适应自旋锁：自旋的次数不固定，如果上次自旋成功了，那么下一次的自旋次数会增加。</li>
<li>锁消除：JVM 如果检测到不可能存在共享数据竞争时，JVM 会对这些同步锁进行锁消除（依据是逃逸分析的数据支持）。比如，StringBuffer 的 append()方法、Vector 的 add() 方法，在出现某些代码时，JVM 会大胆地进行锁消除。</li>
<li>锁粗化：如果一系列连续加锁的操作，也会造成效率降低。锁粗化就是将上面的加锁解锁操作连接在一起，形成范围更大的锁。以上操作由 JVM 检测完成。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/qq_41376740/article/details/80607243">JAVA 并发各种锁</a></p>
<h3 id="9-数据库的-on-where-having-区别"><a href="#9-数据库的-on-where-having-区别" class="headerlink" title="9. 数据库的 on where having 区别"></a>9. 数据库的 on where having 区别</h3><p>on、where、having 都是条件筛选数据。<br>区别：</p>
<ol>
<li>on 通过限制条件筛选后得到中间表，然后中间表返回得到查询结果。</li>
<li>where 是得到中间表后，再通过限制条件筛选出结果。相比下，on 的中间表数据集小，效率更高。</li>
<li>having 必须跟 GroupBy 一起出现，where 不一定。where 在聚集函数计算前筛选，having 在之后筛选。相比之前，where 更快一些。</li>
</ol>
<h3 id="10-一个try-finally-块返回值是哪个"><a href="#10-一个try-finally-块返回值是哪个" class="headerlink" title="10. 一个try finally 块返回值是哪个"></a>10. 一个try finally 块返回值是哪个</h3><ol>
<li>首先，return 放在 try-finally 块中是个不好的习惯。</li>
<li>先执行 try 中的 return，然而并不会结束程序，而是继续执行 finally（但 return 的东西不会改变）。</li>
<li>然后执行 finally 代码，如果 finally 中有 return（提前结束程序，会被 IDE 警告块不正常完成），就会覆盖掉 try 里的 return（即失效了）。</li>
</ol>
<h3 id="11-值传递-索引传递"><a href="#11-值传递-索引传递" class="headerlink" title="11. 值传递 索引传递"></a>11. 值传递 索引传递</h3><ul>
<li>值传递：方法调用时，实参把它的值传递给对应的形参，而方法内部仅能拿到一个副本，对副本的修改不会改变原实参的值。比如基本数据类型传值。</li>
<li>引用传递：方法调用时，实参的地址传递给对应的形参，如果方法内部对地址中的内容进行了修改，那个原实参的值也会相应发生改变。</li>
<li>但对于一些非基本数据类型，比如 String、Integer、Double等 immutable 的类型需要特殊处理，可以当做值传递来处理。</li>
</ul>
<p>Ps：原始类型包装类（primitive wrappers）（Integer，Long, Short, Double, Float, Character, Byte, Boolean）也都是不可变的。</p>
<p>有关不可修改对象可参考：<a href="https://blog.csdn.net/ymrfzr/article/details/51201934">Java中mutable对象和immutable对象的区别</a></p>
<h3 id="12-RPC框架"><a href="#12-RPC框架" class="headerlink" title="12. RPC框架"></a>12. RPC框架</h3><p>RPC 是指远程过程调用，通过网络来表达调用的语义和传达调用的数据，并得到返回的结果。<br>目的是本地调用远程的方法时，隐藏底层的通讯细节，达到功能与服务实现解耦的效果。<br>RPC 框架一般有：rpcx、grpc、go std rpc、thrift、dubbo等<br>推荐阅读：<a href="https://blog.csdn.net/quuqu/article/details/79304614">流行的 rpc 框架性能测试对比</a></p>
<h3 id="13-多线程实现方式"><a href="#13-多线程实现方式" class="headerlink" title="13. 多线程实现方式"></a>13. 多线程实现方式</h3><ol>
<li>继承 Thread，覆写 run()方法，再调用 start()方法。</li>
<li>实现 Runnable 接口，然后创建 Thread 实例，再调用 thread.start()方法。</li>
<li>实现 Callable 接口，覆写 call()方法，通过 FutureTask<V> 包装器创建 Thread 实例，再调用 thread.start()方法。<br>推荐阅读：<a href="https://www.cnblogs.com/felixzh/p/6036074.html">JAVA多线程实现</a></V></li>
</ol>
<p>&#x2F;&#x2F; todo 补充一下  Future 类的用法，在多线程合并请求时也用得上：</p>
<h3 id="14-反射的几种情况"><a href="#14-反射的几种情况" class="headerlink" title="14. 反射的几种情况"></a>14. 反射的几种情况</h3><p>深度好文：<a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析 Java 反射（1） - 基础</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb_EditAndUpdate</title>
    <url>/2018/05/05/javaweb-EditAndUpdate/</url>
    <content><![CDATA[<p>本文进行对象的编辑和提交功能</p>
<h1 id="对分类对象进行编辑和提交"><a href="#对分类对象进行编辑和提交" class="headerlink" title="对分类对象进行编辑和提交"></a>对分类对象进行编辑和提交</h1><h3 id="操作思路"><a href="#操作思路" class="headerlink" title="操作思路"></a>操作思路</h3><ol>
<li><p>在CategoryMapper中增加sql语句</p>
 <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 通过id获取Category对象 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;get&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	select * from category where id = #</span><span class="template-variable">&#123;id&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!-- 提交数据 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Category&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	update category set name = #</span><span class="template-variable">&#123;name&#125;</span><span class="language-xml"> where id = #</span><span class="template-variable">&#123;id&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在CategoryMapper&#x2F;CategoryService&#x2F;CategoryServiceImpl中增加get和update方法，代码略</p>
</li>
<li><p>在listCategory.jsp中增加edit的超链接。效果：网页上点击图标，进入admin_category_edit链接，并传入id</p>
 <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;admin_category_edit?id=$</span></span></span><span class="template-variable">&#123;c.id&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;glyphicon glyphicon-edit&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>
<ol start="4">
<li><p>更新CategoryController，新增get和update方法。<br>get方法中，由注入的id值获得对应的Category对象c，将c注入model后跳转admin&#x2F;editCategory.jsp。<br>update方法解释见步骤6。</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//触发编辑，不包含提交操作  </span></span><br><span class="line">@<span class="constructor">RequestMapping(<span class="string">&quot;admin_category_edit&quot;</span>)</span></span><br><span class="line">public  String get(<span class="built_in">int</span> id,Model  model) throws IOException &#123;</span><br><span class="line">	Category c=categoryService.get(id);</span><br><span class="line">	model.add<span class="constructor">Attribute(<span class="string">&quot;c&quot;</span>,<span class="params">c</span>)</span>;</span><br><span class="line">	return <span class="string">&quot;admin/editCategory&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编辑后的提交操作</span></span><br><span class="line">@<span class="constructor">RequestMapping(<span class="string">&quot;admin_category_update&quot;</span>)</span></span><br><span class="line">public String update(Category c,HttpSession session,UploadedImageFile uploadedImageFile)throws IOException &#123;</span><br><span class="line">	categoryService.update(c);</span><br><span class="line">	MultipartFile  image=uploadedImageFile.get<span class="constructor">Image()</span>;</span><br><span class="line">	<span class="keyword">if</span>(null!=image<span class="operator"> &amp;&amp; </span>!image.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">		File   imageFolder=<span class="keyword">new</span> <span class="constructor">File(<span class="params">session</span>.<span class="params">getServletContext</span>()</span>.get<span class="constructor">RealPath(<span class="string">&quot;img/category&quot;</span>)</span>);</span><br><span class="line">		File file = <span class="keyword">new</span> <span class="constructor">File(<span class="params">imageFolder</span>,<span class="params">c</span>.<span class="params">getId</span>()</span>+<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">		image.transfer<span class="constructor">To(<span class="params">file</span>)</span>;</span><br><span class="line">		BufferedImage img = <span class="module-access"><span class="module"><span class="identifier">ImageUtil</span>.</span></span>change2jpg(file);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>write(img, <span class="string">&quot;jpg&quot;</span>, file);</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="string">&quot;redirect:/admin_category_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新增editCategory.jsp。CategoryController的get方法会跳转到此jsp文件，同时浏览器上弹出编辑页面。此时id和name已被注入，但 id为隐藏字段，不会被修改。浏览器上点击提交后，URL被CategoryController的update方法捕获</p>
 <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;workingArea&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">&quot;breadcrumb&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;admin_category_list&quot;</span>&gt;</span>所有分类<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>编辑分类<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-warning editDiv&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>编辑分类<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;editForm&quot;</span> <span class="attr">action</span>=<span class="string">&quot;admin_category_update&quot;</span>  <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;editTable&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>分类名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;c.name&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">td</span>&gt;</span>分类圖片<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">							<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;categoryPic&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;submitTR&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">							<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;c.id&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">							<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span>&gt;</span>提 交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">						<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">					<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">				<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此时Category对象c和HttpSession对象session以及工具类UploadedImageFile对象被注入，调用CategoryService.update()方法将c内的name更新入数据库中。</p>
</li>
<li><p>然后获取MultipartFile对象image。若image引用存在且内容不为空，则将上传的图片改为jpg格式存入文件系统。最后重定向到admin_category_list.jsp</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb_forDelete</title>
    <url>/2018/05/05/javaweb-forDelete/</url>
    <content><![CDATA[<p>继续javaweb_forQuery的内容，本文讲解删除操作</p>
<h1 id="对列表中对象进行删除操作"><a href="#对列表中对象进行删除操作" class="headerlink" title="对列表中对象进行删除操作"></a>对列表中对象进行删除操作</h1><h3 id="增加删除的超链"><a href="#增加删除的超链" class="headerlink" title="增加删除的超链"></a>增加删除的超链</h3><p>指向地址admin_category_delete，并传递该对象的id过去</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml">/*在listCategory.jsp文件中 */</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">deleteLink</span>=<span class="string">&quot;true&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="language-xml">		<span class="attr">href</span>=<span class="string">&quot;admin_category_delete?id=$</span></span></span><span class="template-variable">&#123;c.id&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot; 	glyphicon glyphicon-trash&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>
<h3 id="用于删除前的确认"><a href="#用于删除前的确认" class="headerlink" title="用于删除前的确认"></a>用于删除前的确认</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在adminHeader.jsp文件中 */</span></span><br><span class="line"><span class="comment">/*对所有的删除链接进行监听  */</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	$(<span class="string">&quot;a&quot;</span>).click(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">var</span> deleteLink = $(this).attr(<span class="string">&quot;deleteLink&quot;</span>);</span><br><span class="line">		<span class="built_in">console</span>.<span class="built_in">log</span>(deleteLink);</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;true&quot;</span>==deleteLink)&#123;</span><br><span class="line">			<span class="keyword">var</span> confirmDelete = confirm(<span class="string">&quot;确认要删除&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(confirmDelete)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>[延伸阅读]有关jsp的知识可以参考<a href="http://www.runoob.com/jsp/jsp-intro.html">JSP简介|菜鸟教程</a>，简要 ：</p>
<ul>
<li>使用jsp将java代码嵌入html网页中。</li>
<li>网络服务器需要一个 JSP 引擎，也就是一个容器来处理 JSP 页面。容器负责截获对 JSP 页面的请求。</li>
</ul>
<p><img src="/2018/05/05/javaweb-forDelete/JSP_Engine_File.png" alt="JSP 容器和 JSP 文件"></p>
<span id="more"></span>

<ul>
<li><p>Web服务器使用JSP来创建网页的过程</p>
<ul>
<li>就像其他普通的网页一样，浏览器发送一个 HTTP 请求给服务器</li>
<li>Web 服务器识别出这是一个对 JSP 网页的请求，并且将该请求传递给 JSP 引擎。通过使用 URL或者 .jsp 文件来完成</li>
<li>JSP 引擎从磁盘中载入 JSP 文件，然后将它们转化为 Servlet。这种转化只是简单地将所有模板文本改用 println() 语句，并且将所有的 JSP 元素转化成 Java 代码</li>
<li>JSP 引擎将 Servlet 编译成可执行类，并且将原始请求传递给 Servlet 引擎</li>
<li>Web 服务器的某组件将会调用 Servlet 引擎，然后载入并执行 Servlet 类。在执行过程中，Servlet 产生 HTML 格式的输出并将其内嵌于 HTTP response 中上交给 Web 服务器</li>
<li>Web 服务器以静态 HTML 网页的形式将 HTTP response 返回到您的浏览器中</li>
<li>最终，Web 浏览器处理 HTTP response 中动态产生的HTML网页，就好像在处理静态网页一样</li>
</ul>
<p>  <img src="/2018/05/05/javaweb-forDelete/webServer2jsp.png" alt="webServer2jsp"></p>
</li>
</ul>
<h3 id="CategoryController中增加delete方法"><a href="#CategoryController中增加delete方法" class="headerlink" title="CategoryController中增加delete方法"></a>CategoryController中增加delete方法</h3><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">@RequestMapping(<span class="string">&quot;admin_category_delete&quot;</span>)</span><br><span class="line">	<span class="keyword">public</span> String <span class="keyword">delete</span>(<span class="keyword">int</span> id,HttpSession  session) <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">		categoryService.<span class="keyword">delete</span>(id);</span><br><span class="line">		<span class="keyword">File</span> imageFolder=<span class="keyword">new</span>  <span class="keyword">File</span>(session.getServletContext().getRealPath(<span class="string">&quot;img/category&quot;</span>));</span><br><span class="line">		<span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(imageFolder,id+<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">		<span class="keyword">file</span>.<span class="keyword">delete</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;redirect:/admin_category_list&quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接受id注入 ，categoryService删除数据</li>
<li>根据 session定位到图片的位置(注：当前图片存入<br>&#x2F;..&#x2F;eclipse_projects&#x2F;.metadata&#x2F;.plugins&#x2F;org.eclipse.wst.server.core&#x2F;<br>tmp0&#x2F;wtpwebapps&#x2F;tmall_ssm&#x2F;img&#x2F;category&#x2F;)，删除图片</li>
<li>客户端重定向跳转到admin_category_list页面</li>
</ul>
<p>[扩展阅读]<a href="https://www.cnblogs.com/Qian123/p/5345527.html">Forward与Redirect的区别</a>，简要理解 ：</p>
<ul>
<li>forward是服务器直接访问URL，在浏览器不知情时接收内容，浏览器地址栏 仍然是原来的地址 ，效率高 ，并可共享request里的数据</li>
<li>redirect是服务器发送302状态码，告诉浏览器重新请求那个地址，所以地址栏显示新的URL，效率低，并不存在 request传递概念</li>
<li>两者的内部机制有很大的区别：   <ol>
<li>请求转发只能将请求转发给同一个WEB应用中的组件<br> 重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL   </li>
<li>重定向可以看见目标页面的URL<br> 转发只能看见第一次访问的页面URL，以后的工作都是有服务器来做的</li>
<li>请求响应调用者和被调用者之间共享相同的request对象和response对象<br> 重定向调用者和被调用者属于两个独立访问请求和响应过程。  </li>
<li>重定向跳转后必须加上return，要不然页面虽然跳转了,	但是还会执行跳转后面的语句<br> 转发是执行了跳转页面，下面的代码就不会在执行了</li>
<li>转发时浏览器只请求一次服务器，重定向时浏览器请求两次服务器</li>
<li>转发调用的是HttpServletRequest对象中的方法，重定向调用的是HttpServletResponse对象中的方法</li>
</ol>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>在doGet()方法中<span class="keyword">if</span>-<span class="keyword">else</span>判断 ，true则转发，false则重定向</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(password))</span><br><span class="line">	<span class="regexp">//</span>转发</span><br><span class="line">	request.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(request,,response);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="regexp">//</span>重定向</span><br><span class="line">	response.sendRedirect(<span class="string">&quot;imooc_test/fail.jsp&quot;</span>);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>[注]转发时可以使用request.setAttribute(“username”,”Harry”);将数据传递给转发目的页面，为什么能传递参考以上步骤3。重定向时只能用Session或者Application带数据。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>Application方式：</span><br><span class="line"><span class="regexp">//</span>转发前的servlet</span><br><span class="line">ServletContext sc = request.getServletContext();</span><br><span class="line">sc.setAttribute(<span class="string">&quot;goods&quot;</span>,<span class="string">&quot;娃娃&quot;</span>);</span><br><span class="line"><span class="regexp">//</span>Todo：转发代码</span><br><span class="line">	</span><br><span class="line"><span class="regexp">//</span>转发后的servlet</span><br><span class="line">String goods  = (String)application.getAttribute(<span class="string">&quot;goods&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb_forQuery2</title>
    <url>/2018/05/04/javaweb-forQuery2/</url>
    <content><![CDATA[<p><img src="/2018/05/04/javaweb-forQuery2/forquery.png" alt="forquery.png"></p>
<h1 id="学习内容："><a href="#学习内容：" class="headerlink" title="学习内容："></a>学习内容：</h1><ol>
<li>接着forQuery1的内容,思路见上图</li>
<li>新增add功能，URL为tmall_ssm&#x2F;admin_category_list</li>
<li>实现图片上传</li>
</ol>
<h1 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h1><ol>
<li>首先在 CategoryMapper.xml中增加id&#x3D;”add”的sql语句，使用keyProperty和useGeneratedKeys属性，将自动递增的id值设置在Category对象上</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">insert</span> id=&quot;add&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot; parameterType=&quot;Category&quot;&gt;</span><br><span class="line">	<span class="keyword">insert</span> <span class="keyword">into</span> category (<span class="type">name</span>) <span class="keyword">values</span> (#&#123;<span class="type">name</span>&#125;)</span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure>

<p>[注] <a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html">Mapper  XML的Insert, Update, Delete ‘s Attributes</a></p>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">id</td>
<td align="center">命名空间中的唯一标识符，可被用来代表这条语句。</td>
</tr>
<tr>
<td align="center"><strong>parameterType</strong></td>
<td align="center">将要传入语句的参数的完全限定类名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</td>
</tr>
<tr>
<td align="center"><del>parameterMap</del></td>
<td align="center"><del>这是引用外部 parameterMap 的已经被废弃的方法。使用内联参数映射和 parameterType 属性。</del></td>
</tr>
<tr>
<td align="center">flushCache</td>
<td align="center">将其设置为 true，任何时候只要语句被调用，都会导致本地缓存和二级缓存都会被清空，默认值：true（对应插入、更新和删除语句）。</td>
</tr>
<tr>
<td align="center">timeout</td>
<td align="center">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为 unset（依赖驱动）。</td>
</tr>
<tr>
<td align="center">statementType</td>
<td align="center">STATEMENT，PREPARED 或 CALLABLE 的一个。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td align="center"><strong>useGeneratedKeys</strong></td>
<td align="center">（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td align="center"><strong>keyProperty</strong></td>
<td align="center">（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认：unset。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="center">keyColumn</td>
<td align="center">（仅对 insert 和 update 有用）通过生成的键值设置表中的列名，这个设置仅在某些数据库（像 PostgreSQL）是必须的，当主键列不是表中的第一列的时候需要设置。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td>
</tr>
<tr>
<td align="center">databaseId</td>
<td align="center">如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前 databaseId 的语句；如果带或者不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<ol start="2">
<li>在CategoryMapper&#x2F;CategoryService&#x2F;CategoryServiceImpl中增加add(Category category)方法，代码略</li>
<li>新建工具类ImageUtil，提供了change2jpg方法，确保 上传 文件的二进制为jpg格式，目前不接触学习，代码略</li>
<li>在CategoryController中增加add方法</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@<span class="constructor">RequestMapping(<span class="string">&quot;admin_category_add&quot;</span>)</span></span><br><span class="line">	public  String add(Category c,UploadedImageFile uploadedImageFile,HttpSession  session)throws  IOException&#123;</span><br><span class="line">		categoryService.add(c);</span><br><span class="line">		<span class="comment">//把上传的图片放到 target/tmall_ssm/img/category中</span></span><br><span class="line">		File imageFolder=<span class="keyword">new</span>  <span class="constructor">File(<span class="params">session</span>.<span class="params">getServletContext</span>()</span>.get<span class="constructor">RealPath(<span class="string">&quot;img/category&quot;</span>)</span>);</span><br><span class="line">		File file = <span class="keyword">new</span> <span class="constructor">File(<span class="params">imageFolder</span>,<span class="params">c</span>.<span class="params">getId</span>()</span>+<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">		<span class="comment">//如果路径不存在，就新建路径</span></span><br><span class="line">		<span class="comment">//如果不加此句，可能会创建target/tmall_ssm/img/category/某某.jpg/格式的文件夹，而非.jpg文件</span></span><br><span class="line">		<span class="keyword">if</span>(!file.get<span class="constructor">ParentFile()</span>.exists<span class="literal">()</span>)</span><br><span class="line">			file.get<span class="constructor">ParentFile()</span>.mkdirs<span class="literal">()</span>;</span><br><span class="line">		<span class="comment">//使用transferTo方法把浏览器图片保存进文件中</span></span><br><span class="line">		uploadedImageFile.get<span class="constructor">Image()</span>.transfer<span class="constructor">To(<span class="params">file</span>)</span>;</span><br><span class="line">		BufferedImage img=<span class="module-access"><span class="module"><span class="identifier">ImageUtil</span>.</span></span>change2jpg(file);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">ImageIO</span>.</span></span>write(img, <span class="string">&quot;jpg&quot;</span>, file);</span><br><span class="line">		</span><br><span class="line">		return <span class="string">&quot;redirect:/admin_category_list&quot;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>[说明]</p>
<ul>
<li><p>参考<a href="http://blog.51cto.com/lavasoft/275589">深入理解HTTP Session</a>。摘要如下：在Servlet中，session指HttpSession类的对象，是一个 容器，可以存放会话过程中的任何对象，为第一次请求本jsp时所创建，同时赋予其sessionID，根据ID找到session对象。</p>
</li>
<li><p>servletContext是servlet引擎提供用来服务于web应用的接口。servletContext具有名字，唯一映射到文件系统的一个目录。</p>
<blockquote>
<p>Web应用中servlet可以使用servlet上下文得到：</p>
<ol>
<li>在调用期间保存和检索属性的功能，并与其他servlet共享这些属性。</li>
<li>读取Web应用中文件内容和其他静态资源的功能。</li>
<li>互相发送请求的方式。</li>
<li>记录错误和信息化消息的功能。</li>
</ol>
</blockquote>
</li>
<li><p>ServletContext（）的方法String getRealPath(String path)    给定一个URI，由相对路径path返回文件系统中URI对应的绝对路径。如果不能进行映射，返回null。 </p>
</li>
<li><p>getParent方法参考<a href="https://blog.csdn.net/cys1991/article/details/7593790">java中的getParentFile</a></p>
</li>
</ul>
<blockquote>
<p>transferTo<br>public void transferTo(java.io.File dest)<br>                throws java.io.IOException,<br>                       java.lang.IllegalStateException</p>
</blockquote>
<blockquote>
<p>Transfer the received file to the given destination file.<br>This may either move the file in the filesystem, copy the file in the filesystem, or save memory-held contents to the destination file. If the destination file already exists, it will be deleted first.<br>[译]将接收的文件传递给指定路径的文件，或者在文件系统中相互传递；或者将内存中内容存入路径文件。若指定路径文件已存在，会先删除旧文件后存入。<br>If the target file has been moved in the filesystem, this operation cannot be invoked again afterwards. Therefore, call this method just once in order to work with any storage mechanism.<br>[译]若目标文件不存在将不会触发操作。因此使用任何存储机制都仅调用一次此 方法。</p>
</blockquote>
<ul>
<li>add方法参数使用了工具类UploadedImageFile（见下面的代码），定义了<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/multipart/MultipartFile.html">MultipartFile</a>属性，用于接收上传文件的注入。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadedImageFile</span> &#123;</span><br><span class="line">    MultipartFile image;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MultipartFile <span class="title">getImage</span><span class="params">()</span>           </span>&#123;       <span class="keyword">return</span> image;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">setImage</span><span class="params">(MultipartFile image)</span> </span>&#123;        <span class="keyword">this</span>.image = image;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>listCategory.jsp中增加了新增分类页面的代码</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel panel-warning addDiv&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-heading&quot;</span>&gt;</span>新增分类<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">id</span>=<span class="string">&quot;addForm&quot;</span> <span class="attr">action</span>=<span class="string">&quot;admin_category_add&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;addTable&quot;</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">td</span>&gt;</span>分类名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span>  <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">td</span>&gt;</span>分类圖片<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    					<span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;categoryPic&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span> /&gt;</span></span><br><span class="line">    				<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;<span class="name">tr</span> <span class="attr">class</span>=<span class="string">&quot;submitTR&quot;</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    					<span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span>&gt;</span>提 交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    				<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    			<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    		<span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>将@RequestMapping修饰的CategoryController.add()方法参数中自动注入name和image</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>javaweb_forQuery</title>
    <url>/2018/05/03/javaweb-forQuery/</url>
    <content><![CDATA[<h1 id="学习内容链接"><a href="#学习内容链接" class="headerlink" title="学习内容链接"></a>学习内容链接</h1><p><a href="http://how2j.cn/k/tmall_ssm/tmall_ssm-1516/1516.html">http://how2j.cn/k/tmall_ssm/tmall_ssm-1516/1516.html</a></p>
<h1 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h1><p>使用<strong>springMVC+spring+mybatis</strong>的方式打通表现层&#x2F;业务层&#x2F;持久层。从浏览器接收访问路径开始，经过数据库调取数据（只做查询），最后从浏览器显示视图的全部简易流程。</p>
<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul>
<li>Eclipse oxygen</li>
<li>tomcat 8.5</li>
<li>Apache maven 3.5.3</li>
<li>mysql</li>
</ul>
<h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><ol>
<li>环境配置完成后，启动Maven新建webapp项目</li>
<li>在pom.xml中添加依赖（依赖来源：<a href="http://mvnrepository.com/">Maven Repository</a>）</li>
</ol>
<h3 id="依赖清单："><a href="#依赖清单：" class="headerlink" title="依赖清单："></a>依赖清单：</h3><pre><code><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;properties&gt;</span></span><br><span class="line">  <span class="section">&lt;spring.version&gt;</span><span class="attribute">4</span>.<span class="number">1</span>.<span class="number">3</span>.RELEASE&lt;/spring.version&gt;</span><br><span class="line">  <span class="section">&lt;pagehelper.version&gt;</span><span class="attribute">5</span>.<span class="number">1</span>.<span class="number">2</span>-beta&lt;/pagehelper.version&gt;</span><br><span class="line">  <span class="section">&lt;mysql.version&gt;</span><span class="attribute">5</span>.<span class="number">1</span>.<span class="number">6</span>&lt;/mysql.version&gt;</span><br><span class="line">  <span class="section">&lt;mybatis.spring.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>.<span class="number">3</span>&lt;/mybatis.spring.version&gt;</span><br><span class="line">  <span class="section">&lt;mybatis.version&gt;</span><span class="attribute">3</span>.<span class="number">1</span>.<span class="number">1</span>&lt;/mybatis.version&gt;</span><br><span class="line">  <span class="section">&lt;junit.version&gt;</span><span class="attribute">4</span>.<span class="number">12</span>&lt;/junit.version&gt;</span><br><span class="line">  <span class="section">&lt;jstl.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>&lt;/jstl.version&gt;</span><br><span class="line">  <span class="section">&lt;jsqlparser.version&gt;</span><span class="attribute">1</span>.<span class="number">0</span>&lt;/jsqlparser.version&gt;</span><br><span class="line">  <span class="section">&lt;jackson.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>.<span class="number">7</span>&lt;/jackson.version&gt;</span><br><span class="line">  <span class="section">&lt;servlet-api.version&gt;</span><span class="attribute">3</span>.<span class="number">1</span>.<span class="number">0</span>&lt;/servlet-api.version&gt;</span><br><span class="line">  <span class="section">&lt;druid.version&gt;</span><span class="attribute">1</span>.<span class="number">0</span>.<span class="number">18</span>&lt;/druid.version&gt;</span><br><span class="line">  <span class="section">&lt;log4j.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>.<span class="number">16</span>&lt;/log4j.version&gt;</span><br><span class="line">  <span class="section">&lt;commons-logging.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>&lt;/commons-logging.version&gt;</span><br><span class="line">  <span class="section">&lt;commons-fileupload.version&gt;</span><span class="attribute">1</span>.<span class="number">2</span>.<span class="number">1</span>&lt;/commons-fileupload.version&gt;</span><br><span class="line">  <span class="section">&lt;commons-io.version&gt;</span><span class="attribute">1</span>.<span class="number">3</span>.<span class="number">2</span>&lt;/commons-io.version&gt;</span><br><span class="line">  <span class="section">&lt;commons-lang.version&gt;</span><span class="attribute">2</span>.<span class="number">6</span>&lt;/commons-lang.version&gt;</span><br><span class="line">  <span class="section">&lt;aopalliance.version&gt;</span><span class="attribute">1</span>.<span class="number">0</span>&lt;/aopalliance.version&gt;</span><br><span class="line">  <span class="section">&lt;mybatis-generator.version&gt;</span><span class="attribute">1</span>.<span class="number">3</span>.<span class="number">5</span>&lt;/mybatis-generator.version&gt;</span><br><span class="line"><span class="section">&lt;/properties&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<ol start="3">
<li><p>创建实体类Category，定义了private的id和name，以及getter&#x2F;setter方法</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">Integer</span> id;</span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">Integer</span> <span class="title function_">getId</span>(<span class="params"></span>)           &#123;		<span class="keyword">return</span> id;	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setId</span>(<span class="params">Integer id</span>)    &#123;		<span class="variable language_">this</span>.<span class="property">id</span> = id;	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">getName</span>(<span class="params"></span>)          &#123;		<span class="keyword">return</span> name;	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setName</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;		<span class="variable language_">this</span>.<span class="property">name</span> = name;	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="4">
<li><p>创建接口CategoryMapper，申明list方法，未来可以添加增删改查等操作</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CategoryMapper</span> &#123;</span><br><span class="line">	<span class="function">List&lt;Category&gt; <span class="title">list</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建接口CategoryService，申明list方法</p>
 <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">CategoryService</span> &#123;</span><br><span class="line">	<span class="function">List&lt;Category&gt; <span class="title">list</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建类CategoryServiceImpl实现CategoryService接</p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CategoryService</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="title class_">CategoryMapper</span> categoryMapper;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">List</span>&lt;<span class="title class_">Category</span>&gt; <span class="title function_">list</span>(<span class="params"></span>) &#123;		<span class="keyword">return</span> categoryMapper.<span class="title function_">list</span>();	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>@Service 表示将CategoryServiceImpl类交给spring来管理，并申明为Service类<br>@Autowired 表示由spring自动装配注入categoryMapper</p>
<ol start="7">
<li><p>创建类CategoryController，处理请求，跳转视图</p>
 <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CategoryController</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	CategoryService categoryService;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//处理admin_category_list路径的url</span></span><br><span class="line">	<span class="meta">@RequestMapping(<span class="string">&quot;admin_category_list&quot;</span>)</span></span><br><span class="line">	<span class="keyword">public</span> String list(Model model) &#123;</span><br><span class="line">		List&lt;Category&gt; cs=categoryService.list();</span><br><span class="line">		<span class="comment">//向</span></span><br><span class="line">		model.addAttribute(<span class="string">&quot;cs&quot;</span>,cs);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//视图跳转到listCategory.jsp文件</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;admin/listCategory&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建CategoryMapper.xml配置文件，实现id倒排序查询所有分类</p>
 <figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">&lt;mapper <span class="keyword">namespace</span>=<span class="string">&quot;com.ihappy.lee.mapper.CategoryMapper&quot;</span>&gt;</span><br><span class="line">  <span class="comment">//id=&quot;list&quot;唯一标识此sql语句，并与接口方法名保持一致</span></span><br><span class="line">	&lt;<span class="keyword">select</span> id=<span class="string">&quot;list&quot;</span> resultType=<span class="string">&quot;Category&quot;</span>&gt;</span><br><span class="line">		<span class="keyword">select</span> * <span class="keyword">from</span> category <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span></span><br><span class="line">	&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>创建核心文件applicationContext.xml–对注解的识别；对jdbc.properties的引用；指定数据库连接池；配置Mybatis的SessionFactory；</p>
 <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ihappy.lee.service&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.url&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.username&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;jdbc.password&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.ihappy.lee.pojo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mapper/*.xml&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建springMVC.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--springMVC的注解配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- base-package后跟要扫描的包            expression是注解类的全名        --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ihappy.lee.controller&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开通静态资源的访问--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">&lt;!-- 视图定位到/WEB-INF/jsp目录下  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">&lt;!-- 对上传文件的解析--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>配置web.xml–指定spring核心配置文件applicationContext.xml；设置中文过滤器；分发servlet，指定springMVC配置文件springMVC.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring的配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">&lt;!--中文过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">&lt;!-- spring mvc核心：分发servlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- spring mvc的配置文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>其他配置（日志文件log4j.properties；数据库配置文件jdbc.properties），略</p>
</li>
<li><p>使用的静态资源，略</p>
</li>
<li><p>创建listCategory.jsp文件</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--  关键代码：</span></span></span><br><span class="line"><span class="comment"><span class="language-xml">遍历cs里的内容，然后挨个显示出来 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">&quot;$</span></span></span><span class="template-variable">&#123;cs&#125;</span><span class="language-xml"><span class="tag"><span class="string">&quot;</span> <span class="attr">var</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>简易测试类</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span> args[]</span>) &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="title class_">Class</span>.<span class="title function_">forName</span>(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="title class_">ClassNotFoundException</span> e) &#123;</span><br><span class="line">		e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> (<span class="title class_">Connection</span> c = <span class="title class_">DriverManager</span>.<span class="title function_">getConnection</span>(</span><br><span class="line">			<span class="string">&quot;jdbc:mysql://localhost:3306/tmall_ssm?useUnicode=true&amp;characterEncoding=utf8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">			<span class="title class_">Statement</span> s = c.<span class="title function_">createStatement</span>();) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++) &#123;</span><br><span class="line">			<span class="title class_">String</span> sqlFormat=<span class="string">&quot;insert into category values (null,&#x27;测试分类%d&#x27;)&quot;</span>;</span><br><span class="line">			<span class="title class_">String</span> sql=<span class="title class_">String</span>.<span class="title function_">format</span>(sqlFormat, i);</span><br><span class="line">			s.<span class="title function_">execute</span>(sql);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(<span class="title class_">SQLException</span> e) &#123;</span><br><span class="line">		e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="运行思路"><a href="#运行思路" class="headerlink" title="运行思路"></a>运行思路</h1><ol>
<li><p>从浏览器上访问路径&#x2F;admin_category_list</p>
</li>
<li><p>根据web.xml中的配置（分发servlet），将拦截到的&#x2F;admin_category_list，交给DispatcherServlet来处理</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>mvc-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>【注】“url-pattern”使用的’&#x2F;‘将会覆盖到容器的<strong>default servlet</strong>，凡是web.xml中找不到匹配的URL，访问请求都将交给该servlet，即DispatcherServlet来处理</p>
<ol start="3">
<li>DispatcherServlet根据springMVC的配置（扫描注解），将这次请求交由CategoryController类来处理，映射到该类的list方法上（list方法带有@RequestMapping(“admin_category_list”)注解）</li>
<li>CategoryController自动注入CategoryService，在访问了categoryService.list()方法时，再自动注入CategoryMapper</li>
<li>根据applicationContext.xml配置的会话工厂SessionFactory，使用mapperLocations属性来指定resources&#x2F;mapper下的xml文件，将读取的CategoryMapper.xml与CategoryMapper关联起来</li>
<li>通过步骤4、5完成CategoryController的实例化，使用CategoryController.list()处理查询请求，id为‘list’的sql语句被执行，将查询结果封装到Category对象，并存入List<Category>类型的cs中</Category></li>
<li>把集合cs放入model中传递给jsp，之后跳转到admin&#x2F;listCategory.jsp页面，经过foreach把List项逐个显示出来</li>
</ol>
<p><img src="/2018/05/03/javaweb-forQuery/forquery.png" alt="forquery.png"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 大作战</title>
    <url>/2019/07/12/leetcode-%E5%A4%A7%E4%BD%9C%E6%88%98/</url>
    <content><![CDATA[<h1 id="leetcode-大作战"><a href="#leetcode-大作战" class="headerlink" title="leetcode 大作战"></a>leetcode 大作战</h1><h3 id="往期链接："><a href="#往期链接：" class="headerlink" title="往期链接："></a>往期链接：</h3><ol>
<li><a href="http://likehui.fun/2019/01/15/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%861/">leetcode： 1、2、3、4、5、7、12、13、14、15、33、38</a></li>
<li><a href="http://likehui.fun/2019/02/17/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%862/">牛客网： 1、2、3 + 补充三题</a></li>
<li><a href="http://likehui.fun/2019/03/26/MS-100%E9%A2%98-1/">MS100： 1、2、3、4、5</a></li>
<li><a href="http://likehui.fun/2019/03/22/%E4%B8%83%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/">七种内部排序的代码实现</a></li>
</ol>
<span id="more"></span>



<h3 id="ARTS全系列："><a href="#ARTS全系列：" class="headerlink" title="ARTS全系列："></a>ARTS全系列：</h3><p><a href="http://likehui.fun/2019/03/15/ARTS-1/">ARTS-1</a> :  leetcode 229、841、</p>
<p><a href="http://likehui.fun/2019/03/28/ARTS-2/">ARTS-2</a> : leetcode 905、129</p>
<p><a href="http://likehui.fun/2019/04/02/ARTS-3/">ARTS-3</a> : leetcode 593、647、491</p>
<p><a href="http://likehui.fun/2019/04/11/ARTS-4/">ARTS-4</a> : 力扣 24、594</p>
<p><a href="http://likehui.fun/2019/04/18/ARTS-5/">ARTS-5</a> : 力扣 121、195</p>
<p><a href="http://likehui.fun/2019/04/26/ARTS-6/">ARTS-6</a> : 力扣 541</p>
<p><a href="http://likehui.fun/2019/05/03/ARTS-7/">ARTS-7</a> : 力扣 79</p>
<p><a href="http://likehui.fun/2019/05/14/ARTS-8/">ARTS-8</a> : 力扣 910</p>
<p><a href="http://likehui.fun/2019/05/18/ARTS-9/">ARTS-9</a> : 力扣 539</p>
<p><a href="http://likehui.fun/2019/05/26/ARTS-10/">ARTS-10</a> : 力扣 792</p>
<p><a href="http://likehui.fun/2019/06/01/ARTS-11/">ARTS-11</a> ： 力扣 967</p>
<p><a href="http://likehui.fun/2019/06/07/ARTS-12/">ARTS-12</a> : 力扣 18</p>
<p><a href="http://likehui.fun/2019/06/23/ARTS-13/">ARTS-13</a> : 力扣 519</p>
<p><a href="http://likehui.fun/2019/06/30/ARTS-14/">ARTS-14</a> : 力扣 142</p>
<h3 id="近期更新："><a href="#近期更新：" class="headerlink" title="近期更新："></a>近期更新：</h3><p><a href="http://likehui.fun/2019/07/12/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%863/">笔经整理 3</a>：力扣 462&#x2F;840&#x2F;1006&#x2F;433&#x2F;112&#x2F;78&#x2F;784&#x2F;875</p>
]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_for_HeadFirstServletsAndJsp2</title>
    <url>/2018/05/13/notes-for-HeadFirstServletsAndJsp2/</url>
    <content><![CDATA[<h1 id="Head-First-Servlets-amp-JSP-读书笔记-2"><a href="#Head-First-Servlets-amp-JSP-读书笔记-2" class="headerlink" title="Head First Servlets&amp;JSP 读书笔记_2"></a>Head First Servlets&amp;JSP 读书笔记_2</h1><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>消息体&#x2F;负载 ：Payload，是数据传输的根本目的，也称实际数据&#x2F;数据体；</li>
<li>元数据：也称数据头&#x2F;开销数据，是帮助负载传输的辅助；</li>
<li>MIME类型：规范的一种，用以描述报文类型的内容和组织形式，包含HTTP响应首部中content-type，Content-Transfer-Encoding等；</li>
<li>端口列表 ：<a href="https://zh.wikipedia.org/wiki/TCP/UDP%E7%AB%AF%E5%8F%A3%E5%88%97%E8%A1%A8">TCP&#x2F;UDP端口列表</a></li>
<li>部署描述文件(deployment descriptor,DD)，即web.xml。每个Web应用需要一个DD，但一个DD可以声明多个servlet</li>
</ul>
<h2 id="干货正文"><a href="#干货正文" class="headerlink" title="干货正文"></a>干货正文</h2><h3 id="为什么有时不建议用HTTP-GET？"><a href="#为什么有时不建议用HTTP-GET？" class="headerlink" title="为什么有时不建议用HTTP GET？"></a>为什么有时不建议用HTTP GET？</h3><ol>
<li>Get的总字符数有限，（取决于服务器），如果在搜索框中写入太多，可能使get方法无法正常工作；</li>
<li>get数据会加到URL后面，在浏览器地址栏中显示出来；</li>
<li>然而，用了post，用户将不能对一个表单提交建立书签，get请求的url能保存为浏览器书签；</li>
<li>然而，用了post，请求不能被缓存下来，不会保存在浏览记录中。</li>
</ol>
<h3 id="Web服务器自己不做的两件事"><a href="#Web服务器自己不做的两件事" class="headerlink" title="Web服务器自己不做的两件事"></a>Web服务器自己不做的两件事</h3><blockquote>
<p>1、动态内容；2、在服务器上保存数据</p>
</blockquote>
<ol>
<li>Web服务器只提供静态页面。web服务器与辅助应用通信，由辅助应用具体写出HTML（即时页面）;</li>
<li>用户提交表单数据时，web服务器看到表单数据，将其移交给辅助应用，由这个应用为客户生成一个响应。</li>
</ol>
<h3 id="辅助应用"><a href="#辅助应用" class="headerlink" title="辅助应用"></a>辅助应用</h3><p>通常包含Servlet和CGI(Common Gateway Interface)，两者各有优缺点。</p>
<h3 id="放在Servlet中的HTML的糟糕表现"><a href="#放在Servlet中的HTML的糟糕表现" class="headerlink" title="放在Servlet中的HTML的糟糕表现"></a>放在Servlet中的HTML的糟糕表现</h3><p>在servlet中创建一个动态Web页面就需要把整个HTML打印到一个输出流,以下是未ps版代码，ps版代码是将java代码放入HTML中（即jsp）</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">out</span>.printl<span class="meta">n</span>(<span class="string">&quot;&lt;html&gt;&quot;</span>+</span><br><span class="line">				<span class="string">&quot;&lt;body&gt;&quot;</span>+today+<span class="string">&quot;&lt;/body&gt;&quot;</span>+</span><br><span class="line">				<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Web容器的作用（tomcat等）"><a href="#Web容器的作用（tomcat等）" class="headerlink" title="Web容器的作用（tomcat等）"></a>Web容器的作用（tomcat等）</h3><h5 id="通信支持"><a href="#通信支持" class="headerlink" title="通信支持"></a>通信支持</h5><p>利用容器提供的方法，你可以简单的实现servlet与web服务器的对话。否则你就要自己建立serverSocket，监听端口，创建新的流等等一系列复杂的操作。而容器的存在就帮我们封装这一系列复杂的操作。使我们能够专注于servlet中的业务逻辑的实现。</p>
<h5 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h5><p>容器负责servlet的整个生命周期（一般都会extends HttpServlet）。如何加载类，实例化和初始化servlet，调用servlet方法，并使servlet实例能够被垃圾回收。有了容器，我们就不用花精力去考虑这些资源管理垃圾回收之类的事情。<br><br>[理解]一般doGet&#x2F;doPost方法传参有HttpServletRequest request和HttpServletResponse response，这俩是由容器创建的。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">PrintWriter out <span class="operator">=</span> response.getWriter()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>以上代码中，out可以将HTML文本&#x2F;图片等输出到相应对象中。</p>
<h5 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h5><p>容器会自动为接收的每个servlet请求创建一个新的java线程，servlet运行完之后，容器会自动结束这个线程。</p>
<h5 id="声明式实现安全"><a href="#声明式实现安全" class="headerlink" title="声明式实现安全"></a>声明式实现安全</h5><p>利用容器，可以使用xml部署描述文件来配置安全性，而不必将其硬编码到servlet中。</p>
<h5 id="jsp支持"><a href="#jsp支持" class="headerlink" title="jsp支持"></a>jsp支持</h5><p>容器将jsp翻译成java</p>
<h3 id="使用DD-web-xml-将URL映射到Servlet"><a href="#使用DD-web-xml-将URL映射到Servlet" class="headerlink" title="使用DD(web.xml)将URL映射到Servlet"></a>使用DD(web.xml)将URL映射到Servlet</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 内部名映射到完全限定类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Ch1Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ch1Servlet.Ch1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 内部名映射到公共URL名--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Ch1Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Ch1Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>servlet有三个名字：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">客户知道的URL名 <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/Ch1Servlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">部署人员知道的秘密的内部名 <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Ch1Servlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">实际文件名 <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>ch1Servlet.Ch1Servlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注：将servlet添加一个对外访问的虚拟路径，除了以上在DD中配置之外，还可以采用注解的方式,在继承了<code>HttpServlet</code>的Servlet类上方添加：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(<span class="string">&quot;/WordAnalyzeServlet&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="DD的其他用途"><a href="#DD的其他用途" class="headerlink" title="DD的其他用途"></a>DD的其他用途</h3><p>包括了大量重要用途，但此时仅关注可以采用声明的方式修改应用。</p>
<p>已完成本书第2章49页，未完待续。。。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_for_HeadFirstServletsAndJsp3</title>
    <url>/2018/05/14/notes-for-HeadFirstServletsAndJsp3/</url>
    <content><![CDATA[<h1 id="Head-First-Servlets-amp-JSP-读书笔记-3"><a href="#Head-First-Servlets-amp-JSP-读书笔记-3" class="headerlink" title="Head First Servlets&amp;JSP 读书笔记_3"></a>Head First Servlets&amp;JSP 读书笔记_3</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li><p>J2EE：Java 2 Enterprise Edition，包含了Web容器和EJB(Enterprise JavaBean)容器，而tomcat只是一种Web容器，不是完整的J2EE应用服务器</p>
</li>
<li><p>独立的EJB容器？独立的EJB容器已经过时，目前所有的EJB容器都作为完整J2EE的一部分</p>
</li>
<li><p>POJO：Plain Old Java Object，普通的java对象。与JavaBean的区别是，POJO可以有属性和getter&#x2F;setter方法，可以有简单的运算属性，但不允许有业务方法和connection之类方法</p>
</li>
<li><p>scriptlet代码：</p>
<blockquote>
<p>In JavaServer Pages (JSP) technology, a scriptlet is a piece of Java-code embedded in the HTML-like JSP code. The scriptlet is everything inside the &lt;%  %&gt; tags. Between these the user can add any valid Scriptlet i.e. any valid Java Code.<br>  [译]JSP中的scriptlet是指在类HTML的JSP中的标准java代码段，使用”&lt;% %&gt;”的格式。</p>
</blockquote>
</li>
<li><p>请求分派机制：容器机制，容器管理的一个组件调用另一个组件</p>
</li>
</ul>
<h2 id="web与MVC"><a href="#web与MVC" class="headerlink" title="web与MVC"></a>web与MVC</h2><p>[理解]MVC：将Servlet中做业务逻辑的功能（查询DB，插入DB，把HTML输出到响应流返回客户）搬到业务层和持久层。业务逻辑本身应该作为一个可重用的Java类，让业务逻辑根本不知道有表现的存在。</p>
<ol>
<li><p>原本Servlet完成的输出HTML的工作，现在Servlet将请求转发给适当的JSP，再由JSP建立响应HTML，并将其返回。</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用ssm的controller凑合理解一下。。</span></span><br><span class="line"><span class="comment">//从这个url（admin_category_list）进来</span></span><br><span class="line">@<span class="constructor">RequestMapping(<span class="string">&quot;admin_category_list&quot;</span>)</span></span><br><span class="line">public String <span class="built_in">list</span>(Model model,Page page) &#123;</span><br><span class="line">	List&lt;Category&gt; cs=categoryService.<span class="built_in">list</span>(page);</span><br><span class="line">	<span class="built_in">int</span> total=categoryService.total<span class="literal">()</span>;</span><br><span class="line">	page.set<span class="constructor">Total(<span class="params">total</span>)</span>;</span><br><span class="line">	model.add<span class="constructor">Attribute(<span class="string">&quot;cs&quot;</span>,<span class="params">cs</span>)</span>;</span><br><span class="line">	model.add<span class="constructor">Attribute(<span class="string">&quot;page&quot;</span>,<span class="params">page</span>)</span>;</span><br><span class="line">	<span class="comment">//视图跳转到listCategory.jsp文件</span></span><br><span class="line">	return <span class="string">&quot;admin/listCategory&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>功能分隔：</p>
<blockquote>
<ul>
<li>视图：负责表示方面。它从控制器得到模型的状态。另外视图还要获得用户的输入，并交给控制器。</li>
<li>控制器：从请求获得用户输入，并明确这些输入对模型有什么影响。告诉模型自行更新，并且让视图（JSP）能得到新的模型状态。</li>
<li>模型：包含具体的业务逻辑和状态。即模型知道用什么规则来得到和更新状态。购物车的内容（和处理购物车内容的规则）就属于MVC中的模型。系统中只有这部分与数据库通信（不过它可能会使用另一个对象完成具体的数据库通信，但这种模式以后再讲）。</li>
</ul>
</blockquote>
 <span id="more"></span></li>
</ol>
<h2 id="servlet调用Jsp"><a href="#servlet调用Jsp" class="headerlink" title="servlet调用Jsp"></a>servlet调用Jsp</h2><h4 id="Servlet代码（初版）"><a href="#Servlet代码（初版）" class="headerlink" title="Servlet代码（初版）"></a>Servlet代码（初版）</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ***;</span><br><span class="line"><span class="keyword">import</span> ***;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Select</span> <span class="keyword">extends</span>  <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	public void doPost(<span class="type">HttpServletRequest</span> request,<span class="type">HttpServletResponse</span> response)<span class="keyword">throws</span> <span class="type">IOException</span>,<span class="type">ServletException</span>&#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html&quot;</span>);<span class="comment">//来自ServletResponse接口</span></span><br><span class="line">		<span class="type">PrintWriter</span> out = response.getWriter();</span><br><span class="line">		out.println(<span class="string">&quot;这是个啥？&quot;</span>);</span><br><span class="line">		<span class="type">String</span> c=request.getParameter(<span class="string">&quot;color&quot;</span>);<span class="comment">//来自ServletRequest接口，与属性值name=”color“标签对应</span></span><br><span class="line">		out.println(<span class="string">&quot;颜色是：&quot;</span>+c);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="让servlet调用JSP生成视图"><a href="#让servlet调用JSP生成视图" class="headerlink" title="让servlet调用JSP生成视图"></a>让servlet调用JSP生成视图</h4><ol>
<li>url找到servlet；</li>
<li>sevlet调用某java类处理业务逻辑；</li>
<li>业务逻辑处理后的返回值增加到请求对象（以某种方式写入request中），以便于JSP的访问；</li>
<li>要求容器把请求转发给”***.jsp”;</li>
</ol>
<h2 id="容器管理servlet"><a href="#容器管理servlet" class="headerlink" title="容器管理servlet"></a>容器管理servlet</h2><h4 id="servlet的生命周期（request和response角度）"><a href="#servlet的生命周期（request和response角度）" class="headerlink" title="servlet的生命周期（request和response角度）"></a>servlet的生命周期（request和response角度）</h4><ul>
<li>客户点击URL</li>
<li>容器按照目标servlet创建HttpServletRequest和HttpServletResponse对象</li>
<li>容器创建或分配一个线程，并调用servlet中的service()方法</li>
<li>service()按需调用doGet()或 doPost()方法</li>
<li>将响应通过容器写至客户</li>
<li>service()结束，线程或撤销或返回到容器所管理的线程池中，Request和Response对象可以垃圾回收</li>
<li>客户得到响应</li>
</ul>
<h4 id="servlet的生命周期（容器与servlet角度）"><a href="#servlet的生命周期（容器与servlet角度）" class="headerlink" title="servlet的生命周期（容器与servlet角度）"></a><a href="http://www.runoob.com/servlet/servlet-life-cycle.html">servlet的生命周期</a>（容器与servlet角度）</h4><ul>
<li>容器加载servlet类，生成.class文件</li>
<li>初始化servlet，运行其构造方法init()。如果不覆盖init方法，就会运行Generic-Servlet的init方法。两种init方法比较：</li>
<li>一般建议使用左侧便利版本</li>
</ul>
<table>
<thead>
<tr>
<th align="center">public void init() throws ServletException</th>
<th align="center">public void init(ServletConfig config) throws ServletException</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A convenience method which can be overridden so that there’s no need to call super.init(config)</td>
<td align="center">Called by the servlet container to indicate to a servlet that the servlet is being placed into service. See Servlet.init(javax.servlet.ServletConfig).</td>
</tr>
<tr>
<td align="center">[译]相比init(ServletConfig)方法，使用init()方法无需调用super.init(config)方法。</td>
<td align="center">[译]Servlet容器调用此方法使servlet进入Service中</td>
</tr>
<tr>
<td align="center">Instead of overriding init(ServletConfig), simply override this method and it will be called by GenericServlet.init(ServletConfig config). The ServletConfig object can still be retrieved via getServletConfig()</td>
<td align="center">This implementation stores the ServletConfig object it receives from the servlet container for later use. When overriding this form of the method, call super.init(config)</td>
</tr>
<tr>
<td align="center">[译]简单重写此方法，未来会被GenericServlet.init(ServletConfig config)方法调用，ServletConfig对象会由getServletConfig方法取到</td>
<td align="center">[译]此实现从Servlet容器存入了ServletConfig对象，当覆盖此方法时，需要调用super.init(config)方法</td>
</tr>
</tbody></table>
<ul>
<li>servlet总是在为第一个客户请求提供服务之前得到加载和初始化</li>
<li>处理客户请求，Servlet容器中有一个线程池 ，针对每次请求会分配一个线程去处理请求，即便是同一个客户多个请求，也同样对应着多个线程</li>
<li>容器调用destroy()，在servlet被杀死之前有机会清理资源，可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动</li>
<li>注：当工程从Tomcat移除时，会调用destroy()方法</li>
<li>在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。由 JVM 的垃圾回收器完成回收</li>
</ul>
<h4 id="有关servlet，你该知道的"><a href="#有关servlet，你该知道的" class="headerlink" title="有关servlet，你该知道的"></a>有关servlet，你该知道的</h4><ol>
<li>servlet一生只调用一次init()和destroy().</li>
<li>每个servlet都仅对应一个实例（SingleThreadModel除外，一般不用）</li>
<li>与HTTP有关的都在javax.servlet.http包中,其余的（通用servlet类和接口）则   在javax.servlet包中</li>
<li>运行init方法后，servlet还不是真正的servlet，还需要具备一些特性，比如能够使用ServletContext引用从容器得到信息</li>
<li>ServletConfig和ServletContext的存在是为了支持servlet处理客户请求，以下是两者对比：</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ServletConfig对象</th>
<th align="center">ServletContext对象</th>
</tr>
</thead>
<tbody><tr>
<td align="center">每个Servlet都有一个ServletConfig对象</td>
<td align="center">每个Web应用只有一个ServletContext</td>
</tr>
<tr>
<td align="center">用于向Servlet传递部署时消息（例如数据库或企业bean的查找名 ），而你不想把这个消息硬编码写到servlet中（servlet初始化参数）</td>
<td align="center">用于访问Web应用参数（也在DD中配置）</td>
</tr>
<tr>
<td align="center">用于访问ServletContext</td>
<td align="center">相当于一种应用公告栏，可以在这里放置信息（称为属性），应用的其他部分可以访问这些信息</td>
</tr>
<tr>
<td align="center">参数在部署描述文件中配置</td>
<td align="center">用于得到服务器信息，包括容器名和容器版本，以及所支持的API的版本等</td>
</tr>
</tbody></table>
<p>已完成全书第4章105页，读书笔记未完待续。。 </p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_for_HeadFirstServletsAndJsp4</title>
    <url>/2018/06/02/notes-for-HeadFirstServletsAndJsp4/</url>
    <content><![CDATA[<h1 id="Head-First-Servlets-amp-JSP-读书笔记-4"><a href="#Head-First-Servlets-amp-JSP-读书笔记-4" class="headerlink" title="Head First Servlets&amp;JSP 读书笔记_4"></a>Head First Servlets&amp;JSP 读书笔记_4</h1><h2 id="HttpServletRequest接口扩展了ServletRequest接口，发生了什么？"><a href="#HttpServletRequest接口扩展了ServletRequest接口，发生了什么？" class="headerlink" title="HttpServletRequest接口扩展了ServletRequest接口，发生了什么？"></a>HttpServletRequest接口扩展了ServletRequest接口，发生了什么？</h2><p>与上同理的还有HttpServletResponse接口扩展了ServletResponse接口。以ServletRequest接口为例解释如下：</p>
<blockquote>
<p>avax.servlet  Interface ServletRequest<br>Defines an object to provide client request information to a servlet. The servlet container creates a ServletRequest object and passes it as an argument to the servlet’s service method.<br>[扩展译]当Servlet容器接收到客户端要求访问特定Servlet的请求时，容器先解析客户端的原始请求数据，把它包装成一个ServletRequest对象。当容器调用Servlet对象的service()方法时，就可以把ServletRequest对象呢作为参数传给service()方法。</p>
</blockquote>
<blockquote>
<p>A ServletRequest object provides data including parameter name and values, attributes, and an input stream. Interfaces that extend ServletRequest can provide additional protocol-specific data (for example, HTTP data is provided by HttpServletRequest.<br>[译]ServletRequest对象提供参数名、参数值、属性、输入流等数据。其扩展接口（比如HttpServletRequest会提供Http数据）会格外增加特定的协议数据。</p>
</blockquote>
<p>Http协议数据主要有如下：</p>
<table>
<thead>
<tr>
<th align="center">method</th>
<th align="center">description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getContextPath():String</td>
<td align="center">Returns the portion of the request URI that indicates the context of the request.[译]获得Request中传入的URI部分（注：URI标记了资源，未给出资源地址，故只是URL的一部分，参考：<a href="https://blog.csdn.net/simplebam/article/details/72644094">Web基础-Uri跟Url的区别</a>）</td>
</tr>
<tr>
<td align="center">getCookies():Cookie[]</td>
<td align="center">Returns an array containing all of the Cookie objects the client sent with this request.[译]获得Request相关的cookie数组</td>
</tr>
<tr>
<td align="center">getHeader(String name):String</td>
<td align="center">Returns the value of the specified request header as a String.[译]获得客户的平台和浏览信息</td>
</tr>
<tr>
<td align="center">getSession():HttpSession</td>
<td align="center">Returns the current session associated with this request, or if the request does not have a session, creates one.[译]返回客户相关的Session会话</td>
</tr>
<tr>
<td align="center">getInputStream():ServletInputStream</td>
<td align="center">Retrieves the body of the request as binary data using a ServletInputStream[译]返回请求体中的二进制内容（请求体若要处理计算机驱动，可能包含二进制）[注]此为ServletRequest的方法</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">其他参数参考：<a href="https://blog.csdn.net/u011159417/article/details/54020827">Servlet技术浅析（三）之—–ServletRequest接口和HttpServletRequest接口</a></td>
<td align="center"></td>
</tr>
</tbody></table>
<span id="more"></span>


<h2 id="Servlet容器如何实现HttpServletRequest接口的？"><a href="#Servlet容器如何实现HttpServletRequest接口的？" class="headerlink" title="Servlet容器如何实现HttpServletRequest接口的？"></a>Servlet容器如何实现HttpServletRequest接口的？</h2><p>背景：使用者按照接口类型来引用请求和响应对象，即调用doGet()方法时，并不知道容器是如何实现此接口和实现了其父接口定义中的所有方法。<br>推荐阅读：<a href="http://www.cnblogs.com/GooPolaris/p/8111837.html">Tomcat中容器是什么，容器间的关系</a><br><a href="https://www.cnblogs.com/GooPolaris/p/8115784.html">Tomcat是如何将请求一步步传递到我们编写的HttpServlet类中的</a><br>大佬写的请求传递的过程实在看不懂，简单复制粘贴如下：</p>
<ol>
<li>请求首先由AbstractEndpoint类及其子类的内部类Acceptor（线程类）的持续监听并接收得到，过程使用套接字</li>
<li>当接收请求完毕，经过一系列的处理后就会由AprEndpoint的内部类SocketProcessor来将请求传给ProtocolHandler来处理。这个SocketProcessor也是一个线程类</li>
<li>AbstractConnectionHandler接收到第二步传来的套接字以后，对套接字进行处理，并传递给AbstractHttp11Processor中的process(…)方法来处理</li>
<li>此时会创建org.apache.coyote.Request类型的请求</li>
<li>在CoyoteAdapter中，由Connector来创建成HttpServletRequest，此方法就是请求对象、响应对象和套接字进行信息交互的地方，也就是真真正正将套接字中的信息转化为请求信息，还要把响应信息写到套接字中</li>
<li>完成之后交给CoyoteAdapter来处理，CoyotoAdapter将请求传入Server容器的切入点</li>
<li>CoyoteAdapter中有一个service()方法。这个方法持有一个Connector的引用。这个Connector又持有一个Service容器的引用，而Service容器有持有一个Container（Container的实现类有StandardEngine、StandardHost等等）的引用。所以CoyoteAdapter就可以根据这些引用将请求传递到Server容器中了</li>
<li>当最后一个StandardWrapperValve（其对应Engine会调用它持有的StandardPipeline对象来处理请求，此管道中的有许多阀门，这些Valve会对请求进行处理）处理完请求后，此时请求已经到达了最底层的容器了。</li>
<li>StandardWrapper就是最底层的容器，它不允许再有子容器。之后把请求交给Filter来处理，此时请求进入过滤器链条中，参考:<a href="https://www.cnblogs.com/ooooevan/p/5727798.html">过滤器中的chain.doFilter(request,response)</a></li>
<li>过滤器处理完之后当将请求传递给我们编写的HttpServlet来处理</li>
</ol>
<h2 id="Cookie和Session的区别与联系"><a href="#Cookie和Session的区别与联系" class="headerlink" title="Cookie和Session的区别与联系"></a>Cookie和Session的区别与联系</h2><p>Cookie和Session都是为了保存客户端和服务端之间的交互状态，实现机制不同，各有优缺点。</p>
<ul>
<li>一个最大的区别就是<strong>Cookie是保存在客户端</strong>而<strong>Session就保存在服务端</strong>的。Cookie是客户端请求服务端时服务器会将一些信息以键值对的形式返回给客户端，保存在浏览器中，交互的时候可以加上这些Cookie值。用Cookie就可以方便的做一些缓存。</li>
<li>Cookie的缺点是大小和数量都有限制；Cookie是存在客户端的可能被禁用、删除、篡改，是不安全的；Cookie如果很大，每次要请求都要带上，这样就影响了传输效率。</li>
<li>Session是基于Cookie来实现的，不同的是Session本身存在于服务端，但是每次传输的时候不会传输数据，只是把代表一个客户端的唯一ID（通常是JSESSIONID）写在客户端的Cookie中，这样每次传输这个ID就可以了。</li>
<li>Session的优势就是传输数据量小，比较安全。</li>
<li>Session也有缺点，就是如果Session不做特殊的处理容易失效、过期、丢失或者Session过多导致服务器内存溢出，并且要实现一个稳定可用安全的分布式Session框架也是有一定复杂度的。</li>
<li>在实际使用中就要结合Cookie和Session的优缺点针对不同的问题来设计解决方案。</li>
</ul>
<p>推荐阅读：<a href="https://blog.csdn.net/xnf1991/article/details/52157378">真相了！关于HTTP 请求方式: GET和POST的比较的本质</a></p>
<h2 id="幂等的Get-非幂等的Post"><a href="#幂等的Get-非幂等的Post" class="headerlink" title="幂等的Get 非幂等的Post"></a>幂等的Get 非幂等的Post</h2><p>[理解]幂等：可以一遍一遍反复做同一件事，不会有预料不到的副作用，Get、Head、Put都是幂等的。Post是非幂等的，Post体的提交数据可能用于不可逆转的事务，如涉及更新DB的操作时，易造成操作不止一次的情况。<br>所以，Post本质上是非幂等的，需要程序人员干涉处理。</p>
<h2 id="你应该知道的表单细节"><a href="#你应该知道的表单细节" class="headerlink" title="你应该知道的表单细节"></a>你应该知道的表单细节</h2><ol>
<li><p>表单中若没有明确给出method&#x3D;‘Post’，则会默认为HttpGet请求。</p>
</li>
<li><p>使用getParameter(“parametername”)方法，返回值始终是String</p>
</li>
<li><p>Post请求若有两个参数，可用&amp;分隔，如：</p>
 <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">color</span>=dark&amp;body=heavy</span><br></pre></td></tr></table></figure></li>
<li><p>getHeader()方法获得首部String，对于某些首部（例如Content-Length信息体的字节数）可能就对应的一个数，此时可以用getIntHeader()直接得到int值</p>
</li>
<li><p>getServerPort()\getLocalPort()\getRemotePort()的区别</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">比较</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getRemotePort()</td>
<td align="center">得到客户的端口，即发出请求的客户的端口号</td>
</tr>
<tr>
<td align="center">getServerPort()</td>
<td align="center">请求原来发送到哪个端口，即服务器监听的端口</td>
</tr>
<tr>
<td align="center">getLocalPort()</td>
<td align="center">请求最后发送到哪个端口，即服务器为每个线程找的一个不同的本地端口，用以实现一个应用同时处理多个客户</td>
</tr>
<tr>
<td align="center">[注]远程意味着客户</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="在Response中为客户发送一个jar"><a href="#在Response中为客户发送一个jar" class="headerlink" title="在Response中为客户发送一个jar"></a>在Response中为客户发送一个jar</h2><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Servlet代码</span></span><br><span class="line">pubilc  <span class="keyword">class</span> Codereturn <span class="keyword">extends</span> Httpservlet&#123;</span><br><span class="line">	<span class="keyword">public</span>  <span class="keyword">void</span> doGet(HttpServletRequest request,HttpServletResponse response)<span class="keyword">throws</span> IOException,ServletException&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//告诉浏览器接下来是什么类型的内容（即内容类型）</span></span><br><span class="line">		response.setContentType(<span class="string">&quot;application/jar&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获得本Servlet对应的背景对象，ctx.getResourceAsStream()方法中是jar所在路径，在JarDownlioad根目录下，并表示给浏览器一个输入流</span></span><br><span class="line">		ServletContext ctx = getServletContext();</span><br><span class="line">		InputStream is = ctx.getResourceAsStream(<span class="string">&quot;/bookCode.jar&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//以下是常规的I/O操作</span></span><br><span class="line">		<span class="keyword">int</span> <span class="keyword">read</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		OutputStream os = response.getOutputStream();</span><br><span class="line">		<span class="keyword">while</span>((<span class="keyword">read</span> = is.<span class="keyword">read</span>(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">			os.<span class="keyword">write</span>(bytes,<span class="number">0</span>,<span class="keyword">read</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		os.flush();</span><br><span class="line">		os.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他：可以设置response来设置首部、发送错误、增加cookie等</p>
<h2 id="setContenttype-常用的内容类型"><a href="#setContenttype-常用的内容类型" class="headerlink" title="setContenttype()常用的内容类型"></a>setContenttype()常用的内容类型</h2><ul>
<li>内容类型：即MIME类型Multipurpose Internet Mail Extensions。服务器告诉浏览器要发出的是什么，浏览器才会做出正确的举动。</li>
<li>注：总是先调好setContenttype()，再调用获得输出流的方法。</li>
<li>服务器不一定能通过文件的扩展名看出内容类型，所以需要MIME<br>MIME类型：不用记忆</li>
</ul>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">MIME类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">超文本标记语言文本 .html</td>
<td align="center">text&#x2F;html</td>
</tr>
<tr>
<td align="center">xml文档 .xml</td>
<td align="center">text&#x2F;xml</td>
</tr>
<tr>
<td align="center">XHTML文档 .xhtml</td>
<td align="center">application&#x2F;xhtml+xml</td>
</tr>
<tr>
<td align="center">普通文本 .txt</td>
<td align="center">text&#x2F;plain</td>
</tr>
<tr>
<td align="center">RTF文本 .rtf</td>
<td align="center">application&#x2F;rtf</td>
</tr>
<tr>
<td align="center">PDF文档 .pdf</td>
<td align="center">application&#x2F;pdf</td>
</tr>
<tr>
<td align="center">Microsoft Word文件 .word</td>
<td align="center">application&#x2F;msword</td>
</tr>
<tr>
<td align="center">PNG图像 .png</td>
<td align="center">image&#x2F;png</td>
</tr>
<tr>
<td align="center">GIF图形 .gif</td>
<td align="center">image&#x2F;gif</td>
</tr>
<tr>
<td align="center">JPEG图形 .jpeg,.jpg</td>
<td align="center">image&#x2F;jpeg</td>
</tr>
<tr>
<td align="center">au声音文件 .au</td>
<td align="center">audio&#x2F;basic</td>
</tr>
<tr>
<td align="center">MIDI音乐文件 mid,.midi</td>
<td align="center">audio&#x2F;midi,audio&#x2F;x-midi</td>
</tr>
<tr>
<td align="center">RealAudio音乐文件 .ra, .ram</td>
<td align="center">audio&#x2F;x-pn-realaudio</td>
</tr>
<tr>
<td align="center">MPEG文件 .mpg,.mpeg</td>
<td align="center">video&#x2F;mpeg</td>
</tr>
<tr>
<td align="center">AVI文件 .avi</td>
<td align="center">video&#x2F;x-msvideo</td>
</tr>
<tr>
<td align="center">GZIP文件 .gz</td>
<td align="center">application&#x2F;x-gzip</td>
</tr>
<tr>
<td align="center">TAR文件 .tar</td>
<td align="center">application&#x2F;x-tar</td>
</tr>
<tr>
<td align="center">任意的二进制数据</td>
<td align="center">application&#x2F;octet-stream</td>
</tr>
</tbody></table>
<h3 id="输出字符或是字节"><a href="#输出字符或是字节" class="headerlink" title="输出字符或是字节"></a>输出字符或是字节</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//将文本数据打印到字符流</span><br><span class="line">PrintWriter writer <span class="operator">=</span> response.getWriter()<span class="comment">;</span></span><br><span class="line">writer.println(<span class="string">&quot;some text and HTML&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//文本打印到字节流</span><br><span class="line">ServletOutputStream out <span class="operator">=</span> response.getOutputStream()<span class="comment">;</span></span><br><span class="line">out.write(aByteArray)<span class="comment">;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>println()写至PrintWriter</li>
<li>write()写至ServletOutputStream</li>
<li>其实PrintWriter内部包装了ServletOutputStream，使之更便于处理字符。</li>
</ul>
<h2 id="请求重定向-x3D-客户"><a href="#请求重定向-x3D-客户" class="headerlink" title="请求重定向 &#x3D; 客户"></a>请求重定向 &#x3D; 客户</h2><p>[理解]让别人来为你的请求处理响应，例如servlet重定向到一个完全不同的URL，或者把请求分派给Web应用的另一个组件。</p>
<ol>
<li>servlet拿到请求后决定使用重定向</li>
<li>servlet在响应上调用sendRedirect(aString)，servlet完成工作</li>
<li>之后Http响应有带着状态码301，以及一个“Location”首部（即一个URL）</li>
<li>浏览器得到响应，发现301状态码，并寻找“Location”首部；并使用该Location的值（即新的URL）建立一个新的请求（用户可以发现此时浏览器地址栏的URL发生了改变）</li>
<li>服务器对新的请求作出响应，在浏览器展示新页面</li>
</ol>
<ul>
<li>可以使用相对URL来作为sendRedirect()的参数（该参数只能是String类型，见下例），即sendRedirect(“foo&#x2F;stuff.html”)，此url是相对于原URL（需要原URL放在location的首部）来建立的，</li>
<li>若sendRedirect(“&#x2F;foo&#x2F;stuff.html”)，此时容器会相对Web应用本身建立完整的URL，不会参考原URL。</li>
<li>要在响应之前发出重定向的指令，因为已经向流中写了东西，想重定向为时已晚，否则抛出IllegalStateException异常。</li>
</ul>
<h2 id="请求分派-x3D-服务器"><a href="#请求分派-x3D-服务器" class="headerlink" title="请求分派 &#x3D; 服务器"></a>请求分派 &#x3D; 服务器</h2><ol>
<li><p>servlet拿到请求后决定交给Web应用的另一个部分（下文以JSP举例）</p>
</li>
<li><p>servlet调用以下代码，由JSP接管响应</p>
 <figure class="highlight vbscript"><table><tr><td class="code"><pre><span class="line">RequestDispatcher view  = </span><br><span class="line">	<span class="built_in">request</span>.getRequestDispatcher(<span class="string">&quot;result.jsp&quot;</span>);</span><br><span class="line">view.forward(<span class="built_in">request</span>,<span class="built_in">response</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>浏览器以正常方法得到响应，而且浏览器地址栏没有变化，用户一无所知</p>
</li>
</ol>
<p>已完成《Head First Servlets and JSP》第4章 146页</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_for_HeadFirstServletsAndJsp5</title>
    <url>/2018/06/08/notes-for-HeadFirstServletsAndJsp5/</url>
    <content><![CDATA[<h1 id="Head-First-Servlets-amp-JSP-读书笔记-5"><a href="#Head-First-Servlets-amp-JSP-读书笔记-5" class="headerlink" title="Head First Servlets&amp;JSP 读书笔记_5"></a>Head First Servlets&amp;JSP 读书笔记_5</h1><h2 id="如何将某些参数写在DD中，而非写死在类中"><a href="#如何将某些参数写在DD中，而非写死在类中" class="headerlink" title="如何将某些参数写在DD中，而非写死在类中"></a>如何将某些参数写在DD中，而非写死在类中</h2><p>初版解决办法（以Email地址为例）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//DD中：</span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>adminEmail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>***@163.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//servlet中：</span></span><br><span class="line">	get<span class="constructor">ServletConfig()</span>.get<span class="constructor">InitParameter(<span class="string">&quot;adminEmail&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>一般<code>Servlet</code>都是继承自<code>HttpServlet</code>，而<code>HttpServlet</code>是<code>GenericServlet</code>的子类。<code>getInitParameter()</code>方法来自于<code>GenericServlet</code>，所以Servlet可以调用此方法去获取web.xml配置文件中的配置信息。</li>
<li>容器初始化一个servlet时，会为这个servlet建一个唯一的ServletConfig。其出场顺序为：先由容器加载servlet类，然后init()初始化，初始化完成前得到了ServletConfig对象，同时可以调用getInitParameter方法，从DD中读取初始化参数，经由ServletConfig传递给init()方法。</li>
<li><strong>划重点</strong>：先 <code>init()</code>，后得到<code>ServletConfig</code>，同时使用<code>初始化参数（只能读一次）</code>！可参考<a href="http://likehui.fun/2018/05/14/notes-for-HeadFirstServletsAndJsp3/">Head First Servlets&amp;JSP 读书笔记_3</a>中关于init()方法的讲解</li>
<li>以上的代码只是专属于此Servlet的初始化参数，无法全局使用；若采取保存下来的方式，又必须使此Servlet最早先运行，这么一来可维护性极差</li>
</ul>
<span id="more"></span>


<h2 id="除了该Servlet，如何让Web中其他部分也得到此参数？"><a href="#除了该Servlet，如何让Web中其他部分也得到此参数？" class="headerlink" title="除了该Servlet，如何让Web中其他部分也得到此参数？"></a>除了该Servlet，如何让Web中其他部分也得到此参数？</h2><p>升级版解决办法：使用<code>ServletContext</code>,对整个Web应用中的所有servlet和JSP都可用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//DD中：</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 在web-app标签中， </span></span><br><span class="line"><span class="comment">			但位于所有servlet标签之外 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>adminEmail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>***@163.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	...</span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时 </p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//servlet中：</span></span><br><span class="line">	get<span class="constructor">ServletContext()</span>.get<span class="constructor">InitParameter(<span class="string">&quot;adminEmail&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>每个servlet有一个ServletConfig，每个Web应用有一个ServletContext</li>
<li>如果应用是分布式应用，那么每个JVM有一个ServletContext</li>
<li>ServletContext也是在Servlet发生初始化时，对初始化参数完成设置</li>
<li>初始化参数&#x3D;部署时常量；运行时可以得到，但无法设置</li>
<li>一般所说初始化参数，默认指“Servlet初始化参数”</li>
<li>ServletContext还可以得到：有关服务器&#x2F;容器的信息；写到服务器的日志文件，RequestDispatcher等</li>
<li>以上的初始化参数只能是String，其他参数怎么玩？使用对象来初始化怎么玩？见下文</li>
</ol>
<h2 id="使用对象来初始化Web应用的办法：listener"><a href="#使用对象来初始化Web应用的办法：listener" class="headerlink" title="使用对象来初始化Web应用的办法：listener"></a>使用对象来初始化Web应用的办法：listener</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul>
<li>需求：使用非String类型的参数，对Web进行初始化。</li>
<li>问题：1.初始化参数只能是String类型，<br>  2.想把对象转成String，但转换代码无法塞到servlet或JSP之前运行</li>
<li>解决办法：建立一个ServletContextListener类，用以监听ServletContext的创建和撤销。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"><code>interface</code> <br>ServletContextListener</th>
</tr>
</thead>
<tbody><tr>
<td align="center">contextInitialized(ServletContextEvent)<br>contextDestroyed(ServletContextEvent)</td>
</tr>
</tbody></table>
<p>以下以DataSource举例，若需要传递对象，可见下文对Dog的举例。两者原理步骤相通</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ServletContextListener类</span></span><br><span class="line"><span class="keyword">import</span> javax.<span class="property">servlet</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServletContextListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实现接口的两个方法</span></span><br><span class="line">	<span class="comment">//上下文初始化时得到通知	</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">contextInitialized</span>(<span class="params">ServletContextEvent event</span>)&#123;</span><br><span class="line">	<span class="comment">//Todo 使用初始化参数查找名（由ServletContext得到）建立一个数据库连接</span></span><br><span class="line">	<span class="comment">//将数据库连接存储为一个属性，使得Web应用的各个部分都能访问</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//上下文撤销时得到通知</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">contextDestroyed</span>(<span class="params">ServletContextEvent event</span>)&#123;</span><br><span class="line">	<span class="comment">//Todo 关闭数据库连接</span></span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举例Dog之步骤陈述"><a href="#举例Dog之步骤陈述" class="headerlink" title="举例Dog之步骤陈述"></a>举例Dog之步骤陈述</h3><p>把Dog类放到ServletContext中</p>
<ol>
<li><p>新建一个监听类放在<code>WEB-INF/classes</code>目录（或其他目录）下，此类实现ServletContextListener接口，并在DD中放一个<listener>告知容器此处有监听者</listener></p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--监听类的全路径--&gt;</span></span><br><span class="line">		com.example.MyServletContextListener</span><br><span class="line">	<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>新建Dog类，普通java类，由<code>ServletContextListener</code>初始化，设置在<code>SerletContext</code>，由<code>servlet</code>获取</p>
</li>
<li><p>新建Servlet类，扩展<code>HttpServlet</code>，验证此监听类。此Servlet从ServletContext中得到Dog属性，然后调用Dog的另外的方法，打印到响应中</p>
</li>
</ol>
<h3 id="举例Dog之代码实现"><a href="#举例Dog之代码实现" class="headerlink" title="举例Dog之代码实现"></a>举例Dog之代码实现</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyServletContextListener类中的contextInitialized()方法：</span></span><br><span class="line">	public void context<span class="constructor">Initialized(ServletContextEvent <span class="params">event</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//由事件使用ServletContext得到初始化参数</span></span><br><span class="line">	ServletContext sc = event.get<span class="constructor">ServletContext()</span>;</span><br><span class="line">	String dogBreed = sc.get<span class="constructor">InitParameter(<span class="string">&quot;breed&quot;</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	Dog d = <span class="keyword">new</span> <span class="constructor">Dog(<span class="params">dogBreed</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用ServletContext来设置一个属性（名/对象对），供其他应用得到此属性</span></span><br><span class="line">	sc.set<span class="constructor">Attribute(<span class="string">&quot;dog&quot;</span>,<span class="params">d</span>)</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dog类,平平无奇</span></span><br><span class="line">package com.example</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> breed;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//含参构造</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="type">String</span> breed)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.breed=breed;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getBreed</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> breed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Servlet类，测试类</span></span><br><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ListenerTester</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line">	public void doGet(<span class="type">HttpServlet</span> <span class="type">Request</span> request,<span class="type">HttpServletResponse</span> response)</span><br><span class="line">			<span class="keyword">throws</span> <span class="type">IOException</span>,<span class="type">ServletException</span>&#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">		<span class="type">PrintWriter</span> out = response.getWriter();</span><br><span class="line">		</span><br><span class="line">		out.println(<span class="string">&quot;test context attributes set by listener&quot;</span>);</span><br><span class="line">		out.println(<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">		<span class="comment">//从ServletContext中得到Dog，在第一次调用服务前，Dog已经放入上下文中了</span></span><br><span class="line">		<span class="type">Dog</span> dog = (<span class="type">Dog</span>)getServletContext().getAttribute(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">		out.println(dog.getBreed());</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整的故事"><a href="#完整的故事" class="headerlink" title="完整的故事"></a>完整的故事</h3><ol>
<li>容器读DD，包括<code>listener</code>和<code>context-param</code>元素，容器为Web创建新的ServletContext</li>
<li>容器为每个<code>ServletContext初始化参数</code>创建一个String <code>名/值对</code>，容器将该名&#x2F;值对（举例为breed）的引用交给ServletContext</li>
<li>容器创建MyServletContextListener类的实例对象</li>
<li>容器调用监听者的<code>contextInitialized() </code>方法，传入新的<code>ServletContextEvent </code>。注：这个event有ServletContext的一个引用，所以事件处理代码可以得到上下文，即<code>event.getServletContext()</code>，进而得到上下文初始化参数</li>
<li>按照4的event，监听者向<code>ServletContextEvent </code>请求<code>ServletContext</code>的一个引用，再向<code>ServletContext</code>请求上下文初始化参数“breed”</li>
<li>监听者使用该初始化参数来构造一个新的Dog对象</li>
<li>监听者将Dog设置为<code>ServletContext</code>的一个属性：<code>sc.setAttribute(&quot;dog&quot;,d)</code>；正式调用Servlet前的准备工作就此完毕</li>
<li>容器建立一个新的Servlet，利用上面的ServletConfig-&gt;ServletContext-&gt;init()方法，新建Servlet完毕</li>
<li>Servlet获得请求，并向ServletContext请求属性dog：<code>getServletContext().getAttribute(&quot;dog&quot;)</code>，Servlet在Dog上调用<code>getBreed()</code>，并将结果打印到HttpResponse中</li>
</ol>
<h2 id="上下文作用域的非线程安全"><a href="#上下文作用域的非线程安全" class="headerlink" title="上下文作用域的非线程安全"></a>上下文作用域的非线程安全</h2><ol>
<li>Web应用的每个部分都可以访问上下文属性，多个servlet说明可能有多个线程，线程并发会引起非线程安全</li>
<li>对doGet进行同步服务<code>synchronized</code>，意味着servlet一次仅能处理一个客户，但并不能阻止不同servlet或JSP访问上下文属性，所以需要对上下文加锁，而非servlet</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//doGet()方法</span></span><br><span class="line">public void <span class="keyword">do</span><span class="constructor">Get(HttpServlet Request <span class="params">request</span>,HttpServletResponse <span class="params">response</span>)</span></span><br><span class="line">		throws IOException,ServletException&#123;</span><br><span class="line">	response.set<span class="constructor">ContentType(<span class="string">&quot;text/html&quot;</span>)</span>;</span><br><span class="line">	PrintWriter out = response.get<span class="constructor">Writer()</span>;	out.println(<span class="string">&quot;test context attributes &quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将设置和提取部分加锁，使得获取同一个上下文属性的代码对此同步</span></span><br><span class="line">	synchronized(getServletContext)&#123;</span><br><span class="line">		get<span class="constructor">ServletContext()</span>.set<span class="constructor">Attribute(<span class="string">&quot;foo&quot;</span>,<span class="string">&quot;22&quot;</span>)</span>;</span><br><span class="line">		out.println(get<span class="constructor">ServletContext()</span>.get<span class="constructor">Attribute(<span class="string">&quot;foo&quot;</span>)</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>已完成全书第5章197页，读书笔记未完待续。。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>notes for Shell 1</title>
    <url>/2018/05/17/notes-for-Shell-1/</url>
    <content><![CDATA[<h1 id="Shell入门知识1"><a href="#Shell入门知识1" class="headerlink" title="Shell入门知识1"></a>Shell入门知识1</h1><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p><a href="http://www.runoob.com/linux/linux-shell.html">Shell教程</a></p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>Shell：一种应用程序，用户通过这个界面访问OS内核的服务。</li>
<li>Shell脚本（shell script）：A shell script is a text file containing shell commands. 为shell编写的脚本程序。一般来说的shell编程都是指shell脚本编程。</li>
<li>脚本语言：短小的，用来让计算机自动化完成一系列工作的程序，这段程序可以用文本编辑器修改，不需要编译，通常是解释运行的。</li>
</ul>
<h2 id="干货正文"><a href="#干货正文" class="headerlink" title="干货正文"></a>干货正文</h2><h4 id="Shell脚本示例"><a href="#Shell脚本示例" class="headerlink" title="Shell脚本示例"></a>Shell脚本示例</h4><pre><code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World !&quot;</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h4><p>与C语言类似的规范，但：</p>
<ol>
<li><p>变量名和等号之间不能有空格</p>
 <figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">my_name</span>=<span class="string">&quot;hahajun&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用一个定义过的变量，只要在变量名前面加美元符号即可,花括号建议 添加，不加亦可。二次赋值时可不加美元符号，使用时必加。</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br><span class="line">my_name=<span class="string">&quot;dafeige&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>readonly修饰只读变量</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myurl=<span class="string">&quot;http://likehui.fun&quot;</span></span><br><span class="line"><span class="built_in">readonly</span> myurl</span><br></pre></td></tr></table></figure></li>
<li><p>删除变量 </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">myurl=<span class="string">&quot;http://likehui.fun&quot;</span></span><br><span class="line"><span class="built_in">unset</span> myurl</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><ol>
<li>局部变量:<br>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
<li>环境变量:<br>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
<li>shell变量:<br>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ol>
<h4 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h4><ul>
<li><p>可单引号，亦可双引号</p>
</li>
<li><p>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</p>
</li>
<li><p>单引号字串中不能出现单引号（对单引号使用转义符后也不行）；</p>
</li>
<li><p>双引号里可以有变量，双引号里可以出现转义字符</p>
</li>
<li><p>字符串可拼接</p>
  <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">your_name</span>=<span class="string">&quot;qinjx&quot;</span></span><br><span class="line"><span class="attribute">greeting</span>=<span class="string">&quot;hello, &quot;</span><span class="variable">$your_name</span><span class="string">&quot; !&quot;</span></span><br><span class="line"><span class="attribute">greeting_1</span>=<span class="string">&quot;hello, <span class="variable">$&#123;your_name&#125;</span> !&quot;</span></span><br><span class="line">echo <span class="variable">$greeting</span> <span class="variable">$greeting_1</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取字符串长度,提取子字符串,查找子字符串</p>
  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>=<span class="string">&quot;abcd&quot;</span></span><br><span class="line"><span class="keyword">echo</span> $&#123;<span class="comment">#string&#125; #输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>=<span class="string">&quot;likehui.fun is a great site&quot;</span></span><br><span class="line"><span class="keyword">echo</span> $&#123;<span class="keyword">string</span>:<span class="number">1</span>:<span class="number">4</span>&#125; <span class="comment"># 输出 ikeh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">string</span>=<span class="string">&quot;likehui is a great man&quot;</span></span><br><span class="line"><span class="keyword">echo</span> `expr index <span class="string">&quot;<span class="subst">$string</span>&quot;</span> is`  <span class="comment"># 查找i或s的位置，输出 1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h4><p>bash只支持一维数组，并对数组大小没有限定</p>
<pre><code><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)<span class="regexp">//</span>定义</span><br><span class="line">valuen=<span class="variable">$&#123;array_name[n]&#125;</span><span class="regexp">//</span>读取某一元素</span><br><span class="line">echo <span class="variable">$&#123;array_name[@]&#125;</span><span class="regexp">//</span>读取所有元素	</span><br></pre></td></tr></table></figure>
</code></pre>
<p>未完待续。。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>notes for statistical learning 1</title>
    <url>/2018/05/29/notes-for-statistical-learning-1/</url>
    <content><![CDATA[<h1 id="统计学习方法入门学习笔记1"><a href="#统计学习方法入门学习笔记1" class="headerlink" title="统计学习方法入门学习笔记1"></a>统计学习方法入门学习笔记1</h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ul>
<li>统计学习：即统计机器学习，目的是对数据进行预测和分析；以方法为中心，统计学习方法1.构建模型2.应用模型进行预测和分析；系统通过数据及统计方法提高系统性能的机器学习，即是统计学习。</li>
<li>统计学习的前提：同类数据具有一定的统计规律性。</li>
<li>统计学习三要素：模型，策略（模型选择的准则），算法（求解最优模型的方法）。</li>
<li>监督学习：从training data出发，由算法实现最优模型的选取，使它对training data和test data在给定评价准则下有最优的预测（假设两种 data独立同分布）。学习一个由输入到输出的映射，这一映射由模型来表示。换句话说，学习的目的就在于找到最好的这样的模型。<strong>由人工给出训练集，所以是监督学习</strong>。</li>
<li>模型f(X)：属于由输入空间到输出空间的<strong>映射的集合</strong>，此集合就是假设空间。模型一般由P(Y|X)或Y&#x3D;f(X)表示，前者是条件概率分布，后者是决策函数。<blockquote>
<p>决策函数：非概率模型,类似y&#x3D;f(x)即Label&#x3D;f（Features），</p>
</blockquote>
  <figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">def classify(<span class="built_in">features</span>):</span><br><span class="line"># <span class="keyword">do</span> <span class="built_in">some</span> logic</span><br><span class="line">	<span class="built_in">return</span> <span class="built_in">label</span></span><br></pre></td></tr></table></figure></li>
<li>假设空间：假设‘要学习的模型属于某个函数’的集合，是<strong>理论上所有可能属性值构成的集合空间</strong>，一般有无穷多个。</li>
</ul>
<span id="more"></span>


<ul>
<li><p>回归&#x2F;分类&#x2F;标注问题：基于输入输出变量的不同类型，对预测任务的三种分类，三者都属监督学习，1.近邻法、感知机、朴素贝叶斯法、决策树、逻辑斯谛回归模型、SVM、adaBoost、贝叶斯网络、神经网络都适合于解决分类问题。2.隐性马尔可夫模型、条件随机场适合解决标注问题。3.最小二乘法适合解决回归问题。<strong>分类问题输出值，标记问题输出向量</strong>。</p>
</li>
<li><p>损失函数**L(Y,f(X))**：使用决策函数的输出与真实值之间不一致（出错）的程度。通常分为：</p>
<ul>
<li>0-1损失，（非此即彼）</li>
<li>平方损失，（见名知意）</li>
<li>绝对损失，（见名知意）</li>
<li>对数损失，（将多项式转换成log加和的形式）</li>
</ul>
<p>  损失函数值越小，模型就越好。特点：真实值不可得，故Rexp无法得到<br>  损失函数的期望（期望风险）Rexp是联合分布P(X,Y)与<br>  L(Y,f(X))与微元dxdy对空间X和Y的积分，所以欲选最小的Rexp，就需要已知P，而P又是未知的，所以需要学习得到。</p>
</li>
<li><p>经验风险Remp：训练数据集的平均损失Remp &#x3D;1&#x2F;N(sigema L(y,f(x))。特点：可以得到，用于估计期望风险Rexp，但因训练样本数量少，需要矫正后再估计。若f(x)，L，N已知，则可知Remp。</p>
</li>
<li><p>经验风险最小化：使得Remp最小化的某f(x)，就是经验风险最小化模型。一个常见的例子就是极大似然估计（需要较大样本）。若样本量过小易发生过拟合的现象。</p>
</li>
<li><p>过拟合：一味追求提高对训练数据的预测能力，所选模型的复杂度则 往往会比真模型更高。[理解]训练中你的天鹅全是白色的，于是机器经过学习后，会认为天鹅的羽毛都是白的，以后看到羽毛是黑的天鹅就会认为那不是天鹅。课后题硬背全对，考试全不会。学习太彻底（比如训练误差为0），把训练集中的所有特征几乎都习得了，于是机器学到了太多由于噪声带来的假特征。所以需要限制机器学习，使其学习不那么彻底，因此提升识别正确率；并关注选取良好的训练数据。</p>
</li>
<li><p>两种常用的模型选择的方法：正则化与交叉验证。</p>
</li>
<li><p>正则化：结构风险最小化策略的实现，在经验风险上加上一个正则化项，即一个模型复杂度的单调递增函数。正则化的作用是选择经验风险与模型复杂度同时较小的模型。</p>
</li>
<li><p>交叉验证：在数据较不足的情况下，重复地使用数据，将给定数据进行切分组合为训练集与测试集，在此基础上反复训练。有简单交叉验证（一分为二，不等分），S折交叉验证（一分为S，等分，应用较多），留一交叉验证（相当于N折交叉验证，适用数据缺乏情况）等方法。</p>
</li>
<li><p>结构风险：在经验风险上加上表示模型复杂度的正则化项（与模型复杂度正相关）。</p>
</li>
<li><p>结构风险最小化SRM：防止过拟合的应对策略，等价于正则化。</p>
</li>
<li><p>算法：学习模型采用的具体算法。统计学习问题归结为最优化问题，通常最优化问题没有显式的解析解，所以需要用数值计算的方法求解。统计学习有时可以利用已有的最优化算法，有时需要开发独自的最优化算法。</p>
</li>
<li><p>训练误差：采用模型关于训练数据集的平均误差。</p>
</li>
<li><p>测试误差：采用模型关于测试数据集的平均误差。反映了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。选取模型时的真实目的是使测试误差达到最小。</p>
</li>
<li><p>泛化能力：学习方法对未知数据的预测能力。使用测试误差来评价。</p>
</li>
<li><p>泛化误差：使用学习模型对未知数据预测的误差。即模型的期望风险。通常以泛化误差上界进行研究。</p>
</li>
<li><p>泛化误差上界性质：样本容量增加时，泛化误差上界趋于0；假设空间容量增加时，模型越难学，泛化误差上界就越大。供参考：<a href="https://blog.csdn.net/winter_evening/article/details/70196011">正则化、误差上界的证明等</a></p>
</li>
<li><p>生成方法：由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，因为模型表示了给定输入X产生输出Y的生成关系。有朴素贝叶斯法和隐马尔可夫模型。[理解]列出Y的概率，由人进行判别。学习收敛速度更快，当样本容量增加时，学到的模型可以更快地收敛于真实模型；当存在隐变量时依旧适用。</p>
</li>
<li><p>隐变量：广义上的隐变量主要就是指“不能被直接观察到，但是对系统的状态和能观察到的输出存在影响的一种东西”。<a href="https://www.zhihu.com/question/43216440/answer/156368711">隐变量是什么?</a></p>
</li>
<li><p>判别方法：由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。[理解]机器替人作出选择。直接面对预测，往往学习的准确率更高，由于直接学习所以可以对数据进行各种程度上的抽象，可以简化学习问题。</p>
</li>
<li><p>分类器：监督学习从数据中学习一个分类模型或分类决策函数，称为分类器。一般有学习和分类两个过程。学习过程中，根据已知训练集利用有效学习方法学习一个分类器；在分类过程中，利用学习到的分类器对新的输入实例进行分类。</p>
</li>
<li><p>分类：分类器对新的输入进行输出的预测，即分类；输出称为类。</p>
</li>
<li><p>以关注的类为正类，其他类为负类。</p>
</li>
</ul>
<p>	</p>
<table>
<thead>
<tr>
<th align="center">符号</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TP</td>
<td align="center">将正类预测为正类</td>
</tr>
<tr>
<td align="center">FN</td>
<td align="center">将正类预测为负类</td>
</tr>
<tr>
<td align="center">FP</td>
<td align="center">将负类预测为正类</td>
</tr>
<tr>
<td align="center">TN</td>
<td align="center">将负类预测为负类</td>
</tr>
</tbody></table>
<ul>
<li>精确率precision：P&#x3D;TP&#x2F;(TP+FP)，[理解]所有被预测为正类中预测结果正确的比例。</li>
<li>召回率recall：R&#x3D;TP&#x2F;(TP+FN)，[理解]真实的正类中被正确预测到的比例。</li>
<li>F1值：精确率和召回率的调和平均值，2&#x2F;F1&#x3D;1&#x2F;P+1&#x2F;R，即F1&#x3D;2TP&#x2F;(2TP+FP+FN)；精确率和召回率都高时，F1值也会高。</li>
<li>标注问题：是结构预测问题的简单形式，输入是一个观测序列，输出是一个标记序列或状态序列，目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。可能的标记个数是有限的，单其组合所称的标记序列的个数是依序列长度呈指数级增长的。常用的有隐马尔可夫模型&#x2F;条件随机场。举例：自然语言处理中的词性标注。</li>
<li>回归问题：回归用于预测输入变量和输出变量之间的关系，回归问题的学习等价于函数拟合。</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>statistical machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>operationSystem_primary_1</title>
    <url>/2018/05/06/operationSystem-primary-1/</url>
    <content><![CDATA[<h1 id="操作系统基础部分-1"><a href="#操作系统基础部分-1" class="headerlink" title="操作系统基础部分_1"></a>操作系统基础部分_1</h1><p>副标题：哈工大 李志军《操作系统》</p>
<h2 id="计算机上电后启动（看不懂，以后补充）"><a href="#计算机上电后启动（看不懂，以后补充）" class="headerlink" title="计算机上电后启动（看不懂，以后补充）"></a>计算机上电后启动（看不懂，以后补充）</h2><h3 id="完成功能：读入内存，完成初始化"><a href="#完成功能：读入内存，完成初始化" class="headerlink" title="完成功能：读入内存，完成初始化"></a>完成功能：读入内存，完成初始化</h3><p>Q：os在磁盘上如何取指执行？<br>A：将os从磁盘载入内存中。由一开机时的操作系统第一段代码，即bootsect.s程序(为控制编写代码出现的位置，使用汇编）来完成。</p>
<blockquote>
<ul>
<li>对于Intel x86 PC , 开启电源后, 机器就会开始执行ROM BIOS的一系列系统测试动作，包括检查RAM，keyboard，显示器，软硬磁盘等等。执行完bios的系统测试之后，紧接着控制权会转移给ROM中 的启动程序(ROM bootstrap routine)；这个程序会将磁盘上的第0轨第0扇区（叫boot sector或MBR ， 系统的引导程序就放在此处）读入内存中，并放到自0x07C0:0x0000开始的512个字节处；然后处理机将跳到此处开始执行这一引导程序；也即装入 MBR中的引导程序后， CS:IP &#x3D; 0x07C0:0x0000 。加电后处理机运行在与8086相兼容的实模式下。 </li>
<li>如果要用 bootsect-loader进行系统引导，则必须把bootsect.S编译连接后对应的二进制代码置于MBR ； 当ROM BIOS 把bootsect.S编译连接后对应的二进制代码装入内存后，机器的控制权就完全转交给bootsect ； 也就是说，bootsect将是第一个被读入内存中并执行的程序。</li>
</ul>
</blockquote>
<p>Q：bootsect.s程序做了什么事情 ？<br>A：将os代码分段读入。先读入setup，然后屏幕打印开机logo，再然后调用BIOS的13号中断把os的system部分读入 ，任务完成。然后交给setup取址执行。 </p>
<span id="more"></span>

<p>Q：setup.s做了什么事情？<br>A：</p>
<blockquote>
<ol>
<li>利用中断读取系统数据并保存到 原bootsect位置；</li>
<li>将system模块向下移动到绝对地址0x00000处；</li>
<li>加载中断描述符表寄存器(idtr)和全局描述符表寄存器(gdtr)；</li>
<li>开启A20 地址线，重新设置两个中断控制芯片8259A，将硬件中断号重新设置为0x20 - 0x2f；</li>
<li>最后设置CPU 的控制寄存器CR0（也称机器状态字），从而进入32 位保护模式运行，并跳转到位于system模块最前面部分的head.s 程序继续运行。</li>
</ol>
</blockquote>
<blockquote>
<p>bootsect.S完成加载动作后，就直接跳转到0x90200，这里正是setup.S的程序入口。 setup.S的主要功能就是将系统参数（包括内存、磁盘等，由BIOS返回）拷贝到 0x90000-0x901FF内存中，这个地方正是bootsect.S存放的地方，这时它将被系统参数覆盖。 以后这些参数将由保护模式下的代码来读取。<br>除此之外，setup.S还将video.S中的代码包含进来，检测和设置显示器和显示模式。最 后，setup.S将系统转换到保护模式，并跳转到0x100000（对于bzImage格式的大内核是 0x100000，对于zImage格式的是0x1000）的内核引导代码，Bootloader过程结束。</p>
</blockquote>
<p>Q：system模块的代码是什么？<br>A：第一部分是head.s（head是进去之后的初始化）,接着main.o，接着main.c 。。。</p>
<p>Q:汇编函数如何跳到c函数<br>A：c函数就终要变成汇编函数</p>
<p>Q：这个main.o的工作？<br>A：内存 &#x2F;中断 &#x2F;设备&#x2F;时钟&#x2F;cpu等的初始化</p>
]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>notes_for_HeadFirstServletsAndJsp1</title>
    <url>/2018/05/07/notes-for-HeadFirstServletsAndJsp1/</url>
    <content><![CDATA[<h1 id="Head-First-Servlets-amp-JSP-读书笔记-1"><a href="#Head-First-Servlets-amp-JSP-读书笔记-1" class="headerlink" title="Head First Servlets&amp;JSP 读书笔记_1"></a>Head First Servlets&amp;JSP 读书笔记_1</h1><h2 id="开篇思考"><a href="#开篇思考" class="headerlink" title="开篇思考"></a>开篇思考</h2><p>Q：web的体系结构？<br>A：请求到来时，必须要有人实例化servlet，或至少新建一个线程处理这个请求。必须有人调用servlet的doPost（）和doGet（）方法。必须有人把请求和响应交给servlet。有人管理servlet的生与死和servlet的资源。————由容器来完成。</p>
<p>Q：servlet要做的工作？<br>A：为客户服务。得到一个客户的请求，再发回一个响应。</p>
<p>Q：会话状态的作用是什么？<br>A：因为web服务器没有短期记忆（发送了响应，web服务器就会忘记你是谁，下次你再发出请求时，web服务器不会认识你），此时就需要会话来完成这项工作。</p>
<p>Q：JSP与servlet的关系？<br>A：Jsp会编程servlet。容器会查看jsp，把它转换成java源代码，再编译成完成的java servlet类。</p>
<p>Q：Jsp转换成servlet过程有哪些是程序员需要知道的？<br>A：需要知道转换过程，需要知道怎么在jsp中写java代码，需要知道如何编写jsp。需要学习EL，学习JSTL，学习过滤器…</p>
<span id="more"></span>

<h2 id="干货正文"><a href="#干货正文" class="headerlink" title="干货正文"></a>干货正文</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><blockquote>
<p>HTTP是TCP&#x2F;IP的上层协议。<br>TCP负责确保从一个网络节点向另一个网络节点发送的文件能作为一个<strong>完整</strong>的文件到达目的地，尽管在具体传送过程中这个文件可能会分解为小块传输。<br>IP是一个底层协议，负责把数据快（数据包）沿路移动&#x2F;路由到目的地。<br>HTTP则是另一个网络协议，又一个web特有的特性，但要依赖于TCP&#x2F;IP从一处想另一处完整地传送请求和响应。</p>
</blockquote>
<p>HTTP响应可以包含HTML。HTTP会在响应的内容前面增加首部信息，浏览器使用首部信息帮助处理HTML页面。可以把HTML内容看作是粘贴到HTTP响应中的数据。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>primary_javaweb_forHTML</title>
    <url>/2018/05/06/primary-javaweb-forHTML/</url>
    <content><![CDATA[<h1 id="javaweb基础之HTML-1"><a href="#javaweb基础之HTML-1" class="headerlink" title="javaweb基础之HTML_1"></a>javaweb基础之HTML_1</h1><h2 id="HTMl基本结构"><a href="#HTMl基本结构" class="headerlink" title="HTMl基本结构"></a>HTMl基本结构</h2><p>可参考教程<a href="https://www.w3schools.com/html/default.asp">w3schools</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>html document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li>The “!DOCTYPE html” declaration defines this document to be HTML5,It must only appear once, at the top of the page (before any HTML tags).The &lt;!DOCTYPE&gt; declaration is not case sensitive.</li>
</ul>
</blockquote>
<ul>
<li>The “html” element is the root element of an HTML page</li>
<li>The “head” element contains meta information about the document</li>
<li>The “title” element specifies a title for the document</li>
<li>The “body” element contains the visible page content</li>
<li>The “h1” element defines a large heading</li>
<li>The “p” element defines a paragraph</li>
</ul>
<span id="more"></span>

<p>属性标签有：id，class，style（这三个是通用属性），colspan，type，value（这三个是特有属性）。<br>语义化标签：标题&#x2F;段落等。。。</p>
<h2 id="HTML-Links"><a href="#HTML-Links" class="headerlink" title="HTML Links"></a>HTML Links</h2><p>链接使用”a” 标签，由href属性说明链接目的。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">a</span> href=<span class="string">&quot;https://www.baidu.com&quot;</span>&gt;This is <span class="keyword">a</span> link&lt;/<span class="keyword">a</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-Images"><a href="#HTML-Images" class="headerlink" title="HTML Images"></a>HTML Images</h2><p>使用”img”标签，有source file (src), alternative text (alt，即替代文本), 宽和高作为参数:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;img <span class="attribute">src</span>=<span class="string">&quot;baidu.jpg&quot;</span> <span class="attribute">alt</span>=<span class="string">&quot;baidu.com&quot;</span> <span class="attribute">width</span>=<span class="string">&quot;104&quot;</span> <span class="attribute">height</span>=<span class="string">&quot;142&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-Headings"><a href="#HTML-Headings" class="headerlink" title="HTML Headings"></a>HTML Headings</h2><p>使用<a href="https://www.w3schools.com/tags/tag_hn.asp">h1到h6</a>，有默认大小，也可以用CSS样式来修改。不要随意改变heading的尺寸和粗细。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-size:60px;&quot;</span>&gt;</span>Heading 1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3schools.com/tags/ref_pxtoemconversion.asp">扩展阅读：em和px的区别</a><br>h1默认是2em，即32px。国内用px，国外用em。<br>px是绝对的，而em是相对的.</p>
<h3 id="Absolute-lengths"><a href="#Absolute-lengths" class="headerlink" title="Absolute lengths:"></a>Absolute lengths:</h3><table>
<thead>
<tr>
<th align="center">Unit</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cm</td>
<td align="center">centimeters</td>
</tr>
<tr>
<td align="center">mm</td>
<td align="center">millimeters</td>
</tr>
<tr>
<td align="center">in</td>
<td align="center">inches(1in&#x3D;96px&#x3D;2.54cm)</td>
</tr>
<tr>
<td align="center">px</td>
<td align="center">pixels(1ps&#x3D;1&#x2F;96th of 1in)</td>
</tr>
<tr>
<td align="center">pt</td>
<td align="center">points (1pt &#x3D; 1&#x2F;72 of 1in)</td>
</tr>
<tr>
<td align="center">pc</td>
<td align="center">picas (1pc &#x3D; 12 pt)</td>
</tr>
</tbody></table>
<blockquote>
<p>Pixels (px) are relative to the viewing device. For low-dpi devices, 1px is one device pixel (dot) of the display. For printers and high resolution screens 1px implies multiple device pixels.<br>[译]对于低dpi设备 ，可能1px对应1个像素，但对于高dpi设备，1px对应多个像素。</p>
</blockquote>
<p>所以一般不建议使用绝对单位，但已知输出设备的情况可以使用（如打印布局等）</p>
<h3 id="Relative-Lengths"><a href="#Relative-Lengths" class="headerlink" title="Relative Lengths"></a>Relative Lengths</h3><table>
<thead>
<tr>
<th align="center">Unit</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">em</td>
<td align="center">Relative to the font-size of the element (2em means 2 times the size of the current font)</td>
</tr>
<tr>
<td align="center">ex</td>
<td align="center">Relative to the x-height of the current font (rarely used)</td>
</tr>
<tr>
<td align="center">ch</td>
<td align="center">Relative to width of the “0” (zero)</td>
</tr>
<tr>
<td align="center">rem</td>
<td align="center">Relative to font-size of the root element</td>
</tr>
<tr>
<td align="center">vw</td>
<td align="center">Relative to 1% of the width of the viewport</td>
</tr>
<tr>
<td align="center">vh</td>
<td align="center">Relative to 1% of the height of the viewport</td>
</tr>
<tr>
<td align="center">vmin</td>
<td align="center">Relative to 1% of viewport’s smaller dimension</td>
</tr>
<tr>
<td align="center">vmax</td>
<td align="center">Relative to 1% of viewport’s larger dimension</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">Relative to the parent element（body is a parent to header etc)</td>
</tr>
</tbody></table>
<blockquote>
<p>Tip: The em and rem units are practical in creating perfectly scalable layout!<br>Viewport &#x3D; the browser window size. If the viewport is 50cm wide, 1vw &#x3D; 0.5cm.<br>[译]em和rem在可扩展布局上应用较多。公式中的Viewport是视窗尺寸。</p>
</blockquote>
<h2 id="HTML-Paragraphs"><a href="#HTML-Paragraphs" class="headerlink" title="HTML Paragraphs"></a>HTML Paragraphs</h2><h3 id="“p”-段落"><a href="#“p”-段落" class="headerlink" title="“p” 段落"></a>“p” 段落</h3><h4 id="margin边距"><a href="#margin边距" class="headerlink" title="margin边距"></a>margin边距</h4><blockquote>
<p>Browsers automatically add some space (margin) before and after each “p” element. The margins can be modified with CSS (with the margin properties).</p>
</blockquote>
<p>p标签被浏览器默认加上了margin，可以用css样式来取消掉，这是浏览器默认样式带来的风险（空标签也占空间）。取消eg：</p>
<pre><code><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<h4 id="align对齐"><a href="#align对齐" class="headerlink" title="align对齐"></a>align对齐</h4><p>在HTML5中不被采用，其功能一般由css替代 </p>
<h3 id="“br”空行"><a href="#“br”空行" class="headerlink" title="“br”空行"></a>“br”空行</h3><blockquote>
<p>The “br” tag inserts a single line break.<br>The “br” tag is an empty tag which means that it has no end tag.<br>Tip: The “br” tag is useful for writing addresses or poems.<br>Note: Use the “br” tag to enter line breaks, not to separate paragraphs.</p>
</blockquote>
<h3 id="“pre”预定义样式（html不支持）"><a href="#“pre”预定义样式（html不支持）" class="headerlink" title="“pre”预定义样式（html不支持）"></a>“pre”预定义样式（html不支持）</h3><blockquote>
<p>The “pre” tag defines preformatted text.<br>Text in a “pre” element is displayed in a fixed-width font (usually Courier), and it preserves both spaces and line breaks.<br>Tip: Use the “pre” element when displaying text with unusual formatting, or some sort of computer code.</p>
</blockquote>
]]></content>
      <categories>
        <category>imooc</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>tiny-spring分析笔记（1）</title>
    <url>/2018/11/02/tiny-spring%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="tinySpring-分析笔记——IOC（1）"><a href="#tinySpring-分析笔记——IOC（1）" class="headerlink" title="tinySpring 分析笔记——IOC（1）"></a>tinySpring 分析笔记——IOC（1）</h1><p>学习项目 Github 地址：<a href="https://github.com/code4craft/tiny-spring/releases">code4craft&#x2F;tiny-spring</a></p>
<h2 id="step-1-container-register-and-get"><a href="#step-1-container-register-and-get" class="headerlink" title="step-1-container-register-and-get"></a>step-1-container-register-and-get</h2><p>使用 map 当作 bean 的容器，避免间接 new ，代替直接 new。</p>
<h4 id="1-1-HelloWorldService-java"><a href="#1-1-HelloWorldService-java" class="headerlink" title="1.1 HelloWorldService.java"></a>1.1 HelloWorldService.java</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorldService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helloWorld</span>()</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<p>简单不解释。</p>
<h4 id="1-2-BeanDefinition-java"><a href="#1-2-BeanDefinition-java" class="headerlink" title="1.2 BeanDefinition.java"></a>1.2 BeanDefinition.java</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanDefinition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">Object</span> bean;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">BeanDefinition</span>(<span class="title class_">Object</span> bean) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">bean</span> = bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">getBean</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的 bean 文件，初始化时为 bean 赋值，getBean() 方法。</p>
<h4 id="1-3-BeanFactory-java"><a href="#1-3-BeanFactory-java" class="headerlink" title="1.3 BeanFactory.java"></a>1.3 BeanFactory.java</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="title class_">Map</span>&lt;<span class="title class_">String</span>, <span class="title class_">BeanDefinition</span>&gt; beanDefinitionMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;<span class="title class_">String</span>, <span class="title class_">BeanDefinition</span>&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title class_">Object</span> <span class="title function_">getBean</span>(<span class="params"><span class="built_in">String</span> name</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanDefinitionMap.<span class="title function_">get</span>(name).<span class="title function_">getBean</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">registerBeanDefinition</span>(<span class="params"><span class="built_in">String</span> name, BeanDefinition beanDefinition</span>) &#123;</span><br><span class="line">		beanDefinitionMap.<span class="title function_">put</span>(name, beanDefinition);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最简单的容器——Map，具有插入和取值功能。</p>
<h4 id="1-4-BeanFactoryTest-java【important】"><a href="#1-4-BeanFactoryTest-java【important】" class="headerlink" title="1.4 BeanFactoryTest.java【important】"></a>1.4 BeanFactoryTest.java【important】</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 1.初始化beanfactory</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanFactory</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.注入bean</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>(<span class="keyword">new</span> <span class="title class_">HelloWorldService</span>());</span><br><span class="line">		beanFactory.registerBeanDefinition(<span class="string">&quot;helloWorldService&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        <span class="type">HelloWorldService</span> <span class="variable">helloWorldService</span> <span class="operator">=</span> (HelloWorldService) beanFactory.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程：</p>
<ol>
<li>目标：执行 HelloWorldService 的 helloWorld 方法，但是不直接 new HelloWorldService()</li>
<li>所以先 new 一个 BeanFactory，然后 new 一个 BeanDefinition，在 BeanDefinition 中 new 一个 HelloWorldService（权宜之计）</li>
<li>将 BeanDefinition 插入 BeanFactory 的属性 Map 中</li>
<li>有需要时，从 BeanFactory 的 Map 中 get 到这个 BeanDefinition，然后执行 helloWorld 方法</li>
<li>结束</li>
</ol>
<p>评价：曲线救国，意识有了，但操作垃圾</p>
<h2 id="step-2-abstract-beanfactory-and-do-bean-initilizing-in-it"><a href="#step-2-abstract-beanfactory-and-do-bean-initilizing-in-it" class="headerlink" title="step-2-abstract-beanfactory-and-do-bean-initilizing-in-it"></a>step-2-abstract-beanfactory-and-do-bean-initilizing-in-it</h2><p>相比上一步，step 2 :</p>
<ol>
<li>BeanDefinition 类增加了 <code>Class beanClass</code> 和 <code>String beanClassName</code>属性，对应增加了 setter 和 getter 方法，<strong>重点关注 setBeanClassName 方法，这个方法加载名为“beanClassName”的类并执行其静态代码块</strong>，同时为属性 beanClass 赋值。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">setBeanClassName</span>(<span class="params"><span class="built_in">String</span> beanClassName</span>) &#123;</span><br><span class="line">	<span class="variable language_">this</span>.<span class="property">beanClassName</span> = beanClassName;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">beanClass</span> = <span class="title class_">Class</span>.<span class="title function_">forName</span>(beanClassName);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (<span class="title class_">ClassNotFoundException</span> e) &#123;</span><br><span class="line">		e.<span class="title function_">printStackTrace</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="2-1-BeanFactoryTest-java"><a href="#2-1-BeanFactoryTest-java" class="headerlink" title="2.1 BeanFactoryTest.java"></a>2.1 BeanFactoryTest.java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 1.初始化beanfactory</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutowireCapableBeanFactory</span>();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.注入bean</span></span><br><span class="line">		<span class="type">BeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinition</span>();</span><br><span class="line">        beanDefinition.setBeanClassName(<span class="string">&quot;us.codecraft.tinyioc.HelloWorldService&quot;</span>);</span><br><span class="line">		beanFactory.registerBeanDefinition(<span class="string">&quot;helloWorldService&quot;</span>, beanDefinition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.获取bean</span></span><br><span class="line">        <span class="type">HelloWorldService</span> <span class="variable">helloWorldService</span> <span class="operator">=</span> (HelloWorldService) beanFactory.getBean(<span class="string">&quot;helloWorldService&quot;</span>);</span><br><span class="line">        helloWorldService.helloWorld();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程：</p>
<ol>
<li>目标依旧：执行 HelloWorldService 的 helloWorld 方法，但是不直接 new HelloWorldService()</li>
<li>先 new 一个 BeanFactory，再 new 一个 BeanDefinition</li>
<li><strong>但是，没有选择继续 new HelloWorldService，而是将 HelloWorldService 的全路径传入 setBeanClassName 方法中，由此得到这个类的 object（不是 instance）</strong></li>
<li><strong>在 beanFactory.registerBeanDefinition 的方法中，执行 beanDefinition.getBeanClass().newInstance() 方法，得到这个类的  instance。</strong></li>
<li>然后从 BeanFactory 的 Map 中 get 到这个 BeanDefinition，然后执行 helloWorld 方法</li>
<li>结束</li>
</ol>
<p>评价：将 bean 的创建放入工厂中，不错</p>
<h2 id="step-3-inject-bean-with-property"><a href="#step-3-inject-bean-with-property" class="headerlink" title="step-3-inject-bean-with-property"></a>step-3-inject-bean-with-property</h2><p>相对上一步，step 3 为 bean 注入属性：</p>
<ol>
<li><p>改变 HelloWorldService.java，增加属性<code>String text</code>及 setText()方法。</p>
</li>
<li><p>在 BeanFactoryTest.java 中增加了一段设置 Property（即 text） 的代码，如下：</p>
</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.定义 bean</span></span><br><span class="line">	...（拿到 HelloWorldService 的 <span class="keyword">object</span>）</span><br><span class="line"><span class="comment">// 3.设置属性</span></span><br><span class="line">PropertyValues propertyValues = <span class="keyword">new</span> <span class="constructor">PropertyValues()</span>;</span><br><span class="line">propertyValues.add<span class="constructor">PropertyValue(<span class="params">new</span> PropertyValue(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;Hello World!&quot;</span>)</span>);</span><br><span class="line">beanDefinition.set<span class="constructor">PropertyValues(<span class="params">propertyValues</span>)</span>;</span><br><span class="line"><span class="comment">// 4.生成 bean</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在生成 newInstance()的方法之后，增加一个 <code>applyPropertyValues()</code>的方法。在这个方法中，将 HelloWorldService 中 name 为“text”的属性与 PropertyValues 中的同名属性“text”相匹配。然后将属性值赋进去。</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> AutowireCapableBeanFactory extends AbstractBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected Object <span class="keyword">do</span><span class="constructor">CreateBean(BeanDefinition <span class="params">beanDefinition</span>)</span> throws Exception &#123;</span><br><span class="line">		Object bean = create<span class="constructor">BeanInstance(<span class="params">beanDefinition</span>)</span>;</span><br><span class="line">		apply<span class="constructor">PropertyValues(<span class="params">bean</span>, <span class="params">beanDefinition</span>)</span>;</span><br><span class="line">		return bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected Object create<span class="constructor">BeanInstance(BeanDefinition <span class="params">beanDefinition</span>)</span> throws Exception &#123;</span><br><span class="line">		return beanDefinition.get<span class="constructor">BeanClass()</span>.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	protected void apply<span class="constructor">PropertyValues(Object <span class="params">bean</span>, BeanDefinition <span class="params">mbd</span>)</span> throws Exception &#123;</span><br><span class="line">		<span class="keyword">for</span> (PropertyValue propertyValue : mbd.get<span class="constructor">PropertyValues()</span>.get<span class="constructor">PropertyValues()</span>) &#123;</span><br><span class="line">			Field declaredField = bean.get<span class="constructor">Class()</span>.get<span class="constructor">DeclaredField(<span class="params">propertyValue</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">			declaredField.set<span class="constructor">Accessible(<span class="params">true</span>)</span>;</span><br><span class="line">			declaredField.set(bean, propertyValue.get<span class="constructor">Value()</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体流程：</p>
<ol>
<li>目标依旧：执行 HelloWorldService 的 helloWorld 方法，但是不直接 new HelloWorldService()。再加上一个小目标：为 HelloWorldService 的 text 属性赋值。</li>
<li>先 new 一个 BeanFactory，再 new 一个 BeanDefinition。</li>
<li>通过 Class.forName 得到 HelloWorldService 的 object（同时 将 bean 的 <code>beanClass</code>和<code>beanClassName</code>设置好了）。</li>
<li>将 PropertyValues 放入 BeanDefinition 的实例中。</li>
<li>得到 HelloWorldService 的 instance，将 PropertyValues 的属性值放入 instance 中，（将 bean 的<code>propertyValues</code>设置好了），在设置属性<code>bean</code>，完整的 bean 就此产生，通过 getBean()方法就能够拿到 HelloWorldService 的 instance 了，就可以调用参数&#x2F;执行方法了。</li>
<li>完毕。</li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>tinySpring</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas 使用小技巧</title>
    <url>/2020/06/26/pandas-%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><a href="https://www.pypandas.cn/docs/getting_started/basics.html#%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8">Pandas 基础用法</a> 、<a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/cookbook.html">Cookbook</a> 、 <a href="https://www.jianshu.com/p/a77b0bc736f2/">pandas 常见用法-简书</a>、<a href="https://cloud.tencent.com/developer/article/1815592">初学者使用Pandas的特征工程</a></p>
<p>以及一些乱七八糟的东西，随用随查</p>
<span id="more"></span>

<p>注：以下代码基本省略了import 的内容，需要的自己补上</p>
<h3 id="dataframe-的列处理：空值、替换、整列删除"><a href="#dataframe-的列处理：空值、替换、整列删除" class="headerlink" title="dataframe 的列处理：空值、替换、整列删除"></a>dataframe 的列处理：空值、替换、整列删除</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_train.isnull().<span class="built_in">sum</span>()   <span class="comment">## 查看各列空值情况</span></span><br><span class="line"></span><br><span class="line">df_train[<span class="string">&quot;标签1&quot;</span>].fillna(<span class="string">&quot;normal&quot;</span>,inplace=<span class="literal">True</span>)  <span class="comment">## 处理空值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 按 map 型替换</span></span><br><span class="line">df_train[<span class="string">&#x27;标签1&#x27;</span>].replace(&#123;<span class="string">&#x27;钱庄账户&#x27;</span>:<span class="string">&#x27;target&#x27;</span>,<span class="string">&#x27;上游钱庄账户&#x27;</span>:<span class="string">&#x27;up&#x27;</span>&#125;,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 获取指定行（即第 index+1 行）</span></span><br><span class="line">tmp_df = df_train.iloc[index]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 获取指定列的元素（去重后）</span></span><br><span class="line">b = np.unique(da_train[<span class="string">&quot;Inverter&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按序号删列</span></span><br><span class="line">x=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">15</span>]</span><br><span class="line">df_train.drop(df_train.columns[x], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按某列的数据过滤</span></span><br><span class="line">df[df[col] &gt; <span class="number">0.5</span>]：选择col列的值大于<span class="number">0.5</span>的行</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按单列排序</span></span><br><span class="line">df_files.sort_values(<span class="string">&#x27;columnName&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按多列排序</span></span><br><span class="line">df = df_train.sort_values([<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;month&#x27;</span>,<span class="string">&#x27;day&#x27;</span>,<span class="string">&#x27;hour&#x27;</span>,<span class="string">&#x27;minute&#x27;</span>,<span class="string">&#x27;second&#x27;</span>], ascending=[<span class="literal">True</span>, <span class="literal">True</span>,<span class="literal">True</span>, <span class="literal">True</span>,<span class="literal">True</span>, <span class="literal">True</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除某列元素中多余的空格、换行符等（rstrip 右，lstrip 左，strip 左右）</span></span><br><span class="line">data[<span class="string">&#x27;交易日期(总)&#x27;</span>] = data[<span class="string">&#x27;交易日期(总)&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="built_in">str</span>(x).rstrip())</span><br><span class="line"></span><br><span class="line"><span class="comment">## 多列求和，成为新列</span></span><br><span class="line"><span class="number">1.</span> df[<span class="string">&quot;Test1&quot;</span>]= df[<span class="string">&#x27;col1&#x27;</span>]+df[<span class="string">&#x27;col2&#x27;</span>]</span><br><span class="line"><span class="number">2.</span> data_01[<span class="string">&quot;three_add&quot;</span>]=data_01[[<span class="string">&#x27;pause_video_ratio&#x27;</span>,<span class="string">&#x27;seek_video_ratio&#x27;</span>,<span class="string">&#x27;click_forum_ratio&#x27;</span>]].apply(<span class="built_in">sum</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="number">3.</span> data[<span class="string">&quot;x1&quot;</span>]=data[[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>]].apply(<span class="keyword">lambda</span> x:x[<span class="string">&quot;a&quot;</span>]+x[<span class="string">&quot;b&quot;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 判断某一列是否有nan</span></span><br><span class="line">data_ra.isnull().<span class="built_in">any</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 0 替换 nan</span></span><br><span class="line">df[<span class="string">&#x27;column&#x27;</span>] = df[<span class="string">&#x27;column&#x27;</span>].replace(np.nan, <span class="number">0</span>)  <span class="comment"># 某列</span></span><br><span class="line">df[<span class="string">&#x27;column&#x27;</span>]=df[<span class="string">&#x27;column&#x27;</span>].fillna(value)  <span class="comment"># 某列</span></span><br><span class="line">df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)    <span class="comment"># 整张表</span></span><br><span class="line">df.replace(np.nan, <span class="number">0</span>, inplace=<span class="literal">True</span>)   <span class="comment"># 整张表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 将df2中的列添加到df1的尾部</span></span><br><span class="line">df.concat([df1, df2],axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 指定列元素的数据格式</span></span><br><span class="line">data_raw[[<span class="string">&#x27;交易金额&#x27;</span>,<span class="string">&#x27;交易余额&#x27;</span>]] = data_raw[[<span class="string">&#x27;交易金额&#x27;</span>,<span class="string">&#x27;交易余额&#x27;</span>]].astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 列名重命名</span></span><br><span class="line">data_a.columns = [<span class="string">&#x27;交易账卡号&#x27;</span>,<span class="string">&#x27;交易总天数&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 三维数组转 DataFrame（不规整的数组不确定行不行）</span></span><br><span class="line">df = pd.DataFrame(my_triple_list, columns=[<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 文本提取：从 Item_Identifier 列（如DRC01）中取出前两个字母，组成新列 Item_Code(如 DR)</span></span><br><span class="line">data[<span class="string">&#x27;Item_Code&#x27;</span>] = data[<span class="string">&#x27;Item_Identifier&#x27;</span>].apply(<span class="keyword">lambda</span> x: x[<span class="number">0</span>:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>



<h3 id="dataframe-的行处理："><a href="#dataframe-的行处理：" class="headerlink" title="dataframe 的行处理："></a>dataframe 的行处理：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 按序号删行</span></span><br><span class="line">data_1.drop([<span class="number">0</span>,<span class="number">1</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除有nan的行</span></span><br><span class="line">data_ra.drop(data_ra[np.isnan(data_ra[<span class="string">&#x27;交易金额&#x27;</span>])].index, inplace=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除重复行</span></span><br><span class="line">data_ra.drop_duplicates(subset=[<span class="string">&#x27;交易账卡号&#x27;</span>,<span class="string">&#x27;交易日期(总)&#x27;</span>,<span class="string">&#x27;收付标志&#x27;</span>,<span class="string">&#x27;交易金额&#x27;</span>,<span class="string">&#x27;交易余额&#x27;</span>],keep=<span class="string">&#x27;first&#x27;</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除空字符串的行（删除指定的行编号）</span></span><br><span class="line">data_ra.drop(labels=<span class="built_in">list</span>(data_ra.loc[data_ra[<span class="string">&#x27;交易金额&#x27;</span>] == <span class="string">&#x27;&#x27;</span>].index), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## jupyter notebook中显示完整的行和列</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;max_columns&#x27;</span>,<span class="number">1000</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;max_row&#x27;</span>,<span class="number">300</span>)</span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="keyword">lambda</span> x: <span class="string">&#x27;%.5f&#x27;</span> % x)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按行遍历</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(my_df.index)):</span><br><span class="line">  tmp_df = my_df.iloc[i] <span class="comment"># 每行都是一个小 dataFrame</span></span><br></pre></td></tr></table></figure>



<h3 id="dataframe-的-lambda"><a href="#dataframe-的-lambda" class="headerlink" title="dataframe 的 lambda"></a>dataframe 的 lambda</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 接入整个 dataframe，然后取某列数据进行数学计算，得出的结果被 apply 添加成新列</span></span><br><span class="line">a0[<span class="string">&quot;交易笔数&quot;</span>] = a0.apply(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x.交易余额&lt;<span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 多元 if elif：https://blog.csdn.net/weixin_39750084/article/details/103437665</span></span><br><span class="line">df[<span class="string">&#x27;col1&#x27;</span>] = df[<span class="string">&#x27;col2&#x27;</span>].apply(<span class="keyword">lambda</span> x:<span class="number">1</span> <span class="keyword">if</span> x==A <span class="keyword">else</span> (<span class="number">2</span> <span class="keyword">if</span> x==B <span class="keyword">else</span> (<span class="number">3</span> <span class="keyword">if</span> x==C <span class="keyword">else</span> <span class="number">4</span>)))</span><br></pre></td></tr></table></figure>

<h3 id="dataframe-的拼接用法（新行）"><a href="#dataframe-的拼接用法（新行）" class="headerlink" title="dataframe 的拼接用法（新行）"></a>dataframe 的拼接用法（新行）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## output4拼接到 output3 下面，按字段匹配，结果：行数增加</span></span><br><span class="line">data_ra=pd.concat([output3,output4,output5])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将df2中的行添加到df1的尾部</span></span><br><span class="line">df1.append(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串拼接</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;st1&#x27;</span>, <span class="string">&#x27;st2&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="dataframe-lt-—-gt-json"><a href="#dataframe-lt-—-gt-json" class="headerlink" title="dataframe &lt;—&gt; json"></a>dataframe &lt;—&gt; json</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## dataframe 跟 json 的转换</span></span><br><span class="line"><span class="comment"># dataframe -&gt; json string -&gt; json object -&gt; string</span></span><br><span class="line">jsonstr = df.to_json()</span><br><span class="line">jsonobject = json.loads(jsonstr)</span><br><span class="line">newString = json.dumps(jsonobject)</span><br></pre></td></tr></table></figure>



<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><a href="https://blog.csdn.net/Asher117/article/details/84725199">[Python3]pandas.merge用法详解</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 普通 Merge 的多种方式</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">&#x27;key1&#x27;</span>) <span class="comment"># key名相同</span></span><br><span class="line">pd.merge(df1, df2, left_on=<span class="string">&#x27;key1&#x27;</span>, right_on=<span class="string">&#x27;key2&#x27;</span>)  <span class="comment"># key 名不同</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">&#x27;key**&#x27;</span>, how=<span class="string">&#x27;left&#x27;</span>) <span class="comment"># 连接方式，此外还有 inner、right、outer 等</span></span><br><span class="line">pd.merge(df1, df2, left_on=<span class="string">&#x27;key1&#x27;</span>, right_index=<span class="literal">True</span>)  <span class="comment">#右表以索引作为连接键</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">&#x27;key1&#x27;</span>, suffixes=(<span class="string">&#x27;_df1&#x27;</span>,<span class="string">&#x27;_df2&#x27;</span>)) <span class="comment">#两表合并后，如果存在相同字段，那么会默认加上_x,_y 之类后缀，使用suffixes可以自定义该后缀</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">&#x27;inner&#x27;</span>, on=[<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>]) <span class="comment"># 多字段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 多个 DataFrame 的 Merge</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">dfs = [df1, df2, df3]</span><br><span class="line">df_final = reduce(<span class="keyword">lambda</span> left,right: pd.merge(left,right,on=<span class="string">&#x27;col&#x27;</span>,how=<span class="string">&#x27;left&#x27;</span>), dfs)</span><br></pre></td></tr></table></figure>





<h3 id="dataframe-的-groupby-用法"><a href="#dataframe-的-groupby-用法" class="headerlink" title="dataframe 的 groupby 用法"></a>dataframe 的 groupby 用法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## groupby + agg 组合用法，diff 等需要提前 def</span></span><br><span class="line">a1 = a0.groupby([<span class="string">&#x27;交易账号&#x27;</span>,<span class="string">&#x27;交易日期&#x27;</span>]).agg(&#123;<span class="string">&#x27;交易账号&#x27;</span>:<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;标签1&#x27;</span>:<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;交易金额&#x27;</span>:diffAmont,<span class="string">&#x27;交易笔数&#x27;</span>:diff&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 对变量Item_Identifier和Item_Type进行分组，以查看Item_Outlet_Sales均值</span></span><br><span class="line">data[<span class="string">&#x27;Item_Outlet_Sales_Mean&#x27;</span>] = data.groupby([<span class="string">&#x27;Item_Identifier&#x27;</span>, <span class="string">&#x27;Item_Type&#x27;</span>])[<span class="string">&#x27;Item_Outlet_Sales&#x27;</span>].transform(<span class="keyword">lambda</span> x: x.mean())</span><br></pre></td></tr></table></figure>



<h3 id="dataframe-处理时间"><a href="#dataframe-处理时间" class="headerlink" title="dataframe 处理时间"></a>dataframe 处理时间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 按时间格式取 year</span></span><br><span class="line">df_train[<span class="string">&quot;date&quot;</span>] = pd.to_datetime(df_train[<span class="string">&quot;交易日期&quot;</span>],<span class="built_in">format</span>=<span class="string">&#x27;%Y/%m/%d&#x27;</span>)</span><br><span class="line">df_train[<span class="string">&quot;year&quot;</span>] = pd.to_datetime(df_train[<span class="string">&quot;date&quot;</span>]).dt.year</span><br><span class="line"></span><br><span class="line"><span class="comment">## 按yyyy-mm-dd HH-MM-SS 排序</span></span><br><span class="line">data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>] = pd.to_datetime(data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>])</span><br><span class="line">data_raw = data_raw.sort_values(<span class="string">&#x27;交易日期(总)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 24 小时分时段统计</span></span><br><span class="line">data_7[<span class="string">&#x27;交易时间段&#x27;</span>]=pd.cut(data_7[<span class="string">&#x27;交易时刻&#x27;</span>],[<span class="number">0</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">24</span>],labels=[<span class="string">&#x27;(0,4]&#x27;</span>,<span class="string">&#x27;(4,8]&#x27;</span>,<span class="string">&#x27;(8,12]&#x27;</span>,<span class="string">&#x27;(12,16]&#x27;</span>,<span class="string">&#x27;(16,20]&#x27;</span>,<span class="string">&#x27;(20,24]&#x27;</span>]</span><br><span class="line">,include_lowest=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 将字符串转换为时间序列时间戳格式</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transforms</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(time.mktime(time.strptime(s, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)))</span><br><span class="line">data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>] = data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>].astype(<span class="built_in">str</span>)</span><br><span class="line">data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>] = data_raw[<span class="string">&#x27;交易日期(总)&#x27;</span>].apply(transforms)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 计算程序段运行时间</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">sqlquerrystart =time.perf_counter()</span><br><span class="line"><span class="comment">#...# 程序段</span></span><br><span class="line">sqlquerryend = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;sqlquerry time: %s Seconds&#x27;</span>%(sqlquerryend-sqlquerrystart))</span><br></pre></td></tr></table></figure>



<h3 id="python-读文件"><a href="#python-读文件" class="headerlink" title="python 读文件"></a>python 读文件</h3><p>done_list 是处理过的文件的路径，以下读文件时会自动跳过。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从路径中获取日期和文件名</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gci</span>(<span class="params">filepath</span>):   </span><br><span class="line">    done_list = []</span><br><span class="line">    files_msg = []</span><br><span class="line">    files = os.listdir(filepath)</span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">if</span> fi.startswith(<span class="string">&quot;done_list&quot;</span>):</span><br><span class="line">            f_0 = <span class="built_in">open</span>(fi)</span><br><span class="line">            lines = f_0.readlines()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines: </span><br><span class="line">                done_list.append(line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>))     </span><br><span class="line">    <span class="keyword">for</span> fi <span class="keyword">in</span> files:</span><br><span class="line">        fi_d = os.path.join(filepath,fi)</span><br><span class="line">        <span class="comment"># 同路径下的文件夹</span></span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(fi_d):</span><br><span class="line">            <span class="comment"># 遍历文件</span></span><br><span class="line">            <span class="keyword">for</span> dd <span class="keyword">in</span> os.listdir(fi_d):</span><br><span class="line">                <span class="keyword">if</span> dd.endswith(<span class="string">&quot;.csv&quot;</span>):</span><br><span class="line">                    day = os.path.basename(fi_d)</span><br><span class="line">                    file_in_day = os.path.join(fi_d, dd)</span><br><span class="line">                    <span class="keyword">if</span> file_in_day <span class="keyword">not</span> <span class="keyword">in</span> done_list:</span><br><span class="line">                        tmp = []</span><br><span class="line">                        tmp.append(dd)</span><br><span class="line">                        tmp.append(file_in_day)</span><br><span class="line">                        tmp.append(day)</span><br><span class="line">                        files_msg.append(tmp)</span><br><span class="line">    df_files = pd.DataFrame(files_msg, columns=[<span class="string">&#x27;fileName&#x27;</span>,<span class="string">&#x27;filePath&#x27;</span>,<span class="string">&#x27;fileCreateDay&#x27;</span>])</span><br><span class="line">    df_files.sort_values(<span class="string">&#x27;fileName&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> df_files </span><br><span class="line"></span><br><span class="line"><span class="comment"># 写 done_list.txt:</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;done_list.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>, mode=<span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(file_in_day)</span><br><span class="line">    file.write(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="python-删除文件"><a href="#python-删除文件" class="headerlink" title="python 删除文件"></a>python 删除文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">os.remove(my_file_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;File &quot;</span> + my_file_path +<span class="string">&quot; removed successfully&quot;</span>) </span><br></pre></td></tr></table></figure>

<h3 id="python-连接-mysql"><a href="#python-连接-mysql" class="headerlink" title="python 连接 mysql"></a>python 连接 mysql</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">password=<span class="string">&#x27;MySQL-root@[st098]&#x27;</span></span><br><span class="line">pwd=parse.quote_plus(password)</span><br><span class="line">DB_CONNECT = <span class="string">f&#x27;mysql+pymysql://root:<span class="subst">&#123;pwd&#125;</span>@***:3306/test?charset=utf8&#x27;</span>    </span><br><span class="line">engine = create_engine(DB_CONNECT)</span><br><span class="line">conn = engine.connect()</span><br><span class="line">conn.execute(<span class="string">&quot;delete from [&quot;</span> + table_name + <span class="string">&quot;] where Day = &#x27;&quot;</span> + day + <span class="string">&quot;&#x27;&quot;</span>)</span><br></pre></td></tr></table></figure>




<h3 id="python-发送-mqtt-消息"><a href="#python-发送-mqtt-消息" class="headerlink" title="python 发送 mqtt 消息"></a>python 发送 mqtt 消息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"></span><br><span class="line">MQTTHOST = <span class="string">&quot;your_ip&quot;</span></span><br><span class="line">MQTTPORT = <span class="number">61613</span></span><br><span class="line">mqttClient = mqtt.Client()</span><br><span class="line"><span class="comment"># 连接MQTT服务器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_mqtt_connect</span>():</span><br><span class="line">    mqttClient.username_pw_set(<span class="string">&#x27;admin&#x27;</span>, password=<span class="string">&#x27;your_pwd&#x27;</span>)    </span><br><span class="line">    mqttClient.connect(MQTTHOST, MQTTPORT, <span class="number">60</span>)</span><br><span class="line">    mqttClient.loop_start()</span><br><span class="line"><span class="comment"># publish 消息</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">on_publish</span>(<span class="params">topic, payload, qos</span>):</span><br><span class="line">    mqttClient.publish(topic, payload, qos)</span><br><span class="line"></span><br><span class="line">on_mqtt_connect()</span><br><span class="line">on_publish(topic, payload, <span class="number">0</span>)    </span><br></pre></td></tr></table></figure>



<h3 id="threading-多线程执行程序（也可读文件）"><a href="#threading-多线程执行程序（也可读文件）" class="headerlink" title="threading 多线程执行程序（也可读文件）"></a>threading 多线程执行程序（也可读文件）</h3><p><a href="https://www.cnblogs.com/gongyanzh/p/14820926.html">python多线程&#x2F;进程文件读取</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进程池方式</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]</span><br><span class="line">b = [<span class="number">31</span>,<span class="number">32</span>,<span class="number">33</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">36</span>,<span class="number">37</span>,<span class="number">38</span>,<span class="number">39</span>,<span class="number">40</span>,<span class="number">41</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(<span class="params">param1, param2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;param1:&quot;</span>, param1, <span class="string">&quot;, param2:&quot;</span>, param2)</span><br><span class="line">thread_num = <span class="number">5</span></span><br><span class="line"><span class="keyword">with</span> ProcessPoolExecutor(thread_num) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">        executor.submit(fn, a[index], b[index]) </span><br></pre></td></tr></table></figure>



<h3 id="特征工程-amp-可视化"><a href="#特征工程-amp-可视化" class="headerlink" title="特征工程&amp;可视化"></a>特征工程&amp;可视化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 查看字段的频率</span></span><br><span class="line">pd.DataFrame(data_00[<span class="string">&#x27;some_fea&#x27;</span>].value_counts())</span><br><span class="line"></span><br><span class="line"><span class="comment">### 绘制柱状图</span></span><br><span class="line">plt.hist(data,<span class="built_in">range</span>=(<span class="number">0</span>,<span class="number">80</span>),bins=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">### one-hot 编码，将 Outlet_Type 列独热编码后生成多列，接在 data 尾部</span></span><br><span class="line">Outlet_Type_Dumm = pd.get_dummies(data=data[<span class="string">&#x27;Outlet_Type&#x27;</span>], columns=[<span class="string">&#x27;Outlet_Type&#x27;</span>], drop_first=<span class="literal">True</span>)</span><br><span class="line">pd.concat([data[<span class="string">&#x27;Outlet_Type&#x27;</span>], Outlet_Type_Dumm], axis=<span class="number">1</span>).head()</span><br><span class="line"></span><br><span class="line"><span class="comment">### Z-score 处理全部 feature</span></span><br><span class="line"><span class="comment">## 提前声明好 train_fea</span></span><br><span class="line"><span class="comment"># z分数标准化（全部特征）</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler </span><br><span class="line"><span class="comment"># 实例化方法 </span></span><br><span class="line">scaler = StandardScaler() </span><br><span class="line">data_mean_scaled = pd.DataFrame(scaler.fit_transform(data01[train_fea]),columns=train_fea) </span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用 cut 函数对 Item_MRP 列进行分箱，以下方法显式地提供 bin 边缘，不保证每个 bin 内观测值的分布都是相等的</span></span><br><span class="line"><span class="comment">#define bins </span></span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">70</span>, <span class="number">140</span>, <span class="number">210</span>, <span class="number">280</span>]</span><br><span class="line"><span class="comment">#name of groups</span></span><br><span class="line">groups = [<span class="string">&#x27;Low&#x27;</span>, <span class="string">&#x27;Med&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Exp&#x27;</span>]</span><br><span class="line">data[<span class="string">&#x27;Item_MRP_Bin_cut&#x27;</span>] = pd.cut(data[<span class="string">&#x27;Item_MRP&#x27;</span>], bins=bins, labels=groups)</span><br><span class="line"></span><br><span class="line"><span class="comment">### qcut 函数是按照频率分箱，各 bin 内观测数一致，但 qcut 不常用，建议使用 cut 函数</span></span><br><span class="line">groups = [<span class="string">&#x27;Low&#x27;</span>, <span class="string">&#x27;Med&#x27;</span>, <span class="string">&#x27;High&#x27;</span>, <span class="string">&#x27;Exp&#x27;</span>]</span><br><span class="line">data[<span class="string">&#x27;Item_MRP_Bin_qcut&#x27;</span>] = pd.qcut(data[<span class="string">&#x27;Item_MRP&#x27;</span>], q=<span class="number">4</span>, labels=groups)</span><br></pre></td></tr></table></figure>



<h3 id="Numpy-之-axis"><a href="#Numpy-之-axis" class="headerlink" title="Numpy 之 axis"></a>Numpy 之 axis</h3><p>axis&#x3D;0代表往**跨行（down)<strong>，而axis&#x3D;1代表</strong>跨列（across)**，作为方法动作的副词。而且Pandas保持了Numpy对关键字axis的用法</p>
<ul>
<li>使用0值表示沿着每一列或行标签\索引值向下执行方法</li>
<li>使用1值表示沿着每一行或者列标签模向执行对应的方法</li>
</ul>
<h3 id="seaborn-绘图"><a href="#seaborn-绘图" class="headerlink" title="seaborn 绘图"></a>seaborn 绘图</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 一行双图</span></span><br><span class="line">f, (ax1,ax2) = plt.subplots(<span class="number">1</span>,<span class="number">2</span>, figsize=(<span class="number">20</span>, <span class="number">6</span>))</span><br><span class="line">sns.distplot(v14_fraud_dist,ax=ax1, fit=norm, color=<span class="string">&#x27;#FB8861&#x27;</span>)</span><br><span class="line">sns.distplot(v14_fraud_dist,ax=ax2, fit=norm, color=<span class="string">&#x27;#FB8861&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 一行四图</span></span><br><span class="line">f, axes = plt.subplots(ncols=<span class="number">4</span>, figsize=(<span class="number">20</span>,<span class="number">4</span>))</span><br><span class="line">sns.boxplot(x=<span class="string">&quot;target&quot;</span>, y=<span class="string">&#x27;间隔交易时间_std&#x27;</span>, data=data, palette=<span class="literal">None</span>, ax=axes[<span class="number">0</span>])</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">## 两行四图</span></span><br><span class="line">f= plt.figure(figsize=(<span class="number">20</span>,<span class="number">10</span>))</span><br><span class="line">axes = [plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">0</span>)),plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">0</span>,<span class="number">1</span>)),</span><br><span class="line">       plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">0</span>)),plt.subplot2grid((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">1</span>))]</span><br><span class="line">sns.boxplot(x=<span class="string">&quot;target&quot;</span>, y=<span class="string">&quot;交易金额大于1000的次数&quot;</span>, data=data, palette=<span class="literal">None</span>, ax=axes[<span class="number">0</span>])</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看柱状计数图</span></span><br><span class="line">colors = [<span class="string">&quot;#0101DF&quot;</span>, <span class="string">&quot;#DF0101&quot;</span>]</span><br><span class="line">sns.countplot(<span class="string">&#x27;target&#x27;</span>, data=data_show, palette=colors)</span><br><span class="line">plt.title(<span class="string">&#x27;Class Distributions \n (0: normal || 1: suspect)&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看特征间的散点相关图</span></span><br><span class="line">cols = [<span class="string">&#x27;isMulti_y&#x27;</span>, <span class="string">&#x27;in_out_ratio&#x27;</span>, <span class="string">&#x27;交易余额均值&#x27;</span>, <span class="string">&#x27;密集交易数据&#x27;</span>]</span><br><span class="line">sns.pairplot(data01[cols], size = <span class="number">2.5</span>)</span><br><span class="line">plt.show();</span><br></pre></td></tr></table></figure>



<h3 id="python-md5-加密"><a href="#python-md5-加密" class="headerlink" title="python+md5 加密"></a>python+md5 加密</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取原始密码+salt的md5值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_md5</span>(<span class="params">pwd,salt=<span class="string">&#x27;128t&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(pwd != <span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        md5_obj = hashlib.md5()  </span><br><span class="line">        md5_obj.update((<span class="built_in">str</span>(pwd) + <span class="built_in">str</span>(salt)).encode(<span class="string">&quot;utf-8&quot;</span>))  </span><br><span class="line"><span class="comment">#         print(&quot;pwd:&quot;,pwd,&quot;,salt:&quot;,salt,&quot;,md5:&quot;,md5_obj.hexdigest())</span></span><br><span class="line">        <span class="keyword">return</span> md5_obj.hexdigest()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">data[<span class="string">&#x27;target&#x27;</span>] = data[<span class="string">&#x27;target&#x27;</span>].apply(create_md5)  <span class="comment">## target 列原地加密</span></span><br></pre></td></tr></table></figure>

<h3 id="树模型查看特征重要性"><a href="#树模型查看特征重要性" class="headerlink" title="树模型查看特征重要性"></a>树模型查看特征重要性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 以下传参中的 gbm 是训练好的模型</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;savefig.dpi&#x27;</span>] = <span class="number">100</span> <span class="comment">#图片像素</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;figure.dpi&#x27;</span>] = <span class="number">100</span> <span class="comment">#分辨率</span></span><br><span class="line"><span class="comment">#模型特征重要性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_show_feature_import</span>(<span class="params">clf,train_x</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------feature importance------&#x27;</span>)</span><br><span class="line">    feature_imp = np.zeros([train_x.shape[<span class="number">1</span>]])  <span class="comment">#df.shape[0] 行数 df.shape[1] 列数</span></span><br><span class="line">    feature_imp += clf.feature_importances_</span><br><span class="line">  feature_importance=pd.DataFrame(&#123;<span class="string">&#x27;features&#x27;</span>:train_x.columns,<span class="string">&#x27;importance&#x27;</span>:feature_imp&#125;)</span><br><span class="line">    feature_importance[<span class="string">&#x27;importance_rate&#x27;</span>]=feature_importance[<span class="string">&#x27;importance&#x27;</span>]/feature_importance[<span class="string">&#x27;importance&#x27;</span>].<span class="built_in">sum</span>()</span><br><span class="line">    feature_importance=feature_importance.sort_values(by=<span class="string">&#x27;importance&#x27;</span>,ascending=<span class="literal">False</span>).reset_index(drop=<span class="literal">True</span>)  </span><br><span class="line">    feature_importance[<span class="string">&#x27;cumsum_rate&#x27;</span>]=np.cumsum(feature_importance[<span class="string">&#x27;importance_rate&#x27;</span>])</span><br><span class="line">    plt.figure(figsize=(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">    sns.barplot(x=<span class="string">&#x27;importance&#x27;</span>,y=<span class="string">&#x27;features&#x27;</span>,data=feature_importance[<span class="number">0</span>:<span class="number">10</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="keyword">return</span> feature_importance </span><br><span class="line"><span class="comment">#调用函数，得到特征重要性</span></span><br><span class="line">feature_importance = _show_feature_import(gbm,x_train)</span><br></pre></td></tr></table></figure>

<h3 id="lightgbm"><a href="#lightgbm" class="headerlink" title="lightgbm"></a>lightgbm</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train, x_test, y_train, y_test = train_test_split(X_train,</span><br><span class="line">                                                    Y_train,</span><br><span class="line">                                                   test_size= <span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">250</span>,</span><br><span class="line">          <span class="string">&#x27;max_depth&#x27;</span>:<span class="number">7</span>,</span><br><span class="line">          <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.03</span>,</span><br><span class="line">          <span class="string">&quot;boosting_type&quot;</span>: <span class="string">&quot;gbdt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;bagging_seed&quot;</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="string">&quot;metric&quot;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">          <span class="comment">#&quot;metric&quot;: &#x27;map&#x27;,</span></span><br><span class="line">          <span class="string">&#x27;reg_alpha&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;reg_lambda&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;random_state&#x27;</span>: <span class="number">233</span>,</span><br><span class="line">          <span class="string">&#x27;is_unbalanced&#x27;</span>:<span class="literal">False</span></span><br><span class="line">         &#125;</span><br><span class="line">gbm = lgb.LGBMClassifier(**params,n_estimators=<span class="number">500</span>)</span><br><span class="line">gbm.fit(x_train,y_train.astype(<span class="string">&#x27;int&#x27;</span>),</span><br><span class="line">        eval_set=[(x_test,y_test)],</span><br><span class="line">        early_stopping_rounds=<span class="number">50</span>,</span><br><span class="line">        verbose=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 绘制 ROC</span></span><br><span class="line">y_probs = gbm.predict_proba(X_test)[:,<span class="number">1</span>]<span class="comment">#模型的预测得分</span></span><br><span class="line">fpr, tpr, thresholds = metrics.roc_curve(Y_test,y_probs)</span><br><span class="line">roc_auc = auc(fpr, tpr)  <span class="comment">#auc为Roc曲线下的面积#开始画ROC曲线</span></span><br><span class="line">plt.plot(fpr, tpr, <span class="string">&#x27;b&#x27;</span>,label=<span class="string">&#x27;AUC = %0.2f&#x27;</span>% roc_auc)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>],<span class="string">&#x27;r--&#x27;</span>)</span><br><span class="line">plt.xlim([-<span class="number">0.1</span>,<span class="number">1.1</span>])</span><br><span class="line">plt.ylim([-<span class="number">0.1</span>,<span class="number">1.1</span>])</span><br><span class="line">plt.xlabel(<span class="string">&#x27;False Positive Rate&#x27;</span>) <span class="comment">#横坐标是fpr</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;True Positive Rate&#x27;</span>)  <span class="comment">#纵坐标是tpr</span></span><br><span class="line">plt.title(<span class="string">&#x27;lightgbm模型ROC曲线&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="随机森林-GridSearchCV"><a href="#随机森林-GridSearchCV" class="headerlink" title="随机森林+GridSearchCV"></a>随机森林+GridSearchCV</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将分类随机森林实例化</span></span><br><span class="line">rd = RandomForestClassifier(random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">param_grid = &#123;</span><br><span class="line">    <span class="string">&quot;n_estimators&quot;</span>:np.arange(<span class="number">2</span>,<span class="number">30</span>), <span class="comment"># 决策树的数量</span></span><br><span class="line">    <span class="string">&quot;max_depth&quot;</span>: np.arange(<span class="number">2</span>,<span class="number">20</span>),  <span class="comment"># 最大决策深度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用这个方法可以直接对随机森林调参</span></span><br><span class="line">algo = GridSearchCV(estimator=rd, param_grid=param_grid, cv=<span class="number">5</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">algo.fit(X_train, Y_train)  <span class="comment"># 训练模型</span></span><br><span class="line">pre_x = algo.predict(X_test)  <span class="comment"># 预测</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;训练集模型评分:&quot;</span>,algo.score(X_train,Y_train)) <span class="comment"># 训练集准确率</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;测试集模型评分:&quot;</span>,algo.score(X_test,Y_test))  <span class="comment"># 测试集准确率</span></span><br><span class="line"></span><br><span class="line">sns.heatmap(confusion_matrix(Y_test, pre_x),annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.10g&#x27;</span>)  <span class="comment"># 混淆矩阵</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;真实值&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;预测值&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Classification report (validation):\n &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(classification_report(pre_x, Y_test,digits =<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">best_params_ = algo.best_params_</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最优参数列表:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(best_params_))</span><br></pre></td></tr></table></figure>

<h3 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lr = LogisticRegression()   <span class="comment"># 初始化LogisticRegression</span></span><br><span class="line">lr.fit(X_train,Y_train)   <span class="comment"># 使用训练集对测试集进行训练</span></span><br><span class="line">lr_y_predit=lr.predict(X_test)  <span class="comment"># 使用逻辑回归函数对测试集进行预测</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;Accuracy of LR Classifier:%f&#x27;</span>%lr.score(X_test,Y_test))   <span class="comment"># 使得逻辑回归模型自带的评分函数score获得模型在测试集上的准确性结果</span></span><br><span class="line"><span class="built_in">print</span> (classification_report(Y_test,lr_y_predit,target_names=[<span class="string">&#x27;Benign&#x27;</span>,<span class="string">&#x27;Malignant&#x27;</span>]) ) <span class="comment">#良性，恶性</span></span><br></pre></td></tr></table></figure>

<h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># rbf核函数，设置数据权重</span></span><br><span class="line">svc = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>,)</span><br><span class="line">c_range = np.logspace(-<span class="number">5</span>, <span class="number">15</span>, <span class="number">11</span>, base=<span class="number">2</span>)</span><br><span class="line">gamma_range = np.logspace(-<span class="number">9</span>, <span class="number">3</span>, <span class="number">13</span>, base=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 网格搜索交叉验证的参数范围，cv=3,3折交叉</span></span><br><span class="line">param_grid = [&#123;<span class="string">&#x27;kernel&#x27;</span>: [<span class="string">&#x27;rbf&#x27;</span>], <span class="string">&#x27;C&#x27;</span>: c_range, <span class="string">&#x27;gamma&#x27;</span>: gamma_range&#125;]</span><br><span class="line">grid = GridSearchCV(svc, param_grid, cv=<span class="number">3</span>, n_jobs=-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">clf = grid.fit(X_train, Y_train)</span><br><span class="line"><span class="comment"># 计算测试集精度</span></span><br><span class="line">score = grid.score(X_test, Y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;精度为%s&#x27;</span> % score)</span><br><span class="line">svc_y_predit = grid.predict(X_test)</span><br><span class="line"><span class="built_in">print</span> (classification_report(Y_test,svc_y_predit,target_names=[<span class="string">&#x27;Benign&#x27;</span>,<span class="string">&#x27;Malignant&#x27;</span>]) ) <span class="comment">#良性，恶性</span></span><br></pre></td></tr></table></figure>

<h3 id="五折-Stacking"><a href="#五折-Stacking" class="headerlink" title="五折 Stacking"></a>五折 Stacking</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;模型融合中使用到的各个单模型&#x27;&#x27;&#x27;</span></span><br><span class="line">lr = LogisticRegression()</span><br><span class="line">svc = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, class_weight=<span class="string">&#x27;balanced&#x27;</span>, probability=<span class="literal">True</span>)</span><br><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">5</span>, n_jobs=-<span class="number">1</span>, criterion=<span class="string">&#x27;gini&#x27;</span>)</span><br><span class="line">clfs = [rf ,lr ,svc]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;切分一部分数据作为测试集&#x27;&#x27;&#x27;</span></span><br><span class="line">X, X_predict, y, y_predict = np.array(X_train), np.array(X_test), np.array(Y_train), np.array(Y_test)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset_blend_train = np.zeros((X.shape[<span class="number">0</span>], <span class="built_in">len</span>(clfs)))</span><br><span class="line">dataset_blend_test = np.zeros((X_predict.shape[<span class="number">0</span>], <span class="built_in">len</span>(clfs)))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;5折stacking&#x27;&#x27;&#x27;</span></span><br><span class="line">n_folds = <span class="number">5</span></span><br><span class="line">skf = <span class="built_in">list</span>(StratifiedKFold(y, n_folds))</span><br><span class="line"><span class="keyword">for</span> j, clf <span class="keyword">in</span> <span class="built_in">enumerate</span>(clfs):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;依次训练各个单模型&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;=========================&#x27;</span>)</span><br><span class="line">    dataset_blend_test_j = np.zeros((X_predict.shape[<span class="number">0</span>], <span class="built_in">len</span>(skf)))</span><br><span class="line">    <span class="keyword">for</span> i, (train, test) <span class="keyword">in</span> <span class="built_in">enumerate</span>(skf):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;使用第i个部分作为预测，剩余的部分来训练模型，获得其预测的输出作为第i部分的新特征。&#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;+++++++++++++&#x27;</span>)</span><br><span class="line">        X_train1, y_train1, X_test1, y_test1 = X[train], y[train], X[test], y[test]</span><br><span class="line">        clf.fit(X_train1, y_train1)</span><br><span class="line">        y_submission = clf.predict_proba(X_test1)[:, <span class="number">1</span>]</span><br><span class="line">        dataset_blend_train[test, j] = y_submission</span><br><span class="line">        dataset_blend_test_j[:, i] = clf.predict_proba(X_predict)[:, <span class="number">1</span>]</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;对于测试集，直接用这k个模型的预测值均值作为新的特征。&#x27;&#x27;&#x27;</span></span><br><span class="line">    dataset_blend_test[:, j] = dataset_blend_test_j.mean(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">params = &#123;<span class="string">&#x27;num_leaves&#x27;</span>: <span class="number">250</span>,</span><br><span class="line">          <span class="string">&#x27;max_depth&#x27;</span>:<span class="number">7</span>,</span><br><span class="line">          <span class="string">&#x27;min_child_weight&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;feature_fraction&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;bagging_fraction&#x27;</span>: <span class="number">0.8</span>,</span><br><span class="line">          <span class="string">&#x27;min_data_in_leaf&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">0.2</span>,</span><br><span class="line">          <span class="string">&quot;boosting_type&quot;</span>: <span class="string">&quot;gbdt&quot;</span>,</span><br><span class="line">          <span class="string">&quot;bagging_seed&quot;</span>: <span class="number">11</span>,</span><br><span class="line">          <span class="string">&quot;metric&quot;</span>: <span class="string">&#x27;auc&#x27;</span>,</span><br><span class="line">          <span class="comment">#&quot;metric&quot;: &#x27;map&#x27;,</span></span><br><span class="line">          <span class="string">&#x27;reg_alpha&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;reg_lambda&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="string">&#x27;random_state&#x27;</span>: <span class="number">233</span>,</span><br><span class="line">          <span class="string">&#x27;is_unbalanced&#x27;</span>:<span class="literal">False</span></span><br><span class="line">         &#125;</span><br><span class="line">clf = lgb.LGBMClassifier(**params,n_estimators=<span class="number">300</span>)</span><br><span class="line">clf.fit(dataset_blend_train,y,</span><br><span class="line">        eval_set=[(X_predict,y_predict)],</span><br><span class="line">        verbose=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">y_submission_real = clf.predict(dataset_blend_test)</span><br><span class="line">accuracy = accuracy_score(y_predict, y_submission_real)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型的准确率为：&#x27;</span>,accuracy)</span><br><span class="line"></span><br><span class="line">sns.heatmap(confusion_matrix(y_predict, y_submission_real),annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.10g&#x27;</span>)  <span class="comment"># 混淆矩阵</span></span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Classification report (validation):\n &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(classification_report(y_submission_real,y_predict,digits =<span class="number">4</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;val auc Score: %f&quot;</span> % roc_auc_score(y_predict, y_submission_real))</span><br></pre></td></tr></table></figure>

<h3 id="OPTICS-优化的-DBScan-聚类"><a href="#OPTICS-优化的-DBScan-聚类" class="headerlink" title="OPTICS _优化的 DBScan 聚类"></a>OPTICS _优化的 DBScan 聚类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 显示决策图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotReachability</span>(<span class="params">data,eps</span>):</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(<span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(data)), data)</span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="built_in">len</span>(data)], [eps, eps])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示分类的类别</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plotFeature</span>(<span class="params">data,labels</span>):</span><br><span class="line">    clusterNum = <span class="built_in">len</span>(<span class="built_in">set</span>(labels))</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    scatterColors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;purple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;brown&#x27;</span>]</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(-<span class="number">1</span>, clusterNum):</span><br><span class="line">        colorSytle = scatterColors[i % <span class="built_in">len</span>(scatterColors)]</span><br><span class="line">        subCluster = data[np.where(labels == i)]</span><br><span class="line">        ax.scatter(subCluster[:, <span class="number">0</span>], subCluster[:, <span class="number">1</span>], c=colorSytle, s=<span class="number">12</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OPTICS1</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data,eps=np.inf,minPts=<span class="number">15</span></span>):</span><br><span class="line">        self.data=data</span><br><span class="line">        self.disMat = self.compute_squared_EDM(data)  <span class="comment"># 获得距离矩阵</span></span><br><span class="line"></span><br><span class="line">        self.number_sample=data.shape[<span class="number">0</span>]</span><br><span class="line">        self.eps=eps</span><br><span class="line">        self.minPts=minPts</span><br><span class="line">        self.core_distances = self.disMat[np.arange(<span class="number">0</span>, self.number_sample), np.argsort(self.disMat)[:, minPts - <span class="number">1</span>]]  <span class="comment"># 计算核心距离</span></span><br><span class="line">        self.core_points_index = np.where(np.<span class="built_in">sum</span>(np.where(self.disMat &lt;= self.eps, <span class="number">1</span>, <span class="number">0</span>), axis=<span class="number">1</span>) &gt;= self.minPts)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算距离矩阵</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compute_squared_EDM</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">return</span> squareform(pdist(X, metric=<span class="string">&#x27;euclidean&#x27;</span>))</span><br><span class="line">    <span class="comment">#训练</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">train</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化每一个点的最终可达距离(未定义)</span></span><br><span class="line">        self.reach_dists = np.full((self.number_sample,), np.nan)</span><br><span class="line">        self.orders=[]<span class="comment">#结果数组</span></span><br><span class="line">        start_core_point=self.core_points_index[<span class="number">0</span>]<span class="comment">#从一个核心点开始</span></span><br><span class="line">        <span class="comment">#标记数组</span></span><br><span class="line">        isProcess = np.full((self.number_sample,), -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#训练</span></span><br><span class="line">        isProcess[start_core_point] = <span class="number">1</span></span><br><span class="line">        <span class="comment">#选择一个核心点作为开始节点，并将其核心距离作为可达距离</span></span><br><span class="line">        self.reach_dists[start_core_point] = self.core_distances[start_core_point]</span><br><span class="line">        self.orders.append(start_core_point)  <span class="comment"># 加入结果数组</span></span><br><span class="line">        seeds = &#123;&#125;<span class="comment">#种子数组，或者叫排序数组</span></span><br><span class="line">        seeds = self.updateSeeds(seeds, start_core_point, isProcess)<span class="comment">#更新排序数组</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(seeds) &gt; <span class="number">0</span>:</span><br><span class="line">            nextId = <span class="built_in">sorted</span>(seeds.items(), key=operator.itemgetter(<span class="number">1</span>))[<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># 按可达距离排序，取第一个(最小的)</span></span><br><span class="line">            <span class="keyword">del</span> seeds[nextId]</span><br><span class="line">            isProcess[nextId] = <span class="number">1</span></span><br><span class="line">            self.orders.append(nextId)  <span class="comment"># 加入结果数组</span></span><br><span class="line">            seeds = self.updateSeeds(seeds, nextId, isProcess)<span class="comment">#更新种子数组和可达距离数组的可达距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#更新可达距离</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">updateSeeds</span>(<span class="params">self,seeds, core_PointId, isProcess</span>):</span><br><span class="line">        <span class="comment"># 获得核心点core_PointId的核心距离</span></span><br><span class="line">        core_dist = self.core_distances[core_PointId]</span><br><span class="line">        <span class="comment"># 计算所未访问的样本点更新可达距离</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.number_sample):</span><br><span class="line">            <span class="keyword">if</span> (isProcess[i] == -<span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 计算可达距离</span></span><br><span class="line">                new_reach_dist = <span class="built_in">max</span>(core_dist, self.disMat[core_PointId][i])</span><br><span class="line">                <span class="keyword">if</span> (np.isnan(self.reach_dists[i])):</span><br><span class="line">                    <span class="comment"># 可达矩阵更新</span></span><br><span class="line">                    self.reach_dists[i] = new_reach_dist</span><br><span class="line">                    seeds[i] = new_reach_dist</span><br><span class="line">                <span class="keyword">elif</span> (new_reach_dist &lt; self.reach_dists[i]):</span><br><span class="line">                    self.reach_dists[i] = new_reach_dist</span><br><span class="line">                    seeds[i] = new_reach_dist</span><br><span class="line">        <span class="keyword">return</span> seeds</span><br><span class="line">    <span class="comment">#生成label</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self</span>):</span><br><span class="line">        clusterId = <span class="number">0</span></span><br><span class="line">        self.labels = np.full((self.number_sample,), -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.orders:</span><br><span class="line">            <span class="keyword">if</span> self.reach_dists[i]&lt;=self.eps:</span><br><span class="line">                self.labels[i]=clusterId</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> self.core_distances[i]&lt;=self.eps:</span><br><span class="line">                    clusterId +=<span class="number">1</span></span><br><span class="line">                    self.labels[i] = clusterId</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = X</span><br><span class="line">    OP=OPTICS1(data,<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line">    OP.train()</span><br><span class="line">    OP.predict()</span><br><span class="line">    plotReachability(OP.reach_dists[OP.orders], <span class="number">1.7</span>)</span><br><span class="line">    plotFeature(np.array(data),OP.labels)</span><br><span class="line">    le = pd.Series(OP.labels)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>statistical machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title>tiny-spring分析笔记（2）</title>
    <url>/2018/11/02/tiny-spring%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="tinySpring-分析笔记——IOC（2）"><a href="#tinySpring-分析笔记——IOC（2）" class="headerlink" title="tinySpring 分析笔记——IOC（2）"></a>tinySpring 分析笔记——IOC（2）</h1><p>学习项目 Github 地址：<a href="https://github.com/code4craft/tiny-spring/releases">code4craft&#x2F;tiny-spring</a></p>
<p>上一篇博客：<a href="http://likehui.fun/2018/11/02/tiny-spring%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/">tiny-spring分析笔记（1）</a></p>
<h2 id="step-4-config-beanfactory-with-xml"><a href="#step-4-config-beanfactory-with-xml" class="headerlink" title="step-4-config-beanfactory-with-xml"></a>step-4-config-beanfactory-with-xml</h2><ul>
<li>在 step 3 中，“text”参数是直接写入 java 类中。</li>
<li>step 4 的目标就是将参数的配置信息写入 xml 文件中，然后代码通过读取 xml 文件获得参数。</li>
<li>参数放入<code>BeanDefinition</code>中，然后用<code>BeanFactory</code>将它们一一注册（包括 setBean），最终实现 getBean。</li>
</ul>
<span id="more"></span>

<h4 id="4-1-tinyioc-xml"><a href="#4-1-tinyioc-xml" class="headerlink" title="4.1 tinyioc.xml"></a>4.1 tinyioc.xml</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">// 部分代码：</span><br><span class="line">&lt;bean name<span class="operator">=</span><span class="string">&quot;helloWorldService&quot;</span> class<span class="operator">=</span><span class="string">&quot;us.codecraft.tinyioc.HelloWorldService&quot;</span>&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;text&quot;</span> value<span class="operator">=</span><span class="string">&quot;Hello World!&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-2-BeanFactoryTest-java"><a href="#4-2-BeanFactoryTest-java" class="headerlink" title="4.2 BeanFactoryTest.java"></a>4.2 BeanFactoryTest.java</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> BeanFactoryTest &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test<span class="literal">()</span> throws Exception &#123;</span><br><span class="line">		<span class="comment">// 1.读取配置</span></span><br><span class="line">		XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> <span class="constructor">XmlBeanDefinitionReader(<span class="params">new</span> ResourceLoader()</span>);</span><br><span class="line">		xmlBeanDefinitionReader.load<span class="constructor">BeanDefinitions(<span class="string">&quot;tinyioc.xml&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.初始化BeanFactory并注册bean</span></span><br><span class="line">		BeanFactory beanFactory = <span class="keyword">new</span> <span class="constructor">AutowireCapableBeanFactory()</span>;</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.get<span class="constructor">Registry()</span>.entry<span class="constructor">Set()</span>) &#123;</span><br><span class="line">			beanFactory.register<span class="constructor">BeanDefinition(<span class="params">beanDefinitionEntry</span>.<span class="params">getKey</span>()</span>, beanDefinitionEntry.get<span class="constructor">Value()</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.获取bean</span></span><br><span class="line">		HelloWorldService helloWorldService = (HelloWorldService) beanFactory.get<span class="constructor">Bean(<span class="string">&quot;helloWorldService&quot;</span>)</span>;</span><br><span class="line">		helloWorldService.hello<span class="constructor">World()</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>详细步骤：</p>
<ol>
<li>首先 new 一个<code>XmlBeanDefinitionReader</code>类，调用其父类 BeanDefinitionReader 的构造方法，在构造方法中，new 一个 <code>HashMap&lt;String,BeanDefinition&gt;</code>和一个<code>ResourceLoader</code>，分别赋给其私有属性<code>registry</code>和<code>resourceLoader</code>。</li>
<li>调用<code>XmlBeanDefinitionReader</code>的<code>loadBeanDefinitions</code>方法并传入 xml 文件的文件名。</li>
<li>随后将 xml 文件转换成 URL 类型，再将 url 与资源建立联系（使用 URLConnection 类），得到<code>InputStream</code>对象。</li>
<li>随后使用<code>DocumentBuilder</code>（DocumentBuilder 实例也是用 DocumentbuilderFactory 的生成的工厂实例）解析<code>inputStream</code>，得到<code>Document</code>对象。</li>
<li><strong>将<code>document</code>沿着根元素解析，new 一个 <code>BeanDefinition</code>（如果有多个 name-class 属性，将对应多个 <code>BeanDefinition</code>，以下以一个 name-class 属性为例），拿到 xml 所配置的<code>name</code>和<code>value</code>值并组装成<code>① PropertyValues</code>，之后拿到<code>② beanClassName</code>和<code>③ beanClass</code>，把它们放入<code>beanDefinition</code>中。</strong></li>
<li>然后 new 一个<code>BeanFactory</code>（引用其实现类 AutowireCapableBeanFactory），生成<code>④ bean</code>实例，放入<code>beanDefinition</code>中（至此，4项凑齐），同时将 <code>beanDefinition</code>注册进属性<code>beanDefinitionMap</code>中。</li>
<li>后续需要调用<code>helloWorldService.helloWorld()</code>时，只需要从<code>beanFactory</code>中<code>getBean(&quot;helloWorldService&quot;)</code>，即可。</li>
<li>完毕。</li>
</ol>
<p>特点：</p>
<ul>
<li>完成了读取 xml 文件的 I&#x2F;O 操作；</li>
<li>考虑了配置文件中多个 class 的情况；</li>
<li>但没有考虑多个 bean 循环依赖的问题。</li>
</ul>
<h2 id="step-5-inject-bean-to-bean"><a href="#step-5-inject-bean-to-bean" class="headerlink" title="step-5-inject-bean-to-bean"></a>step-5-inject-bean-to-bean</h2><ul>
<li>step 4 的场景比较简单，如果有两个 class 类，都在 xml 文件中配置，但是如果 classA 是 classB 的属性，classB 同时也是 classA 的属性，那么该怎么处理呢？究竟先注入哪一个呢？</li>
<li>循环依赖的后果：<ul>
<li>比如，在为 classA 进行 register 操作时，会创建 classA 的 bean，同时将其 PropertyValues 插入，插入时会对其属性（即 classB）进行bean 的注入。</li>
<li>然而，对 classB 进行注入又需要用到 class A 的 bean 的注入。</li>
<li>（估计是因为 tiny 代码不规范的缘故，所以并没有对 classA 的属性进行 bean 的注入，不然一定会报出<code>org.springframework.beans.factory.BeanCurrentlyInCreationException</code>的错误。）</li>
</ul>
</li>
<li>扩展阅读：<a href="https://my.oschina.net/yibuliushen/blog/737640">从 spring 源码角度分析循环依赖 bean 的组装原理</a></li>
</ul>
<p><img src="/2018/11/02/tiny-spring%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/1.png" alt="1"></p>
<h4 id="5-1-互相依赖示例：-xml-文件"><a href="#5-1-互相依赖示例：-xml-文件" class="headerlink" title="5.1 互相依赖示例： xml 文件"></a>5.1 互相依赖示例： xml 文件</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">&lt;bean name<span class="operator">=</span><span class="string">&quot;outputService&quot;</span> class<span class="operator">=</span><span class="string">&quot;us.codecraft.tinyioc.OutputService&quot;</span>&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;helloWorldService&quot;</span> ref<span class="operator">=</span><span class="string">&quot;helloWorldService&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name<span class="operator">=</span><span class="string">&quot;helloWorldService&quot;</span> class<span class="operator">=</span><span class="string">&quot;us.codecraft.tinyioc.HelloWorldService&quot;</span>&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;text&quot;</span> value<span class="operator">=</span><span class="string">&quot;Hello World!&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name<span class="operator">=</span><span class="string">&quot;outputService&quot;</span> ref<span class="operator">=</span><span class="string">&quot;outputService&quot;</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-step-5-的处理办法是："><a href="#5-2-step-5-的处理办法是：" class="headerlink" title="5.2 step 5 的处理办法是："></a>5.2 step 5 的处理办法是：</h4><ul>
<li>在<code>beanDefinition</code>刚被 new 出来时，此时四项都没有被加入。遍历子节点时，如果是 name-value，则将<code>PropertyValues</code>加入<code>beanDefinition</code>。</li>
<li><strong>如果是 name-ref，则 new 一个 <code>BeanReference</code>，将 ref 对应的字符串保留在<code>beanReference</code>的属性区，并把这个<code>beanReference</code>当作<code>PropertyValue</code>存入</strong>。<ul>
<li>相当于，读取 xml 文件时，将<strong>引用关系</strong>初始化（记录下来），但不注入。</li>
</ul>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="meta">#step 4: 此方法完成 bean 的实例化</span></span><br><span class="line">	@Override</span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> registerBeanDefinition(String <span class="type">name</span>, BeanDefinition beanDefinition) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">        <span class="keyword">Object</span> bean = doCreateBean(beanDefinition);</span><br><span class="line">        beanDefinition.setBean(bean);</span><br><span class="line">        beanDefinitionMap.put(<span class="type">name</span>, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#step 5: bean 的实例化延后，不在此处完成</span></span><br><span class="line">	@Override</span><br><span class="line">	<span class="built_in">public</span> <span class="type">void</span> registerBeanDefinition(String <span class="type">name</span>, BeanDefinition beanDefinition) throws <span class="keyword">Exception</span> &#123;</span><br><span class="line">		beanDefinitionMap.put(<span class="type">name</span>, beanDefinition);</span><br><span class="line">		beanDefinitionNames.<span class="keyword">add</span>(<span class="type">name</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>在后续遍历<code>Map&lt;String,BeanDefinition&gt;</code>（此处 key 为class 的 name）时，如果遍历到<code>bean == null</code>时，再进行 newInstance，得到最终的 bean。</li>
<li>需要注意，因为对属性增加了<code>beanReference</code>，所以在注入 bean 时，会对属性增加 if 判断，然后实例化属性的 bean。<ul>
<li>情景分析：</li>
<li>如果先对 classA 进行 setBean，classA 的原始 bean 已经生成，然后对属性（即 classB）进行 setBean。</li>
<li>classB 会生成原始 bean，并对他的属性（即 classA）进行 setBean，此时可以拿到 classA 的 bean（看似不完整，但有 bean 就可以走完 classB 的注入流程），classB 的 bean 至此完成注入。</li>
<li>回到 classA，完成其 bean 的注入。</li>
</ul>
</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅展示部分代码：</span></span><br><span class="line">if (value <span class="keyword">instanceof </span><span class="keyword">BeanReference) </span>&#123;</span><br><span class="line">	<span class="keyword">BeanReference </span><span class="keyword">beanReference </span>= (<span class="keyword">BeanReference) </span>value;</span><br><span class="line">	value = getBean(<span class="keyword">beanReference.getName());</span></span><br><span class="line"><span class="keyword"></span>&#125;</span><br></pre></td></tr></table></figure>


<h2 id="step-6-invite-application-context"><a href="#step-6-invite-application-context" class="headerlink" title="step-6-invite-application-context"></a>step-6-invite-application-context</h2><p>引入<code>applicationContext</code>，封装读取xml配置文件，完成bean类的初始化的工作，功能完全一致！</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"># step-<span class="number">5</span>: 繁琐</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.读取配置</span></span><br><span class="line">XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="keyword">new</span> <span class="constructor">XmlBeanDefinitionReader(<span class="params">new</span> ResourceLoader()</span>);</span><br><span class="line">xmlBeanDefinitionReader.load<span class="constructor">BeanDefinitions(<span class="string">&quot;tinyioc.xml&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.初始化BeanFactory并注册bean</span></span><br><span class="line">AbstractBeanFactory beanFactory = <span class="keyword">new</span> <span class="constructor">AutowireCapableBeanFactory()</span>;</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, BeanDefinition&gt; beanDefinitionEntry : xmlBeanDefinitionReader.get<span class="constructor">Registry()</span>.entry<span class="constructor">Set()</span>) &#123;</span><br><span class="line">	beanFactory.register<span class="constructor">BeanDefinition(<span class="params">beanDefinitionEntry</span>.<span class="params">getKey</span>()</span>, beanDefinitionEntry.get<span class="constructor">Value()</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.初始化bean</span></span><br><span class="line">beanFactory.pre<span class="constructor">InstantiateSingletons()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取bean</span></span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) beanFactory.get<span class="constructor">Bean(<span class="string">&quot;helloWorldService&quot;</span>)</span>;</span><br><span class="line">helloWorldService.hello<span class="constructor">World()</span>;</span><br><span class="line"></span><br><span class="line"># step-<span class="number">6</span>：封装后，精简：</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> <span class="constructor">ClassPathXmlApplicationContext(<span class="string">&quot;tinyioc.xml&quot;</span>)</span>;</span><br><span class="line">HelloWorldService helloWorldService = (HelloWorldService) applicationContext.get<span class="constructor">Bean(<span class="string">&quot;helloWorldService&quot;</span>)</span>;</span><br><span class="line">helloWorldService.hello<span class="constructor">World()</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>至此 tiny-spring 的 IOC 部分学习完毕。撒花 ✿✿ヽ(°▽°)ノ✿</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>tinySpring</tag>
      </tags>
  </entry>
  <entry>
    <title>tiny-spring-Aop 分析笔记（1）</title>
    <url>/2018/11/16/tinySpring-Aop-%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="tinySpring-Aop-分析笔记（1）"><a href="#tinySpring-Aop-分析笔记（1）" class="headerlink" title="tinySpring Aop 分析笔记（1）"></a>tinySpring Aop 分析笔记（1）</h1><p>项目学习地址：<a href="https://github.com/code4craft/tiny-spring/releases">code4craft&#x2F;tiny-spring</a></p>
<h3 id="step-7-method-interceptor-by-jdk-dynamic-proxy"><a href="#step-7-method-interceptor-by-jdk-dynamic-proxy" class="headerlink" title="step-7-method-interceptor-by-jdk-dynamic-proxy"></a>step-7-method-interceptor-by-jdk-dynamic-proxy</h3><p>step 7 针对有接口的情况，采用 jdk 动态代理的方式实现 AOP。</p>
<blockquote>
<p>另一种情况是：无接口时，创建子类，然后进行增强（调用父类的方法），实现动态代理的实现。即 cglib 动态代理。</p>
</blockquote>
<span id="more"></span>


<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JdkDynamicAopProxyTest.java</span></span><br><span class="line"></span><br><span class="line">public void test<span class="constructor">Interceptor()</span> throws Exception &#123;</span><br><span class="line">	<span class="comment">// --------- helloWorldService with AOP</span></span><br><span class="line">	<span class="comment">// 1. 设置被代理对象(Joinpoint)</span></span><br><span class="line">	AdvisedSupport advisedSupport = <span class="keyword">new</span> <span class="constructor">AdvisedSupport()</span>;</span><br><span class="line">	TargetSource targetSource = <span class="keyword">new</span> <span class="constructor">TargetSource(<span class="params">helloWorldService</span>, HelloWorldService.<span class="params">class</span>)</span>;</span><br><span class="line">	advisedSupport.set<span class="constructor">TargetSource(<span class="params">targetSource</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 设置拦截器(Advice)</span></span><br><span class="line">	TimerInterceptor timerInterceptor = <span class="keyword">new</span> <span class="constructor">TimerInterceptor()</span>;</span><br><span class="line">	advisedSupport.set<span class="constructor">MethodInterceptor(<span class="params">timerInterceptor</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 创建代理(Proxy)</span></span><br><span class="line">	JdkDynamicAopProxy jdkDynamicAopProxy = <span class="keyword">new</span> <span class="constructor">JdkDynamicAopProxy(<span class="params">advisedSupport</span>)</span>;</span><br><span class="line">	HelloWorldService helloWorldServiceProxy = (HelloWorldService) jdkDynamicAopProxy.get<span class="constructor">Proxy()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 基于AOP的调用</span></span><br><span class="line">    helloWorldServiceProxy.hello<span class="constructor">World()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Joinpoint：被代理的对象，其实是指代码的横向插入点。</p>
<ol>
<li><p>首先拿到<code>TargetSource</code>，然后拿到<code>TimerInterceptor</code>，设置到<code>AdvisedSupport</code>的成员属性中。</p>
<ul>
<li>其中的<code>TargetSource</code>是指被代理的对象，即等待增强功能的那个类（本文指 helloWorldService.java）。</li>
<li>其中的<code>TimerInterceptor</code>代码如下：</li>
</ul>
 <figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">	<span class="built_in">public</span> <span class="keyword">class</span> TimerInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">Object</span> invoke(MethodInvocation invocation) throws Throwable &#123;</span><br><span class="line">		long <span class="type">time</span> = <span class="keyword">System</span>.nanoTime();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; start!&quot;);</span><br><span class="line">		<span class="keyword">Object</span> proceed = invocation.proceed();</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println(&quot;Invocation of Method &quot; + invocation.getMethod().getName() + &quot; end! takes &quot; + (<span class="keyword">System</span>.nanoTime() - <span class="type">time</span>)</span><br><span class="line">				+ &quot; nanoseconds.&quot;);</span><br><span class="line">		<span class="keyword">return</span> proceed;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 invocation 执行前后分别往 console 输出一句话，而且计算时间差。</li>
</ul>
</li>
<li><p>将上面拿到的<code>advisedSupport</code>设置到<code>JdkDynamicAopProxy</code>中，然后通过<code>getProxy()</code>的方法，获取代理。</p>
<ul>
<li>其中的<code>getProxy()</code>的方法会直接调用<code>newProxyInstance()</code>方法（见以下代码）。 方法中分别传入：① 类加载器；② 需要实现的接口数组；③ InvocationHandler接口。<code>newProxyInstance()</code>方法做了两件事情：<ol>
<li><p>调用<code>getProxyClass()</code>方法，创建代理类<code>cl</code>（此时 cl 中仅有：$Proxy1 这一个 Class），并不是 HelloWorldService 这个类的代理。实现了 interfaces 的接口，同时继承了 Proxy 类，见以下代码：</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; cl = get<span class="constructor">ProxyClass0(<span class="params">loader</span>, <span class="params">intfs</span>)</span>;</span><br></pre></td></tr></table></figure>

</li>
<li><p>实例化代理类。在构造方法中将<code>JdkDynamicAopProxy</code>类（这才是 HelloWorldService 这个类的代理）传入代理类中，</p>
 <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Proxy</span>.</span></span><span class="keyword">new</span><span class="constructor">ProxyInstance(<span class="params">getClass</span>()</span>.get<span class="constructor">ClassLoader()</span>, <span class="keyword">new</span> Class<span class="literal">[]</span> &#123; advised.get<span class="constructor">TargetSource()</span>.get<span class="constructor">TargetClass()</span> &#125;, this);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ol>
<p>说明：</p>
<ol>
<li><p>这个代理的逻辑是：</p>
<ol>
<li>包装实现类；<ul>
<li>将<code>HelloWorldService</code>包装起来。</li>
</ul>
</li>
<li>添加自定义逻辑；<ul>
<li>配置拦截器<code>TimerInterceptor</code>，设置前置代码和后置代码。</li>
<li>将拦截器设置到代理类中。</li>
</ul>
</li>
<li>在使用的时候，用代理类来生成实例。<ul>
<li>即由<code>JdkDynamicAopProxy</code>来执行方法（比如.helloWorld()方法）。</li>
</ul>
</li>
</ol>
</li>
<li><p>当执行<code>.helloWorld()</code>方法时，<code>TimerInterceptor.invoke()</code>方法会被触发（本代码中无论什么切点，都会执行此方法），然后将相关参数传入<code>ReflectiveMethodInvocation()</code>中，</p>
 <figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">Override</span></span><br><span class="line"><span class="keyword">public</span> Object invoke(<span class="keyword">final</span> Object proxy, <span class="keyword">final</span> <span class="keyword">Method</span> <span class="title function_">method</span>, <span class="title function_">final</span> <span class="title function_">Object</span>[] <span class="title function_">args</span>) <span class="title function_">throws</span> <span class="title function_">Throwable</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	MethodInterceptor methodInterceptor = advised.getMethodInterceptor();</span></span><br><span class="line"><span class="comment">	return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method,</span></span><br><span class="line"><span class="comment">			args));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>tinySpring</tag>
      </tags>
  </entry>
  <entry>
    <title>tinySpring-Aop-分析笔记（2）</title>
    <url>/2018/11/17/tinySpring-Aop-%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="tinySpring-Aop-分析笔记（2）"><a href="#tinySpring-Aop-分析笔记（2）" class="headerlink" title="tinySpring Aop 分析笔记（2）"></a>tinySpring Aop 分析笔记（2）</h1><p>项目学习地址：<a href="https://github.com/code4craft/tiny-spring/releases">code4craft&#x2F;tiny-spring</a></p>
<h2 id="step-8-invite-pointcut-and-aspectj"><a href="#step-8-invite-pointcut-and-aspectj" class="headerlink" title="step-8-invite-pointcut-and-aspectj"></a>step-8-invite-pointcut-and-aspectj</h2><ul>
<li>step-8 新增了对<code>AspectJExpressionPointcut</code>这个类。<ul>
<li>它使用 AspectJ 表达式进行匹配。</li>
<li>实现了<code>Pointcut, ClassFilter, MethodMatcher</code>三个接口。</li>
<li>首先拿到一个<code>PointcutParser</code>，是用来解析 expression 的。</li>
<li>解析传入的<code>expression</code>，拿到一个<code>PointcutExpression</code>的实现类。</li>
<li>ClassFilter 表示与表达式匹配的类；</li>
<li>MethodMatcher 查找与表达式匹配的方法；</li>
<li>Pointcut 表示获取的是方法还是类。</li>
</ul>
</li>
</ul>
<span id="more"></span>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">ClassFilter()</span> throws Exception &#123;</span><br><span class="line">    String expression = <span class="string">&quot;execution(* us.codecraft.tinyioc.*.*(..))&quot;</span>;</span><br><span class="line">    AspectJExpressionPointcut aspectJExpressionPointcut = <span class="keyword">new</span> <span class="constructor">AspectJExpressionPointcut()</span>;</span><br><span class="line">    aspectJExpressionPointcut.set<span class="constructor">Expression(<span class="params">expression</span>)</span>;</span><br><span class="line">    boolean matches = aspectJExpressionPointcut.get<span class="constructor">ClassFilter()</span>.matches(<span class="module-access"><span class="module"><span class="identifier">HelloWorldService</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span><span class="keyword">assert</span><span class="constructor">True(<span class="params">matches</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void test<span class="constructor">MethodInterceptor()</span> throws Exception &#123;</span><br><span class="line">    String expression = <span class="string">&quot;execution(* us.codecraft.tinyioc.*.*(..))&quot;</span>;</span><br><span class="line">    AspectJExpressionPointcut aspectJExpressionPointcut = <span class="keyword">new</span> <span class="constructor">AspectJExpressionPointcut()</span>;</span><br><span class="line">    aspectJExpressionPointcut.set<span class="constructor">Expression(<span class="params">expression</span>)</span>;</span><br><span class="line">    boolean matches = aspectJExpressionPointcut.get<span class="constructor">MethodMatcher()</span>.matches(<span class="module-access"><span class="module"><span class="identifier">HelloWorldServiceImpl</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">DeclaredMethod(<span class="string">&quot;helloWorld&quot;</span>)</span>,<span class="module-access"><span class="module"><span class="identifier">HelloWorldServiceImpl</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Assert</span>.</span></span><span class="keyword">assert</span><span class="constructor">True(<span class="params">matches</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>评价：step-8 引入了 AspectJ 表达式，但是还没有将切点表达式这个类放入到<code>ProxyAdvisor</code>类中。</p>
<h2 id="step-9-auto-create-aop-proxy"><a href="#step-9-auto-create-aop-proxy" class="headerlink" title="step-9-auto-create-aop-proxy"></a>step-9-auto-create-aop-proxy</h2><p>暂停更新</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>tinySpring</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 入门一</title>
    <url>/2018/12/17/vue-%E5%85%A5%E9%97%A8%E4%B8%80/</url>
    <content><![CDATA[<p>vue 最简用法：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!-- jsp文件 --&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">h2</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">product</span>&#125;&#125;</span><span class="language-xml"> is in stock<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">			<span class="attr">product</span>: <span class="string">&#x27;Boots&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	&#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>开发版使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不学了，没意思，此话题停更</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC使用记录1</title>
    <url>/2020/07/22/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/</url>
    <content><![CDATA[<p>本小节是 webrtc 前置内容，主要介绍 tcp 跟 udp 的 server 及 client 端实现代码。</p>
<p>tips：c 语言实现，demo 级别，仅供一对一通讯。</p>
<p>参考自慕课网 <a href="https://coding.imooc.com/class/chapter/387.html#Anchor">百万级高并发WebRTC流媒体服务器设计与开发</a></p>
<span id="more"></span>

<p><img src="/2020/07/22/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%951/1.png"></p>
<p>udp 是无连接的，绑定了端口后直接进行收发处理，<strong>不需要监听</strong>。</p>
<h3 id="TCP连接相关结构体"><a href="#TCP连接相关结构体" class="headerlink" title="TCP连接相关结构体"></a>TCP连接相关结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span>     sin_family; <span class="comment">//什么协议，如 ipv4 or ipv6</span></span><br><span class="line">	<span class="type">uint16_t</span>        sin_port;   <span class="comment">// port addr</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>  <span class="title">sin_addr</span>;</span>   <span class="comment">// ip addr</span></span><br><span class="line">	<span class="type">char</span>            sin_zero[<span class="number">8</span>] <span class="comment">// 默认 0</span></span><br><span class="line">&#125; <span class="comment">// 用于服务端设置ip 和 port</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="type">in_addr_t</span>       s_addr; <span class="comment">// ip addr，一般整型存储</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">	<span class="type">sa_family_t</span>     sin_family; <span class="comment">//什么协议，如 ipv4 or ipv6</span></span><br><span class="line">	<span class="type">char</span>            sin_zero[<span class="number">8</span>] <span class="comment">// 默认 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Tcp-server-端的c实现demo"><a href="#Tcp-server-端的c实现demo" class="headerlink" title="Tcp_server 端的c实现demo"></a>Tcp_server 端的c实现demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_server.c</span></span><br><span class="line"><span class="comment">// 1. 创建 socket(socket_fd; 2. 配置 sin 相关; 3. bind; 4. listen;</span></span><br><span class="line"><span class="comment">// 5. accept &amp; 生成 accept_fd; 5.5 loop 接收请求;</span></span><br><span class="line"><span class="comment">// 6. 结束时关闭 accept_fd; 7. 最终结束时关闭 socket_fd</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//应该传入local_addr、remote_addr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 8444</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> socket_fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> accept_fd = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> curpos = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> backlog = <span class="number">10</span>;</span><br><span class="line">  <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> in_buf[MESSAGE_SIZE] = &#123;<span class="number">0</span>,&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">local_addr</span>, <span class="title">remote_addr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//create a tcp socket</span></span><br><span class="line">  socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( socket_fd == <span class="number">-1</span> )&#123;</span><br><span class="line">    perror(<span class="string">&quot;create socket error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set option of socket</span></span><br><span class="line">  ret = setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">  <span class="keyword">if</span> ( ret == <span class="number">-1</span> )&#123;</span><br><span class="line">    perror(<span class="string">&quot;setsockopt error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//set local address</span></span><br><span class="line">  local_addr.sin_family = AF_INET;</span><br><span class="line">  local_addr.sin_port = htons(PORT);</span><br><span class="line">  local_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  bzero(&amp;(local_addr.sin_zero), <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//bind socket</span></span><br><span class="line">  ret = bind(socket_fd, (<span class="keyword">struct</span> sockaddr *)&amp;local_addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in));</span><br><span class="line">  <span class="keyword">if</span>(ret == <span class="number">-1</span> ) &#123;</span><br><span class="line">    perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ret = listen(socket_fd, backlog);</span><br><span class="line">  <span class="keyword">if</span> ( ret == <span class="number">-1</span> )&#123;</span><br><span class="line">    perror(<span class="string">&quot;listen error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//loop</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="type">int</span> addr_len = <span class="keyword">sizeof</span>( <span class="keyword">struct</span> sockaddr_in );</span><br><span class="line">    <span class="comment">//accept an new connection</span></span><br><span class="line">    accept_fd = accept( socket_fd, (<span class="keyword">struct</span> sockaddr *)&amp;remote_addr, &amp;addr_len );</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      <span class="built_in">memset</span>(in_buf, <span class="number">0</span>, MESSAGE_SIZE);</span><br><span class="line">      <span class="comment">//receive network data and print it</span></span><br><span class="line">      ret = recv( accept_fd ,(<span class="type">void</span>*)in_buf ,MESSAGE_SIZE ,<span class="number">0</span> );</span><br><span class="line">      <span class="keyword">if</span>(ret == <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">&quot;receive message:%s\n&quot;</span>, in_buf );</span><br><span class="line">      send(accept_fd, (<span class="type">void</span>*)in_buf, MESSAGE_SIZE, <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;close client connection...\n&quot;</span>);</span><br><span class="line">    close(accept_fd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;quit server...\n&quot;</span>);</span><br><span class="line">  close(socket_fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Tcp-client-端的-c-实现demo"><a href="#Tcp-client-端的-c-实现demo" class="headerlink" title="Tcp_client 端的 c 实现demo"></a>Tcp_client 端的 c 实现demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tcp_client.c</span></span><br><span class="line"><span class="comment">// 1. 创建 socket; 2. connect;</span></span><br><span class="line"><span class="comment">// 3. loop send &amp; receive; 4. quit &amp; close</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 8111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_LENGTH 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> socket_fd;</span><br><span class="line">  <span class="comment">//server addr</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span>;</span></span><br><span class="line">  <span class="type">char</span> sendbuf[MESSAGE_LENGTH];</span><br><span class="line">  <span class="type">char</span> recvbuf[MESSAGE_LENGTH];</span><br><span class="line">  <span class="type">int</span> data_len;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((socket_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  serverAddr.sin_family = AF_INET;</span><br><span class="line">  serverAddr.sin_port = htons(SERVER_PORT);</span><br><span class="line">  <span class="comment">//inet_addr()函数，将点分十进制IP转换成网络字节序IP</span></span><br><span class="line">  serverAddr.sin_addr.s_addr = inet_addr(<span class="string">&quot;39.105.185.198&quot;</span>);</span><br><span class="line">  <span class="comment">//serverAddr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// connect</span></span><br><span class="line">  <span class="keyword">if</span>(connect(socket_fd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;success to connect server...\n&quot;</span>);</span><br><span class="line">  <span class="comment">// loop send and receive data</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, MESSAGE_LENGTH);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&lt;&lt;&lt;&lt;send message:&quot;</span>);</span><br><span class="line">    gets(sendbuf);</span><br><span class="line">    <span class="comment">//printf(&quot;\n&quot;);</span></span><br><span class="line">    ret = send(socket_fd, sendbuf, <span class="built_in">strlen</span>(sendbuf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt;= <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;the connection is disconnection!\n&quot;</span>); </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf, <span class="string">&quot;quit&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// 收到 quit 关键词，退出</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&gt;&gt;&gt; echo message:&quot;</span>);</span><br><span class="line">    recvbuf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    data_len = recv(socket_fd, recvbuf, MESSAGE_LENGTH, <span class="number">0</span>);</span><br><span class="line">    recvbuf[data_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, recvbuf);</span><br><span class="line">  &#125;</span><br><span class="line">  close(socket_fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="UDP-server-端的-c-实现demo"><a href="#UDP-server-端的-c-实现demo" class="headerlink" title="UDP_server 端的 c 实现demo"></a>UDP_server 端的 c 实现demo</h3> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// upd_server.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * *argv)</span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  addr.sin_family     = AF_INET;</span><br><span class="line">  addr.sin_port       = htons(<span class="number">9876</span>);</span><br><span class="line">  addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">  <span class="type">char</span> buff_recv[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">char</span> buff_send[<span class="number">512</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientAddr</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">int</span> len = <span class="keyword">sizeof</span>(clientAddr);</span><br><span class="line">  <span class="type">int</span> sock;   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome! This is a UDP server.\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;socket error.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (bind(sock, (<span class="keyword">struct</span> sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;bind error.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">    n = recvfrom(sock, buff_recv, <span class="number">511</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;clientAddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      buff_recv[n] = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;recv data from client:%s %u says: %s\n&quot;</span>, inet_ntoa(clientAddr.sin_addr), ntohs(clientAddr.sin_port), buff_recv);</span><br><span class="line">      n = sendto(sock, buff_send, n, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;clientAddr, <span class="keyword">sizeof</span>(clientAddr));</span><br><span class="line">      <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sendto error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv error.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Udp-client-端的-c-实现demo"><a href="#Udp-client-端的-c-实现demo" class="headerlink" title="Udp_client 端的 c 实现demo"></a>Udp_client 端的 c 实现demo</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * *argv)</span>&#123;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    addr.sin_family     = AF_INET;</span><br><span class="line">    addr.sin_port       = htons(<span class="number">9876</span>);</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;111.231.68.13&quot;</span>);</span><br><span class="line">    <span class="type">char</span> buff_send[<span class="number">512</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buff_recv[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a UDP client\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ((sock = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;socket error.\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr.sin_addr.s_addr == INADDR_NONE)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Incorrect ip address!&quot;</span>);</span><br><span class="line">      close(sock);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    n = sendto(sock, buff_send, <span class="built_in">strlen</span>(buff_send), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;sendto error.\n&quot;</span>);</span><br><span class="line">      close(sock);</span><br><span class="line">    &#125;</span><br><span class="line">    n = recvfrom(sock, buff_recv, <span class="number">512</span>, <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *) &amp;addr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        buff_recv[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;received from sever:&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(buff_recv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server closed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recvfrom error.\n&quot;</span>);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在问题来了：</p>
<blockquote>
<p>使用 while(1)或者其他死循环接收信息的方式，在多 client 的场景下，仅第一个连接上的 client 可以跟 server 通讯，其他 client 虽然也能连接上，但无法传输数据。</p>
</blockquote>
<p>解决办法通常有：</p>
<ol>
<li><p>fork</p>
</li>
<li><p>select</p>
</li>
<li><p>epoll</p>
</li>
<li><p>IO事件库</p>
<p>详见下一节内容。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC使用记录2</title>
    <url>/2020/07/23/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%952/</url>
    <content><![CDATA[<p>副标题：高性能网络服务器的demo 级别实现</p>
<ol>
<li>fork</li>
<li>select</li>
<li>epoll</li>
<li>IO事件库，以 libevent 举例。</li>
</ol>
<span id="more"></span>

<h2 id="c-语言实现高性能网络服务器"><a href="#c-语言实现高性能网络服务器" class="headerlink" title="c 语言实现高性能网络服务器"></a>c 语言实现高性能网络服务器</h2><h3 id="以-fork-方式"><a href="#以-fork-方式" class="headerlink" title="以 fork 方式"></a>以 fork 方式</h3><p>（父进程）每收到一个连接，就 fork 一个子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 tcp_server.c 的基础上进行改写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// create tcp socket</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// bind socket</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// listen</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">// accept</span></span><br><span class="line">  ...    </span><br><span class="line">  pid = fork() <span class="comment">// pid == 0 子进程，pid&gt;0 父进程    </span></span><br><span class="line">  <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">  	<span class="comment">// recv &amp; close_accept</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="comment">// close_socket</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：</p>
<ol>
<li>资源被长期占用</li>
<li>分配子进程花费时间长</li>
</ol>
<hr>
<h3 id="select-实现"><a href="#select-实现" class="headerlink" title="select 实现"></a>select 实现</h3><ul>
<li>属于异步 IO，即以事件触发的机制对 IO 操作进行处理。</li>
<li>系统开销小，不必创建进程或者线程，也不必维护。</li>
<li>默认只有 1024 个连接，epoll 无此限制</li>
</ul>
<p>步骤：</p>
<ol>
<li><p>遍历文件描述符集中所有描述符，找到有变化的描述符。</p>
<ol>
<li>os 底层发现socket 有数据过来时，select 自己还需要做判断，确定到底有没有数据过来。</li>
</ol>
</li>
<li><p>监听 socket 跟数据处理 socket 要区别对待。</p>
</li>
<li><p>socket 必须设置为非阻塞方式工作，但 select 是阻塞的。</p>
</li>
</ol>
<p>重要 API：</p>
<table>
<thead>
<tr>
<th>api</th>
<th>FD_ZERO</th>
<th>FD_SET</th>
<th>FD_ISSET</th>
<th>FD_CLEAR</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>文件描述符集中的所有描述符全部清掉</td>
<td>将某描述符设置到集内</td>
<td>判断某描述符是否在集内</td>
<td></td>
</tr>
<tr>
<td><strong>api</strong></td>
<td><strong>flag fcntl(fd, F_SETFL&#x2F;F_GETFL,flag)</strong></td>
<td><strong>events select(nfds, readfds, writefds, exceptfds, timeout)</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>文件描述符控制函数，用于控制阻塞&#x2F; 非阻塞</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>tips: </p>
<ol>
<li>events——select 找出哪些事件被触发了</li>
<li>nfds——最大的文件描述符+1（约定俗成，意义不明）</li>
<li>readfds、writefds、exceptfds——读、写、异常的文件描述符集</li>
<li>timeout——超时时间，select 以阻塞方式执行，所以达到超时时间后，select 结束掉，进入下一个循环。一般 500 毫秒。</li>
</ol>
<p> select demo：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 tcp_server.c 的基础上进行改写</span></span><br><span class="line"><span class="comment">// 重点就是文件描述符集fd_sets，首先制造 socket_fd用于监听</span></span><br><span class="line"><span class="comment">// 在遍历 fd_sets 时，发现有连接，就制造 accept_fd；有数据，就使用accept_fd 传输数据。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> accept_fds[FD_SIZE] = &#123;<span class="number">-1</span>,&#125;; <span class="comment">// FD_SIZE 默认 1024</span></span><br><span class="line"><span class="comment">// create tcp socket</span></span><br><span class="line">...</span><br><span class="line">flags = fcntl(socket_fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取 socket_fd 的 flag</span></span><br><span class="line">fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">// 设置为非阻塞 </span></span><br><span class="line">max_fd=socket_fd;</span><br><span class="line"><span class="comment">// bind socket</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// listen</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  FD_ZERO(&amp;fd_sets); <span class="comment">// 清空fd_sets</span></span><br><span class="line">  FD_SET(socket_fd, &amp;fd_sets); <span class="comment">// 将当前 socket （监听 socket）设置到 fd_sets 文件描述符集内</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;FD_SIZE; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(accept_fd[i]  != <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(accept_fds[i] &gt; max_fd)&#123;</span><br><span class="line">        max_fd = accept_fds[i]; <span class="comment">//使 max_fd 保持为最大文件描述符</span></span><br><span class="line">      &#125;</span><br><span class="line">      FD_SET(accept_fds[i], &amp;fd_sets);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  events = select(max_fd+<span class="number">1</span>, &amp;fd_sets,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>); <span class="comment">// 读文件描述符集被 select</span></span><br><span class="line">	<span class="keyword">if</span>(events &lt; <span class="number">0</span>)&#123;</span><br><span class="line">   	<span class="comment">// 调用失败</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 超时</span></span><br><span class="line">    continues;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events)&#123;</span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(socket_fd, &amp;fd_sets))&#123; </span><br><span class="line">      <span class="comment">// socket_fd 发生了变动，说明来了新的连接，可以进行 accept</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; FD_SIZE; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(accept_fds[i] == <span class="number">-1</span>)&#123;</span><br><span class="line">          curpos = i;</span><br><span class="line">          <span class="keyword">break</span>; <span class="comment">// 找到空槽</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr);</span><br><span class="line">      accept_fd = accept(socket_fd,</span><br><span class="line">                        	(<span class="keyword">struct</span> sockaddr *)&amp;remoteaddr,</span><br><span class="line">                        	&amp;addr_len); <span class="comment">//创建一个accept_fd</span></span><br><span class="line">      flags = fcntl(accept_fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取 socket_fd 的 flag</span></span><br><span class="line">			fcntl(accept_fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">// 设置为非阻塞 </span></span><br><span class="line">      accept_fd[curpos]=accept_fd; <span class="comment">// 插入槽中</span></span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 触发的是数据事件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j &lt; FD_SIZE; j++ )&#123;</span><br><span class="line">      <span class="keyword">if</span>( (accept_fds[j] != <span class="number">-1</span>) &amp;&amp; FD_ISSET(accept_fds[j], &amp;fd_sets))&#123; </span><br><span class="line">        <span class="comment">//有事件时，读数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept event :%d, accept_fd: %d\n&quot;</span>,j, accept_fds[j]);</span><br><span class="line">        <span class="type">char</span> in_buf[MESSAGE_SIZE];</span><br><span class="line">        <span class="built_in">memset</span>(in_buf, <span class="number">0</span>, MESSAGE_SIZE);</span><br><span class="line">        <span class="type">int</span> ret = recv(accept_fds[j], &amp;in_buf, MESSAGE_SIZE, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">          close(accept_fds[j]);</span><br><span class="line">          accept_fds[j] = <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;receive message:%s\n&quot;</span>, in_buf );</span><br><span class="line">        send(accept_fds[j], (<span class="type">void</span>*)in_buf, MESSAGE_SIZE, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// close_socket</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="epoll-实现"><a href="#epoll-实现" class="headerlink" title="epoll 实现"></a>epoll 实现</h3><p>特点：</p>
<ol>
<li>没有文件描述符的限制，数量远远超过 1024。</li>
<li>时间复杂度 O(1)，不受文件描述符数量而影响效率。</li>
<li>epoll 经过内核级优化。</li>
<li>触发模式：<ol>
<li>水平触发Level trigger，默认，如果数据没有处理完，下次过来时会告知。 select 也属于水平触发的情况。一般用于比较重要的场合。</li>
<li>边缘触发edge trigger，效率更高，但开发难度高。仅触发一次，不会管你有无处理完所有数据。</li>
</ol>
</li>
</ol>
<p>重要 api：</p>
<table>
<thead>
<tr>
<th>api</th>
<th>int epoll_create()</th>
<th>int epoll_ctl(epfd,op,fd,struct epoll_event *event)</th>
<th>int epoll_wait(epfd,events, maxevents,timeout)</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>创建一个 epoll 的文件描述符</td>
<td>向 epoll 添加事件fd</td>
<td>等待事件</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>tips：</p>
<pre><code>1. epfd：由 epoll_create 创建出的 fd
 2. events：发生改变的事件数组
 3. maxevents：每次返回时最大返回的事件数量
 4. timeout：超时时间，没有事件时，会等待到timeout 后停止 epoll，然后再来一轮 ，500 毫秒即可
</code></pre>
<p>epoll 的事件：</p>
<ol>
<li>EPOLLET：可以用来设置成边缘触发模式 。</li>
<li>EPOLLIN：数据来的事件。</li>
<li>EPOLLOUT：数据往外写的事件。</li>
<li>EPOLLPRI：出现问题、中断的事件。</li>
<li>EPOLLERR：读写出现问题的事件。</li>
<li>EPOLLHUP：挂起的事件。</li>
</ol>
<p>epoll_ctl 相关操作：</p>
<ol>
<li>EPOLL_CTL_ADD：将文件描述符 add 到 epoll 里</li>
<li>EPOLL_CTL_MOD: 修改 epoll 里的文件描述符</li>
<li>EPOLL_CTL_DEL: 删除 epoll 里的文件描述符</li>
</ol>
<p>epoll 重要结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">	<span class="type">void</span>      *ptr;</span><br><span class="line">	<span class="type">int</span> 		  fd;</span><br><span class="line">	<span class="type">uint32_t</span>	u32;</span><br><span class="line">	<span class="type">uint64_t</span>	u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> 				events;</span><br><span class="line">	<span class="type">epoll_data_t</span> 		data; <span class="comment">//用户数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>epoll demo：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 tcp_server.c 的基础上进行改写</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span> <span class="comment">// MAX_EVENTS可以设为 20，同时刻的并发数</span></span><br><span class="line"><span class="comment">// create tcp socket</span></span><br><span class="line">...</span><br><span class="line">flags = fcntl(socket_fd, F_GETFL, <span class="number">0</span>); <span class="comment">// 获取 socket_fd 的 flag</span></span><br><span class="line">fcntl(socket_fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">// 设置为非阻塞 </span></span><br><span class="line"></span><br><span class="line">epoll_fd = epoll_create(<span class="number">256</span>);</span><br><span class="line">ev.events = EPOLLIN; <span class="comment">//监听一般设置为水平触发</span></span><br><span class="line">ev.fd = socket_fd;</span><br><span class="line">epoll_ctl(epoll_fd,EPOLL_CTL_ADD, socket_fd, &amp;ev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">  <span class="comment">// epoll_wait用于等待IO事件。如果当前没有可用的事件，这个函数会阻塞调用线程。</span></span><br><span class="line">  event_number = epoll_wait(epoll_fd, events, MAX_EVENTS, TIMEOUT); </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;event_number; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(events[i].data.fd == socket_fd)&#123;</span><br><span class="line">      <span class="comment">//监听的 socket事件，所以需要创建连接</span></span><br><span class="line">      <span class="type">int</span> addr_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in);</span><br><span class="line">      accept_fd = accept(socket_fd,</span><br><span class="line">                        	(<span class="keyword">struct</span> sockaddr *)&amp;remoteaddr,</span><br><span class="line">                        	&amp;addr_len); <span class="comment">//创建一个accept_fd</span></span><br><span class="line">      flags = fcntl(accept_fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">      fcntl(accept_fd, F_SETFL, flags | O_NONBLOCK); <span class="comment">// 设置为非阻塞 </span></span><br><span class="line">   		ev.events = EPOLLIN | EPOLLET; <span class="comment">//边缘触发</span></span><br><span class="line">      ev.data.fd = accept_fd;</span><br><span class="line">      epoll_ctl(epoll_fd, EPOLL_CTL_ADD, accept_fd, &amp;ev); <span class="comment">// accept_fd 交由 epoll 托管</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">      <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(in_buf, <span class="number">0</span>, MESSAGE_SIZE);</span><br><span class="line">          <span class="type">int</span> ret = recv(events[i,.data.fd, (<span class="type">void</span>*)in_buf, MESSAGE_SIZE, <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">            close(events[i].data.fd);</span><br><span class="line">          &#125; </span><br><span class="line">          <span class="keyword">if</span>(ret == MESSAGE_LEN)&#123; <span class="comment">// 缓冲区满了</span></span><br><span class="line">            <span class="comment">// 进一步处理</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;<span class="keyword">while</span>(ret &lt; <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">switch</span>(errno)&#123;</span><br><span class="line">            <span class="keyword">case</span> EAGAIN: <span class="comment">// 数据没了，等下一次再传数据</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(写操作)&#123;...略&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">                                </span><br><span class="line">close(socket_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                </span><br></pre></td></tr></table></figure>



<hr>
<h3 id="epoll-fork"><a href="#epoll-fork" class="headerlink" title="epoll + fork"></a>epoll + fork</h3><p>实现demo:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在执行 epoll 前（即上文 for 死循环前）执行：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;MAX_PROCESS;i++)&#123; <span class="comment">//4 核 cpu 时，MAX_PROCESS可以设为4</span></span><br><span class="line">	<span class="keyword">if</span>(pid != <span class="number">0</span>)&#123;</span><br><span class="line">		pid = fork(); <span class="comment">// 创建预设的子进程</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//子进程做的事,一直包含到 return0 之前的“epoll执行”部分</span></span><br><span class="line">	<span class="comment">// epoll_wait</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//accept_fd</span></span><br><span class="line">	...</span><br><span class="line">	<span class="comment">//recv</span></span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// 父进程</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    pid = waitpid(<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">// 等待所有子进程结束</span></span><br><span class="line">  &#125;<span class="keyword">while</span>(pid != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="libevent"><a href="#libevent" class="headerlink" title="libevent"></a>libevent</h3><p> 重要函数：</p>
<ol>
<li><p>event_base_new：创建实例，并初始化</p>
</li>
<li><p>event_base_dispatch: 事件触发器</p>
</li>
<li><p>event_new: 创建 event 队列，还有event_add、event_del、event_free 等都属于较底层 api。</p>
</li>
<li><p>evconnlistener_new_bind:  综合了socket监听和触发的功能，属于较高级的 api</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*evconnlistener_cb)</span> <span class="params">(<span class="keyword">struct</span> evconnlistener *,</span></span><br><span class="line"><span class="params">																	<span class="type">evutil_socket_t</span>,</span></span><br><span class="line"><span class="params">																	<span class="keyword">struct</span> sockaddr *,</span></span><br><span class="line"><span class="params">																	<span class="type">int</span> socklen, <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="keyword">struct</span> evconnlistener *</span><br><span class="line"><span class="title function_">evconnlistener_new_bind</span><span class="params">(<span class="keyword">struct</span> event_base *base,</span></span><br><span class="line"><span class="params">												evconnlistener_cb cb,</span></span><br><span class="line"><span class="params">												<span class="type">void</span> *ptr,</span></span><br><span class="line"><span class="params">												<span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">												<span class="type">int</span> backlog,</span></span><br><span class="line"><span class="params">												<span class="type">const</span> <span class="keyword">struct</span> sockaddr *sa,</span></span><br><span class="line"><span class="params">												<span class="type">int</span> socklen)</span>;</span><br></pre></td></tr></table></figure>

<p>tips：</p>
<ol>
<li>event_base ：通过event_base_new生成。</li>
<li>evconnlistener_cb：是一种回调函数，当有连接进来时，会触发这个回调函数</li>
<li>*ptr 是一个指针，指向 evconnlistener_cb函数的参数</li>
<li>flags：事件的标识，libevent 提供有重复触发。。。各种标识。</li>
<li>backlog：socket 相关，相当于排队请求的。。。（不明）</li>
<li>sockaddr：服务请求的地址，包括 ip 和 port</li>
<li>socklen：socket 的长度</li>
</ol>
<p>libevent demo（使用高级 api）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 event_base</span></span><br><span class="line"><span class="comment">// 监听&amp;触发，使用evconnlistener_new_bind</span></span><br><span class="line"><span class="comment">// 开始循环，使用event_base_dispatch</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evconnlistener</span> *<span class="title">listener</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">    <span class="type">int</span> port = <span class="number">8111</span>;</span><br><span class="line"></span><br><span class="line">    base = event_base_new(); <span class="comment">/* 初始化event_base */</span></span><br><span class="line">    <span class="keyword">if</span> (!base) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Couldn&#x27;t open event base&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化绑定地址*/</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;<span class="built_in">sin</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    <span class="built_in">sin</span>.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化evconnlistener(绑定地址、设置回调函数以及连接属性) */</span></span><br><span class="line">    listener = evconnlistener_new_bind(base, accept_conn_cb, <span class="literal">NULL</span>, LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE, <span class="number">-1</span>,(<span class="keyword">struct</span> sockaddr*)&amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">    <span class="keyword">if</span> (!listener) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Couldn&#x27;t create listener&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置Listen错误回调函数 */</span></span><br><span class="line">    evconnlistener_set_error_cb(listener, accept_error_cb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 开始accept进入循环 */</span></span><br><span class="line">    event_base_dispatch(base);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上涉及了<code>accept_conn_cb</code>，<code>accept_error_cb</code>这些回调函数，需要另外实现。</p>
<p>接收数据事件的回调函数accept_conn_cb：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 举例：接收数据事件的回调函数：</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">accept_conn_cb</span><span class="params">(<span class="keyword">struct</span> evconnlistener *listener,<span class="type">evutil_socket_t</span> fd, <span class="keyword">struct</span> sockaddr *address, <span class="type">int</span> socklen,<span class="type">void</span> *ctx)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化一个bufferevent用于数据的写入和读取，首先需要从Listerner中获取event_base */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> evconnlistener_get_base(listener);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bufferevent</span> *<span class="title">bev</span> =</span> bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</span><br><span class="line">    <span class="comment">/*设置buferevent的回调函数，这里设置了读和事件的回调函数*/</span></span><br><span class="line">    bufferevent_setcb(bev, echo_read_cb, <span class="literal">NULL</span>, echo_event_cb, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* 启用该bufevent写和读 */</span></span><br><span class="line">     bufferevent_enable(bev, EV_READ|EV_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上又涉及了<code>echo_read_cb</code>,<code>echo_event_cb</code>等回调函数，此处略去不表。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC使用记录3</title>
    <url>/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/</url>
    <content><![CDATA[<p>副标题：webRTC 使用准备之流媒体协议</p>
<p>参考文章：<a href="https://www.jianshu.com/p/c84be6f3ddf3">WebRTC中RTP&#x2F;RTCP协议实现分析</a></p>
<p>RTP 协议定义流媒体数据在互联网上传输的数据包格式，而 RTCP 协议则负责可靠传输、流量控制和拥塞控制等服务质量保证。有名的是Google的GCC（拥塞控制算法(Google Congestion Control,简称GCC[1])））.</p>
<span id="more"></span>

<p>UDP 协议：源端口、目的端口、UDP 长度、校验和、数据</p>
<ul>
<li>相比 TCP 协议，数据有效性、有序性等等完全不管，更适合流媒体的实时传输。</li>
<li>TCP 为了保证包的有序到达，具有丢包重传机制，比如丢包时的计时器从 200ms 到 400ms 到更久的时间，所以不适合实时传输。但当 UDP 不通时，需要换用 TCP 来保证连通率。但当 TCP 不通时，需要换用 HTTPS 来保证连通。</li>
<li>UDP 无法解决的有序性等问题，由应用层的协议来解决。</li>
</ul>
<p>RTP 协议：UDP 的上层协议，也能跑在 TCP 上（但一般不会这么干）。</p>
<ul>
<li>具有 sequence number 字段，用于对数据包进行排序。</li>
<li>timestamp 字段，用于判断某些包是否属于同一帧。若多个包具有相同的 timestamp，说明它们属于同一帧。</li>
<li>SSRC 字段，synchronization source identifier，同步信源。占 32 位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。</li>
<li>CSRC 字段，共享源。每个 CSRC 标识符占 32 位，可以有 0～15 个。每个 CSRC 标识了包含在该RTP报文有效载荷中的所有特约信源。</li>
</ul>
<ol>
<li>视频或音频的接收端通常有一个环形队列，计算：一秒 30 帧数据，控制 200 毫秒以内的延迟，然后一个队列中能够装多少包，是可以计算出的，进而推算出环形队列的大小。</li>
</ol>
<p>RTCP 协议：</p>
<ul>
<li>标准的 Header：version+P(即 padding)+Count+Type+Length &#x3D; 2 + 1 + 5 + 8 + 16 bit</li>
</ul>
<p>RTCP Type：</p>
<table>
<thead>
<tr>
<th>PT</th>
<th>缩写</th>
<th>说明</th>
<th>tips</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>SR</td>
<td>Sender Report packet</td>
<td>重要※</td>
</tr>
<tr>
<td>201</td>
<td>RR</td>
<td>Receiver Report packet</td>
<td>重要※</td>
</tr>
<tr>
<td>202</td>
<td>SDES</td>
<td>Source Description packet</td>
<td>源描述协议，用于切源</td>
</tr>
<tr>
<td>203</td>
<td>BYE</td>
<td>Goodbye packet</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>APP</td>
<td>Application-defined packet</td>
<td>应用层自定义</td>
</tr>
<tr>
<td>192</td>
<td>FIR</td>
<td>Full INTRA-frame Request</td>
<td>请求完整的I-帧，用于完全重新开始接收时（废弃，功能由 206 完成）</td>
</tr>
<tr>
<td>193</td>
<td>NACK</td>
<td>Negative Acknowledgement</td>
<td>标记收包情况（废弃，功能由 206 完成）</td>
</tr>
<tr>
<td>205</td>
<td>RTPFB</td>
<td>Generic RTP Feedback</td>
<td>传输层的返回包</td>
</tr>
<tr>
<td>206</td>
<td>PSFB</td>
<td>Payload-specific Feedback</td>
<td>应用层的返回包，对内容编解码器进行反馈</td>
</tr>
</tbody></table>
<hr>
<p>Intra的含义是图像内编码，不需要其他图像信息即可解码.</p>
<h2 id="RTCP-SR"><a href="#RTCP-SR" class="headerlink" title="RTCP SR"></a>RTCP SR</h2><p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/SR.png"></p>
<ol>
<li>SR &#x3D; header + sender info + report block * N 。</li>
<li>header  也就是标准的 RTCP header。</li>
<li>Sender info block 和 report block 如下。</li>
</ol>
<p>Sender Information block：</p>
<p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/Sender_info.png"></p>
<ul>
<li>NTP timestamp，用于音视频同步的时间戳，网络时间戳，64 位。</li>
<li>RTP timestamp， RTP 的普通时间戳，32 位，与 RTP 包时间戳一致。</li>
<li><strong>SPC</strong>，发送的包的总数，32 位。</li>
<li><strong>SOC</strong>，发送的包的全部字节，32 位。</li>
</ul>
<p>Report block:</p>
<p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/Report_block.png"></p>
<ul>
<li>SSRC_1：标识哪个 SSRC，32 位</li>
<li>fraction lost：丢包率，8 位。</li>
<li>packets lost：自接收开始的丢包总数，迟到包不计入，24 位。</li>
<li>cumulative number of packets lost：丢包总数</li>
<li>extended highest sequence number received：一般 2^16个<strong>包</strong>算一个<strong>段</strong>，这个字段里面，高 16 位标识属于哪个段，低 16 位标识属于段中哪里 sequence number。</li>
<li>jitter：RTP 包接收时间间隔的统计方差，用于拥塞防止的重要参考字段，如果持续增长，说明可能存在拥塞。</li>
<li>last SR（LSR），上次发送SR 的时间戳，34 位。</li>
<li>delay since last SR： 接收 SR 的时间与发送 SR 的时间差。</li>
</ul>
<h2 id="RTCP-RR"><a href="#RTCP-RR" class="headerlink" title="RTCP RR"></a>RTCP RR</h2><p>RR &#x3D; header + report block * N</p>
<p>看下图，跟  SR 类似，不再赘述。</p>
<p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/RR.png"></p>
<hr>
<h2 id="RTCP-SDES"><a href="#RTCP-SDES" class="headerlink" title="RTCP SDES"></a>RTCP SDES</h2><p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/SDES.png"></p>
<p>SDES：header + （SSRC + SDES items）* N</p>
<p>SDES item 采用TLV 结构类型：type + length + value</p>
<ul>
<li>举例： CNAME + length + name…</li>
</ul>
<table>
<thead>
<tr>
<th>type</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CNAME</strong></td>
<td><strong>CNAME 与 SSRC 对应，CNAME 为源的唯一标识</strong></td>
</tr>
<tr>
<td>NAME</td>
<td>用于描述源名，人类可读</td>
</tr>
<tr>
<td>EMAIL</td>
<td></td>
</tr>
<tr>
<td>PHONE</td>
<td></td>
</tr>
<tr>
<td>LOC</td>
<td></td>
</tr>
<tr>
<td>TOOL</td>
<td>没啥用</td>
</tr>
<tr>
<td>NOTE</td>
<td>备注</td>
</tr>
<tr>
<td>PRIV</td>
<td>私有扩展</td>
</tr>
</tbody></table>
<hr>
<h2 id="RTCP-BYE"><a href="#RTCP-BYE" class="headerlink" title="RTCP BYE"></a>RTCP BYE</h2><p>BYE &#x3D; header + SSRC * N + length + opt（reason for leaving）</p>
<hr>
<h2 id="RTCP-APP"><a href="#RTCP-APP" class="headerlink" title="RTCP APP"></a>RTCP APP</h2><p>APP &#x3D; header + SSRC + nameN + applicationData</p>
<hr>
<h2 id="RTCP-RTPFB-amp-PSFB"><a href="#RTCP-RTPFB-amp-PSFB" class="headerlink" title="RTCP RTPFB &amp; PSFB"></a>RTCP RTPFB &amp; PSFB</h2><p><img src="/2020/07/24/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%953/FB.png"></p>
<p>FB &#x3D; header(传统 RTCP 的 header 小改) + SSRC + SSRC2 + FCI</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>传输层的 FB</td>
<td>RTPFB，是对传输层的控制，如 NACK</td>
</tr>
<tr>
<td>负载层的 FB</td>
<td>PSFB，是对负载层的控制，如编解码器，如 PLI</td>
</tr>
<tr>
<td>应用层的 FB</td>
<td>应用层自己识别，一般认为是一种特殊的 PSFB</td>
</tr>
</tbody></table>
<p>RTPFB分类：</p>
<ol>
<li>NACK：对丢包请求的</li>
<li>TMMBR：最大媒体流比特率请求，max media stream bitrate request。表明接收端当前带宽受限，告诉发送端控制码率。</li>
<li>TMMBN：max media stream bitrate notification.响应的通知，会告知最大的带宽，是 TMMBR 的响应。</li>
</ol>
<p>PsFB 分类：</p>
<ol>
<li>PLI：picture loss indication, 图片丢失，可能会将这个帧的所有包都发送过来。</li>
<li>SLI：slice loss indication, 每个视频帧可能包含多个 slice，每个 slice 可能对应一个包，slice 如果丢失时可能会发送这个请求。</li>
<li>RPSI：reference picture selection indication, 参考图片丢失，相当于 B 帧丢失。</li>
<li>FIR：full intra request command, 请求一个完整的内部帧。</li>
<li>TSTR：temporal-spatial trade-off request, 空间时间交互系统的请求。</li>
<li>TSTN：temporal-spatial trade-off notification, 上面 5 的响应。</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC使用记录4</title>
    <url>/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/</url>
    <content><![CDATA[<p>副标题：webRTC 前置知识之 STUN、ICE、SRTP 协议</p>
<p><a href="https://www.rfc-editor.org/info/rfc3489">RFC34 89</a></p>
<p><a href="https://www.rfc-editor.org/info/rfc5389">RFC5389</a></p>
<p><a href="https://www.rfc-editor.org/info/rfc3711">SRTP</a></p>
<p><a href="https://www.rfc-editor.org/info/rfc4568">SDP</a></p>
<!-- more  -->

<h2 id="STUN协议"><a href="#STUN协议" class="headerlink" title="STUN协议"></a>STUN协议</h2><ul>
<li>STUN 的目的是进行 NAT 穿越。</li>
<li>STUN 是 S&#x2F;C 模式，客户端发送请求，服务端进行响应。</li>
<li>规范：<ol>
<li>RFC3489 &#x2F; STUN。使用 UDP 进行 NAT 穿越。</li>
<li>RFC5389 &#x2F; STUN。可以适用 TCP 进行 NAT 穿越，是前者的增量版本。</li>
</ol>
</li>
</ul>
<p>STUN &#x3D; header（20B） + Attribute * N</p>
<p>header  &#x3D; 00(2b) + STUN Message Type(14b) + Message Length(16b) + Magic Cookie(32b)+Transaction ID(96b)</p>
<p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/STUNheader.png"></p>
<ul>
<li>STUN MessageType 中取出 2bits用于分类，分出 C0 和 C1：<ul>
<li>0b00&#x2F;0b01&#x2F;0b10&#x2F;0b11 分别表示：一个请求、一个指示、请求成功的响应，请求失败的响应。</li>
</ul>
</li>
<li>每个 Attribteute 进行 TLV 编码，即 Type + Length + Value</li>
</ul>
<p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/attr1.png"></p>
<hr>
<h2 id="ICE"><a href="#ICE" class="headerlink" title="ICE"></a>ICE</h2><p>ICE,interactive connectivity establishment</p>
<p>两种终端进行交互，才能创建连接。</p>
<p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/ice.png"></p>
<ul>
<li>ICE Candidate: 一个包括协议、ip、端口和类型的地址。</li>
</ul>
<p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/candi.png"></p>
<ul>
<li>Candidate 类型：主机候选者、反射候选者、中继候选者。<ul>
<li>本机候选者 host candidate，可以通过本地方式获取；</li>
<li>反射候选者 reflexive candidate，1. 向 Stun 服务发起 binding request；2. Stun 服务返回的结果中，就包含了外网的 ip 地址和端口。使用 STUN&#x2F;TURN 协议。</li>
<li>中继候选者 relay candidate，1. 向relay 服务器发起请求，2. relay 服务器返回结果中，就包含了relay 服务器的 ip 地址的端口。使用 TURN 协议。</li>
<li>tips：TURN 位于 STUN 协议上层，并依赖于 STUN。</li>
</ul>
</li>
<li>ICE作用：<ol>
<li>收集 Candidate</li>
<li>对 Candiate pair 排序，比如两台主机优先进行 Host candidate，不行的话再尝试别的 candidate</li>
<li>连通性检测</li>
</ol>
</li>
</ul>
<hr>
<h2 id="DTLS-协议"><a href="#DTLS-协议" class="headerlink" title="DTLS 协议"></a>DTLS 协议</h2><p>为了保证安全传输，推出了 TLS 和 DTLS 两类协议，其中TLS 是基于 TCP 的，DTLS 是基于 UDP 的。</p>
<h3 id="OpenSSL-的使用"><a href="#OpenSSL-的使用" class="headerlink" title="OpenSSL 的使用"></a>OpenSSL 的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">OpenSSL初始化--&gt;创建SSL上下文--&gt;加载SSL证书--&gt;加载SSL私钥--&gt;创建SSL实例--&gt;通过SSL收发数据--&gt;释放SSL资源--&gt;OpenSSL初始化</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> tips: 创建 SSL 实例时，会跟 socket 进行绑定</p>
<h3 id="DTLS-四次握手"><a href="#DTLS-四次握手" class="headerlink" title="DTLS 四次握手"></a>DTLS 四次握手</h3><p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/dtls.png"></p>
<p><img src="/2020/07/26/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%954/dtls2.png"></p>
<ol>
<li>媒体协商，建立房间，主要用来告知 ufrag 和 password。 </li>
<li>发送 binding request</li>
<li>握手</li>
<li>收发数据</li>
</ol>
<h3 id="DTLS-SRTP"><a href="#DTLS-SRTP" class="headerlink" title="DTLS-SRTP"></a>DTLS-SRTP</h3><ul>
<li><p>DTLS：交换密钥，确认加密算法（双方相互告知自己支持的算法有哪些）</p>
<ul>
<li>webRTC 默认采用 AES128</li>
</ul>
</li>
<li><p>SRTP：真正进行加解密，一般是对称加密算法（只对 payload 进行加密）。保证数据完整性，一般通过 协议中增加的字段 Authentication Tag 进行完整性校验。</p>
</li>
<li><p>libsrtp：开源的 libsrtp 库，高效好用</p>
<ul>
<li>初始化 libsrtp</li>
<li>创建 Session</li>
<li>加密、解密</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>webRTC使用记录5</title>
    <url>/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/</url>
    <content><![CDATA[<p>副标题：webRTC使用记录之 媒体协商SDP及媒体服务器</p>
<p><a href="https://www.rfc-editor.org/info/rfc4568">SDP</a></p>
<span id="more"></span>



<h2 id="媒体协商"><a href="#媒体协商" class="headerlink" title="媒体协商"></a>媒体协商</h2><p><img src="/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/meiti.png"></p>
<ol>
<li>Amy 创建 offer，告知<strong>待协商信息</strong>同时存入本地的 setLocalDescription。</li>
<li>offer 经由信令服务器抵达 Bob。</li>
<li>Bob 提取 offer，存入本地的setRemoteDescription。</li>
<li>Bob 自己做判断，将<strong>协商结果</strong>发起Answer，同时存入本地的 setLocalDescription。</li>
<li>Answer 经由信令服务器抵达 Amy。</li>
<li>Amy提取 Answer，存入本地的 setRemoteDescription。同时 Amy 依据协商结果，对格式等信息进行一些调整。</li>
</ol>
<p>待协商信息一般是SDP，也可以是其他。</p>
<hr>
<h2 id="SDP-协议"><a href="#SDP-协议" class="headerlink" title="SDP 协议"></a>SDP 协议</h2><p>SDP 协议，属于一种文本规范。</p>
<ol>
<li>多个媒体级描述<ol>
<li>媒体格式</li>
<li>传输协议</li>
<li>传输 ip 和 port</li>
<li>媒体负载类型</li>
</ol>
</li>
<li>一个会话级描述<ol>
<li>会话名称、目的</li>
<li>会话存活时间</li>
<li>包含多个媒体信息</li>
</ol>
</li>
<li>由多个 type &#x3D; value 组成</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># SDP 范例 s session/o owner/m media /c connect/a attribute/ rtpmap</span><br><span class="line"><span class="comment">// 必选</span></span><br><span class="line">s = &lt;session name&gt;</span><br><span class="line">o = &lt;username&gt;&lt;session id&gt;&lt;version&gt;&lt;network type&gt;&lt;address type&gt;&lt;address&gt;</span><br><span class="line">	<span class="comment">//如： o = - 70176543125 2 IN IP4 127.0.0.1</span></span><br><span class="line">m = &lt;media&gt;&lt;port&gt;&lt;transport&gt;&lt;fmt/payload type <span class="built_in">list</span>&gt; <span class="comment">// 关键</span></span><br><span class="line">	<span class="comment">//如：m = audio 1024 UDP/TLS/RTP/SAVPF 111 102 104 9 0 8 106 105 13 126</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选</span></span><br><span class="line">c = &lt;network type&gt;&lt;address type&gt;&lt;connection address&gt;</span><br><span class="line">	<span class="comment">//如：c = IN IP4 0.0.0.0</span></span><br><span class="line">a = &lt;Type&gt;</span><br><span class="line">	<span class="comment">//如：a = framerate </span></span><br><span class="line">a=rtpmap:&lt;fmt payload type&gt;&lt;encoding name&gt;/&lt;clock rate&gt;[/&lt;encodingparameters]</span><br><span class="line">	<span class="comment">//如：a = rtpmap:103 ISAC/16000</span></span><br><span class="line">a=fmtp:&lt;format/payload type&gt; parameters</span><br><span class="line">	<span class="comment">//如：a = fmtp:13 apt=106</span></span><br></pre></td></tr></table></figure>



<h2 id="WebRTC-中的-SDP"><a href="#WebRTC-中的-SDP" class="headerlink" title="WebRTC 中的 SDP"></a>WebRTC 中的 SDP</h2><p>与上文 SDP 有所区别。webRTC的 SDP 组成：</p>
<ol>
<li>会话元 </li>
<li>网络描述 </li>
<li>流描述 </li>
<li>安全描述 </li>
<li>服务质量</li>
</ol>
<p><img src="/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/sdp.png"></p>
<p>参考链接：<a href="https://segmentfault.com/a/1190000020794391">WebRTC会话描述协议（SDP）详解</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复制以下代码到 chrome 的 console 即可拿到 SDP 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PeerConnection</span> = <span class="variable language_">window</span>.<span class="property">RTCPeerConnection</span> || <span class="variable language_">window</span>.<span class="property">mozRTCPeerConnection</span> || <span class="variable language_">window</span>.<span class="property">webkitRTCPeerConnection</span>; <span class="keyword">const</span> peer = <span class="keyword">new</span> <span class="title class_">PeerConnection</span>(); navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123; <span class="attr">video</span>: <span class="literal">true</span>, <span class="attr">audio</span>: <span class="literal">true</span> &#125;) .<span class="title function_">then</span>(<span class="function"><span class="params">stream</span> =&gt;</span> &#123; stream.<span class="title function_">getTracks</span>().<span class="title function_">forEach</span>(<span class="function"><span class="params">track</span> =&gt;</span> &#123; peer.<span class="title function_">addTrack</span>(track, stream); &#125;); peer.<span class="title function_">createOffer</span>().<span class="title function_">then</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">sdp</span>); &#125;) &#125;) .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">alert</span>(<span class="string">&#x27;无法获取摄像头信息&#x27;</span>));</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="主流媒体服务器"><a href="#主流媒体服务器" class="headerlink" title="主流媒体服务器"></a>主流媒体服务器</h2><p>多人音视频架构</p>
<ol>
<li>Mesh 方案：建立多个 p2p 通信，难以商用。</li>
<li>MCU 方案：中心服务器，硬件实现架构，价格昂贵。</li>
<li>SFU 方案：主要进行网络流的转发，传输量大，可能丢包。 <strong>主流方案</strong>。</li>
</ol>
<p>1 对 1 方案： </p>
<p><img src="/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/p2pmodel.png"></p>
<p>SFU 方案：</p>
<p><img src="/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/sfu.png"></p>
<p>tips: </p>
<ol>
<li>SFU 不进行音视频的编解码，直接转发</li>
<li>webRTC 使用signaling（空耳） 或者 SVC 的方式，应对传输带宽的难题，比如先传核心层（较模糊的音视频），等带宽足够了，再传细节层（粗粗的理解）。</li>
</ol>
<p> Mediasoup 方案：</p>
<p><img src="/2020/07/27/webRTC%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%955/mediasoup.png"></p>
<p>其中 Nodejs 部分可以用其他方案替代：Tomcat、jetty、nginx 都行。</p>
<ol>
<li>提供 www 服务、提供客户端代码</li>
<li>提供信令服务，执行 SDP 消息传递、room 的创建及销毁等</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>wireshark 命令</title>
    <url>/2023/05/02/wireshark-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>wireshark 常见的命令</p>
<span id="more"></span>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ip<span class="selector-class">.addr</span> eq <span class="number">192.168</span>.<span class="number">50.1</span>  <span class="comment">// 源或目的IP</span></span><br><span class="line">ip<span class="selector-class">.src</span> eq <span class="number">192.168</span>.<span class="number">50.1</span>   <span class="comment">// 源IP</span></span><br><span class="line">ip<span class="selector-class">.dst</span> eq <span class="number">192.168</span>.<span class="number">50.1</span>   <span class="comment">// 目的IP</span></span><br><span class="line"></span><br><span class="line">tcp port <span class="number">21</span> <span class="comment">// 端口过滤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tcp<span class="selector-class">.flags</span><span class="selector-class">.reset</span> eq <span class="number">1</span>     <span class="comment">// TCP 的 RST 报文</span></span><br><span class="line">tcp<span class="selector-class">.seq</span> eq <span class="number">1</span> and tcp<span class="selector-class">.ack</span> eq <span class="number">1</span>   <span class="comment">// TCP 的 seq 和 ack 都是1 的报文 (or 表示或，not 表示取反)</span></span><br><span class="line">frame<span class="selector-class">.time</span> &gt;= <span class="string">&quot;may 02, 2023 18:30:00&quot;</span> and frame<span class="selector-class">.time</span> &lt;= <span class="string">&quot;may 02, 2023 18:35:00&quot;</span> <span class="comment">// 过滤时间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在wireshark中，如何从一个报文，找到它所在整个TCP流的所有其他报文？</p>
<blockquote>
<p>该报文，右键 -&gt; Follow -&gt; TCP Stream </p>
</blockquote>
<p>如果想对服务端和客户端进行对照抓包，最好采用TCP序列号进行对应（必须使用Raw Sequence number），然后过滤：<br><code>tcp.seq_raw eq 4252547432</code></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>zk学习笔记</title>
    <url>/2019/06/22/zk%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="zk-学习笔记"><a href="#zk-学习笔记" class="headerlink" title="zk 学习笔记"></a>zk 学习笔记</h1><h2 id="一、参考资料："><a href="#一、参考资料：" class="headerlink" title="一、参考资料："></a>一、参考资料：</h2><p>zk，一般就是指 zookeeper。在 CAP 理论中，zk 主要保证 CA，并在发生网络分区错误时，仅提供只读能力。</p>
<p>学习书籍：《ZooKeeper 分布式过程协同技术详解》 Flavio Junqueira &#x2F;Benjamin Reed</p>
<p>推荐阅读：<a href="https://blog.csdn.net/qianshangding0708/article/details/50052069">Zookeeper你应该了解基础知识</a></p>
<span id="more"></span>



<h2 id="二、核心内容："><a href="#二、核心内容：" class="headerlink" title="二、核心内容："></a>二、核心内容：</h2><h3 id="2-1-主从模型"><a href="#2-1-主从模型" class="headerlink" title="2.1 主从模型"></a>2.1 主从模型</h3><ol>
<li>主从模型需要解决的三大问题：<ol>
<li>主节点崩溃：<ol>
<li>可以使用备份从节点，但如果想要恢复到原主节点崩溃时的状态，就要通过 zk 来获取此状态信息。</li>
<li>假崩溃：当主结点负载很高，导致的消息延迟时，备份主结点转正，此时系统就存在了两个主节点。</li>
<li>脑裂：主要指网络分区引起的、系统被分为子系统独立工作的情况。多个从节点因网络分区中断了跟主节点的通信，然后与第二主节点建立 master-slave 关系。<strong>脑裂是要被重点避免的情况。</strong></li>
</ol>
</li>
<li>从节点崩溃：<ol>
<li>主结点需要检测① worker 是否崩溃；② 哪些 worker 存活以便接手崩溃 worker 的工作。</li>
<li>崩溃 worker 的任务执行进度如何，是否需要清除异常状态等。</li>
</ol>
</li>
<li>通信故障：<ol>
<li>跟任务的幂等性有关，如果任务是幂等的，在任务再分配时无需额外的动作。</li>
<li>但如果任务是非幂等的，任务再分配时，需要验证第一个 worker 是否已完成了工作，同时 app 需要考虑任务被多次重复执行的可能性。</li>
</ol>
</li>
</ol>
</li>
<li>zk 为了配合主从模型，所以需要具备以下能力：<ol>
<li>主节点选举；</li>
<li>崩溃检测；</li>
<li>成员关系管理；</li>
<li>元数据管理；</li>
</ol>
</li>
</ol>
<h3 id="2-2-zk-的数据模型"><a href="#2-2-zk-的数据模型" class="headerlink" title="2.2 zk 的数据模型"></a>2.2 zk 的数据模型</h3><p>采用树状模型（与文件系统很像，但有所不同，zk 使用 znode 的概念）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line"></span><br><span class="line">|-- server id  /master</span><br><span class="line"></span><br><span class="line">|-- /workers </span><br><span class="line"></span><br><span class="line">​     |-- /workers/worker-1   	## 保存某个可用 worker 结点的信息</span><br><span class="line"></span><br><span class="line">​     |-- /workers/worker-2</span><br><span class="line"></span><br><span class="line">|-- /tasks</span><br><span class="line"></span><br><span class="line">​     |-- /tasks/task-1				## 保存已被创建并等待执行的某个 task 信息(未分配)</span><br><span class="line"></span><br><span class="line">​     |-- /tasks/task-2</span><br><span class="line"></span><br><span class="line">|-- /assign</span><br><span class="line"></span><br><span class="line">​     |-- /assign/worker-1</span><br><span class="line"></span><br><span class="line">​				     |-- /assign/worker-1/task-1-1	## 保存从属于worker-1的 task 信息(已分配)</span><br><span class="line"></span><br><span class="line">​				     |-- /assign/worker-1/task-1-2</span><br></pre></td></tr></table></figure>

<p>注：znode 中的数据以<strong>字节数组</strong>的形式存储（使用工具序列化后存入），但可以无数据。</p>
<h3 id="2-3-对外-Api"><a href="#2-3-对外-Api" class="headerlink" title="2.3 对外 Api"></a>2.3 对外 Api</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /path data   ##创建一个名为/path 的结点，并包含数据 data</span><br><span class="line">delete /path        ## 此操作发生前会校验 znode 的版本号</span><br><span class="line">exists /path</span><br><span class="line">setData /path data  ## 此操作发生前会校验 znode 的版本号</span><br><span class="line">getData /path</span><br><span class="line">getChildren /path   ##获取所有/path 结点的子节点列表</span><br></pre></td></tr></table></figure>

<p>注：znode 的读写都是整个结点粒度的，不存在局部读写的情况。</p>
<p>注 2：版本是用来阻止并行操作的不一致性。</p>
<h3 id="2-4-znode-的结点分类"><a href="#2-4-znode-的结点分类" class="headerlink" title="2.4 znode 的结点分类"></a>2.4 znode 的结点分类</h3><ol>
<li><p>一般 znode 分为<strong>持久结点</strong>和<strong>临时结点</strong>两种：</p>
<ol>
<li>持久结点：可以将一些数据落盘。虽然 zk 的数据一般都是在内存中，</li>
<li>临时结点：当 client 崩溃时，或者跟 zk 连接关闭时（client 与 zk 的 session 关闭时），临时结点会被删除，删除动作可主动可被动。临时结点如果拥有子节点，那么子节点也是临时结点。</li>
<li>有序结点：是另一个范畴的概念。持久结点和临时结点分别可以设置为有序的，创建有序结点时，命名会分配到唯一一个单调递增的整数序号。</li>
</ol>
</li>
</ol>
<h3 id="2-5-notification-机制"><a href="#2-5-notification-机制" class="headerlink" title="2.5 notification 机制"></a>2.5 notification 机制</h3><ol>
<li>client 向 zk 注册需要接受通知的 znode，并对 znode 设置监视点(watch)；</li>
<li>当 znode 发生变更时，client 会接收到通知，一次性的watch 发生失效，然后会继续设置下一个 watch；<ul>
<li>接到通知与下一个 watch 设完之间存在时间差，此时znode 可能发生再次变更。为了获取此变更，设下一个 watch 前，client 会再读一次 znode 的状态。</li>
</ul>
</li>
</ol>
<h3 id="2-6-zk-的-server-模式"><a href="#2-6-zk-的-server-模式" class="headerlink" title="2.6 zk 的 server 模式"></a>2.6 zk 的 server 模式</h3><ol>
<li>通常分为<strong>独立模式</strong>和<strong>仲裁模式</strong>。<ol>
<li>用人话讲：就是单机模式和集群模式。</li>
<li><strong>[重点]仲裁模式下，所有 server 都维护相同的数据树，但 client 不可能等待所有 server 完全复制数据一致后才工作，所以引入了法定人数的折中选择。</strong></li>
</ol>
</li>
<li>法定人数：保证 zk 工作的 server 最小数量。(只有满足了人数，才能保证投票立法有效)。<ol>
<li>举例：5 个 server 中，法定人数为 3 个，只有当至少 3 个 zkServer 保证client 的操作生效时，client 的工作才能继续下去。而且，剩下的 2 个 server 也会最终一致。</li>
<li>法定人数采用多数方案，而且总 server 数一般为奇数，偶数系统较脆弱。<ol>
<li>偶数情况举例：如果总共 4 个 server，那么法定为 3 个，系统只能允许最多 1 台 server 崩溃。</li>
<li>奇数情况举例：如果总共 5 个 server，那么法定也为 3 个，系统可以允许最多2 台 server 崩溃，系统将更加牢靠。</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​	</p>
<h3 id="2-7-client-与-zk-之间的-session"><a href="#2-7-client-与-zk-之间的-session" class="headerlink" title="2.7 client 与 zk 之间的 session"></a>2.7 client 与 zk 之间的 session</h3><ol>
<li>client 与 zk 的某一个 server 之间建立 Tcp 连接。<ol>
<li>session具有透明性。如果连接不可用时，session 会被转移到另一个 server 上。<ol>
<li>此时session不会过期，只是会经历 connected - connecting - connected 的状态转换过程。</li>
<li>欲建立连接的备胎 server需要保证状态最新(具有最新的事务标识符即 zkid），否则即使此 server 可用也将不会建立连接。</li>
</ol>
</li>
<li>session 保障顺序性，同一个 session 中的 request 以 FIFO 顺序执行。但跨 Session 时不保证顺序性。</li>
</ol>
</li>
</ol>
<h3 id="2-8-多-server-间的通信"><a href="#2-8-多-server-间的通信" class="headerlink" title="2.8 多 server 间的通信"></a>2.8 多 server 间的通信</h3><p>使用配置文件如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=./data</span><br><span class="line">clientPort=2181</span><br><span class="line">server.1=127.0.0.1:2222:2223 ## 编号1【ip地址 ：仲裁通信 port 号 ：群首选举 port 号】</span><br><span class="line">server.2=127.0.0.1:3333:3334 ## 编号 2 的 zkServer，其他类似</span><br><span class="line">server.3=127.0.0.1:4444:4445 ## 编号 3 的 zkServer，其他类似</span><br></pre></td></tr></table></figure>

<p>注：单机模拟时因为 ip 相同，所以选用不同的 port 号，如果是集群 server，ip 地址不同时，可以选择相同的端口号。</p>
<h2 id="三、server-集群和-client-搭建实战"><a href="#三、server-集群和-client-搭建实战" class="headerlink" title="三、server 集群和 client 搭建实战"></a>三、server 集群和 client 搭建实战</h2><p>背景：单机上模拟创建三个 server 以及一个 client。本机系统 centos6.4，zk 版本3.4.12。</p>
<p>配置参考《ZooKeeper 分布式过程协同技术详解》P34</p>
<ol>
<li><p>安装 zk，略。</p>
</li>
<li><p>设置路径、建立文件夹、配置文件等</p>
<ol>
<li><p><code>$&#123;PATH_TO_ZK&#125;=/root/zookeeper</code>，改成你的 zookeeper 主目录路径</p>
</li>
<li><p>在 zookeeper 目录下建立文件夹：”z1&#x2F;data&#x2F;“、”z1&#x2F;data&#x2F;“、”z1&#x2F;data&#x2F;“。</p>
</li>
<li><p>执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; z1/data/myid</span><br><span class="line">echo 2 &gt; z2/data/myid</span><br><span class="line">echo 3 &gt; z3/data/myid</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立文件”z1&#x2F;z1.cfg”&#x2F;“z2&#x2F;z2.cfg”&#x2F;“z3&#x2F;z3.cfg”，写入配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataDir=./data</span><br><span class="line">clientPort=2181   ## z2/z3 中分别改为 2182、2183</span><br><span class="line">server.1=127.0.0.1:2222:2223</span><br><span class="line">server.2=127.0.0.1:3333:3334</span><br><span class="line">server.3=127.0.0.1:4444:4445</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 z1、z2 服务器(另开一个终端)，3 台 server 启动至少 2 台就可以提供服务了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动 z1 为例</span></span></span><br><span class="line">cd z1</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;PATH_TO_ZK&#125;/bin/zkServer.sh start ./z1.cfg</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>检查 zookeeper.out 日志，确定一个是 leader，另一个是 follower（日志中有明确的字段指示是 <code>following</code> 还是 <code>leading</code>），进入下一步。</p>
</li>
<li><p>另开一个终端作为 client，执行以下命令，提示 session establishment 以及 complete on server…说明 client 与 zk 的 session 连接完成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;PATH_TO_ZK&#125;/bin/zkCli.sh -server 127.0.0.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 server 的 status 及单 Server 的停止命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 在 z2 目录下：</span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">&#123;PATH_TO_ZK&#125;/bin/zkServer.sh status ./z2.cfg</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"> $</span><span class="language-bash">&#123;PATH_TO_ZK&#125;/bin/zkServer.sh stop ./z2.cfg</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 master 挂掉了，那么待转正的备胎会经历以下步骤：</p>
<ol>
<li>备胎感知到 master 跪了，自己也会被 <strong>interrupted</strong>，然后操作一波 <strong>shutdown</strong>，进入<strong>looking</strong> 状态，然后进入新的选举；</li>
<li>备胎当选成功，更新为 <strong>leading</strong> 状态.</li>
<li>另一个落选的备胎，也会经历 <strong>looking</strong> 状态，当选举失败后进入 <strong>following</strong> 状态。</li>
<li>如果挂掉的结点刚好是与 <strong>Client 建立连接的结点</strong>，那么新连接还是会从目前存活的结点中重新建立。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>《kubernetes in Action》读书笔记(1)</title>
    <url>/2019/07/07/%E3%80%8Akubernetes-in-Action%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h1 id="《kubernetes-in-Action》-中文版-读书笔记-1"><a href="#《kubernetes-in-Action》-中文版-读书笔记-1" class="headerlink" title="《kubernetes in Action》(中文版)读书笔记 1"></a>《kubernetes in Action》(中文版)读书笔记 1</h1><h3 id="1-集群内如果使用服务"><a href="#1-集群内如果使用服务" class="headerlink" title="1. 集群内如果使用服务"></a>1. 集群内如果使用服务</h3><ol>
<li><p>K8s 可以通过创建 service 的方式，提供固定的 IP 和端口，当服务不受经常变动的 pod 的影响。</p>
</li>
<li><p>k8s 可以根据 service 的 manifest 来创建新的服务，可以通过以下命令来访问service，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl exec [podName] --curl -a [url]</span><br></pre></td></tr></table></figure>

<p>收到请求的 service 会从下辖的 pod 中用负载均衡的方式随机调一个pod 对请求进行响应。</p>
<ol>
<li>配置<code>sessionAffinity</code>为<code>ClientIp</code>可以让特定客户端的请求每次都指向同一个 pod。</li>
<li>service 是在 TCP 和 UDP 层进行工作的，所以不涉及 HTTP 协议中的 cookie 概念。</li>
<li>service mainifest：指明 name：http；port：80；targetPort：8080(Pod 上的端口)。<ol>
<li>也可以是 targetPort：someAliaName，然后再 pod 的 manifest 中指明 name：someAliaName，containerPort：8080.实现了解耦。</li>
</ol>
</li>
<li>服务发现：<ol>
<li>方法一：环境变量。先有 service后有 pod 时，pod 可以取到环境变量中的 serviceIp和 port 等信息。但若先有 pod 后有 service，信息就很难取到。</li>
<li>方法二：DNS 服务。k8s 中设置一个 DNS 服务的 pod，如此一来，—curl 时不再使用ip 地址的 url，而是使用 FQDN(全限定域名)，请求先查 DNS 服务，然后就能找到服务了，再然后就找到真正工作的 pod 了。</li>
</ol>
</li>
</ol>
</li>
</ol>
<span id="more"></span>



<ol>
<li>但 service 也只能指向此集群内部的若干 pod，无法对外暴露，无法指向外部 IP 和端口。<ol>
<li>所以可能需要手动创建 Endpoint 来完成。<ol>
<li>在 create service 时，如果制定了 pod 选择器，那么 service 被创建，endpoint 也会自动创建，此时的 endpoint 携带着 pod 选择器选中的 pod 的信息(都属于内部 pod)。</li>
<li>手动创建时，需要 create 一个没有 pod 选择器的 service，那么将不会有 Endpoint 被自动创建，所以可以手动create一个，并将外部的 ip 及端口信息写入 endpoint 的 manifest中，这样一来，当请求 service 服务时，就可以关联到外部的 ip 地址及端口上了。</li>
</ol>
</li>
<li>除了手动创建 Endpoint 外，还可以用创建别名的方式来做到。<ol>
<li>对 service manifest 中的 type 字段设置为<code>ExternalName</code>，随后在 externalName自定义一个别名。</li>
<li>这样就可以通过此别名请求服务，即通过 CNAME 的方式定位到你想去的地方（需要 FQDN，而不是集群 IP），隐藏了实际的服务名称和服务的 pod 信息，可以完全绕过服务代理。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="2-服务对外暴露"><a href="#2-服务对外暴露" class="headerlink" title="2. 服务对外暴露"></a>2. 服务对外暴露</h3><p>service 的类型设置为 NodePort、LoadBalance，或者创建 Ingress 资源等三种机制。</p>
<p>这篇文章讲得不错：<a href="https://www.itcodemonkey.com/article/2791.html">NodePort，LoadBalancer还是Ingress？我该如何选择</a></p>
<h5 id="2-1-NodePort"><a href="#2-1-NodePort" class="headerlink" title="2.1. NodePort"></a>2.1. NodePort</h5><ul>
<li><p>创建一个 NodePort 服务（type 为 NodePort），k8s 在每一个 node 上都可以保留一个 port（所有 node 上的此 port 都相同），传入此 port 的流量转发给服务部分（type 为 clusterIP）的 pod。</p>
<ul>
<li>NodePort 服务可以跟服务部分 pod 互联。而且，node 之间，可以通过此 port 做到彼此互联。</li>
<li>在 NodePort 的 manifest 中定义好了service port（service port 是跟背后的 pod 的 targetPort是一对多映射的），也就明确了能够提供的哪种服务。</li>
<li>开放的 port 可以自定义，也可以不设置，交由 k8s 来决定。</li>
</ul>
</li>
<li><p>通过地址<code>[any node&#39;s ip]:开放port</code> 就可以访问服务。</p>
<blockquote>
<p>这种方式有一些不足：</p>
<ol>
<li>一个端口只能供一个服务使用；<ol start="2">
<li>只能使用30000–32767的端口；</li>
<li>如果节点 &#x2F; 虚拟机的IP地址发生变化，需要进行处理。</li>
</ol>
</li>
</ol>
</blockquote>
</li>
</ul>
<h5 id="2-2-loadBalance"><a href="#2-2-loadBalance" class="headerlink" title="2.2 loadBalance"></a>2.2 loadBalance</h5><ul>
<li><p>loadBalance 是 NodePort 的扩展，在部分不支持 loadBalance 的环境中，k8s 应该采取 NodePort 的方式。</p>
</li>
<li><p>type 为 LoadBalancer。</p>
</li>
<li><p><strong>这是默认方式。指定端口的所有流量都会转发到服务中</strong>，没有过滤，也没有路由。这意味着你几乎可以发送任意类型的流量到服务中，比如HTTP、TCP、UDP、Websockets、gRPC等等。</p>
</li>
<li><p>这里最大的不足是，使用LoadBalancer发布的每个服务都会有一个独有的公有IP地址，你需要支付每个服务的LoadBalancer 费用，这是一笔不小的开支。</p>
<blockquote>
<p>可设置 spec 中 <code>externalTrafficPolicy</code>为<code>Local</code>，来让真正运行的 pod，就是接收连接的 node 上的 pod。可减少网络中不必要的跳数。</p>
<p>举例：node1、node2、node3 上都有相同的 pod 提供对外服务。此时 node1被外部连接上了，通过 loadBalancer 后，外部通信需要重定向到执行的 pod 上，如果将 <code>externalTrafficPolicy</code>设置为<code>Local</code>了，那么将优先选择本地运行的 pod 来执行服务。</p>
<ol>
<li>如果没有本地 pod 存在，则连接将被挂起（此情况应当被避免，所以负载均衡器要确保把连接转发到至少具有一个 pod 的 node 上）。</li>
<li>采用此策略可能导致负载分布的不均衡。LoadBalancer 在 node 间是均匀分布连接的，但nodes 之间的 pod 数量可能各有不同。</li>
</ol>
</blockquote>
</li>
<li><p>因为发生了源网络地址转换(SNAT)，所以最初连接时的客户端 IP 在数据包转发时发生更改，pod 将不会看到实际的客户端 IP。</p>
</li>
</ul>
<h5 id="2-3-Ingress"><a href="#2-3-Ingress" class="headerlink" title="2.3 Ingress"></a>2.3 Ingress</h5><ul>
<li><p>Ingress 是在多个服务前充当入口的角色，通过一个 Ingress 就可以暴露多个服务。</p>
</li>
<li><p>Ingress 只需要一个公网 IP 就能为许多服务提供访问。进入的 HTTP 请求，会根据请求的主机名和路径决定请求转发到的服务。</p>
<ul>
<li><p>想使用 Ingress的前提是需要一个 <strong>Ingress 控制器</strong>，有了控制器才可以创建 Ingress 资源，创建步骤：</p>
<ol>
<li><p>Ingress manifest 如下，说明是将 host 的所有 HTTP 请求，全都转发给80 端口上的 kubia-nodeport 服务。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略了 apiVersion、kind、metadata 等 info</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">rules:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">host:</span> <span class="string">kubia.example.com</span></span><br><span class="line">		<span class="attr">http:</span></span><br><span class="line">			<span class="attr">paths:</span></span><br><span class="line">			<span class="string">-path:</span> <span class="string">/</span></span><br><span class="line">				<span class="attr">backend:</span></span><br><span class="line">					<span class="attr">serviceName:</span> <span class="string">kubia-nodeport</span></span><br><span class="line">					<span class="attr">servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ol>
<li>rules 和 paths 都是数组，说明可以将多个主机和路径映射到多个服务</li>
</ol>
</li>
<li><p>创建后使用命令：<code>kubectl get ingresses</code>，查看 Ingress 的 IP 地址。</p>
</li>
</ol>
</li>
<li><p>需要在 Ingress 中<strong>配置 Host 指向 Ingress 的 IP 地址</strong>。</p>
</li>
<li><p>之后就可以<code>curl http://kubia.example.com</code>访问服务了。</p>
<ul>
<li>原理：Ingress 通过此 host 知道 client 想连接的是哪个服务，然后通过服务关联的 endpoint查看 podIp，并将 client 的请求转发给其中的一个 pod。</li>
</ul>
</li>
</ul>
</li>
<li><p>Ingress 甚至可以创建TLS认证，支持 HTTPS 服务。</p>
<ul>
<li><p>Ingress 控制器负责处理与 TLS 相关的内容，而后面的服务以及 Pod 都只需处理 Http 的内容即可。</p>
</li>
<li><p>需要将证书和私钥附加到 Ingress 上，做法：这两个东西存储在 Secret 的资源中，然后在 Ingress manifest 中引用它。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">	<span class="attr">tls:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">		<span class="bullet">-</span> <span class="string">kubia.example.com</span></span><br><span class="line">		<span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 先创建证书和私钥，然后创建一个 Secret，可以取名为 tls-secret</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Ingress目前只支持 L7 层的负载均衡。</p>
</li>
</ul>
<h3 id="3-Volume-数据卷"><a href="#3-Volume-数据卷" class="headerlink" title="3. Volume 数据卷"></a>3. Volume 数据卷</h3><ol>
<li>容器是无状态的，容器内会挂载一个远程数据卷，使得在容器里创建的文件，实质上保存在远程的存储服务器上，或者以分布式的方式保存在多个节点上，与当前的宿主机没有任何绑定关系。<ol>
<li>因此无论在哪个宿主机上启动新的容器，都可以请求挂载指定的持久化 Volume，从而访问到数据卷里保存的内容。</li>
<li>以上过程可以借助 k8s 的存储插件来完成，比如 Ceph、Rook等。Rook 甚至具备了迁移、容灾备份、监控等大型企业级功能。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>《分布式机器学习算法、理论与实践_刘铁岩》读书记录</title>
    <url>/2019/11/10/%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E3%80%81%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E8%B7%B5-%E5%88%98%E9%93%81%E5%B2%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>注：此书偏公式理论，本文仅对部分章节进行记录，标*表示跳过不读，文中使用 P54，表示《分布式机器学习算法、理论与实践_刘铁岩》中对应页码 54 页有详细解释。</p>
<ol>
<li>绪论</li>
<li>机器学习基础*</li>
<li>分布式机器学习框架</li>
<li>单机优化之确定性算法*</li>
<li>单机优化之随机算法*</li>
<li>数据与模型并行* </li>
<li>通信机制 </li>
<li>数据与模型聚合 </li>
<li>分布式机器学习算法 </li>
<li>分布式机器学习理论 </li>
<li>分布式机器学习系统</li>
<li>结语</li>
</ol>
<span id="more"></span>


<h1 id="1-why-分布式机器学习？"><a href="#1-why-分布式机器学习？" class="headerlink" title="1. why 分布式机器学习？"></a>1. why 分布式机器学习？</h1><blockquote>
<p>业界的大规模机器学习任务往往涉及如何充分地利用“大数据 ” 、如何有效地训练 “大模型” 。 使用价格昂贵的高性能设备， 例如TB级内存的计算服务器未尝不可 ， 但硬件能力的增长速度显然比不上机器学习所面对数据的增长速度，因此目前业界更主流的解决方案是分布式机器学习 。 </p>
</blockquote>
<p>分布式机器学习并非分布式处理技术与机器学习的简单结合 。 一方面，它 必须考虑机器学习模型构成与算法流程本身的特点，否则分布式处理的结果可 能失之毫厘、谬以千里 ; 另一方面，机器学习内含的算法随机性、参数冗余性 等 ， 又会带来一般分布式处理过程所不具备的、宜于专门利用的便利 。 </p>
<h1 id="2-分布式系统的鲁棒性："><a href="#2-分布式系统的鲁棒性：" class="headerlink" title="2. 分布式系统的鲁棒性："></a>2. 分布式系统的鲁棒性：</h1><ol>
<li><p>允许不同实现，但需要（跟单机）基本一致的模型和规律。 </p>
</li>
<li><p>为了泛化，允许一定噪音。</p>
</li>
</ol>
<h1 id="3-分布式器学基本流程-P45："><a href="#3-分布式器学基本流程-P45：" class="headerlink" title="3. 分布式器学基本流程 P45："></a>3. 分布式器学基本流程 P45：</h1><p>分布式机器学习的三种情形：计算量太大、训练数据太多、模型规模太大。</p>
<ol>
<li>计算量太大：多线程、多机计算。 </li>
<li>训练数据太多（key problem）：划分数据，分配多工作结点训练。 <ul>
<li>拿到子模型，然后按照一定的规律和其他工作结点进行通信，将子模型及参数进行更新等，最后整合得到全局学习模型。</li>
</ul>
</li>
<li>模型规模太大：划分模型，分配多个工作结点进行训练。 <ul>
<li>此处拿到的子模型间 maybe 相互依赖。 </li>
<li>对通信要求高。 </li>
<li>四大模块：数据与模型划分、单机优化模块、通信模块、数据与模型聚合模块。 </li>
<li>因为四大模型存在不同的组合方法，产生出了多种多样的分布式机器学习算法（每个模块都有各自的设计准则，可按需选取并组合 ）。</li>
</ul>
</li>
</ol>
<h2 id="3-1-数据与模型划分模块"><a href="#3-1-数据与模型划分模块" class="headerlink" title="3.1. 数据与模型划分模块"></a>3.1. 数据与模型划分模块</h2><ol>
<li><p>数据划分。有随机采样、置乱切分（训练时可以定期打乱局部数据）这两种常用做法。还可以在特征维度的切分，P47 。</p>
</li>
<li><p>模型划分。一个机器学习的模型对应多个子模型，一个子模型对应多个模型参数，每个子模型放在一个 worker 上进行计算。</p>
</li>
</ol>
<h2 id="3-2-单机优化模块"><a href="#3-2-单机优化模块" class="headerlink" title="3.2. 单机优化模块"></a>3.2. 单机优化模块</h2><ul>
<li><p>传统的单机机器学习任务。 </p>
</li>
<li><p>训练数据、计算经验风险、利用优化算法通过最小化经验风险来学习模型的参数。 </p>
</li>
<li><p>在分布式环境下，单机算法的收敛、泛化能力都可能发生变化。</p>
</li>
</ul>
<h2 id="3-3-通信模块"><a href="#3-3-通信模块" class="headerlink" title="3.3. 通信模块"></a>3.3. 通信模块</h2><ol>
<li><p>通信内容：子模型或者子模型的更新（如梯度）、甚至重要样本（如支持向量）、计算的中间结果等。 </p>
</li>
<li><p>拓扑结构：基于<code>迭代式MapReduce</code>的通信拓扑、基于参数服务器的通信拓扑、基于数据流的通信拓扑。 </p>
<ol>
<li><p>（早期做法）基于<code>迭代式MapReduce</code>的通信拓扑：如 Spark MLlib。在继承 MR 基础上增加了迭代式，具备了内存运行、持久化等优点。但仍需要完成全部 Mapper 后，进入 Reduce 过程中。单机的优化算法需要较大改动后才能完全符合 Map 和 Reduce 的编程接口。 </p>
</li>
<li><p>基于参数服务器（数据并行）的通信拓扑：如 CMU 的 Parameter Server，微软的 <strong>Multiverso</strong>。把工作结点和模型存储结点在逻辑上区分开来。（lee 理解：一个做计算，一个保存模型参数）P50。worker 只与 ps 交互，各个 worker 之间不需要交互，因此快 worker 不需要等待慢 worker。全局参数拆分到多个 ps 上，可以平衡负载提高通信效率，而且对稀疏模型访问的情况比较友好（达到模型并行的效果）。 </p>
</li>
<li><p>基于数据流（模型并行）的通信拓扑：如 <strong>TensorFlow</strong>。数据流，也就是 dag。每个节点有两个通信通道：控制信息流和计算数据流。 </p>
<ol>
<li><p>控制信息流：input[data、参数],calculate,output[interval data, 参数update] </p>
</li>
<li><p>控制信息流：worker 应该接受什么 data、data 是否完整，计算是否完成，是否可以开始下游等。lee理解[一些配置信息，以及状态维持等]。 </p>
</li>
<li><p>通信步调：同步 or 异步？ </p>
<ol>
<li><p>同步：应用于早期，逻辑清晰，但上千结点同时工作情况下等待时间过长。 </p>
<ol>
<li>基于同步的通信算法：例BSP 的随机下降算法、模型平均法、ADMM 法、弹性平均随机梯度下降法等。</li>
</ol>
</li>
<li><p>异步：每个 worker 在完成本地一定量训练后，不等待其他 worker，而将自己的 output 推送到 ps 上，随即继续本地的模型训练 P52。 </p>
<ol>
<li><p>基于异步的通信算法：例异步随机梯度下降法ASGD、HogWild！、Cyclades 等。 </p>
</li>
<li><p>优化：对延迟不敏感的算法：AdaptiveRevision、AdaDelay; 补偿延迟算法，DC-ASGD。 </p>
</li>
<li><p>分为有锁、无锁两种。是指局部模型并入全局模型时是否加锁。</p>
</li>
</ol>
</li>
<li><p>半同步：例SSP。当检测到延迟过大时，会要求最快的结点停下工作等待较慢的结点。 </p>
</li>
<li><p>混合同步：工作结点分组，组内同步通信，组间异步通信。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="3-4-数据与模型聚合模块"><a href="#3-4-数据与模型聚合模块" class="headerlink" title="3.4. 数据与模型聚合模块"></a>3.4. 数据与模型聚合模块</h2><ul>
<li>其实就是将来自不同 worker 的data、模型进行聚合的过程。以下以 ps 为例：</li>
</ul>
<ol>
<li><p>ps 拿到多个局部模型后，可以进行 ①模型参数的简单平均；②做一致性优化（如 ADMM、BMUF）； ③模型集成。但各有利弊。模型参数的简单平均和一致性优化：不适合非凸函数（例如深度学习）。模型集成会增加模型的规模，严重时导致模型爆炸，解决办法：模型集成+压缩；考虑子模型的延迟生成，模型集成可能需要异步聚合。 </p>
</li>
<li><p>当 ps 将全局模型推送到 worker 上时，worker 可以无条件信任全局模型，也可以部分信任并概率更新本地模型。 </p>
</li>
<li><p>典型分布式机器学习系统的比较，P56</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">MapReduce</th>
<th align="center">Multiverso</th>
<th align="center">TensorFlow</th>
</tr>
</thead>
<tbody><tr>
<td align="center">通信拓扑</td>
<td align="center">迭代式 MR</td>
<td align="center">ps</td>
<td align="center">dag</td>
</tr>
<tr>
<td align="center">灵活性</td>
<td align="center">低，需要遵从 Map+Reduce 步骤</td>
<td align="center">高，它只是提供了全局存储的服务器和 访问全局存储的 API，对分布式程序自身执行的流程以及具体的运算都没有作要求</td>
<td align="center">中等，任务需要描述成 dag</td>
</tr>
<tr>
<td align="center">运行效率</td>
<td align="center">低，同步逻辑</td>
<td align="center">较高，异步</td>
<td align="center">较高，异步</td>
</tr>
<tr>
<td align="center">学习任务</td>
<td align="center">浅层任务，如 LR 等</td>
<td align="center">无限制，但需要用户自己实现器学算法</td>
<td align="center">提供一些算子和优化器，用户可自由搭建类深度学习的模型等</td>
</tr>
<tr>
<td align="center">用户使用</td>
<td align="center">较多现成算子</td>
<td align="center">生态系统较薄弱</td>
<td align="center">较多现成算子</td>
</tr>
</tbody></table>
<h1 id="4-数据和模型切分类型"><a href="#4-数据和模型切分类型" class="headerlink" title="4.数据和模型切分类型"></a>4.数据和模型切分类型</h1><ol>
<li>计算并行模式<ul>
<li>data 和 model 都在同一块内存中，所有 worker 结点共享，可以并行计算。如单机多线程环境。</li>
</ul>
</li>
<li>数据并行模式<ul>
<li>训练数据量很大，但本地内存容量受限，所以要切分数据。</li>
<li>数据会被分配到各个 worker 上，worker 依据局部数据训练模型。</li>
</ul>
</li>
<li>模型并行模式<ul>
<li>模型规模比较大，但本地内存容量受限，所以要切分模型。</li>
<li>模型切分跟模型的结构特点有关。线性模型可以按照特征维度进行划分；深层 NN 划分时，可以考虑逐层横向划分（接口清晰，但并行度可能不高）或者跨层纵向划分（子模型间依赖关系复杂、通信代价高）。</li>
</ul>
</li>
</ol>
<p>#5.通信机制</p>
<ul>
<li><p>分布式机器学习的通信特点：通信频率高、通信数据量大，但数值优化算法的容错性较好。</p>
</li>
<li><p>通信的内容：参数(或参数的更新)、计算的中间结果。</p>
<ol>
<li>参数(或参数的更新)：基于<strong>数据并行</strong>的机器学习（不同 worker 用的同一份 model，参数的重叠度高，所以采用参数进行通信）。稀疏更新，而且随着模型趋于收敛，参数的更新会越来越少，相应通信量会降低。</li>
<li>计算的中间结果：基于<strong>模型并行</strong>的机器学习（不同 worker 的 model 不同，参数重叠度低，所以通信传递的不是参数，而是相互依赖的中间计算结果）。</li>
</ol>
</li>
<li><p>通信的拓扑：参考上文第 3 节内容</p>
<ul>
<li>发展历史：&gt;通信拓扑结构的演化与分布式机器学习的发展历史有关 。 早期，当人 们用 于训练模型的数据量还不够大，预测模型还不够复杂时，分布式机器学习常常利用已有的分布式计算框架来实现通信，如消息通信接口( MPI)或者 MapReduce 计算框架 。 这类通用的<br>计算框架，有利于快速实现分布式机器学习任务，但也有本身的局限性，例如，使用MPI 的方式，各个节点之间仅支持同步计算 。 随着数据量增大，模型变得越来越复杂，人们设计了参数服务器这样的分布式机器 学习系统。通过采 用 二部图的网络拓扑结构,参数服务器可以支持基于异步通信的并行训练 。 后来，随着深度学习的普及，机器学习系统将计算和通信统一抽象为一个数据图模型，通信可以在任意两个相连的图节点之间产生。</li>
</ul>
</li>
</ul>
<!--后注：Spark MLlib 在 P140、以及 11 章-->

]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统之time clock ordering</title>
    <url>/2018/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8Btime-clock-ordering/</url>
    <content><![CDATA[<p>参考阅读：<br><a href="http://www.cnblogs.com/bangerlee/p/5448766.html">分布式系统理论基础 - 时间、时钟和事件顺序</a><br><a href="https://www.jianshu.com/p/8500882ab38c">分布式系统的时间</a><br><a href="https://www.jianshu.com/p/d888642ef72c?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">分布式系统一致性的发展历史</a><br><a href="https://36kr.com/p/5037166.html">分布式系统一致性的发展历史（一）</a></p>
<h1 id="时间、时钟和事件顺序"><a href="#时间、时钟和事件顺序" class="headerlink" title="时间、时钟和事件顺序"></a>时间、时钟和事件顺序</h1><ul>
<li>分布式系统使用<strong>逻辑时钟</strong>记录事件顺序关系。<ul>
<li>采用物理时钟，在分布式系统中仍然会有毫秒级别的偏差。</li>
</ul>
</li>
</ul>
<h2 id="Lamport-timestamps"><a href="#Lamport-timestamps" class="headerlink" title="Lamport timestamps"></a>Lamport timestamps</h2><blockquote>
<p>每个事件对应一个Lamport时间戳，初始值为0<br>如果事件在节点内发生，时间戳加1<br>如果事件属于发送事件，时间戳加1并在消息中带上该时间戳<br>如果事件属于接收事件，时间戳 &#x3D; Max(本地时间戳，消息中的时间戳) + 1</p>
</blockquote>
<p><strong>偏序关系 partial order</strong>，如下图方框内的编号：</p>
 <span id="more"></span>
<p> <img src="/2018/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8Btime-clock-ordering/1.png" alt="1"></p>
<p><strong>全序关系 total order</strong>，除了上面的偏序关系外，加上以下排序，构成全序关系：<br>A1 &#x3D;&gt; B3 、 A2 &#x3D;&gt; C2  、 B4 &#x3D;&gt; C3 、B5 &#x3D;&gt; A3 。</p>
<h2 id="Vector-clock"><a href="#Vector-clock" class="headerlink" title="Vector clock"></a>Vector clock</h2><blockquote>
<p>Vector clock是在Lamport时间戳基础上演进的另一种逻辑时钟方法，它通过vector结构不但记录本节点的Lamport时间戳，同时也记录了其他节点的Lamport时间戳</p>
</blockquote>
<p><img src="/2018/12/31/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B9%8Btime-clock-ordering/2.png" alt="2"></p>
<blockquote>
<p>如果 Tb[Q] &gt; Ta[Q] 并且 Tb[P] &lt; Ta[P]，则认为a、b同时发生，记作 a &lt;-&gt; b。例如图2中节点B上的第4个事件 (A:2，B:4，C:1) 与节点C上的第2个事件 (B:3，C:2) 没有因果关系、属于同时发生事件。</p>
</blockquote>
<h2 id="True-Time"><a href="#True-Time" class="headerlink" title="True Time"></a>True Time</h2><ul>
<li>NTP是有误差的，而且NTP还可能出现时间回退的情况，所以我们不能直接依赖NTP来确定一个事件发生的时间。在Google Spanner里面，通过引入True Time来解决了分布式时间问题。<ul>
<li>NTP，network time protocol，网络时间协议。提供了一个服务，使得跨互联网的用户能精准地与 UTC 同步。</li>
<li>这个服务是可靠的，通常使用冗余服务器的方式。</li>
<li>提供对时间服务的保护，采用认证技术来检查数据和地址。</li>
</ul>
</li>
<li>Spanner通过使用GPS + Atomic Clock来对集群的机器进行校时，精度误差范围能控制在ms级别，通过提供一套TrueTime API给外面使用。</li>
<li>虽然spanner引入了TrueTime可以得到全球范围的时序一致性，但相关事务在提交的时候会有一个wait时间，只是这个时间很短，而且spanner后续都准备将其优化到 ε &lt; 1ms，也就是对于关联事务，仅仅在上一个事务commit之后等待2ms之后就能执行，性能还是很强悍的。</li>
<li>最关键的是，<strong>TrueTime 是基于硬件的</strong>，对于很多企业来说，是没有办法搞定这套部署的。</li>
</ul>
<h2 id="Hybrid-Logic-Clock"><a href="#Hybrid-Logic-Clock" class="headerlink" title="Hybrid Logic Clock"></a>Hybrid Logic Clock</h2><ul>
<li>从软件层面，基于 NTP ，解决分布式时间问题。</li>
<li>读取当前系统时间，对于一个 HLC 的时间t 来说，他总是等于或者略大于当前的系统时间。</li>
<li>HLC 由两部分组成——physical clock 和 logic clock。某一结点 j 维护了 l.j 和 c.j ，前者是节点 j 当前已知的最大的物理时间，后者是当前的逻辑时间。<ul>
<li>如果有两个事件，那么先判断物理时间 pt，再判断逻辑时间 ct。</li>
</ul>
</li>
</ul>
<blockquote>
<p>HLC虽然方便，它毕竟是基于NTP的，所以如果NTP出现了问题，可能导致HLC与当前系统pt的时间误差过大</p>
</blockquote>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>七种内部排序的代码实现</title>
    <url>/2019/03/22/%E4%B8%83%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>七种内部排序算法的代码实现（Java）：</p>
<ol>
<li>冒泡排序</li>
<li>选择排序</li>
<li>插入排序</li>
<li>快排排序</li>
<li>归并排序</li>
<li>希尔排序</li>
<li>堆排序</li>
</ol>
<span id="more"></span>


<h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> class 手写冒泡排序 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		sorts(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sorts</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head; i &lt;= tail; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> tail; j &gt; i; --j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) &#123;</span><br><span class="line">					swap(a,j-<span class="number">1</span>,j);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 手写选择排序 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		<span class="built_in">sorts</span>(a,<span class="number">0</span>,a.length<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;a.length;++i)&#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(a[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">sorts</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i =head;i&lt;=tail;++i)&#123;</span><br><span class="line">			<span class="type">int</span> min = a[i];</span><br><span class="line">			<span class="type">int</span> minIndex = i;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = i;j&lt;=tail;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[j]&lt;min)&#123;</span><br><span class="line">					min = a[j];</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">swap</span>(a,i,minIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 手写插入排序 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		sorts(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sorts</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head + <span class="number">1</span>; i &lt;= tail; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; head &amp;&amp; a[j] &lt; a[j - <span class="number">1</span>]; --j) &#123;</span><br><span class="line">				swap(a, j, j - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="4-快排排序"><a href="#4-快排排序" class="headerlink" title="4. 快排排序"></a>4. 快排排序</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> 手写快排 &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		sorts(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static <span class="type">void</span> sorts(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head &gt; tail) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = a[head];</span><br><span class="line">		<span class="type">int</span> i = head, j = tail;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">			<span class="keyword">while</span> (a[j] &gt; <span class="keyword">temp</span> &amp;&amp; i &lt; j) j<span class="comment">--;</span></span><br><span class="line">			a[i] = a[j];</span><br><span class="line">			<span class="keyword">while</span> (a[i] &lt; <span class="keyword">temp</span> &amp;&amp; i &lt; j) i++;</span><br><span class="line">			a[j] = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		a[i] = <span class="keyword">temp</span>;</span><br><span class="line">		sorts(a, head, i - <span class="number">1</span>);</span><br><span class="line">		sorts(a, i + <span class="number">1</span>, tail);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="5-归并排序"><a href="#5-归并排序" class="headerlink" title="5. 归并排序"></a>5. 归并排序</h2><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> 手写归并排序 &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		sorts(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.print(a[i] + &quot; &quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static <span class="type">void</span> sorts(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail) &#123;</span><br><span class="line">		<span class="keyword">if</span> (head &gt;= tail) <span class="keyword">return</span>;</span><br><span class="line">		<span class="type">int</span> mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(head + <span class="number">1</span> == tail)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[head]&gt;a[tail]) swap(a,head,tail);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sorts(a,<span class="number">0</span>,mid);</span><br><span class="line">		sorts(a,mid+<span class="number">1</span>,tail);</span><br><span class="line">		merge(a,head,mid,tail);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static <span class="type">void</span> merge(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> mid,<span class="type">int</span> tail) &#123;</span><br><span class="line">		<span class="type">int</span> len = tail - head +<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span>[] b = <span class="built_in">new</span> <span class="type">int</span>[len];</span><br><span class="line">		<span class="type">int</span> i =head,j=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=tail)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">				b[<span class="keyword">index</span>++] = a[i++];</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				b[<span class="keyword">index</span>++] = a[j++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">			b[<span class="keyword">index</span>++] = a[i++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(j&lt;=tail)&#123;</span><br><span class="line">			b[<span class="keyword">index</span>++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t = head;t&lt;=tail;++t)&#123;</span><br><span class="line">			a[t] = b[<span class="keyword">index</span>++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static <span class="type">void</span> swap(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = <span class="keyword">temp</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="6-希尔排序"><a href="#6-希尔排序" class="headerlink" title="6. 希尔排序"></a>6. 希尔排序</h2><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> 手写shell排序 &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>[] a = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		<span class="built_in">sorts</span>(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			System.out.<span class="built_in">print</span>(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">sorts</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> head, <span class="type">int</span> tail)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> len = tail - head + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> step = len / <span class="number">2</span>; step &gt; <span class="number">0</span>; step /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = head + step; i &lt;= tail; ++i) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= head+step &amp;&amp; a[j] &lt; a[j - step]; j -= step) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(a, j, j - step);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> temp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public <span class="keyword">class</span> 手写堆排序 &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> a = &#123;-<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		sorts(a, <span class="number">1</span>, a.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; a.length; ++i) &#123;</span><br><span class="line">			<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(a<span class="literal">[<span class="identifier">i</span>]</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println<span class="literal">()</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		堆的存储就从脚标 1 开始,low 参数就是摆设，从来都是 1</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> static void sorts(<span class="built_in">int</span><span class="literal">[]</span> a, <span class="built_in">int</span> low, <span class="built_in">int</span> high) &#123;</span><br><span class="line">		<span class="comment">// 建一个最大堆</span></span><br><span class="line">		create<span class="constructor">Heap(<span class="params">a</span>, <span class="params">low</span>, <span class="params">high</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = high; i &gt; low; --i) &#123;</span><br><span class="line">			<span class="comment">// 移动堆顶元素到数组的 i 处</span></span><br><span class="line">			swap(a, low, i);</span><br><span class="line">			<span class="comment">// 向下调整</span></span><br><span class="line">			down<span class="constructor">Adjust(<span class="params">a</span>, <span class="params">low</span>, <span class="params">i</span> - 1)</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		新建一个最大堆</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> static void create<span class="constructor">Heap(<span class="params">int</span>[] <span class="params">a</span>, <span class="params">int</span> <span class="params">low</span>, <span class="params">int</span> <span class="params">high</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = high<span class="operator"> / </span><span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">			down<span class="constructor">Adjust(<span class="params">a</span>, <span class="params">low</span>, <span class="params">high</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		最大堆向下调整</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> static void down<span class="constructor">Adjust(<span class="params">int</span>[] <span class="params">a</span>, <span class="params">int</span> <span class="params">low</span>, <span class="params">int</span> <span class="params">high</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">int</span> i = low, j = low<span class="operator"> * </span><span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt;= high) &#123;</span><br><span class="line">			<span class="keyword">if</span> (j + <span class="number">1</span> &lt;= high) &#123;</span><br><span class="line">				j = a<span class="literal">[<span class="identifier">j</span> + <span class="number">1</span>]</span> &gt; a<span class="literal">[<span class="identifier">j</span>]</span> ? j + <span class="number">1</span> : j; <span class="comment">// j 设为较大的孩子结点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (a<span class="literal">[<span class="identifier">i</span>]</span> &lt; a<span class="literal">[<span class="identifier">j</span>]</span>) &#123;</span><br><span class="line">				swap(a, i, j);</span><br><span class="line">				i = j;</span><br><span class="line">				j = <span class="number">2</span><span class="operator"> * </span>j;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static void swap(<span class="built_in">int</span><span class="literal">[]</span> a, <span class="built_in">int</span> i, <span class="built_in">int</span> j) &#123;</span><br><span class="line">		<span class="built_in">int</span> temp = a<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">		a<span class="literal">[<span class="identifier">i</span>]</span> = a<span class="literal">[<span class="identifier">j</span>]</span>;</span><br><span class="line">		a<span class="literal">[<span class="identifier">j</span>]</span> = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>各个设计模式间的区别和联系</title>
    <url>/2019/01/05/%E5%90%84%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="23-种传统的设计模式分类"><a href="#23-种传统的设计模式分类" class="headerlink" title="23 种传统的设计模式分类"></a>23 种传统的设计模式分类</h1><h2 id="创建型："><a href="#创建型：" class="headerlink" title="创建型："></a>创建型：</h2><p>如何创建对象的模式，抽象了实例化的过程。<br>将创建对象的过程进行了抽象和封装，作为客户程序仅仅需要去使用对象，而不再关心创建对象过程中的逻辑。</p>
<ol>
<li>工厂方法；</li>
<li>抽象工厂；</li>
<li>建造者；</li>
<li>原型；</li>
<li>单例；</li>
</ol>
<span id="more"></span>

<h2 id="结构型："><a href="#结构型：" class="headerlink" title="结构型："></a>结构型：</h2><p>描述如果将类或者对象结合在一起，形成更复杂、功能更加强大的结构。</p>
<ol>
<li>适配器；</li>
<li>桥接；</li>
<li>组合；</li>
<li>装饰者；</li>
<li>外观；</li>
<li>享元；</li>
<li>代理；</li>
</ol>
<h2 id="行为型："><a href="#行为型：" class="headerlink" title="行为型："></a>行为型：</h2><p>使用多态、对象关联等不同方式，动态地改变对象的行为，进而分配多个类的职责。</p>
<ol>
<li>解释器；</li>
<li>模板方法；</li>
<li>负责链；</li>
<li>命令；</li>
<li>迭代器；</li>
<li>中介者；</li>
<li>备忘录；</li>
<li>观察者；</li>
<li>状态；</li>
<li>策略；</li>
<li>访问者。</li>
</ol>
<h1 id="相似设计模式的区别和联系"><a href="#相似设计模式的区别和联系" class="headerlink" title="相似设计模式的区别和联系"></a>相似设计模式的区别和联系</h1><p> 不展开了，本人有写一篇相关的读书报告，有空了整理上传。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>大型网站技术架构——读书笔记（1）</title>
    <url>/2018/11/25/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>《大型网站技术架构——核心原理与案例分析》 李智慧</p>
<p>读书笔记（1）</p>
<h1 id="1-技术演化"><a href="#1-技术演化" class="headerlink" title="1. 技术演化"></a>1. 技术演化</h1><ol>
<li>最初是应用程序、文件、数据库都在同一台服务器上完成最简单的网站结构。</li>
<li>为解决存储空间不足的问题，出现应用服务器、文件服务器、数据库服务器职责分开的情况。<ul>
<li>应用服务器主要处理业务逻辑，需要更快更强的 CPU；</li>
<li>文件服务器需要存储用户上传的文件，需要更大的硬盘；</li>
<li>数据库服务器需要快速磁盘检索和数据缓存，所以需要更快的硬盘和更大的内存。<ul>
<li>网站使用的缓存分为两种：应用服务器上的本地缓存（特点：响应快，但数据量小，可能跟程序争用内存资源）、缓存在分布式缓存服务器上的远程缓存（可采用集群的方式，不受内存容量限制）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li>为提高并发处理能力，采用应用服务器集群的方式。<ul>
<li>采用集群的方式，是改善负载压力的一种简单成熟的方式。【important】至此，应用服务器的负载压力不再是瓶颈了。</li>
<li>可以增加负载均衡调度服务器，进行请求分发的工作。</li>
</ul>
</li>
<li>数据库读写负荷过大时，可以采用两台数据库主从热备的方式。<ul>
<li>写数据时，访问<strong>主数据库</strong>，主数据库将数据更新同步到从数据库中。</li>
<li>读数据库，直接访问<strong>从数据库</strong>。</li>
<li>在应用服务器使用专门的数据访问模块，使得数据库的读写分离对应用透明。</li>
<li>数据库拆分的最终手段是：<strong>分布式数据库</strong>，而且是在单表数据规模非常庞大的时候才使用。网站更常用的是业务拆库，将不同业务的数据库部署在不同的物理服务器上。（采用超链接建立关系，比如网站首页的导航），也可以通过消息队列进行数据分发。</li>
</ul>
</li>
<li>为缓解<strong>网络访问延迟</strong>的问题，可以采用 CDN 和反向代理的方式。<ul>
<li>CDN：推荐阅读：<a href="https://blog.csdn.net/lu_embedded/article/details/80519898">什么是 CDN</a>。CDN 的缓存来自距离用户最近的网络提供商机房获取数据。</li>
<li>反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是反向代理服务器，如果反向代理服务器中缓存着用户所请求的资源，那么将直接返回给用户。</li>
<li>效果：一方面加快用户访问速度、另一方面减轻后端服务器的负载压力。两种方式最常见的应用场景就是缓存静态资源。</li>
</ul>
</li>
<li>为满足对数据存储和检索的需求，网站采用一些非关系型数据库如 NoSQL 和非数据库查询技术如搜索引擎等。<ul>
<li>此时应用服务器最好使用一个<strong>统一数据访问模块</strong>访问各种数据，使诸多数据源的访问对应用程序透明。</li>
</ul>
</li>
</ol>
<h1 id="2-大型网站架构模式"><a href="#2-大型网站架构模式" class="headerlink" title="2. 大型网站架构模式"></a>2. 大型网站架构模式</h1><h2 id="2-1-横向分层"><a href="#2-1-横向分层" class="headerlink" title="2.1 横向分层"></a>2.1 横向分层</h2><p>在大型网站架构中，将软件系统分成应用层（表示层）、服务层、数据层（持久层）。<br>分层的注意点：</p>
<ol>
<li>必须合理规划层次边界和接口。</li>
<li>分层依据的是逻辑层次，不是物理层次。</li>
<li>虽然可以将三层安排在同一个物理机上，但是大型的网站上，三层一定会安排在独立的服务器上。</li>
</ol>
<h2 id="2-2-纵向分割"><a href="#2-2-纵向分割" class="headerlink" title="2.2 纵向分割"></a>2.2 纵向分割</h2><p>将功能和服务分割成<strong>高内聚低耦合</strong>的模块单元，</p>
<blockquote>
<p>网站分割成“购物、论坛、搜索、广告”等；<br>购物继续分割成“机票酒店、3C、小商品”等；<br>小商品继续分割成“首页、搜索列表、商品详情”等</p>
</blockquote>
<h2 id="2-3-分布式"><a href="#2-3-分布式" class="headerlink" title="2.3 分布式"></a>2.3 分布式</h2><p>目的：实现高并发、大数据量的访问，服务更多的用户。</p>
<h3 id="2-3-1-分布式的弊端"><a href="#2-3-1-分布式的弊端" class="headerlink" title="2.3.1 分布式的弊端"></a>2.3.1 分布式的弊端</h3><ol>
<li>服务调用需要经过<strong>网络</strong>，可能对性能造成比较严重的影响；</li>
<li>服务器越多，宕机的概率越大，降低网站的可用性；</li>
<li>数据一致性、分布式事务很难保证；</li>
<li>网站依赖错综复杂、开发管理维护困难；</li>
</ol>
<h3 id="2-3-2-常用的分布式方案"><a href="#2-3-2-常用的分布式方案" class="headerlink" title="2.3.2 常用的分布式方案"></a>2.3.2 常用的分布式方案</h3><ol>
<li>分布式应用和服务<ul>
<li>将分层、分割后的应用和服务模块分布式部署。</li>
</ul>
</li>
<li>分布式静态资源<ul>
<li>即动静分离。静态资源分布式部署，可以减轻应用服务器的负载压力；使用独立域名加快浏览器并发加载的速度。</li>
</ul>
</li>
<li>分布式数据和存储<ul>
<li>可对传统的 RDBMS 进行分布式部署，也可直接采用分布式产品如 NoSQL 等。</li>
</ul>
</li>
<li>分布式计算<ul>
<li>主要针对一些后台业务、包括搜索引擎的索引构建、数据仓库的数据分析统计等。</li>
<li>特点：移动计算（而不是移动数据），将计算程序分发到数据所在的位置以加速计算和分布式计算。</li>
</ul>
</li>
</ol>
<h3 id="2-3-3-集群"><a href="#2-3-3-集群" class="headerlink" title="2.3.3 集群"></a>2.3.3 集群</h3><p>使用分布式将已经分层和分割的模块独立部署了，<strong>但是对于用户访问集中的模块（比如首页），仍要将独立部署的服务器集群化</strong>，即多台服务器部署相同应用构成一个集群，再通过负载均衡服务设备共同对外提供服务。</p>
<ul>
<li>重点关注：并发性和失效转移机制</li>
<li>即使访问量很小的分布式应用和服务，也至少部署两台服务器构成一个小的集群，目的就是提高系统的可用性。</li>
</ul>
<h3 id="2-3-4-缓存"><a href="#2-3-4-缓存" class="headerlink" title="2.3.4 缓存"></a>2.3.4 缓存</h3><p>除了上文介绍的 CDN、反向代理外，还有本地缓存、分布式缓存等形式。</p>
<ol>
<li>本地缓存：在应用服务器的本地缓存热点数据。</li>
<li>分布式缓存：适用在大型网站中（因为缓存的数据量也很大），将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。</li>
</ol>
<p>缓存的前提条件：</p>
<pre><code>1. 局部性原理；
2. 数据在某段时间内有效，不会很快过期。
</code></pre>
<h3 id="2-3-5-异步"><a href="#2-3-5-异步" class="headerlink" title="2.3.5 异步"></a>2.3.5 异步</h3><p>异步的使用场景举例（可以按照生产者消费者模式来理解）：</p>
<ul>
<li>单服务器内部通过多线程共享内存队列的方式实现异步。<ul>
<li>前一个线程将输出写入队列中，后一个线程从队列中读取数据进行处理</li>
</ul>
</li>
<li>分布式系统中，多个服务器集群通过分布式消息队列实现异步。</li>
</ul>
<p>异步消息队列的特性：</p>
<pre><code>1. 提高系统可用性；
2. 加快网站响应速度；
3. 消除并发访问高峰；
</code></pre>
<h3 id="2-3-6-冗余"><a href="#2-3-6-冗余" class="headerlink" title="2.3.6 冗余"></a>2.3.6 冗余</h3><ul>
<li>通过冗余实现服务高可用。</li>
<li>数据库除了冷备份（定期备份，存档保存）外，还需要热备份（数据库主从分离，实时同步）。</li>
<li>为了抵御地震等不可抗力导致的网络完全瘫痪，还要对整个数据中心进行备份，全球范围内部署<strong>灾备数据中心</strong>。</li>
</ul>
<h3 id="2-3-7-自动化"><a href="#2-3-7-自动化" class="headerlink" title="2.3.7 自动化"></a>2.3.7 自动化</h3><ol>
<li>发布过程自动化。<ol>
<li>自动化代码管理；</li>
<li>自动化测试；</li>
<li>自动化安全监测（安全攻击测试）；</li>
<li>自动化部署。</li>
</ol>
</li>
<li>线上生产环境进行自动化监控。<ol>
<li>自动化报警（参数异常报警）；</li>
<li>自动化失效转移（将失效的服务器从集群中隔离出去）；</li>
<li>自动化失效恢复（故障消除后，服务重启，同步数据保持数据一致性）；</li>
<li>自动化降级（当访问超负荷时，通过拒绝部分请求即关闭部分不重要的服务进行降负载）；</li>
<li>自动化分配资源（将空闲资源分配给重要的服务）。</li>
</ol>
</li>
</ol>
<h3 id="2-3-8-安全"><a href="#2-3-8-安全" class="headerlink" title="2.3.8 安全"></a>2.3.8 安全</h3><p>关键词：密码和手机校验码、加密、过滤、风险控制。</p>
<h2 id="3-架构"><a href="#3-架构" class="headerlink" title="3. 架构"></a>3. 架构</h2><p>架构的定义：<strong>最高层次的规划，难以改变的决定。</strong><br>软件架构需要考虑<strong>性能、可用性、伸缩性、扩展性和安全性</strong>这五个要素。</p>
<h3 id="3-1-性能"><a href="#3-1-性能" class="headerlink" title="3.1 性能"></a>3.1 性能</h3><p>性能的评价指标有：响应时间、TPS、系统性能计数器等</p>
<h3 id="3-2-可用性"><a href="#3-2-可用性" class="headerlink" title="3.2 可用性"></a>3.2 可用性</h3><p>当服务器宕机的时候，服务或应用依然可用。<br>主要手段：<strong>冗余</strong>。</p>
<h3 id="3-3-伸缩性"><a href="#3-3-伸缩性" class="headerlink" title="3.3 伸缩性"></a>3.3 伸缩性</h3><p>伸缩性是指，<strong>通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求</strong>。<br>评价标准：是否可以用多台服务器构建集群，是否容易向集群中新增服务器，加入的新服务器是否可以提供跟原本服务器无差别的服务，集群中可容纳的服务器的总数是否有限制等。</p>
<p>Tips：大部分 NoSQL 数据库产品对伸缩性支持地很好。</p>
<h3 id="3-4-扩展性"><a href="#3-4-扩展性" class="headerlink" title="3.4 扩展性"></a>3.4 扩展性</h3><p>扩展性：主要指功能需求变化的适应能力。<br>衡量标准：网站新增业务时，是否对现有业务的产品透明性无影响，不需要任何改动或少量改动既有业务就可以上线新产品等。<br>主要手段：<strong>事件驱动架构</strong>和<strong>分布式服务</strong>。</p>
<h3 id="3-5-安全性"><a href="#3-5-安全性" class="headerlink" title="3.5 安全性"></a>3.5 安全性</h3><p>针对现存和潜在的各种攻击和窃密手段，是否有可靠的应对策略。</p>
<h1 id="4-瞬时响应"><a href="#4-瞬时响应" class="headerlink" title="4. 瞬时响应"></a>4. 瞬时响应</h1><h2 id="4-1-开发人员看待网站性能"><a href="#4-1-开发人员看待网站性能" class="headerlink" title="4.1 开发人员看待网站性能"></a>4.1 开发人员看待网站性能</h2><p>开发者关注：应用程序本身及其相关子系统的性能，包括<strong>响应延迟、系统吞吐量、并发处理能力、系统稳定性</strong>等技术指标。<br>优化手段：缓存加速、集群提高吞吐能力、异步消息加快响应及实现削峰、代码优化。</p>
<h2 id="4-2-运维人员看待网络性能"><a href="#4-2-运维人员看待网络性能" class="headerlink" title="4.2 运维人员看待网络性能"></a>4.2 运维人员看待网络性能</h2><h2 id="运维者关注：基础设施性能和资源利用率，包括带宽、服务器配置等。优化手段：建设优化骨干网、使用高性价比定制服务器，利用虚拟化技术优化资源利用等。"><a href="#运维者关注：基础设施性能和资源利用率，包括带宽、服务器配置等。优化手段：建设优化骨干网、使用高性价比定制服务器，利用虚拟化技术优化资源利用等。" class="headerlink" title="运维者关注：基础设施性能和资源利用率，包括带宽、服务器配置等。优化手段：建设优化骨干网、使用高性价比定制服务器，利用虚拟化技术优化资源利用等。
 "></a>运维者关注：基础设施性能和资源利用率，包括带宽、服务器配置等。<br>优化手段：建设优化骨干网、使用高性价比定制服务器，利用虚拟化技术优化资源利用等。
 </h2><blockquote>
<p>网站性能的主要指标有：响应时间、并发数、吞吐量、性能计数器（比如对象与线程数、内存使用、CPU 使用、磁盘&#x2F;IO）等。</p>
</blockquote>
<hr>
<h2 id="4-3-如何进行性能测试"><a href="#4-3-如何进行性能测试" class="headerlink" title="4.3 如何进行性能测试"></a>4.3 如何进行性能测试</h2><p>手段：性能测试、负载测试、压力测试、稳定性测试。</p>
<p>专业用词：</p>
<ol>
<li>系统最大负载点：随系统压力持续增加，系统处理能力最终到达的最大值。</li>
<li>系统的崩溃点：到达最大负载点后，如果继续增加压力，系统处理能力反而下降，直到资源消耗到达极限，此时就是系统的崩溃点。</li>
</ol>
<h2 id="4-4-如何对性能问题进行优化"><a href="#4-4-如何对性能问题进行优化" class="headerlink" title="4.4 如何对性能问题进行优化"></a>4.4 如何对性能问题进行优化</h2><p>主要分为 Web 前端性能优化、应用服务器性能优化、存储服务器性能优化。</p>
<h3 id="4-4-1-Web-前端性能优化"><a href="#4-4-1-Web-前端性能优化" class="headerlink" title="4.4.1 Web 前端性能优化"></a>4.4.1 Web 前端性能优化</h3><h4 id="4-4-1-1-浏览器访问优化"><a href="#4-4-1-1-浏览器访问优化" class="headerlink" title="4.4.1.1 浏览器访问优化"></a>4.4.1.1 浏览器访问优化</h4><ol>
<li>减少 HTTP 请求。因为 HTTP 请求开销昂贵，所以考虑合并 HTTP 请求，即将浏览器一次访问需要的 JavaScript、CSS、图片等合并成一个文件。</li>
<li>采用浏览器缓存。静态资源可缓存在浏览器中（数天或者几个月），在更新静态资源时可以通过更改文件名来实现，即生成一个新的 JS 文件，并更新 HTML 文件中的引用。</li>
<li>启用压缩。服务器端压缩文件、浏览器端解压缩文件。但压缩过程也有压力损耗，需权衡决定是否采用。</li>
<li>CSS 放在页面最上面，JS 放在页面最下面。CSS 下完后才会开始渲染，而JS 会立即执行，可能会阻塞整个页面。</li>
<li>减少 Cookie 传输。每次请求和响应都有 Cookie，所以 Cookie 带的数据量要小；同时一些静态资源的访问中，Cookie 没有意义，可考虑静态资源使用独立域名访问，避免请求时发送 Cookie。</li>
</ol>
<h4 id="4-4-1-2-CDN-加速"><a href="#4-4-1-2-CDN-加速" class="headerlink" title="4.4.1.2 CDN 加速"></a>4.4.1.2 CDN 加速</h4><p>CDN 缓存的多是静态资源。其他略。</p>
<h4 id="4-4-1-3-反向代理"><a href="#4-4-1-3-反向代理" class="headerlink" title="4.4.1.3 反向代理"></a>4.4.1.3 反向代理</h4><p>反向的理解：一般的代理都是在浏览器一侧，然而反向代理是放在网站机房的一侧。<br>反向代理服务器三个作用：<strong>安全、缓存、负载均衡</strong>。</p>
<pre><code>1. 安全是指所有请求必须经过代理服务器，所以可当做安全屏障；
2. 缓存是指，一些静态资源（甚至部分热点动态资源）可以放在反向代理服务器中，加快 Web 的响应速度，减轻 Web 服务器的负载压力。
    + 如果动态内容发生变化，通过内部通知机制告知反向代理服务器缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。
3. 负载均衡。略，不解释。
</code></pre>
<h3 id="4-4-2-应用服务器性能优化"><a href="#4-4-2-应用服务器性能优化" class="headerlink" title="4.4.2 应用服务器性能优化"></a>4.4.2 应用服务器性能优化</h3><p>指处理业务的服务器的优化。<br>优化手段：<strong>缓存、集群、异步</strong>。</p>
<h4 id="4-4-2-1-缓存"><a href="#4-4-2-1-缓存" class="headerlink" title="4.4.2.1 缓存"></a>4.4.2.1 缓存</h4><p>缓存的本质：一个内存 Hash 表。</p>
<p>Tips：缓存也有其可用性。因为一旦缓存服务崩溃时，数据库完全不能承受过大的压力而宕机，所以实践中有些网站会通过<strong>缓存热备</strong>的方式提高缓存可用性，但此举违背了缓存的初衷（缓存本就不是可靠地数据源）。</p>
<ul>
<li><strong>缓存预热</strong>：新启动的缓存系统要花很久建立缓存，所以可以在缓存系统启动时就把热点数据加载好。</li>
<li><strong>缓存穿透</strong>：因为不恰单的业务或者恶意攻击，持续高并发地请求某一个不存在的数据，因为缓存没有保存该数据，所有的请求都落在数据库上，对数据库造成很大的压力，甚至崩溃。<ul>
<li>解决办法是，将不存在的数据也缓存起来。</li>
</ul>
</li>
</ul>
<h4 id="4-4-2-2-分布式缓存架构"><a href="#4-4-2-2-分布式缓存架构" class="headerlink" title="4.4.2.2 分布式缓存架构"></a>4.4.2.2 分布式缓存架构</h4><p>定义：缓存部署在多个服务器组成的集群中，以集群的方式提供缓存服务。</p>
<p>一般有 JBoss Cache 和 Memcached 两种方式：</p>
<ol>
<li>JBoss Cache：缓存集群中的所有服务器中保存相同的缓存数据，当某一台出现数据更新时，会通知其他服务器更新缓存数据。<ul>
<li>特点1：缓存与应用通常在同一台服务器上，应用程序可从本地快速获取缓存数据。</li>
<li>特点2：缓存数据总量受限于单台服务器的内存空间，而且如果集群规模较大，信息同步需要的代价太大，所以很少在大型网站中使用，一般是企业应用系统中（即专用系统，用户没那么多的情况）。</li>
</ul>
</li>
<li>Memcached：采用互不通信的分布式架构方式，缓存与应用分属不同的服务器，应用程序通过一致性 Hash 等路由算法选择缓存服务器并远程访问缓存数据。<ul>
<li>特点1：缓存服务器间互不通信，可以理解为耦合度低，所以缓存集群可以很容易实现扩容，具有良好的可伸缩性。</li>
<li>特点2：使用 TCP 协议（UDP 也支持）通信。</li>
<li>特点3：Memcached 通信协议简单，可以发展出非常丰富的客户端程序，几乎支持所有主流的网站编程语言。</li>
<li>特点4：网络通信性能高。</li>
<li>特点5：内存管理高效。</li>
</ul>
</li>
</ol>
<h4 id="4-4-2-3-异步操作"><a href="#4-4-2-3-异步操作" class="headerlink" title="4.4.2.3 异步操作"></a>4.4.2.3 异步操作</h4><p>通过异步操作，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</p>
<blockquote>
<p>任何可以晚点做的事情都应该晚点再做。</p>
</blockquote>
<h4 id="4-4-2-4-使用集群"><a href="#4-4-2-4-使用集群" class="headerlink" title="4.4.2.4 使用集群"></a>4.4.2.4 使用集群</h4><p>使用负载均衡技术，使服务器的并发请求数据控制在最佳运行区间，获得最佳的访问请求延迟。</p>
<h4 id="4-4-2-5-代码优化"><a href="#4-4-2-5-代码优化" class="headerlink" title="4.4.2.5 代码优化"></a>4.4.2.5 代码优化</h4><ol>
<li>使用多线程。<ol>
<li>将对象设计为无状态对象：比如 servlet 就是无状态对象可以被并发调用；</li>
<li>使用局部对象；</li>
<li>并发访问资源时使用锁。</li>
</ol>
</li>
<li>资源复用。<ol>
<li>单例，比如 spring 容器管理的单例。</li>
<li>对象池，比如数据库连接池、线程池等。</li>
</ol>
</li>
<li>善用数据结构。<ol>
<li>比如尽力提高 HashCode 的随机性，可提高 Hash 表的读写性能。</li>
</ol>
</li>
<li>垃圾回收，选择较优的垃圾回收策略。</li>
</ol>
<h3 id="4-4-3-存储性能优化"><a href="#4-4-3-存储性能优化" class="headerlink" title="4.4.3 存储性能优化"></a>4.4.3 存储性能优化</h3><ol>
<li>选择机械硬盘或者 SSD？<ul>
<li>传统机械硬盘在数据随机访问时性能较差。</li>
<li>在 SSD 中，寻道一如往事不再~~</li>
</ul>
</li>
<li>选择 B+ 树或者 LSM 树？推荐阅读：<a href="https://blog.csdn.net/yyd19921214/article/details/69676953">B+树与LSM树的区别与联系</a><ul>
<li>B+ 树广泛应用在 RDBMS 中，检索时从根开始查找数据所在的节点编号和磁盘位置，将其加载到内存中然后继续查找。</li>
<li>LSM 树应该在非关系型数据库如 NoSQL 中，是一个 N 阶合并树。写操作都在内存中完成，增删改都会新建一个记录并在内存中成为排序树，只有等到数据量超过内存阈值后，将这颗排序树与磁盘上最新的排序树合并。<ul>
<li>特点：写操作比使用 B+ 树快上 5~10 倍，读操作可能有所提升，也可能有所减弱。</li>
</ul>
</li>
</ul>
</li>
<li>RAID 和 HDFS？扩展阅读：<a href="https://blog.csdn.net/Post_Yuan/article/details/53517206">Hadoop 不用RAID 0的原因</a><ul>
<li>RAID 是廉价磁盘冗余阵列，在 RDBMS 和文件系统中应用较多。</li>
<li>HDFS 在存储集群的多台服务器上进行数据并发和备份。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>在线学习防作弊综述</title>
    <url>/2021/03/18/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E9%98%B2%E4%BD%9C%E5%BC%8A%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<p>【题外话】机器学习论文怎么写：</p>
<p>很大一部分论文描述或研究了新的机器学习方法或理论。这类论文的例子可能包括: 一篇提出新的学习算法的论文; 一篇描述困难应用的解决方案的论文; 或者一篇证明某种学习方法的错误的界限的论文。这些论文有望作出重要的(i)算法，(ii)应用，或(iii)理论贡献。NIPS 寻求发表在世界上有很高影响力的论文——不仅在我们的研究社区，而且在其他领域。因此，在适当的情况下，将根据以下五个标准对文件进行评价:</p>
<ol>
<li>算法的新颖性。例如，一篇论文给出了一个算法的优雅的新推导; 或者一篇论文提出了一个解决现有问题的新方法。</li>
<li>应用&#x2F;问题的新颖性。例如，一篇论文提出了一个重要的应用，迄今为止很少在 NIPS 研究。或者，引入一个新的机器学习问题(过去的一些例子包括独立分量分析和结构预测) ，并提出一个算法。</li>
<li>应用的难度。例如，将机器学习应用于一个困难的、重要的、“真实”的应用程序，它考虑到让一个非琐碎的系统工作的全部复杂性。</li>
<li>结果的质量。该算法是否经过严格论证，能够对所考虑的任务给出良好的经验性表现(在这里，“真实”数据或“真实”实验可能比“人工”或“玩具”实验更有效) ，或者理论结果是否强大和有趣等等。</li>
<li>洞察力传达。论文是否传达了对算法性质的洞察力; 实际应用或问题的性质; 学到的一般经验教训; 以及&#x2F;或其他人今后工作可能使用的理论或数学工具。</li>
</ol>
<p>论文的类型：</p>
<ol>
<li>为该模型提出了一种新的自然学习模型和算法(例如: 贝叶斯学习、统计学习、 PAC 学习、在线学习、 MDP 学习、 Boosting)。</li>
<li>在一些标准设置中提出了一种改进的算法并进行了分析。</li>
<li>证明一些人一直在尝试的学习任务是困难的或不可能的。</li>
<li>“其他”。学习定理的元定理等。技术上的困难或新奇不是目标。影响学习的过程和实践是目标。实验结果是好的，但一般来说是不必要的。</li>
</ol>
<span id="more"></span>

<h2 id="基于深度学习的MOOC作弊行为检测研究"><a href="#基于深度学习的MOOC作弊行为检测研究" class="headerlink" title="基于深度学习的MOOC作弊行为检测研究"></a>基于深度学习的MOOC作弊行为检测研究</h2><p>万子云,陈世伟,秦斌,聂伟,徐明.基于深度学习的MOOC作弊行为检测研究[J].信息安全学报,2021,6(01):32-39.</p>
<p>为了提高教育平台的学分认可度，需要做防作弊的研究。</p>
<p><strong>被动防护：技术手段禁止学习者在在线学习过程做一些违规操作。</strong></p>
<ul>
<li><strong>早期技术</strong>：例如,采用操作系统内核的API调用技术、系统消息拦截技术、回调技术、钩子技术、注册表访问技术等手段对一些违规操作实施禁用或者屏蔽,从而达到禁止学生进行页面切换、答案复制及互助抄袭的目的。</li>
</ul>
<p>知识：</p>
<p>正常的学习者会先观看学习视频,再做练习,最后提交答案,异常的学习者可能会直接做练习或者集中在某一个时间段进行刷课等。</p>
<p>异常行为检测问题广泛存在于各个领域,例如网络入侵检测[<a href="javascript:void(0);">5</a>,<a href="javascript:void(0);">6</a>]、信用卡欺诈检测[<a href="javascript:void(0);">7</a>]、故障检测[<a href="javascript:void(0);">8</a>]、居民用电检测[<a href="javascript:void(0);">9</a>]。根据已有的文献研究,异常行为检测算法可以分为基于人工提取特征的传统机器学习算法和基于自动化提取特征的深度学习算法[<a href="javascript:void(0);">10</a>],但是传统机器学习算法过度依赖于人工特征提取,且常常由于特征提取不完整,导致模型性能不佳等问题。因此,许多学者尝试使用基于深度学习的方法进行异常行为检测。</p>
<p>研究现状——适用于特定作弊形式：</p>
<ol>
<li>常永虎等人基于考生在网络考试中的行为数据,提出了一种基于互相抄袭的作弊检测算法,该算法通过计算考生在答题的时间和答案上的相似度来判断作弊的可能性。</li>
<li>Ruiperez-Valiente J A等人开发了一种算法来识别使用CAMEO(使用多个账号复制答案)方法进行作弊的学习者,该算法通过比较学习者、问题和提交特征对CAMEO的影响,<strong>建立了一个不依赖IP的随机森林分类器</strong>，以识别CAMEO学习者。</li>
<li>Sangalli V A等人[<a href="javascript:void(0);">3</a>]针对学习者互相分享答案以及使用虚假账号获取正确答案这两种作弊手段,设计了一些指标来得到相应的特征,再利用K-means聚类算法对其进行聚类来识别使用这两种作弊手段的学习者。</li>
</ol>
<p>研究现状——通用场景</p>
<ol>
<li>卷积神经网络(Convolutional Neural Networks,CNN)[<a href="javascript:void(0);">11</a>]与循环神经网络(Recurrent Neural Networks,RNN)[<a href="javascript:void(0);">12</a>]是比较常见的深度学习网络模型,CNN的优势在于能够在空间维度上提取局部特征,RNN的优势在于能够在时间维度上提取时序特征。<strong>对于复杂的MOOC学习者的学习行为数据,一般是具有序列性质的,因此,在挖掘学习行为特征时,需要考虑其空间上的联系,也需要考虑其时间维度上的关联信息</strong>。</li>
<li>本文尝试将深度学习模型应用于MOOC作弊行为检测中,结合CNN和RNN网络模型来对学习者的学习行为序列进行建模,但是,普通的RNN一方面存在着梯度消失的问题,另一方面只能学习单个方向的时序特征,为了解决这些问题,本文将RNN网络替换成其变种网络—双向门控循环单元(Bidirectional Gated Recurrent Unit,Bi GRU)[<a href="javascript:void(0);">13</a>],采用CNN-Bi GRU联合网络提取学习行为序列的空间及时序特征。(1)针对之前的MOOC作弊行为检测方法存在的应用场景单一化,过度依赖人工提取特征,检测效果不稳定等问题,本文提出了一种基于CNN-Bi GRU-Attention联合网络的MOOC作弊行为检测模型,该模型融合了CNN、Bi GRU、Attention三层网络结构,实现了自动化特征提取,可以适用于多种作弊形式的检测,性能较好。</li>
</ol>
<p>样本选取：</p>
<p>在进行MOOC作弊行为检测研究时,相对于正常样本,作弊样本往往是少之又少。基于此,本文采用<strong>序列截断扩增、平移扩增</strong>这两种数据扩增方法来增加作弊行为序列的样本量。截断扩增,具体而言就是<strong>对长度过长的作弊行为序列进行截断,将截断后的序列打上作弊的标签,从而增加作弊标签的样本量</strong>。而平移扩增是指<strong>通过时间滑窗的方式,以24 h的固定窗口前后滑动,获取一段新的作弊行为序列</strong>。</p>
<p>行业成熟应用</p>
<p><a href="https://zhuanlan.zhihu.com/p/148738080?from_voters_page=true">有效防止学员通过挂机的方式进行学时作弊</a>:**防切屏模式 **&#x2F; <strong>规定时间内的离开提醒(播放视频时隔一段时间检测鼠标任务)</strong></p>
<hr>
<h2 id="Identifying-Cheating-Users-in-Online-Courses"><a href="#Identifying-Cheating-Users-in-Online-Courses" class="headerlink" title="Identifying Cheating Users in Online Courses"></a>Identifying Cheating Users in Online Courses</h2><p>Sangalli, V. A., Martinez-Munoz, G., &amp; Canabate, E. P. (2020). <em>Identifying Cheating Users in Online Courses. 2020 IEEE Global Engineering Education Conference (EDUCON).</em> doi:10.1109&#x2F;educon45650.2020.9125252 </p>
<p>学生类型：通读所有材料和练习的学生，以复习内容为主的学生，以及少数以做练习为主的学生。</p>
<h4 id="A-Co-occurrence-in-exercise-answers"><a href="#A-Co-occurrence-in-exercise-answers" class="headerlink" title="A. Co-occurrence in exercise answers"></a>A. Co-occurrence in exercise answers</h4><p><strong>事件的同时发生</strong>是一个用户与另一个用户的关联程度的指标；<strong>在相同的时间做相同练习</strong>的帐户们将被认为是可疑的。</p>
<ol>
<li>为了计算可疑的用户对，首先计算<strong>每个可能的用户对在短时间内做相同的练习的次数</strong>。</li>
<li>然后，为了进行后续分析，我们将在给定的时间范围内回答了至少一定数量的练习的学生配对。设置最小练习数是为了排除在同一时间窗口中偶然回答相同练习的用户。我们考虑的时间框架为1分钟，2分钟，5分钟和10分钟，期间发生最少10~20 个相同的练习</li>
</ol>
<h4 id="B-Interaction-types"><a href="#B-Interaction-types" class="headerlink" title="B. Interaction types"></a>B. Interaction types</h4><ol>
<li>△t 基本都是负数</li>
<li>巧合出现的几乎都是XC和CC， 这些模式似乎是使用收获帐户（CAMEOtechnique）的真实用户的清晰暗示。其中分享 IP 的比例高是 CAMEO 的典型特征，比例低则不一定。</li>
<li>很少有第一答案正确和第二错误（CX）的情况。 缺少这种模式和答案的同时出现似乎是两个真实用户之间进行协作的明确指标</li>
</ol>
<h4 id="C-Amount-of-pairs-of-users-and-shared-exercises"><a href="#C-Amount-of-pairs-of-users-and-shared-exercises" class="headerlink" title="C. Amount of pairs of users and shared exercises"></a>C. Amount of pairs of users and shared exercises</h4><ol>
<li>许多用户都有不止一对可疑账户。一个用户可能有几个收获帐户，或者一组用户相互协作。</li>
<li>多组时间窗口：1、2、5、10 分钟，完成 10 个、20 个练习的 unique user 的柱状图分布情况。全文以 <strong>2 分钟至少 10 个练习</strong>进行实验！</li>
</ol>
<p>计算过程step</p>
<ol>
<li><strong>确定用户偏向</strong>。即 UB(u1, u2)，UB为正表示u1 做题发生在 u2 之后。</li>
<li><strong>计算最终得分差</strong>。<ol>
<li>如果一对用户在一个时间窗口内解决相同的练习并具有<strong>较高的最终分数差异</strong>，则表明这对用户可能由区域帐户和虚假帐户组成，因为存在一个不关心最终分数的帐户。 </li>
<li>相反，如果他们的<strong>最终成绩差异很小</strong>，则可能表明两个合作的学生，因为他们都试图通过该课程。</li>
</ol>
</li>
<li><strong>材料和练习的比例 MIR</strong>。</li>
<li><strong>共享 IP 的比例。</strong></li>
</ol>
<p>KMeans 做法：</p>
<p>为了自动识别收割者和合作者，我们对先前定义的变量进行了K-均值分析。 具体来说，对于每对分别应用1分钟，2分钟，5分钟和10分钟的时间框架以及最少10和20次练习的帐户，我们计算了指标：用户偏见，得分差异，最小MIR和共享IP地址的百分比。 由于用户偏见和得分差异根据用户排列的顺序而具有不同的符号，因此我们选择对用户输入的顺序进行排序，以使用户偏见为正，并保留该顺序以计算其他指标。 这样做是为了避免仅由用户输入的顺序引起的歧义。 此外，还添加了CC和XC案例的百分比作为属性。 在处理数据集之前，通过去除均值和按比例缩放到单位方差来对功能进行标准化。 K-means是使用k &#x3D; 2执行的，结果被用于将成对的帐户标记为a harvester pair和a collaborator pair</p>
<h2 id="Detecting-and-preventing“multiple-account”cheating-inmassive-open-online-courses"><a href="#Detecting-and-preventing“multiple-account”cheating-inmassive-open-online-courses" class="headerlink" title="Detecting and preventing“multiple-account”cheating inmassive open online courses"></a>Detecting and preventing“multiple-account”cheating inmassive open online courses</h2><p>Northcutt, C. G., Ho, A. D., &amp; Chuang, I. L. (2016). Detecting and preventing “multiple-account” cheating in massive open online courses. Computers &amp; Education, 100, 71–80. doi:10.1016&#x2F;j.compedu.2016.04.008 </p>
<p><img src="/2021/03/18/%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%E9%98%B2%E4%BD%9C%E5%BC%8A%E7%BB%BC%E8%BF%B0/1.png"></p>
<p>分布 B 代表两个合作者，有时一个人的答案先于另一个人，有时会反过来，但时间会非常接近。</p>
<p>分布C 是 CAMEO 行为的典型。</p>
<p>分布 D 只是一种有序的巧合，可以通过注册时间或者时间偏好来过滤掉。</p>
<h2 id="The-Detection-of-Cheating-on-E-Exams-in-Higher-Education—The-Performance-of-Several-Old-and-Some-New-Indicators"><a href="#The-Detection-of-Cheating-on-E-Exams-in-Higher-Education—The-Performance-of-Several-Old-and-Some-New-Indicators" class="headerlink" title="The Detection of Cheating on E-Exams in Higher Education—The Performance of Several Old and Some New Indicators"></a>The Detection of Cheating on E-Exams in Higher Education—The Performance of Several Old and Some New Indicators</h2><p>AUTHOR&#x3D;Ranger Jochen, Schmidt Nico, Wolgast Anett TITLE&#x3D;The Detection of Cheating on E-Exams in Higher Education—The Performance of Several Old and Some New Indicators  JOURNAL&#x3D;Frontiers in Psychology     VOLUME&#x3D;11      YEAR&#x3D;2020 PAGES&#x3D;2390   URL&#x3D;<a href="https://www.frontiersin.org/article/10.3389/fpsyg.2020.568825">https://www.frontiersin.org/article/10.3389/fpsyg.2020.568825</a>     DOI&#x3D;10.3389&#x2F;fpsyg.2020.568825    ISSN&#x3D;1664-1078  </p>
<p>五种不同类型的指标。</p>
<ol>
<li>我们考虑的<strong>person-fit</strong>指标，评估规律的考生的反应模式。这些指标是 U1统计量(van der Flier，1977)、 U3统计量(van der Flier，1982)、 CS 统计量(Sato，1975)和 HT 统计量(Sijtsma，1986)。<ol>
<li>当一个考生的回答和所有其他回答之间的平均协方差为零时，HT 统计值为零，其最大值为1，越小越异常。</li>
</ol>
</li>
<li>基于<strong>响应时间</strong>的指标。这些指标是 KL 统计量(Man 等，2018) ，一个类似于 Marianti 等人(2014)和 Sinharay (2018)提出的 Z2统计量，和一个新的指标ー KT 统计量ー来评估一个考生的反应时间模式的 Guttman 同质性。<ol>
<li>KL：基于考生在单题上花费的总测试时间的比例，评估了一个考生的反应时间剖面与样本中的平均反应时间剖面的一致性，越大说明欺骗。</li>
<li>KT 统计评估一个考生的个人答复时间是否与样本中的典型答复时间顺序相同。</li>
</ol>
</li>
<li>基于<strong>响应修订数量和相应响应时间</strong>的指标(Qualls，2005; Bishop 和 Egan，2017)。其中两个指标(N1、 N2)与答复修订次数有关，两个指标(NC1、 NC2)与修订次数有关，三个指标(T1、 T2、 T3)与修订次数有关。<ol>
<li>N1和 NC1统计量化了考生在考试期间改变答案的频率。它们是基于最后一次尝试的反应。N1 是考生修改次数，这个修改是否由不正确答案改为正确答案[ NC1(g) &#x3D; 1]。</li>
<li>N2 和 NC2 量化了中途修正的情况。</li>
<li>T1、 T2和 T3统计值反映了回答问题所需的时间。</li>
</ol>
</li>
<li>基于<strong>答复和答复时间之间关系</strong>的指标。这个指标(CD)是库克的距离总测试时间的回归总得分的反应。<ol>
<li>CD 统计评估考生的数据模式是否与样本中测试成绩和总测试时间之间的一般关系一致。</li>
</ol>
</li>
<li>基于<strong>不同考生反应模式相似性</strong>的两个指标(Maynes，2017; zoploglu，2017)。第一个指标(PT)是根据相同答复的数量确定的，第二个指标(PI)是根据相同的错误答复的数量确定的; 关于早先对教育测试领域某些指标的表现进行的研究，见卡拉巴索(2003年)、 Tendeiro 和 Meijer (2014年)、 Kim 等人(2017年)、 Sinharay (2017年)和 Man 等人(2018年)。<ol>
<li>PT 和 PI 统计评估不同考生的反应模式的相似程度。对于 PT 统计信息，可以将每个响应模式与样本中最相似的响应模式匹配。这是具有最多相同数量的响应模式。PT 统计量是反应模式中相同反应的相对频率及其匹配。PI 统计量与 PT 统计量相似，只有一个例外。为了确定最相似的响应模式，只考虑不正确的响应。PI 统计量是相同的不正确答案在回答模式及其匹配中的相对频率。</li>
</ol>
</li>
</ol>
<h2 id="Towards-a-General-Purpose-Anomaly-Detection-Method-toIdentify-Cheaters-in-Massive-Open-Online-Courses"><a href="#Towards-a-General-Purpose-Anomaly-Detection-Method-toIdentify-Cheaters-in-Massive-Open-Online-Courses" class="headerlink" title="Towards a General Purpose Anomaly Detection Method toIdentify Cheaters in Massive Open Online Courses"></a>Towards a General Purpose Anomaly Detection Method toIdentify Cheaters in Massive Open Online Courses</h2><p>Alexandron G , JA Ruipérez-Valiente,  Pritchard D E . Towards a General Purpose Anomaly Detection Method to Identify Cheaters in Massive Open Online Courses.  2020.</p>
<ol>
<li>我们证明了一种基于异常检测的通用检测方法，在一种作弊类型上进行训练，<strong>可以泛化地检测使用其他方法的作弊者</strong>。</li>
<li>其次，我们提出了一个新的基于时间的个体异常行为统计。</li>
</ol>
<p>主要贡献：</p>
<ol>
<li>使用了更通用的参数：GE、GE-time、video-watch-time、Fraction of videos watched 这些。</li>
</ol>
<h2 id="一种干部在线作弊学习行为分析与预测策略"><a href="#一种干部在线作弊学习行为分析与预测策略" class="headerlink" title="一种干部在线作弊学习行为分析与预测策略"></a>一种干部在线作弊学习行为分析与预测策略</h2><p>陈乾国. 一种干部在线作弊学习行为分析与预测策略[J]. 计算机工程, 2017, 43(009):17-22,28.</p>
<p>作弊检测规则：</p>
<ol>
<li>同一时间学习多门课程，Cnum≥2，则判定该学员存在作弊学习行为。而此种情况又具体分为下面 2 种类型:<ol>
<li>同一时间学习完成，则判定学员存在作弊学习。</li>
<li>同一时间开始学习多门课程，即判定为作弊学习行为。</li>
</ol>
</li>
<li>学员学习视频课程所用时间小于课程总时长的 80% ，则判定学员存在作弊学习行为。</li>
<li>学员学习视频课程结束时间小于课程学习开始时间，这明显违反学习规则，判定为作弊学习 行为。</li>
<li>学员在1d之内所学课程时长总和大于 24 h，即判定为存在作弊学习行为。</li>
</ol>
<p>首先对数据集中学习记录的每个特征进行编码，根据编码对学习记录进行识别与检测分析。 然后，利用第 1 节中的作弊检测规则及步骤，分析 干部学员的学习特点，对每条学习记录进行检测分析，发现存在作弊行为的学习记录（lee：相当于打标签了）。这种模式对数据量相对较少的数据集处理起来方便准确，但一旦数据量过大，此种模式的检测效率将大大降低。下面将以本节的检测结果集作为基准进行数据挖掘，分析和预测学员学习行为。</p>
<p>模型：libSVM</p>
<h2 id="一种在线学习平台检测刷课作弊的技术"><a href="#一种在线学习平台检测刷课作弊的技术" class="headerlink" title="一种在线学习平台检测刷课作弊的技术"></a>一种在线学习平台检测刷课作弊的技术</h2><p>王晖, 宋学庆. 一种在线学习平台检测刷课作弊的技术:. </p>
<p>定时心跳检测：检测用户播放时长以及视频间隔播放的时间点，<strong>数据库中两次相邻插入播放记录的时间差值，若小于本地提交播放时间，说明存在刷课行为</strong>。</p>
<hr>
<p><a href="https://www.imufe.edu.cn/jwc/jwgl/201811/t20181101_95600.html">关于网络课程刷课、作弊处理通知</a></p>
<p>刷课、代考、异常操作学员账号。</p>
<hr>
<p> <a href="https://www.gksec.com/auto_NetClass.html">对某在线教育网站的刷课检测对抗之旅</a></p>
<blockquote>
<p>同学，我们已经发现您具有相应的网络知识，了解浏览器的调试模式，这挺好的，以下是要对您说的一些警告信息。警告：请不要以任何取巧方式进行作弊刷课或帮助其他人刷课，系统已对所有课时的真实性进行统计计算评估，收集数据包括不限于（浏览器头，版本，播放器记录，登录时长，cookie,referer,ip追踪,终端平台，是否符是您的账号，登录过多少个账号，历史登录记录.. 等各种操作数据及ajax随机埋点），一经发现作弊轻则取消学时，重则取消成绩。</p>
</blockquote>
<hr>
<p><a href="https://www.tlpoe.com/key/%E7%94%A8%E8%84%9A%E6%9C%AC%E5%88%B7%E8%AF%BE%E6%A3%80%E6%B5%8B%E4%B8%8D%E5%87%BA%E6%9D%A5%E5%90%97.html">为什么刷课会被检测出违规呢</a></p>
<p>一个是通过行为的判定，比如很机械化的规律操作（这个几率很低）</p>
<p>第二个是通过IP判断，一般来说刷课平台用家庭IP就很安全，但是难免同学要登录签到上直播课，可能导致ip全国飞来飞去，增加了检测的几率。所以能提供签到+直播的平台可以完美解决这个问题。</p>
<p>第三是小白喜欢用秒刷，高倍数去刷完课，但是官方并不提供相应倍数，就时长与学习记录不匹配，可以抓。</p>
<hr>
<p><a href="https://liaoguoyin.com/2018/fake-xxt">轻松刷掉学习通、双创网课的猥琐思路</a></p>
<ol>
<li>通过 JavaScript 脚本把<strong>手动点击</strong>模拟为<strong>脚本自动点击</strong>下一步等一系列操作</li>
</ol>
<p>他为啥能判断你作弊？后台大数据..？”别太高估了这群可能是外包的开发人员”</p>
<p>在学习通的服务器端检测机制：</p>
<ul>
<li>当你第一次请求播放 API 的时候，他会记录你请求的时间戳，然后每隔 60 秒检测一次心跳包。</li>
<li>如果你频繁的请求新视频，不论你是加速看的还是直接拖 Safari 进度条，但是你几秒就看完了一节他好几分钟的课的事实，已经明明白白的摆在他服务器的请求数据里面的，然后你也就明明白白的了。</li>
</ul>
<hr>
<p><a href="https://www.edusoho.com/news/34/show">EduSoho学习数据全站升级：学员多开、挂机、刷学时？这个功能帮你全部搞定</a></p>
<p>“课程学习时长”、“用户学习时长”,”累加学习时长”,”去重学习时长”.</p>
<ol>
<li>在某些网校中，学员为了冲击排行、获取奖励，很可能会使用多个浏览器或多个终端，同时打开不同的学习任务进行刷课。<ul>
<li>以视频、音频、图文等课程类型为主的网校可以选择“后踢前”策略，方便用户进行终端切换。</li>
<li>以作业、考试、直播等课程类型为主的网校则可以选择“前踢后”策略，避免造成学习中断。</li>
</ul>
</li>
<li>为了刷满学时，完成规定任务，学员还可能将课程后台挂机，或是在上课的同时切换窗口发邮件、聊天、看视频。<ul>
<li>网校还可以通过学习行为的差别，对学员的“有效学习时长”进行自由定义。比如以视频的实际播放时长作为统计维度，就可以更有效的防止学员挂机作弊哦</li>
</ul>
</li>
</ol>
<hr>
<p>《教育审计分析模型与案例》期刊</p>
<p>主要审计分析模型：</p>
<ol>
<li>学前教育发展总体评价分 析模型。多部门数据关联分析，并按城乡、区际、幼儿园 性质(公办园、民办园)分组，分析了 城乡之间、区域之间、不同性质幼儿 园之间的收费、生均收支、师资力量 等，对南京市学前教育均等化现状进 行总体评价。</li>
<li>幼儿园规划制定与落实情 况分析模型。审计不同区域幼儿园规划数 与适龄儿童数据是否匹配，判断幼儿 园规划是否能满足区域需求，审计不 同区域幼儿园规划是否按照进度落 实，将规划与需求严重不匹配、规划 落实严重滞后的区域作为延伸审计 重点。</li>
<li>幼儿园教师编制落实情况 分析模型。判断不同区域幼儿园教师编制是否 落实到位，将幼儿园教师严重缺编的 区域作为延伸审计重点。</li>
<li>不 同 性 质 幼 儿 园 家 长 、教 师满意度分析模型。并按区域、幼儿园性质进 行分组，分析不同性质、不同区域、不 同财政投入情况下，家长、教师对幼 儿园的满意度。</li>
</ol>
<hr>
<p>《基于改进时间卷积网络的日志序列异常检测_杨瑞朋》</p>
<p>检验模型：embedding 层、改进的 TCN 层、自适应平均池化层。</p>
<ol>
<li>embedding 层。日志模板序号映射成<strong>词向量</strong>。</li>
<li>改进 TCN。<ol>
<li>输入第一个一维空洞卷积层，并进行归 一化。需要指明的参数包括日志模板词嵌入的维 度、日志模板词典的大小、卷积核尺寸、步长、padding 大小及是否加入空洞。</li>
<li>根据第一个卷积层的输出与 padding 的 大小，对卷积后的张量进行切片来实现因果卷积。<ol>
<li>因果卷积：利用卷积，从后往前数长度 h 个日志记录，来预测下一个日志记录。特点是该卷积仅依赖于 1，2~h 的输入，而不会依赖 h+1 及以后的输入。</li>
</ol>
</li>
<li>添加 PReLU 激活函数。</li>
<li>dropout</li>
<li>堆叠相同结构的第 2 个卷积块，构成一个残差块。</li>
</ol>
</li>
<li>自适应平均池化层。</li>
</ol>
]]></content>
      <categories>
        <category>review</category>
      </categories>
      <tags>
        <tag>Cheating Detection</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第一章练习</title>
    <url>/2018/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h1><h4 id="1-操作系统的概念、特征、功能"><a href="#1-操作系统的概念、特征、功能" class="headerlink" title="1. 操作系统的概念、特征、功能"></a>1. 操作系统的概念、特征、功能</h4><ul>
<li>概念：<strong>控制和管理</strong>整个计算机系统的硬件和软件资源，并<strong>合理地组织调度</strong>计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的<strong>程序集合</strong>。</li>
<li>特征：<strong>并发、共享</strong>、虚拟、异步。<ul>
<li>并发。多个事件在同一个时间间隔内（时间段）发生，通过分时（引入进程）实现。</li>
<li>共享。系统中的资源可供多个并发执行的进程共同使用。分为互斥共享和同时访问两种方式。前者指进程独占资源，此时的独占资源也被称为临界资源；举例：物理设备、软件的栈、变量等。后者指宏观上多进程使用同一个资源，但微观上可能仍然是交替使用（分时共享）；举例：磁盘设备的多进程读入。</li>
<li>虚拟。一个物理上的实体变为若干个逻辑上的对应物。比如一个CPU虚拟为多个逻辑上的CPU，让每一个终端用户都感觉到有一个CPU在专门为他服务。举例：虚拟CPU、虚拟内存、虚拟I&#x2F;O外设等。</li>
<li>异步。因为进程的并发执行，所以可能导致进程产生与时间有关的错误（执行顺序等），但操作系统必须保证，只要运行环境相同，都必须获得相同的结果。</li>
</ul>
</li>
<li>功能：处理机管理、存储器管理、设备管理（主要是I&#x2F;O请求）、文件管理、为用户提供接口（命令接口和程序接口，命令接口又分为联机命令接口和脱机命令接口，比如终端命令等，程序接口则是由系统调用（请求系统服务）组成，比如键鼠的键入或点击的交互等）。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="2-库函数和系统调用的区别和联系"><a href="#2-库函数和系统调用的区别和联系" class="headerlink" title="2. 库函数和系统调用的区别和联系"></a>2. 库函数和系统调用的区别和联系</h4><ul>
<li>系统调用是操作系统的一部分，是内核提供给用户的程序接口，运行在内核空间（内核态）中。</li>
<li>库函数是语言或应用程序的一部分，可以运行在用户空间（用户态）中，许多库函数都会使用系统调用来实现功能。</li>
<li>没有使用系统调用的库函数，执行效率通常比使用系统调用的高。因为使用系统调用时，需要上下文的切换（变量、寄存器的值等进程上下文；硬件变量、参数等中断上下文）以及用户态向核心态的转换。</li>
</ul>
<h5 id="扩展-用户态转内核态的3种主要方式"><a href="#扩展-用户态转内核态的3种主要方式" class="headerlink" title="[扩展]用户态转内核态的3种主要方式"></a>[扩展]用户态转内核态的3种主要方式</h5><ul>
<li>① 系统调用（System Call）。用户态进程主动要求切换到内核态的一种方式，会触发trap指令，如Linux的int0x80。比如fork()实际上就是执行了一个创建新进程的系统调用。系统调用的核心机制是OS为用户开放的中断来实现，凡是与资源有关的操作，都要经过系统调用。</li>
<li>② 异常（也叫内中断、例外或陷入trap）。CPU在执行用户态的某程序时，发生了某异常，这时会触发当前进程切换到处理该异常的内核相关程序中，也就转到了内核态。分为故障fault、陷阱trap和终止abort三类。例如缺页异常。</li>
<li>③ I&#x2F;O设备的中断。当外设完成用户的请求的操作时，会向CPU发送中断信号，这时CPU会暂停当前的指令A，转而执行与中断信号对应的处理程序。如果指令A是用户态下的程序，那么这个转换过程就发生了由用户态到内核态的切换，例如硬盘读写操作的完成。</li>
<li>第一种System call是进程主动发起的，后两种是被动的。</li>
<li>以下内容的指令在内核态：<ul>
<li>与硬件关联较密切的模块，诸如时钟管理、中断处理、设备驱动等；</li>
<li>其次是运行频率较高的程序：进程管理、存储器管理、设备管理等。</li>
</ul>
</li>
<li><a href="https://baike.baidu.com/item/%E8%AE%BF%E7%AE%A1%E6%8C%87%E4%BB%A4/5435216?fr=aladdin">访管中断</a>：操作系统不允许系统直接执行某些“危险性高”的指令，故用户态运行这些指令的时候会转换到内核态去运行。访管指令不是特权指令（因为是用户态使用的）。流程：当用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，该程序将按照系统调用的 操作数和参数转到相应的例行子程序，完成服务功能后，退出中断，返回到用户程序断点继续执行。</li>
<li>时钟管理：计时功能；用以实现进程切换的时钟中断功能。</li>
<li>原语：被调用频繁、完成一个规定操作的、具有原子性的操作系统最底层的小程序。</li>
<li>用来登记状态信息（上下文）的数据结构主要有：作业控制块、进程控制块、设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。</li>
<li>内核态指令包括：系统调用类指令和一些针对时钟、中断和原语的操作指令。</li>
<li>特权指令，是指操作系统或其他系统软件的指令：清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。用户态下只能使用非特权指令，内核态下可以使用除访管指令外的所有指令。</li>
</ul>
<hr>
<h4 id="3-操作系统的发展"><a href="#3-操作系统的发展" class="headerlink" title="3. 操作系统的发展"></a>3. 操作系统的发展</h4><ul>
<li>操作系统出现前：手工操作阶段、批处理阶段（单道、多道）。多道批处理系统：多个程序同时进入内存并运行，当某程序因I&#x2F;O请求暂停运行时，CPU立刻转去另一个程序，没有使用机制来解决瓶颈问题。多道优点：资源利用率高，多道程序共享资源，系统吞吐量大；缺点：用户响应时间长，不提供人机交互能力。</li>
<li>操作系统出现后：分时操作系统、实时操作系统、网络操作系统和分布式操作系统、个人计算机操作系统。<ul>
<li>分时操作系统：在一台主机上连接了<strong>多个终端</strong>，允许许多用户同时通过自己的终端，以<strong>交互</strong>方式<strong>独立</strong>地使用计算机。技术上把CPU运行时间分成时间片，CPU被轮流分配到各联机作用使用，使用户的请求得到<strong>及时</strong>的响应。</li>
<li>实时操作系统：与分时操作系统底层原理相同，但要求在规定时间内完成特定功能。特点：<strong>及时可靠</strong>具有一定的紧迫性，有多种划分方式：<ul>
<li>按任务执行是否有周期性变化：周期性实时任务和非周期性实时任务。前者由外设周期性发送激励信号（即某一类电路信号&#x2F;输入信号，如时钟和复位信号）给计算机，要求它按指定周期执行；后者所发的激励信号无明显的周期性（如文件读写），但必须联系一个截止时间（用以控制运行的实现）。</li>
<li>按截止时间的要求：硬实时任务和软实时任务。字面意思不解释。</li>
</ul>
</li>
<li>网络操作系统和分布式计算机系统：网络中多台计算机结合起来，统一使用管理。特点：<strong>分布式和并行性。</strong>条件：<ul>
<li>以通信的方式实现信息交换；</li>
<li>每台计算机地位同等，没有主从关系；</li>
<li>每台计算机上的资源为所有用户共享；</li>
<li>任意若干台计算机可以组成子系统，并且能够重构；</li>
<li>任何工作都能分布到几台计算机中，由它们并行工作、协同完成（分布式计算机系统的独有特点，网络操作系统没有此特点）。</li>
</ul>
</li>
<li>个人计算机操作系统：目前应用最为广泛，常见win、Linux、Macintosh等。此外还有嵌入式、服务器、多处理器操作系统等。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第三章（1）</title>
    <url>/2018/09/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统——内存管理（1）"><a href="#操作系统——内存管理（1）" class="headerlink" title="操作系统——内存管理（1）"></a>操作系统——内存管理（1）</h1><h2 id="内存管理的功能及相关概念"><a href="#内存管理的功能及相关概念" class="headerlink" title="内存管理的功能及相关概念"></a>内存管理的功能及相关概念</h2><ul>
<li>内存管理：OS对内存的划分和动态分配。</li>
<li>功能：<ul>
<li>1.地址转换：程序的逻辑地址与内存中的物理地址不一致，需要相关转换；</li>
<li>2.内存空间的扩充：使用虚拟存储的技术或者自动覆盖技术，从逻辑上扩充内存；</li>
<li>3.内存保护：各道作业在各自的存储空间内运行，互不干扰。</li>
<li>4.（重点）内存空间的分配和回收：让程序员摆脱存储分配的麻烦，提高编程效率；<ul>
<li>连续分配管理方式</li>
<li>非连续分配管理方式</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-程序装入内存和链接"><a href="#1-程序装入内存和链接" class="headerlink" title="1. 程序装入内存和链接"></a>1. 程序装入内存和链接</h3><p>创建进程的第一步就是讲程序和数据装入内存，需要经过：编译、链接、装入三个阶段：</p>
<span id="more"></span>


<ol>
<li>编译：源代码编译成若干个目标模块（若干程序段）。</li>
<li>链接：由链接程序将上一步产生的目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开（重点是：以后不拆）；</li>
<li>装入时动态链接：目标模块装入内存的同时，进行链接；</li>
<li>运行时动态链接：在程序执行过程中需要该目标模块时，才进行链接。优点是便于修改和更新，便于实现对目标模块的共享。</li>
</ul>
</li>
<li>装入：使用装入程序，将装入模块放入内存运行。<ul>
<li>绝对装入：编译产生的目标代码是绝对地址（可在编译或汇编时给出，也可由程序员赋予）。绝对装入程序按照该地址完成程序的装入（无需对数据和程序的地址进行修改）。只适用于单道程序环境。</li>
<li>可重定位装入：在多道程序环境下，目标模块的起始地址一般都是0，所以逻辑地址都是相对于起始地址的。根据内存的当前情况，将装入模块装入内存适当的位置。装入时对目标程序中的指令和数据的修改过程称为重定位。因为地址变换是在装入时一次性完成的，所以称为静态重定位。一旦进入内存后，整个运行期间不能在内存中移动，也不能再申请新的内存空间。</li>
<li>动态运行时装入：装入程序把模块装入内存以后，并不立即将模块中的相对地址修改为绝对地址（内存中的都还是相对地址），而是把这种<strong>地址转换推迟到程序真正要执行时</strong>才进行。需要一个重定位寄存器。特点：可以将程序分配到不连续的存储区中，在程序运行之前只装入部分代码就可以投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。</li>
</ul>
</li>
</ol>
<h3 id="2-内存保护"><a href="#2-内存保护" class="headerlink" title="2. 内存保护"></a>2. 内存保护</h3><ul>
<li>保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。</li>
<li>做法是设立基址寄存器（重定位寄存器）和限长寄存器（界地址寄存器）。<ul>
<li>基址寄存器是用来“加”的，逻辑地址加上该寄存器的值，转换得到物理地址；</li>
<li>限长寄存器是用来“比”的，逻辑地址的值与该寄存器的值进行比较。</li>
</ul>
</li>
</ul>
<h3 id="3-内存扩充的方法：覆盖和交换"><a href="#3-内存扩充的方法：覆盖和交换" class="headerlink" title="3. 内存扩充的方法：覆盖和交换"></a>3. 内存扩充的方法：覆盖和交换</h3><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><ul>
<li>程序运行时并非任何时候都要访问程序的各个部分，因此可以把用户空间划分成一个固定区和若干个覆盖区。经常活跃的部分放在固定区，其余部分按照调用关系分段。</li>
<li>首先将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统将其调入覆盖区，覆盖掉原有的段。</li>
<li>特点：虽然打破了之前“必须将进程全部信息转主存才能运行”的限制，但若当前运行程序的代码量大于主存时仍然不能运行（需要使用虚拟内存的技术来解决）。而且不在覆盖区的段会常驻内存。</li>
<li>覆盖技术用在同一个程序或进程中，而且要求给出程序段之间的覆盖结构，对用户和程序员不透明，所以覆盖技术已成历史。</li>
</ul>
<h4 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h4><ul>
<li>把处于等待状态的程序从内存移到辅存，把内存空间腾出来，即换出；把准备好竞争CPU的程序从辅存移到内存，即换入。比如，将作业挂起的内存调度方法。</li>
<li>交换时注意点：<ul>
<li>交换需要备份存储；</li>
<li>要求进程执行时间比交换时间长，其中交换时间与所交换的内存空间大小成正比；</li>
<li>如果换出进程，要求该进程必须处于空闲状态；</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，使用可能就很快；</li>
<li>交换通常发生在多进程运行且内存吃紧的时候，系统负荷较低时就暂停交换；</li>
<li>当前交换技术使用不多，但其延伸技术依然应用在Unix等系统中。</li>
</ul>
</li>
</ul>
<h3 id="4-1-连续分配管理方式"><a href="#4-1-连续分配管理方式" class="headerlink" title="4.1 连续分配管理方式"></a>4.1 连续分配管理方式</h3><ul>
<li>分为单一连续分配、固定分区分配、动态分区分配三种。</li>
<li>共同特点：进程在主存中都是连续存放的。</li>
</ul>
<h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><ul>
<li>分为系统区和用户区，内存中永远只有一道程序</li>
<li>应用在单道程序，优点：简单、无外部碎片，可采用覆盖技术。缺点：只能用在单用户、单任务的操作系统，有内部碎片，存储器的利用率极低。</li>
</ul>
<h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><ul>
<li>最简单的一种多道程序存储管理方式，将用户内存空间划分为若干个固定大小（可彼此相等或不等）的区域，一个分区只装入一道作业。当有分区是空闲状态时，可以选择合适大小的作业装入分区，如此循环。</li>
<li>为了便于管理，建立一张分区说明表，表项包括各个分区的起始地址、大小和是否已分配。</li>
<li>缺点：程序可能太大而放不进任何一个分区中，用户不得不采用覆盖技术；会产生内部碎片。</li>
</ul>
<h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><ul>
<li>是一种动态划分内存的分区方式，进程在装入内存时，根据进程的大小动态地建立分区，使得分区的大小正好适合进程的需要（没有内部碎片）。</li>
<li>缺点：开始分配时状况较好，但随着时间推移，内存中会出现很多很小的内存碎块（即外部碎片），必须要通过紧凑技术来解决，这种操作需要动态重定向技术来解决，而且相对费时。</li>
<li>如果内存有着多个足够大的内存块，某个进程需要装入内存时，可以选择四种不同的策略进行分配：<ul>
<li>首次适应：按地址顺序查找，首次找到合适大小的，就给予分配。虽然够简单、够快、够好，但每次要从低地址部分开始寻找，增加了查找的开销。</li>
<li>最佳适应：按容量递增形成分区链，找到第一个能满足要求的内存块。虽然“看上去很美”，但性能不好，容易造成更多的外部碎片。</li>
<li>最坏适应：按容量递减形成分区链，找到第一个能满足要求的内存块。虽然不容易产生外部碎片，但会导致内存中缺少可用的大的内存块，使性能变差。</li>
<li>邻近适应：循环首次适应算法，从上次查找结束的位置开始查找，会在内存的末尾分配空间，分裂成小碎片，比首次适应算法结果差。</li>
</ul>
</li>
</ul>
<h3 id="4-2-非连续分配管理方式"><a href="#4-2-非连续分配管理方式" class="headerlink" title="4.2 非连续分配管理方式"></a>4.2 非连续分配管理方式</h3><ul>
<li>允许一个程序分散地装入到不相邻的内存分区中。这种方式针对的问题是：内存中有超过需要大小的内存空间，但该空间并不连续，如果采用连续分配的管理方式，仍然无法运行。</li>
<li>按照分区的大小是否固定可以分为分页存储管理方式和分段存储管理方式</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">分页</th>
<th align="center">分段</th>
</tr>
</thead>
<tbody><tr>
<td align="center">目的</td>
<td align="center">页是信息的物理单位，分页是为实现离散分配方式，以减少内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要</td>
<td align="center">是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了能更好的满足用户的需要</td>
</tr>
<tr>
<td align="center">长度</td>
<td align="center">页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，由机器硬件实现，因而在系统中只能有一种大小的页面</td>
<td align="center">段的长度不固定，决定于用户编写的程序，通常由编译程序在对程序进行编译时，根据信息的性质来划分</td>
</tr>
<tr>
<td align="center">地址空间</td>
<td align="center">作业地址空间是一维的，即单一的线性地址空间，程序员只需要利用一个记忆符，即可表示一个地址</td>
<td align="center">作业地址空间是二维的，程序员在标识一个地址时，既给出段名，又需给出段内地址</td>
</tr>
<tr>
<td align="center">碎片</td>
<td align="center">有内部碎片，无外部碎片</td>
<td align="center">有外部碎片，无内部碎片</td>
</tr>
<tr>
<td align="center">共享和动态链表</td>
<td align="center">不容易实现</td>
<td align="center">容易实现</td>
</tr>
</tbody></table>
<p>运行时是否要把作业的<strong>所有页面都装入内存</strong>才能运行分为两种：基本分页和请求分页（请求分页见下一节：<a href="http://likehui.fun/2018/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/#more">操作系统第三章（2）</a>）</p>
<h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h4><ul>
<li><p>分页：把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位（叫：页Page）。同时，每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间（叫，页框Page Frame）。同时，外存中直接叫：块Block。</p>
</li>
<li><p>逻辑地址结构：页号P（12到31位，故总共允许2^20页）和页内偏移量W（0到11位，故每页大小2^12即4KB）。可以定位到某页某处，直接找到字节。</p>
</li>
<li><p>页表：由页表项组成，页表项包含页号P和块号b（块号即物理内存中的块的编号，根据块号b和页内偏移量W可以找到内存中的物理地址）。每个进程对应一张页表，页表存在内存中。 页表的作用：实现从页号到物理块号的地址映射。</p>
</li>
<li><p>基本地址变换机构。任务：将逻辑地址（通常十进制表示）转换为内存中的物理地址。需要：一个页表寄存器（PTR），存放页表在内存的始址F（理解：连续页在内存中最开始的地址）和页表长度M（理解：总页数）。</p>
</li>
<li><p>流程：</p>
<ol>
<li>进程未执行时，始址F和页表长度M放在进程的PCB中；当进程执行时，这两个数据写入PTR中。</li>
<li>明确需求：计算一个逻辑地址A对应的物理地址E（待求）。</li>
<li>计算页号P和页内偏移量W（P&#x3D;A&#x2F;L;W&#x3D;A%L，L是页面大小，A和L都是B为单位）。</li>
<li>比较页号P和页表长度的大小M。如果P&gt;&#x3D;M，说明页数超了，发生越界中断；没超继续下一步。</li>
<li>计算页号P对应的页表项地址（P页第一个字节的物理地址），页表项地址&#x3D;页表起始地址F+页号P×页表项长度（页表项长度即每页多少B）。从该页表项的地址可以得到块号b。</li>
<li>计算物理地址E&#x3D;b×L+W。</li>
</ol>
</li>
<li><p>以上流程中取一次数据至少要访问两次内存，第一次得到物理地址，第二次根据该地址访问数据。使用块表（某高速缓冲存储器，TLB）进行辅助。流程：CPU给出逻辑地址后，由硬件进行地址转换并将页号与TLB比较，如果找到了，直接一次性存取内存数据；如果没有找到，那就读内存，顺便将该数据存入TLB，方便下一次快查。</p>
</li>
<li><p>两级页表:构建页表的索引页表。顶级页表最多只能有1个页面。</p>
<ul>
<li>解决了：当逻辑地址空间过大时，页表的长度会大大增加的问题。</li>
</ul>
</li>
</ul>
<h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h4><ul>
<li>分段：按照用户进程中的自然段划分逻辑空间。比如可以分为主程序、两个子程序、栈和一段数据统共五段组成，每段从0开始编址，并且段内是连续的地址空间。</li>
<li>逻辑地址是由段号S（16到31位）和段内偏移量W（0到15位）两部分组成（一个作业最多2^16段，每段最长64KB）。</li>
<li>段表：逻辑空间与内存空间映射的作用。段表项为：段号+段长+本段在主存的起始地址。</li>
<li>流程：<ul>
<li>进程中取出段表始址F和段表长度M，放入段表寄存器中。</li>
<li>根据逻辑地址A（通常二进制表示）中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较S和M，如果S&gt;&#x3D;M，产生越界中断，没有则下一步。</li>
<li>计算S的段表项地址&#x3D;始址F+S×段表项长度。取出段表项，段表项的前几位得到段长C，段内偏移量W如果大于C，产生越界中断，否则继续执行。</li>
<li>取出段表项该段的起始地址b，计算物理地址E&#x3D;b+W。</li>
</ul>
</li>
<li>段的共享是通过两个作业的段表中相应表项只想被共享的段的同一个物理副本来实现的。可修改的代码和数据不能被共享，不能修改的代码可以被共享（即纯代码或可重入代码）。</li>
<li>对比分页。页有固定大小，所以可以通过整除得到段号和段内偏移；但分段方式需要显式地给出段号和段内偏移。</li>
</ul>
<h4 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h4><ul>
<li>段页式：作业的地址空间被分成若干个逻辑段，每段都有自己的段号，然后将每一段分成若干个大小固定的页。</li>
<li>段页式逻辑地址：段号S+页号P+页内偏移量W。</li>
<li>流程：先通过段表查到页表起始地址，然后通过页表查到页帧号，最后形成物理地址。</li>
<li>特点：实际需要三次访问主存，可以使用快表加快查找速度。</li>
</ul>
<h4 id="碎片问题"><a href="#碎片问题" class="headerlink" title="碎片问题"></a>碎片问题</h4><p>只要是固定的分配就会产生内部碎片，其余的都会产生外部碎片。<br>段页式也要看作固定式的。</p>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第三章（2）</title>
    <url>/2018/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统——内存管理（2）"><a href="#操作系统——内存管理（2）" class="headerlink" title="操作系统——内存管理（2）"></a>操作系统——内存管理（2）</h1><h2 id="虚拟内存技术"><a href="#虚拟内存技术" class="headerlink" title="虚拟内存技术"></a>虚拟内存技术</h2><ul>
<li>背景：不采用虚拟内存技术的内存管理策略的缺点：<ul>
<li>一次性。必须将作业一次性装入内存中，可能会不能全部装入从而作业无法运行；或者大量作业要求运行时，内存不能容纳导致仅少量作业在运行；</li>
<li>驻留性。作业进入内存后会驻留在内存中，任何部分都不会被调出，直到作业结束。</li>
</ul>
</li>
<li>局部性原理。原理不解释。采用此原理的技术有快表、页高速缓存、虚拟内存技术以及“goto语句有害”说法等。<ul>
<li>时间局部性：刚执行的指令，不久之后很有可能再次执行。</li>
<li>空间局部性：一旦访问了某个存储单元，不久之后附近的存储单元很有可能被访问。</li>
</ul>
</li>
</ul>
<span id="more"></span>	
<ul>
<li>虚拟存储器：OS提供的，在用户看来是一个很大的存储器（比实际内存大得多的，事实上并不存在）。虚拟存储器的特征：多次性（并非一次性，多次调入内存中运行）、对换性（无需常驻，运行时可换入换出）、虚拟性（逻辑上的超大内存）。流程：<ul>
<li>基于局部性原理，程序装入时，可以将程序一部分装入内存开始执行，而将其余部分留在外存。</li>
<li>在执行过程中如果所访问的信息不在内存中时，由OS将所需要的部分调入内存，然后继续执行程序。</li>
<li>另一方面，OS将内存中暂时不适用的内容换到外存上，从而腾出空间。</li>
</ul>
</li>
<li>虚拟存储器必须建立在离散分配（即非连续）的内存管理方式的基础上。可以采用：请求分页式、请求分段式、请求段页式。硬件前提：一定容量的外存和内存、页表&#x2F;段表机制、中断机构、地址变换机构。</li>
</ul>
<h3 id="请求分页"><a href="#请求分页" class="headerlink" title="请求分页"></a>请求分页</h3><ul>
<li>在基本分页技术的基础上，增加了<strong>虚拟存储器</strong>功能。只需要将一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时通过置换功能将暂时不同的页面换出。</li>
<li>页表项：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">页号</th>
<th align="center">物理块号</th>
<th align="center">状态位P</th>
<th align="center">访问字段A</th>
<th align="center">修改位M</th>
<th align="center">外存地址</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">标记是否已经调入内存</td>
<td align="center">记录本页在某一个时间段内被访问的次数</td>
<td align="center">标记调入后是否被修改</td>
<td align="center">在外存上的地址&#x2F;物理块号</td>
</tr>
</tbody></table>
<ul>
<li>缺页中断机制<ul>
<li>使用请求分页技术，每次访问页面不在内存中，就会产生一个缺页中断。把缺页的进程阻塞，等待分配内存块或者置换某淘汰页。</li>
<li>与一般的中断的区别：在指令执行期间产生和处理中断信号，属于内部中断，而非一条指令执行完后产生；</li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
</li>
</ul>
<p><img src="/2018/09/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/1.jpg" alt="请求分页的地址变换"></p>
<h3 id="页面置换算法（挑选哪些不常用的页并换掉它）"><a href="#页面置换算法（挑选哪些不常用的页并换掉它）" class="headerlink" title="页面置换算法（挑选哪些不常用的页并换掉它）"></a>页面置换算法（挑选哪些不常用的页并换掉它）</h3><ul>
<li>最佳置换算法（OPT）<ul>
<li>机制：未来不使用或很少使用的页，换掉它；</li>
<li>评价：无法预知所以无法实现。</li>
</ul>
</li>
<li>先进先出（FIFO）页面置换算法<ul>
<li>机制：淘汰进来最久的页；</li>
<li>评价：跟进程规律不相符，进程常常访问有些页面；而且会出现Belady异常（增加分配的物理块数，但页故障数不减反增；页故障数可以当作置换次数来理解）。</li>
</ul>
</li>
<li>最近最久未使用（LRU）置换算法<ul>
<li>机制：从历史数据上，发现那些很长一段时间未被访问的页，换掉它；</li>
<li>性能较好，需要寄存器和栈的支持。</li>
</ul>
</li>
<li>时钟（CLOCK）置换算法<ul>
<li>机制：<ul>
<li>页第一次装入，使用位设1；随后被访问，使用位也设1。</li>
<li>有一个候选循环队列（挑中了会被淘汰），指针开始扫描，发现使用位为1的，跳过它的同时将其使用位设0；发现使用位是0的，选中它，置换，指针指向下一个。</li>
</ul>
</li>
</ul>
</li>
<li>时钟改良算法<ul>
<li>机制跟上面的clock算法一样，都是尽可能保留曾经使用过的页面，淘汰未使用的页面。但改良算法增加一个修改位。如果全部页面都使用过，优先淘汰那些未修改过的页面。</li>
<li>机制：<ul>
<li>每一个页都有两个位参选（使用位u：0&#x2F;1；修改位m：0&#x2F;1）；</li>
<li>① 有一个候选循环队列（挑中了会被淘汰），指针开始第一次扫描，查找u&#x3D;0且m&#x3D;0的，选中它，置换，指针指向下一个。如果一圈后没有找到，进入下一步；</li>
<li>② 进行第二次扫描，查找u&#x3D;0且m&#x3D;1的，如果不是，则跳过它的同时，将其u置为0，指针指向下一个。如果找到了，选中它，置换，指针指向下一个；</li>
<li>如果②没有找到，此时所有页的u应该都是0了，那么重复步骤 ①，如果有必要再重复步骤 ②，如此可以找到合适的页。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><h4 id="驻留集大小"><a href="#驻留集大小" class="headerlink" title="驻留集大小"></a>驻留集大小</h4><ul>
<li>驻留集即给某一进程分配的主存空间。多了影响进程数 ，少了增加页错误率 。</li>
<li>三种策略:<ul>
<li>固定分配局部置换：每个进程分配一定数量物理块，运行期间不改变。</li>
<li>可变分配全局置换:每个进程分配一定数量物理块，OS也预留一部分。运行时如果需要，OS再为进程动态增加一些物理块。弊端：可能会盲目增加（类似央妈无脑放水救市）</li>
<li>可变分配局部置换：每个进程分配一定数量物理块，缺页时只能换一页。如果换页频繁，OS再分配物理块；如果换页次数少，可适当减少进程的物理块。</li>
</ul>
</li>
</ul>
<h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a>调入页面的时机</h4><ul>
<li>预调页策略：一次调入若干个相邻的页，成功率约50%</li>
<li>请求调页策略：缺多少调多少</li>
</ul>
<h4 id="何处调入页面"><a href="#何处调入页面" class="headerlink" title="何处调入页面"></a>何处调入页面</h4><ul>
<li>页面来源有两种：文件区（存放文件）和对换区（存放对换页面）<ul>
<li>对换区采用连续分配的方式，I&#x2F;O速度快；文件区是离散分配的方式，I&#x2F;O慢。</li>
<li>如果对换区空间够大，可以把进程相关文件放入对换区（进程执行前），在需要对换时，内存直接和对换区交互；</li>
<li>如果对换区空间不够大，读文件还是从文件区里置换。写文件比较慢，通过对换区中转。<ul>
<li>[扩展]对换区可以理解为文件系统的缓存。就是一个页在内存中的，那么肯定有一份拷贝在外存里，而内存中的页被改写了之后，出现了内存外存不一致的情况.</li>
<li>本来的方法是里面把改写后的内存拷贝写到外存去，但是这样浪费了时间，所以这儿的方法是先不写回去，而是写到内存的另一个区域（这儿把它叫做对换区），等到下次还需要这个页的时候就再调回来，等到这个页要被淘汰的时候才写回到外存，这样就节省下来了一些写外存的时间。</li>
</ul>
</li>
<li>Unix方式：进程相关文件放在文件区，曾经运行过的放在对换区。</li>
</ul>
</li>
</ul>
<h4 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h4><ul>
<li>频繁发生缺页中断导致页面被频繁换入换出。</li>
<li>根源；某个进程频繁访问的页面数量高于可用的物理页帧数量。因此需要合理地使用虚拟内存技术。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第二章（2）</title>
    <url>/2018/09/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统——进程管理（2）"><a href="#操作系统——进程管理（2）" class="headerlink" title="操作系统——进程管理（2）"></a>操作系统——进程管理（2）</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><ul>
<li>概念：“轻量级进程”，是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</li>
<li>线程也有就绪、阻塞和运行三种基本状态。</li>
</ul>
<h3 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h3><p>推荐阅读：<a href="https://blog.csdn.net/shenwanjiang111/article/details/79898774">多线程</a></p>
<ul>
<li>调度。线程是独立调度的基本单位。</li>
<li>拥有资源。线程不拥有系统资源（或少量必不可少的资源，如自己的内核栈）。</li>
<li>并发性。多个线程之间可以并发执行。</li>
<li>系统开销。线程切换时，只需保存少量寄存器内容，开销很小。同一进程中的多个线程共享进程的地址空间，因此线程之间的同步和通信非常容易实现。</li>
<li>地址空间和其他资源。同一进程的多个线程共享进程资源（地址空间、页表等），进程的线程对其他进程透明。</li>
<li>通信方面。线程间可以直接读写进程数据段（如全局变量）来进行通信，不一定需要系统调用函数。</li>
</ul>
<span id="more"></span>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>每个线程有唯一的标识符和线程控制块；</li>
<li>不同的线程可以执行相同的程序（比如浏览器可以打开相同的网站，相同于开启多个线程）；</li>
<li>同一个进程中的各个线程共享该进程所拥有的资源；</li>
<li>线程是CPU的独立调度单位，在单CPU的计算机系统中，各线程可交替的占用CPU；在多CPU的计算机系统中，允许不同线程占用不同的CPU，若各个CPU同时为一个进程内的各线程服务则可以缩短进程的处理时间；</li>
<li>一个线程被创建后便开始了它的生命周期，直至终止，线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li>
</ul>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p>分为两类，用户级线程和内核态线程：</p>
<ul>
<li>用户级线程：线程管理工作由<strong>应用程序</strong>完成，内核完全意识不到线程的存在（线程切换由application完成，少了管&#x2F;目态切换的消耗，但不能很好地利用多核CPU）。应用程序可以通过使用线程库设计成多线程程序。</li>
<li>内核态线程：线程管理（如线程切换，切换线程前从目态切到管态，线程切换后从管态切到目态）由<strong>内核</strong>完成，内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。</li>
<li>组合形式：应用程序负责线程的创建，线程的调度和同步也在应用程序中进行。这些用户级线程被映射到一些内核级线程上（数量少于用户级线程数）。</li>
</ul>
<h2 id="CPU调度"><a href="#CPU调度" class="headerlink" title="CPU调度"></a>CPU调度</h2><ul>
<li>调度：存在进程争用CPU的情况，CPU调度就是对CPU进行分配，从就绪队列中，按照一定的算法（公平、高效）选择一个进程并将CPU分配给它运行，以实现进程并发的执行。</li>
</ul>
<h3 id="调度的层次"><a href="#调度的层次" class="headerlink" title="调度的层次"></a>调度的层次</h3><p>一个作业从提交直到完成，往往要经历三级调度，高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）</p>
<ul>
<li>高级调度。按一定的原则，从外存上处于后备状态的作业中挑选一个或多个作业，给它们分配内存、I&#x2F;O设备等必要的资源，并建立相应的进程，以使它们<strong>获得竞争CPU</strong>的权利。对于每个作业只调入一次、调出一次。高级调度在三种调度中频率最低。</li>
<li>中级调度。为了提高<strong>内存利用率和系统吞吐量</strong>。使哪些暂时不能运行的进程，调至外存等待（即挂起）。当它们具备运行条件而且内存又稍有空闲时，由中级调度决定，将挂起的进程重新调入内存，挂在就绪队列等待运行。</li>
<li>低级调度。按照某种方法和策略从就绪队列中选取一个进程，并将CPU分配给它。进程调度的频率很高，一般几十毫秒一次。此调度室最基本的，不可或缺。</li>
<li>三级调度的关系：作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</li>
</ul>
<h3 id="调度的时机、切换和过程"><a href="#调度的时机、切换和过程" class="headerlink" title="调度的时机、切换和过程"></a>调度的时机、切换和过程</h3><h4 id="OS中，不能进行进程调度的情况"><a href="#OS中，不能进行进程调度的情况" class="headerlink" title="OS中，不能进行进程调度的情况"></a>OS中，不能进行进程调度的情况</h4><ol>
<li><strong>处理中断</strong>的过程不能进行进程的调度。中断处理过程复杂，实现上很难做到进程切换；而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺CPU资源；</li>
<li>当进程在os内核程序临界区中，理论上必须加锁，在解锁前不应切换到其他进程运行；</li>
<li>其他一些完全屏蔽中断的原子操作过程。比如加锁、解锁、中断现场保护、恢复等。</li>
</ol>
<p>出现以上情况时，不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束之后才进行相应的调度与切换。</p>
<h4 id="剥夺调度和非剥夺调度"><a href="#剥夺调度和非剥夺调度" class="headerlink" title="剥夺调度和非剥夺调度"></a>剥夺调度和非剥夺调度</h4><ul>
<li>剥夺调度：当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。原则主要有：优先权、短进程优先和时间片原则等。</li>
<li>非剥夺调度：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生 进程调度某事件而阻塞时，才把处理机分配给另一个进程。实现简单、系统开销小，适用于大多数的批处理系统，但不能用于分时系统和大多数的实时系统。</li>
</ul>
<h4 id="进程调度时的上下文处理"><a href="#进程调度时的上下文处理" class="headerlink" title="进程调度时的上下文处理"></a>进程调度时的上下文处理</h4><ul>
<li>进程切换往往在调度完成后立刻发生，它要求保存原进程当前切换点的现场信息，恢复被调度进程的现场信息。</li>
<li>现场切换时，操作系统内核将原进程的现场信息推入到当前进程的内核堆栈来保存它们，并更新堆栈指针。</li>
<li>内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作后，开始运行新的进程。</li>
</ul>
<h3 id="调度基本原则（也是评价一个调度算法的指标）"><a href="#调度基本原则（也是评价一个调度算法的指标）" class="headerlink" title="调度基本原则（也是评价一个调度算法的指标）"></a>调度基本原则（也是评价一个调度算法的指标）</h3><p>基本原则主要有：CPU利用率（尽可能使CPU处于繁忙状态）、系统吞吐量（单位时间内CPU完成作业的数量，如果作业都是短作业，吞吐量就比较高）、周转时间（从作业提交到作业完成所经历的时间）、<strong>等待时间</strong>（进程处于等待CPU状态时间之和）、响应时间（用户提交请求到系统首次产生响应所用的时间）</p>
<p>重点关注：</p>
<ul>
<li>周转时间。<ul>
<li>周转时间&#x3D;作业完成时间-作业提交时间。</li>
<li>平均周转时间是指多个作业周转时间的平均值。</li>
<li>带权周转时间是指作业周转时间与作业实际运行时间的比值。</li>
<li>平均带权周转时间&#x3D;（sigma作业i的带权周转时间）&#x2F;n。</li>
</ul>
</li>
<li>等待时间。<ul>
<li>CPU调度算法实际上不影响作业执行或输入&#x2F;输出操作的时间，只影响作业在就绪队列中等待所花的时间；</li>
<li>衡量一个算法的优劣，常常只需要简单的考察等待时间即可。</li>
</ul>
</li>
</ul>
<h3 id="典型调度算法"><a href="#典型调度算法" class="headerlink" title="典型调度算法"></a>典型调度算法</h3><ul>
<li>有的调度算法适合于作业调度，有的适合于进程调度，有的算法两者都适用。</li>
<li>常用的调度算法有：先来先服务FCFS，短作业优先SJF、优先级调度算法、高响应比优先调度算法、时间片轮转调度算法、多级反馈队列调度算法</li>
</ul>
<h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><ul>
<li>既可用于作业调度，又可用于进程调度；</li>
<li>应用在作业调度时，每次从后备作业队列中选择最先进入队列的作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列；</li>
<li>应用在进程调度时，每次从就绪队列中选择最先进入队列的进程，将CPU分配给它，直到完成或因某些原因而阻塞时才释放CPU；</li>
<li>FCFS属于不可剥夺算法。</li>
<li>特点：算法简单、效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，不利于I&#x2F;O繁忙型作业。</li>
</ul>
<h4 id="短作业优先SJF"><a href="#短作业优先SJF" class="headerlink" title="短作业优先SJF"></a>短作业优先SJF</h4><ul>
<li>既可用于作业调度，又可用于进程调度；</li>
<li>应用在作业调度时，从后备队列中选择一个或多个<strong>估计运行时间</strong>最短的作业，调入内存中；</li>
<li>应用在进程调度时，从就绪队列中选择一个<strong>估计运行时间</strong>最短的进程；</li>
<li>缺点：对长作业不利，可能导致长作业长期不被调度出现饥饿现象；未考虑作业的紧迫程度，不能保证紧迫性作业会被及时处理；作业的长短由用户提供的估计执行时间而定，用户可能刻意缩短该估计时间；</li>
<li>特点：SJF调度算法的平均等待时间、平均周转时间最少。</li>
</ul>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><ul>
<li>既可用于作业调度，又可用于进程调度；</li>
<li>应用在作业调度时，从后备队列中挑选优先级最高的一个或多个作业调入内存；</li>
<li>应用在进程调度时，从就绪队列中选择优先级最高的进程；</li>
<li>新的最高优先级进程能够抢占当前执行的进程，要分两种情况：<ul>
<li>非剥夺式。当前执行的进程让它出于自身原因主动让出CPU（任务完成或等待事件）给更高优先级的进程；</li>
<li>剥夺式。立即暂停当前执行的进程，将CPU移交给更高优先级的进程。</li>
</ul>
</li>
<li>进程创建后其优先级能够改变，要分两种情况：<ul>
<li>静态优先级。优先级在进程创建之初确认，之后保持不变。确定静态优先级的依据主要有：进程类型、进程对资源的要求、用户要求。</li>
<li>动态优先级。进程运行过程中，根据进程情况的变化动态调整优先级。确定动态优先级的依据主要有：进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</li>
</ul>
</li>
</ul>
<h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><ul>
<li>主要用于作业调度</li>
<li>同时考虑每个作业的等待时间和估计的运行时间。每次作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</li>
<li>响应比Rp&#x3D;等待时间&#x2F; 要求服务时间 + 1 。要求服务时间即估计运行时间。有利于短作业，同时也有利于先来先服务。</li>
<li>优点：克服了饥饿状态，兼顾了长作业。</li>
</ul>
<h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><ul>
<li>用在进程调度，不用在作业调度（理解：作业的调入调出不可能随时间片频繁变动）</li>
<li>主要用在分时系统，总是选择就绪队列中第一个进程执行，等待一个时间片后，即使进程未完成运行，也必须释放出（或被剥夺）CPU给下一个进程，被剥夺的进程进入就绪队列的末尾重新排队。</li>
<li>时间片的大小需要选择合适，太大会使本算法退化成先来先服务算法；太小会使进程切换过于频繁，造成CPU开销太大。选取的标准视以下因素：系统的响应时间、就绪队列中的进程数量和系统的处理能力而定。</li>
<li>此算法利于多用户干预，人机交互得到提升。</li>
</ul>
<h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ul>
<li>用在进程调度，不用在作业调度（理由与时间片算法相同）</li>
<li>通过动态调整进程优先级和时间片大小，综合了时间片轮转调度算法和优先级调度算法</li>
<li>对短进程和I&#x2F;O型进程照顾，不必事先估计进程的执行时间；</li>
<li>实现思想：<ul>
<li>设置多个不同优先级的队列，比如第1队列优先级最高；</li>
<li>赋予各个队列的时间片大小也不相同，优先级越高的队列的时间片越小；</li>
<li>当新进程进入内存后，先放入第1队列的末尾，按照FCFS原则排队。等轮到该进程执行时，如果任务能够完成，便可撤离系统；如果任务完不成，调度程序会将该进程转入第2队列的末尾，再同样按照FCFS原则等待执行，以此类推；</li>
<li>仅当第1队列为空时，调度程序才会调度第2队列中的进程运行，以此类推。例如，如果CPU正在运行第3队列时，有新的进程加入第1进程末尾，此时新进程将抢占CPU；</li>
</ul>
</li>
<li>优点：终端型作业用户：短作业优先；短批处理作业用户：周转时间较短；长批处理作业用户：经过前几个队列得到部分执行，不会长期得不到处理。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第二章（3）</title>
    <url>/2018/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统——进程管理（3）"><a href="#操作系统——进程管理（3）" class="headerlink" title="操作系统——进程管理（3）"></a>操作系统——进程管理（3）</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><ul>
<li>（大概理解）虽然多进程是并发执行的，但仍然要满足一定的时空规则，即同步规则。</li>
<li>同步：直接制约关系。指为完成某种任务建立的多个进程之间，必须有一个次序、先后的制约关系。</li>
<li>临界资源：一次仅允许一个进程使用的资源。对临界资源的访问必须是互斥地进行，而访问临界资源的代码称为临界区</li>
<li>互斥：间接制约关系。[理解]因为临界资源的限制，所以制约后来者无法立即获得资源，即为互斥。同时要满足四个准则：<ul>
<li>空闲让进</li>
<li>忙则等待</li>
<li>有限等待，保证有限时间内进入临界区</li>
<li>让权等待，当无法进入临界区，进程应立即释放CPU</li>
</ul>
</li>
</ul>
<h3 id="互斥实现办法"><a href="#互斥实现办法" class="headerlink" title="互斥实现办法"></a>互斥实现办法</h3><p>通常有软件实现和硬件实现两种</p>
<span id="more"></span>

<h4 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h4><ol>
<li>单标志法<ul>
<li>设置公用变量turn，设turn&#x3D;1，允许P1进入，设turn&#x3D;2，允许P2进入</li>
<li>缺点：两个进程必须交替进入。P1退出后，如果P2不打算进，那么将不允许P1进入。</li>
</ul>
</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>P1</span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>)；<span class="regexp">//</span>等待</span><br><span class="line"><span class="regexp">//</span>Todo 进临界区</span><br><span class="line">turn =<span class="number">2</span>;<span class="regexp">//</span>允许P2进入</span><br><span class="line"><span class="regexp">//</span>Todo 退临界区</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>P2</span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">2</span>)；<span class="regexp">//</span>等待</span><br><span class="line"><span class="regexp">//</span>Todo 进临界区</span><br><span class="line">turn =<span class="number">1</span>;<span class="regexp">//</span>允许P1进入</span><br><span class="line"><span class="regexp">//</span>Todo 退临界区</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>双标志法先检查<ul>
<li>每一个进程访问临界资源前，先查看临界资源是否正在被访问，查看后进入临界区，改变自身标志</li>
<li>设置数据flag[i]，若第i个元素为flase，说明Pi未进入临界区</li>
<li>缺点：会出现多进程进入同一个临界区。根源：检查和修改并非原子操作</li>
</ul>
</li>
<li>双标志法后检查<ul>
<li>先置自己的标志，再检验对方状态，若对方不在则自己进入临界区</li>
<li>数据依旧是flag[i]，同先检查</li>
<li>缺点：会出现双方谦让，标志位都置true，但都没进入临界区的情况。问题根源同先检查法</li>
</ul>
</li>
<li>Peterson‘s Algorithm（皮特森算法）<ul>
<li>先设置进入标志，再设置turn，同时检查另一个进程的标志，是单标志和后检查法的混用；</li>
<li>flag解决临界资源的互斥，turn解决饥饿（以下代码中，两个while句子同一时刻最多成立一条，所以解决了饥饿问题）</li>
</ul>
</li>
</ol>
<figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pi</span></span><br><span class="line"><span class="built_in">flag</span>[i]=<span class="literal">true</span>;turn=j;<span class="comment">//flag[i]=true表示i想进临界区</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">flag</span>[j]&amp;&amp;turn==j);<span class="comment">//表示j已在临界区</span></span><br><span class="line"><span class="comment">//Todo 进临界区</span></span><br><span class="line"><span class="built_in">flag</span>[i]=<span class="literal">false</span>;</span><br><span class="line">/Todo 退临界区</span><br><span class="line"></span><br><span class="line"><span class="comment">//Pj</span></span><br><span class="line"><span class="built_in">flag</span>[j]=<span class="literal">true</span>;turn=i;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">flag</span>[i]&amp;&amp;turn==i);</span><br><span class="line"><span class="comment">//Todo 进临界区</span></span><br><span class="line"><span class="built_in">flag</span>[j]=<span class="literal">false</span>;</span><br><span class="line">/Todo 退临界区</span><br></pre></td></tr></table></figure>

<h4 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h4><p>主要有中断屏蔽方法和硬件指令方法</p>
<ol>
<li>中断屏蔽。当一个进程正在CPU执行临界区代码时，禁止一切中断发生（即关中断）。步骤为①关中断；②临界区；③开中断。缺点：CPU能力被限制，效率降低明显，而且关中断的权力交给用户就很不明智。</li>
<li>硬件指令。TestAndSet指令和Swap指令。<ul>
<li>TestAndSet指令是原子指令，执行代码时不允许被中断。</li>
<li>Swap指令，交换两个字&#x2F;字节的内容</li>
<li>以下代码中，lock所指内存代表共享布尔变量，*lock&#x3D;true表示被占用</li>
</ul>
</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">==TestAndSet==</span><br><span class="line">//读出标志（即<span class="keyword">return</span> 标志）后，置标志为真</span><br><span class="line"><span class="type">boolean</span> TestAndSet(<span class="type">boolean</span> *<span class="keyword">lock</span>)&#123;</span><br><span class="line">	<span class="type">boolean</span> <span class="built_in">old</span>;</span><br><span class="line">	<span class="built_in">old</span>=*<span class="keyword">lock</span>;</span><br><span class="line">	*<span class="keyword">lock</span>=<span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">old</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> TestAndSet(&amp;<span class="keyword">lock</span>);//<span class="keyword">lock</span>若<span class="keyword">true</span>，沉浸<span class="keyword">while</span>里；<span class="keyword">lock</span>若<span class="keyword">false</span>，①跳出<span class="keyword">while</span>循环，②<span class="keyword">lock</span>置ture。</span><br><span class="line">//Todo 临界区代码</span><br><span class="line"><span class="keyword">lock</span>=<span class="keyword">false</span>;</span><br><span class="line">//Todo 普通代码</span><br><span class="line"></span><br><span class="line">////硬件保证①②原子同时</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==Swap==</span><br><span class="line">Swap(<span class="type">boolean</span> *a,<span class="type">boolean</span>*b)&#123;</span><br><span class="line">//简单交换而已，别瞎想</span><br><span class="line">	<span class="type">boolean</span> <span class="keyword">temp</span>;</span><br><span class="line">	<span class="keyword">temp</span>=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=<span class="keyword">temp</span>;</span><br><span class="line">&#125;</span><br><span class="line">key=<span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">while</span>(key!=<span class="keyword">false</span>)</span><br><span class="line">	swap(&amp;<span class="keyword">lock</span>,&amp;key);//<span class="keyword">lock</span>若<span class="keyword">true</span>，交换，而且沉浸在<span class="keyword">while</span>里；<span class="keyword">lock</span>若<span class="keyword">false</span>，交换，key变成<span class="keyword">false</span>，①<span class="keyword">lock</span>变为<span class="keyword">true</span>，②跳出<span class="keyword">while</span>循环。</span><br><span class="line">//Todo 临界区代码</span><br><span class="line"><span class="keyword">lock</span>=<span class="keyword">false</span>;</span><br><span class="line">//Todo 普通代码</span><br><span class="line"></span><br><span class="line">////硬件保证①②原子同时</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>硬件优点：适合任意数目的进程，不管是单核还是多核CPU；简单、容易验证正确性；可以支持多临界区，只需为每个临界区设立一个布尔变量；</li>
<li>硬件缺点：进程进入临界区需要耗费CPU时间，不能让权等待。有些进程出现饥饿现象。</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>为了解决互斥和同步的问题，只能被两个标准的原语wait(S)、signal(S)来访问，即P、V操作</p>
<h4 id="整数型资源S"><a href="#整数型资源S" class="headerlink" title="整数型资源S"></a>整数型资源S</h4><p>P、V描述如下：</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><span class="line"><span class="title function_">wait</span>(<span class="params">S</span>)&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="variable">S</span><span class="operator">&lt;=</span><span class="number">0</span>);<span class="comment">//忙等</span></span><br><span class="line">	<span class="variable">S</span><span class="operator">-</span><span class="operator">-</span>;	<span class="comment">//占，S&gt;=0时才会流转到这一步</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">signal</span>(<span class="params">S</span>)&#123;</span><br><span class="line">	<span class="variable">S</span><span class="operator">+</span><span class="operator">+</span>;	<span class="comment">//放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="记录性信号量"><a href="#记录性信号量" class="headerlink" title="记录性信号量"></a>记录性信号量</h4><p>除了一个代表资源数目的整型变量value外，还有一个进程链表L，链接所有等待该资源的进程（即存有记录）</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">process</span> *L;</span><br><span class="line">&#125;semaphore;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S.value--;</span><br><span class="line">	<span class="keyword">if</span>(S.value&lt;<span class="number">0</span>)&#123;原value为负或零，即缺少资源</span><br><span class="line">		add <span class="keyword">this</span> process to S.L;</span><br><span class="line">		<span class="built_in">block</span>(S.L);<span class="comment">//此process放弃CPU</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span></span>&#123;</span><br><span class="line">	S.value++;</span><br><span class="line">	<span class="keyword">if</span>(S.value&lt;=<span class="number">0</span>)&#123;<span class="comment">//原value为负，即有进程在等待资源</span></span><br><span class="line">		remove a process P from S.L;</span><br><span class="line">		<span class="built_in">wakeup</span>(P);<span class="comment">//进入就绪队列，等待CPU</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量实现同步"><a href="#信号量实现同步" class="headerlink" title="信号量实现同步"></a>信号量实现同步</h4><p>以下代码保证了会按照先P1后P2的顺序执行</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">Semaphore S<span class="operator">=</span><span class="number">0</span><span class="comment">;</span></span><br><span class="line">P1()&#123;</span><br><span class="line">	...</span><br><span class="line">	x<span class="comment">;</span></span><br><span class="line">	V(S)<span class="comment">;//放</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S)<span class="comment">;//占</span></span><br><span class="line">	y<span class="comment">;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="信号量实现互斥"><a href="#信号量实现互斥" class="headerlink" title="信号量实现互斥"></a>信号量实现互斥</h4><p>以下代码可实现两进程对临界资源的互斥访问</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">semaphore S<span class="operator">=</span><span class="number">1</span><span class="comment">;</span></span><br><span class="line">P1()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S)<span class="comment">;//占</span></span><br><span class="line">	x<span class="comment">;</span></span><br><span class="line">	V(S)<span class="comment">;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	...</span><br><span class="line">	P(S)<span class="comment">;</span></span><br><span class="line">	y<span class="comment">;</span></span><br><span class="line">	V(S)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="信号量实现前驱关系"><a href="#信号量实现前驱关系" class="headerlink" title="信号量实现前驱关系"></a>信号量实现前驱关系</h4><p>拓扑结构如下：</p>
<ul>
<li>S1-&gt;S2-&gt;S4-&gt;S6</li>
<li>S1-&gt;S2-&gt;S5-&gt;S6	</li>
<li>S1-&gt;S3-&gt;S6</li>
</ul>
<p>代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">semaphore a1=a2=b1=b2=c=d=e=<span class="number">0</span>;</span><br><span class="line"><span class="constructor">S1()</span>&#123;</span><br><span class="line">	...;</span><br><span class="line">	<span class="constructor">V(<span class="params">a1</span>)</span>;<span class="constructor">V(<span class="params">a2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">S2()</span>&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">a1</span>)</span>;</span><br><span class="line">	...;</span><br><span class="line">	<span class="constructor">V(<span class="params">b1</span>)</span>;<span class="constructor">V(<span class="params">b2</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">S3()</span>&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">a2</span>)</span>;</span><br><span class="line">	...;</span><br><span class="line">	<span class="constructor">V(<span class="params">c</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">S4()</span>&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">b1</span>)</span>;</span><br><span class="line">	...;</span><br><span class="line">	<span class="constructor">V(<span class="params">d</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">S5()</span>&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">b2</span>)</span>;</span><br><span class="line">	...;</span><br><span class="line">	<span class="constructor">V(<span class="params">e</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">S6()</span>&#123;</span><br><span class="line">	<span class="constructor">P(<span class="params">c</span>)</span>;</span><br><span class="line">	<span class="constructor">P(<span class="params">d</span>)</span>;</span><br><span class="line">	<span class="constructor">P(<span class="params">e</span>)</span>;</span><br><span class="line">	...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul>
<li>定义：由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。[理解]数据+操作，像java中的抽象类（具有成员变量和方法、构造）</li>
</ul>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="例1：生产成品的同步问题，操作buffer区的互斥问题"><a href="#例1：生产成品的同步问题，操作buffer区的互斥问题" class="headerlink" title="例1：生产成品的同步问题，操作buffer区的互斥问题"></a>例1：生产成品的同步问题，操作buffer区的互斥问题</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>,list1=n,list2=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//list1为producer需要消耗的原料集；list2为供consumer使用的成品</span></span><br><span class="line">producer<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">		<span class="constructor">P(<span class="params">list1</span>)</span>;<span class="comment">//消耗原料</span></span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		add nextp <span class="keyword">to</span> buffer;</span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">		<span class="constructor">V(<span class="params">list2</span>)</span>;<span class="comment">//产出成品</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">consumer<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">list2</span>)</span>;<span class="comment">//消耗成品</span></span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		remove an item from buffer;</span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">		<span class="constructor">V(<span class="params">list1</span>)</span>;<span class="comment">//付费给producer，等价于为producer购买原料</span></span><br><span class="line">		consume the item;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例2：（dad与daughter的同步）和（mom与son的同步），以及操作plate的互斥问题"><a href="#例2：（dad与daughter的同步）和（mom与son的同步），以及操作plate的互斥问题" class="headerlink" title="例2：（dad与daughter的同步）和（mom与son的同步），以及操作plate的互斥问题"></a>例2：（dad与daughter的同步）和（mom与son的同步），以及操作plate的互斥问题</h3><ul>
<li>dad如果操作了，mom和son都会静默，而daughter被唤醒，所以是同步问题；</li>
<li>daughter和son是选择条件执行，他们之间没有同步或互斥问题；</li>
<li>plate的操作是四人的互斥问题；</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">semaphore plate=<span class="number">1</span>,apple=<span class="number">0</span>,orange=<span class="number">0</span>;</span><br><span class="line">dad<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		prepare an apple;</span><br><span class="line">		<span class="constructor">P(<span class="params">plate</span>)</span>;</span><br><span class="line">		put the apple on the plate;</span><br><span class="line">		<span class="constructor">V(<span class="params">apple</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">mom<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		prepate an orange;</span><br><span class="line">		<span class="constructor">P(<span class="params">plate</span>)</span>;</span><br><span class="line">		put the orange on the plate;</span><br><span class="line">		<span class="constructor">V(<span class="params">orange</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">son<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">orange</span>)</span>;</span><br><span class="line">		take an orange from the plate;</span><br><span class="line">		<span class="constructor">V(<span class="params">plate</span>)</span>;</span><br><span class="line">		eat the orange;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">daughter<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">apple</span>)</span>;</span><br><span class="line">		take an apple from the plate;</span><br><span class="line">		<span class="constructor">V(<span class="params">plate</span>)</span>;</span><br><span class="line">		eat the apple;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="例3：读与写文件的复杂问题"><a href="#例3：读与写文件的复杂问题" class="headerlink" title="例3：读与写文件的复杂问题"></a>例3：读与写文件的复杂问题</h3><ul>
<li>允许多个读进程；</li>
<li>只允许一个写进程；</li>
<li>写进程时执行前，要退出已有的读进程和写进程；</li>
<li>写进程执行完毕前，不允许其他读进程与写进程进入。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">==①读进程优先算法==</span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;<span class="comment">//记录读者数量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//保护count变量的更新</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//访问文件的互斥</span></span><br><span class="line">writer<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">rw</span>)</span>;</span><br><span class="line">		writing;</span><br><span class="line">		<span class="constructor">V(<span class="params">rw</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">			<span class="constructor">P(<span class="params">rw</span>)</span>;<span class="comment">//第一个读进程来了，锁死rw</span></span><br><span class="line">		count++;</span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">		reading;</span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">			<span class="constructor">V(<span class="params">rw</span>)</span>;<span class="comment">//最有一个读进程退出后，解锁rw</span></span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==②读写公平算法==</span><br><span class="line"><span class="built_in">int</span> count=<span class="number">0</span>;<span class="comment">//记录读者数量</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//保护count变量的更新</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;<span class="comment">//访问文件的互斥</span></span><br><span class="line"># semaphore w=<span class="number">1</span>;<span class="comment">//用来实现写优先（相对的）</span></span><br><span class="line">writer<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"># 		<span class="constructor">P(<span class="params">w</span>)</span>;</span><br><span class="line">		<span class="constructor">P(<span class="params">rw</span>)</span>;</span><br><span class="line">		writing;</span><br><span class="line">		<span class="constructor">V(<span class="params">rw</span>)</span>;</span><br><span class="line"># 		<span class="constructor">V(<span class="params">w</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reader<span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"># 		<span class="constructor">P(<span class="params">w</span>)</span>;</span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">			<span class="constructor">P(<span class="params">rw</span>)</span>;<span class="comment">//第一个读进程来了，锁死rw</span></span><br><span class="line">		count++;</span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line"># 		<span class="constructor">V(<span class="params">w</span>)</span>;</span><br><span class="line">		reading;</span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		count--;</span><br><span class="line">		<span class="keyword">if</span>(count==<span class="number">0</span>)</span><br><span class="line">			<span class="constructor">V(<span class="params">rw</span>)</span>;<span class="comment">//最后一个读进程退出后，解锁rw</span></span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>读进程优先算法中，只要有一个读进程活跃，后来的读进程将被允许但写进程将会阻塞，可能导致写进程饿死（此时写进程地位偏低）；</li>
<li>读写公平算法中，<code>#</code>部分为新增代码，新来的读&#x2F;写进程公平竞争资源w。</li>
</ul>
<h3 id="例4：哲学家抓筷子问题"><a href="#例4：哲学家抓筷子问题" class="headerlink" title="例4：哲学家抓筷子问题"></a>例4：哲学家抓筷子问题</h3><ul>
<li>5个哲学家坐在圆桌上，每两人之间摆上一只筷子</li>
<li>一左一右的筷子分别拿起（不论次序）</li>
<li>拿到全部筷子的可以吃饭，没拿到的饿着</li>
<li>哲学家编号0~4，左边筷子编号i，右边筷子编号（i+1）%5</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">semaphore chopstick<span class="literal">[<span class="number">5</span>]</span>=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex=<span class="number">1</span>;<span class="comment">//取筷子的信号量</span></span><br><span class="line">P<span class="literal">[<span class="identifier">i</span>]</span><span class="literal">()</span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">mutex</span>)</span>;</span><br><span class="line">		<span class="constructor">P(<span class="params">chopstick</span>[<span class="params">i</span>])</span>;</span><br><span class="line">		<span class="constructor">P(<span class="params">chopstick</span>[(<span class="params">i</span>+1)</span>%<span class="number">5</span>]);</span><br><span class="line">		<span class="constructor">V(<span class="params">mutex</span>)</span>;<span class="comment">//同时抓到左右筷子时才释放mutex</span></span><br><span class="line">		eat;</span><br><span class="line">		<span class="constructor">V(<span class="params">chopstick</span>[<span class="params">i</span>])</span>;</span><br><span class="line">		<span class="constructor">V(<span class="params">chopstick</span>[(<span class="params">i</span>+1)</span>%<span class="number">5</span>]);</span><br><span class="line">		think;</span><br><span class="line">	&#125;<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有mutex的互斥，可能出现所有人拿着左边筷子然后等不到右边筷子的集体饥饿现象（死锁）；</li>
<li>使用mutex的互斥，相当于增加限制条件：当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子</li>
</ul>
<h3 id="例5：吸烟者与供应者的复杂问题"><a href="#例5：吸烟者与供应者的复杂问题" class="headerlink" title="例5：吸烟者与供应者的复杂问题"></a>例5：吸烟者与供应者的复杂问题</h3><ul>
<li>吸一根烟需要3种材料，3个吸烟者各自持有某一种材料（数量无穷多）；</li>
<li>供应者每次提供2种材料，其中能凑足3样材料的吸烟者拿到材料，吸掉烟，告知供应者；</li>
<li>供应者提供另外2种材料。</li>
<li>明显，3个吸烟者的吸烟操作是互斥的</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> random;</span><br><span class="line">semaphore offer1=<span class="number">0</span>;<span class="comment">//分别指代3种组合</span></span><br><span class="line">semaphore offer2=<span class="number">0</span>;</span><br><span class="line">semaphore offer3=<span class="number">0</span>;</span><br><span class="line">semaphore finish=<span class="number">0</span>;<span class="comment">//抽烟的互斥操作</span></span><br><span class="line"><span class="constructor">P0()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		random=整数随机数%<span class="number">3</span>；</span><br><span class="line">		<span class="keyword">if</span>(random==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="constructor">V(<span class="params">offer1</span>)</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(random==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="constructor">V(<span class="params">offer2</span>)</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="constructor">V(<span class="params">offer3</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="constructor">P(<span class="params">finish</span>)</span>;<span class="comment">//如果材料没被拿走，就会卡在这里，材料拿走了，才会重新random，进而重新offer</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">P1()</span>&#123;<span class="comment">//缺offer3的两种材料的吸烟者</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">offer3</span>)</span>;</span><br><span class="line">		已有三种材料，变成烟，抽掉；</span><br><span class="line">		<span class="constructor">V(<span class="params">finish</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">P2()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">offer2</span>)</span>;</span><br><span class="line">		已有三种材料，变成烟，抽掉；</span><br><span class="line">		<span class="constructor">V(<span class="params">finish</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="constructor">P3()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="constructor">P(<span class="params">offer1</span>)</span>;</span><br><span class="line">		已有三种材料，变成烟，抽掉；</span><br><span class="line">		<span class="constructor">V(<span class="params">finish</span>)</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul>
<li><p>定义：多个进程因竞争资源而造成的一种僵局，若无外力推动，进程将无法推进。举例：哲学家的筷子问题时，如果五人全都拿起左手的筷子，将无一人取得右手的筷子，陷入江局 ○( ＾皿＾)っHiahiahia…</p>
</li>
<li><p>死锁产生原因：</p>
<ul>
<li>多个进程请求和释放资源不当会引起死锁；例：双方等待对方的资源。</li>
<li>信号量使用不当会引起死锁。例：双方等待对方的消息。</li>
</ul>
</li>
<li><p>形成死锁的4个必要条件，而破坏这些条件就可以打破死锁的江局</p>
<ul>
<li>互斥条件。</li>
<li>不剥夺条件。对可剥夺资源的竞争是不会引起死锁的。</li>
<li>请求和保持条件。进程已经保持了至少一个资源，还想要别的资源但该资源被占用，而本进程也不愿意放弃已获得的资源。</li>
<li>循环等待条件。存在一条循环等待链，构成了一个死循环的闭环。</li>
</ul>
</li>
<li><p>三种策略：①预防死锁：破坏四个必要条件；②避免死锁：防止系统进入不安全状态，进而避免死锁；③死锁检测：允许死锁产生的时候能够检测死锁并恢复进程的执行。</p>
<ul>
<li>前两者是事先预防，但预防死锁的条件比较严格，实现起来简单却导致系统的效率低，资源利用率低；</li>
<li>避免死锁的限制条件宽松，但要通过判断是否进入不安全状态，实现较难</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">资源分配策略</th>
<th align="center">各种可能模式</th>
<th align="center">主要优点</th>
<th align="center">主要缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">死锁预防</td>
<td align="center">保守，宁可资源闲置</td>
<td align="center">一次请求所有资源，资源剥夺，资源按序分配</td>
<td align="center">适用于做突发式处理的进程，不必进行剥夺</td>
<td align="center">效率低，进程初始化时间延长，剥夺次数过多，不便灵活申请新资源</td>
</tr>
<tr>
<td align="center">死锁避免</td>
<td align="center">是“预防”和“检测”的折中（在运行中判断是否可能死锁）</td>
<td align="center">寻找可能的安全允许顺序</td>
<td align="center">不必进行剥夺</td>
<td align="center">必须知道将来的资源需求，进程不能被长时间阻塞</td>
</tr>
<tr>
<td align="center">死锁检测</td>
<td align="center">宽松，只要允许就分配资源</td>
<td align="center">定期检查死锁是否已经发生</td>
<td align="center">不延长进程初始化时间，允许对死锁进行现场处理</td>
<td align="center">通过剥夺解除死锁，造成损失</td>
</tr>
</tbody></table>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="（1）破坏互斥条件"><a href="#（1）破坏互斥条件" class="headerlink" title="（1）破坏互斥条件"></a>（1）破坏互斥条件</h4><ul>
<li>不太可行，有些场合需要保护这种互斥性</li>
</ul>
<h4 id="（2）破坏不剥夺条件"><a href="#（2）破坏不剥夺条件" class="headerlink" title="（2）破坏不剥夺条件"></a>（2）破坏不剥夺条件</h4><ul>
<li>若一个进程请求新资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。从而破坏了不剥夺条件。</li>
<li>但实现起来比较复杂，释放资源会造成前一阶段的工作实效，反复申请和释放资源可能增加系统开销。</li>
<li>这种方法适用于状态易于保存和恢复的资源，比如CPU的寄存器或内存资源，但不适合于打印机之类的资源。</li>
</ul>
<h4 id="（3）破坏请求和保持条件"><a href="#（3）破坏请求和保持条件" class="headerlink" title="（3）破坏请求和保持条件"></a>（3）破坏请求和保持条件</h4><ul>
<li>采用预先静态分配的方法，进程在运行前一次性申请完它所需要的全部资源，在资源未满足前，不把它投入运行；一旦投入运行后，这些资源都归它所有，也不再提出其他资源请求。</li>
<li>实现简单，缺点：资源被严重浪费，有些资源可能仅在开始或结束短暂使用甚至不被使用。导致饥饿现象，等待某些资源的进程迟迟得不到资源。</li>
</ul>
<h4 id="（4）破坏循环等待条件"><a href="#（4）破坏循环等待条件" class="headerlink" title="（4）破坏循环等待条件"></a>（4）破坏循环等待条件</h4><ul>
<li>可采用<strong>顺序资源分配法</strong>，先把资源编号，规定每个进程必须按照编号递增的顺序请求资源，同类资源一次申请完。进程如果申请到了资源6，之后只能申请编号大于6的资源，不能申请1~6了。</li>
<li>缺点：编号必须相对稳定，这就限制了新设备的增加。容易出现作业使用资源的顺序与系统规定顺序不同的请求，造成资源的浪费。同时也给用户编程带来麻烦。</li>
</ul>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><ul>
<li>在<strong>资源动态分配过程中</strong>，防止系统进入不安全状态，以避免发生死锁。限制条件较弱。</li>
<li>不安全状态：在当前时刻，找不到一个安全序列顺利完成进程的执行。</li>
<li>安全序列：按照此序列，可以使各个进程逐一满足资源条件，顺利的执行下去。</li>
<li>不安全序列：进程们无法获得资源执行完成，此时便进入了不安全状态。</li>
<li>并非所有不安全状态都是死锁状态（因为随着时间推移，可能某些占大量资源的进程被阻塞释放资源也说不定啊hhhh），但极可能进入死锁状态。</li>
<li>死锁避免最著名的算法：银行家算法</li>
</ul>
<h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><ul>
<li>本质：得到一个分配资源的安全序列</li>
<li>进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则推迟分配；</li>
<li>当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</li>
<li>数据描述：<ul>
<li>可利用资源矢量Available。Available[j]&#x3D;K，指系统现有Rj类资源K个；</li>
<li>最大需求矩阵Max，n×m矩阵，n个进程中的每个进程对m类资源的最大需求；</li>
<li>分配矩阵Allocation：与Max结构相同，为当前时刻，各进程已拥有的各资源情况；</li>
<li>需求矩阵Need：与Max结构相同，为当前时刻，各进程还需要的各资源情况，关系：Need&#x3D;Max-Allocation；</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Max(A B C)</th>
<th align="center">T0时刻 Allocation(A B C)</th>
<th align="center">T0时刻 Need(A B C)</th>
<th align="center">T0时刻 Available(A B C)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P0</td>
<td align="center">7 5 3</td>
<td align="center">0 1 0</td>
<td align="center">7 4 3</td>
<td align="center">3 3 2</td>
</tr>
<tr>
<td align="center">P1</td>
<td align="center">3 2 2</td>
<td align="center">2 0 0</td>
<td align="center">1 2 2</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">P2</td>
<td align="center">9 0 2</td>
<td align="center">3 0 2</td>
<td align="center">6 0 0</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">P3</td>
<td align="center">2 2 2</td>
<td align="center">2 1 1</td>
<td align="center">0 1 1</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">P4</td>
<td align="center">4 3 3</td>
<td align="center">0 0 2</td>
<td align="center">4 3 1</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>本例原本Available数组{10,5,7}</li>
<li>对比Need各行与Available数组，看出P1和P3可以满足条件，所以安全队列可以从P1开始（也可以从P3开始）；</li>
<li>资源给了P1，P1完成执行后，Available数组变成了{5,3,2},</li>
<li>Need矩阵没了P1行，只剩如下：</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Need</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P0</td>
<td align="center">7 4 3</td>
</tr>
<tr>
<td align="center">P2</td>
<td align="center">6 0 0</td>
</tr>
<tr>
<td align="center">P3</td>
<td align="center">0 1 1</td>
</tr>
<tr>
<td align="center">P4</td>
<td align="center">4 3 1</td>
</tr>
</tbody></table>
<ul>
<li>此Need矩阵跟Available数组比较，继续消行（比如P3和P4均可）</li>
<li>依次类推，得到一组安全序列{P1,P3,P4,P2,P0}，事实上不止唯一答案。</li>
</ul>
<h3 id="死锁检测和解除"><a href="#死锁检测和解除" class="headerlink" title="死锁检测和解除"></a>死锁检测和解除</h3><p>推荐阅读：<a href="https://blog.csdn.net/sinat_22055459/article/details/51454468">死锁检测和解除1</a>以及<a href="https://blog.csdn.net/lierming__/article/details/79000632">死锁检测和解除2</a></p>
<p><img src="/2018/09/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%883%EF%BC%89/1.png" alt="死锁检测"></p>
<ul>
<li>从上文博客2介绍利用资源分配图来判断死锁的方式，简述：<ul>
<li>R1资源有3份，分给P1两份，分给P2一份，此时P2还向R1申请一份，故R1缺一份；</li>
<li>R2资源有两份，分给P2一份，此时P1向R2申请一份，故R2完全有能力继续分配给P1；</li>
<li>一边进程P1申请资源R2一份，另一边R2也有空余资源，两位一拍即合，执行进程P1，执行完成后P1变成孤立点，P1的两条入边和一条出边也消去；</li>
<li>继续考虑P2，发现P1释放了资源后，P2的资源申请也能得到满足，P2也开始执行；</li>
<li>综上，该图是可完全简化的。</li>
</ul>
</li>
<li>死锁发生：S状态的资源分配图是不可完全简化的（亦称死锁定理）。</li>
<li>检测的时机：①进程请求资源得不到满足时（此时检测系统开销太大）；②定时检测；③系统资源利用率下降时检测；</li>
<li>死锁解除方法：<ol>
<li>资源剥夺法：挂起某些死锁进程，并抢占它的资源。需要放置被挂起的进程长时间得不到资源，而处于资源匮乏状态。</li>
<li>撤销进程法：可按照进程优先级和撤销进程代价的原则，强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。</li>
<li>进程回退法：让一个或多个进程回退到足以避免死锁的地步，进程回退时自愿放弃资源而不是被剥夺，需要系统保持进程的历史信息，设置还原点。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统第二章练习（1）</title>
    <url>/2018/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="操作系统之进程管理——进程概览"><a href="#操作系统之进程管理——进程概览" class="headerlink" title="操作系统之进程管理——进程概览"></a>操作系统之进程管理——进程概览</h1><h4 id="1-进程的概念、特征和状态转换"><a href="#1-进程的概念、特征和状态转换" class="headerlink" title="1. 进程的概念、特征和状态转换"></a>1. 进程的概念、特征和状态转换</h4><ul>
<li>推荐阅读：<a href="(https://www.cnblogs.com/jacklu/p/5317406.html">进程详解</a></li>
<li>[定义]进程：进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。[理解]进程类似一个实例化的程序，是“执行中的程序”，是一个过程。</li>
<li>进程实体：由程序段、相关数据段和PCB（进程控制块,由链表实现，进程的唯一标识，进程创建时，OS为其生成一个PCB，进程终止时回收PCB）三部分构成。</li>
<li>进程的特征：动态性、并发性、独立性、异步性、结构性：<ul>
<li>动态性：进程实体不运行就不叫进程，一个没有被调用的进程实体也不叫进程。具有着创建、活动、暂停、终止等过程。具有一定的生命周期，所以是动态的。</li>
<li>并发性：引入进程就是为了使程序能够与其他进程的程序并发执行，用以提高资源利用率。</li>
<li>独立性：进程实体拥有着独立的资源（程序段和数据段），是能够独立地接受调度并独立运行的基本单位（因为PCB的存在）。</li>
<li>异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按照各自独立地、不可预知的速度向前推进。但异步会导致执行结果的不可再现性（类似数据库的一致性），为此，OS必须配置相应的进程同步机制（为解决访问顺序和共享变量的冲突问题，推荐阅读：<a href="https://blog.csdn.net/williamyi96/article/details/78233753">进程间同步机制</a>）。</li>
<li>结构性：一个进程配置一个PCB进行描述，按进程实体定义的三部分组成。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<p><img src="/2018/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%83%E4%B9%A0%EF%BC%881%EF%BC%89/1.png" alt="1"></p>
<ul>
<li>进程的状态转换：三种基本状态（<strong>就绪状态、执行状态、阻塞&#x2F;等待状态</strong>），某些系统的附加状态（<strong>挂起状态</strong>），另外两种常见状态（<strong>创建状态、终止状态</strong>）。<ul>
<li>就绪状态：进程拥有除了CPU外的一切所需资源；</li>
<li>执行状态：运行在CPU上，一般单CPU系统某一时刻下最多运行一个进程；</li>
<li>阻塞&#x2F;等待状态：进程在等待某一事件（不包括CPU）而暂停运行。</li>
<li>挂起状态：出于种种原因，我们让进程处于静止状态（即让进程不能立即执行），OS把这些进程换到磁盘中的挂起队列，推荐阅读：<a href="https://blog.csdn.net/freeelinux/article/details/53562592">进程的挂起状态详细分析</a>。</li>
<li>创建状态：正在被创建，尚未进入就绪状态。创建步骤：申请一个空白PCB，向PCB中写入控制信息，然后OS为进程分配资源，最后转入就绪状态。</li>
<li>终止状态：进程由于正常结束&#x2F;其他原因中断运行，OS设置进程为结束状态，然后进一步处理资源释放和回收工作。</li>
<li>[注]运行状态 -&gt; 阻塞状态是进程的主动过程，但由阻塞状态 -&gt; 就绪状态是一个被动的行为，需要其他相关进程的协助（见本博客第4节内容）。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">事件</th>
<th align="center">导致进程挂起的事件说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">交换</td>
<td align="center">操作系统需要释放足够的内存空间，以调入并执行处于就绪状态的进程</td>
</tr>
<tr>
<td align="center">其他OS原因</td>
<td align="center">操作系统可能挂起后台进程或工具程序进程，或者被怀疑导致问题的进程</td>
</tr>
<tr>
<td align="center">交互式用户请求</td>
<td align="center">用户可能希望挂起一个程序的执行，目的是为了调试或与一个资源的使用进行连接</td>
</tr>
<tr>
<td align="center">定时</td>
<td align="center">一个进程可能会周期性地执行（例如记账或系统监视进程），而且可能在等待下一个时间间隔时被挂起</td>
</tr>
<tr>
<td align="center">父进程请求</td>
<td align="center">父进程可能会希望挂起后代进程的执行，以检查或修改挂起的进程，或者协调不同后代进程之间的行为</td>
</tr>
</tbody></table>
<hr>
<h4 id="2-进程的创建"><a href="#2-进程的创建" class="headerlink" title="2. 进程的创建"></a>2. 进程的创建</h4><ul>
<li><p>在OS中，用户登录、作业调度、系统提供服务、用户程序的应用请求都会引起进程的创建。</p>
</li>
<li><p>以Linux为例，说明创建步骤：</p>
<ol>
<li>① 首先在内存中为新进程创建一个task_struct结构（Linux下对PCB定义的结构体）；</li>
<li>② 然后将父进程的task_struct内容复制其中，再修改部分数据。</li>
<li>③ 分配新的内核堆栈、新的PID，再将task_struct这个node添加到PCB链表中。</li>
</ol>
<ul>
<li>进程的以上创建步骤是单个原语，不允许分割，其他的撤销已有进程、实现进程状态的转换等都是原语。</li>
<li>因为绝大多数信息是从父进程拷贝&#x2F;克隆来的，系统有必要记录这种亲属关系，使进程之间的协作更加方便（例如kill信号或通信信号）。初始化进程init中的task_struct结构是进程树的根（init进程是所有进程的祖先进程）。推荐阅读：<a href="https://www.cnblogs.com/hanxiaoyu/p/5549212.html">Linux - PCB之task_struct结构体</a></li>
<li>子进程刚开始时，内核并没有为它分配物理内存，而是以只读的方式共享父进程内存，只有当子进程写时，才复制，即“copy on write”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-进程的终止"><a href="#3-进程的终止" class="headerlink" title="3. 进程的终止"></a>3. 进程的终止</h4><ul>
<li>终止的事件有：正常结束（main中的return，调exit，调_exit或_EXIT）、异常结束（存储区越界、保护错、非法指令、特权指令错、I&#x2F;O故障等，调abort等）、外界干预（人为干预、OS干预、父进程干预）</li>
<li>终止步骤：<ol>
<li>根据被终止进程的标识符，检索PCB，读出该进程的状态；</li>
<li>若被终止进程处于执行状态，立即终止该进程的执行，将CPU分配给其他进程；</li>
<li>若该进程还有子进程，应将所有子进程终止；</li>
<li>将该进程所拥有的所有资源，归还给父进程或OS；</li>
<li>将PCB从链表中删除；</li>
</ol>
</li>
</ul>
<hr>
<h4 id="4-进程的阻塞和唤醒"><a href="#4-进程的阻塞和唤醒" class="headerlink" title="4. 进程的阻塞和唤醒"></a>4. 进程的阻塞和唤醒</h4><ul>
<li>重点：只有获得CPU的进程才能够转为阻塞状态，这种转换是主动的，方式为执行阻塞原语（Block）。</li>
<li>当资源或数据等条件得到满足后，由合作进程或其他相关进程执行唤醒原语（Wakeup），唤醒该被阻塞的进程，进入就绪队列。</li>
<li>引起阻塞和唤醒的事件：<ul>
<li>向系统申请资源时失败。如申请打印机，但打印机被其他进程占用。</li>
<li>等待某种操作。如进程A启动了某I&#x2F;O，只有等完成该I&#x2F;O任务后进程A才能执行，则进程A启动I&#x2F;O后自动阻塞。</li>
<li>新数据尚未到达。如相互合作的进程，没等到另一个进程的数据之前，先进入阻塞状态。</li>
<li>等待新任务的到达。进程完成了自己的任务后将自己阻塞起来，等待新任务到来才将其唤醒。</li>
</ul>
</li>
<li>Block的执行步骤：<ol>
<li>找到该进程的PID对应的PCB；</li>
<li>查看PCB中进程的状态，若是运行状态，则保护现场，将状态改为阻塞状态，停止运行；</li>
<li>把该PCB插入到相应事件的阻塞队列中。</li>
</ol>
</li>
<li>Wakeup的执行步骤：<ol>
<li>在该事件的等待队列中找到相应进程的PCB；</li>
<li>将其从等待队列中移出，并置为就绪状态；</li>
<li>将PCB插入就绪队列中，等待调度程序调度。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="5-进程的切换"><a href="#5-进程的切换" class="headerlink" title="5. 进程的切换"></a>5. 进程的切换</h4><ul>
<li>推荐阅读：<a href="https://blog.csdn.net/lixungogogo/article/details/52202714">进程概念，进程切换，上下文切换，虚拟地址空间</a></li>
<li>进程的切换步骤：<ol>
<li>OS保存处理的上下文到PCB，包括PC（program counter）、PSW（program status word）及其他寄存器，保存到tast_struct中的thread结构体中（把寄存器中的值赋给thread中的各变量）；</li>
<li>更新PCB信息；</li>
<li>把进程PCB移入相应的队列；</li>
<li>选择另一个进程执行，并更新其PCB；</li>
<li>更新内存管理的数据结构（如地址页表、进程表、进程打开的文件表等）；</li>
<li>恢复CPU上下文。</li>
</ol>
</li>
<li>切换发生的时机：<ol>
<li>阻塞式系统调用、虚拟地址异常。导致进入等待态。</li>
<li>时间片中断、I&#x2F;O中断后更改优先级进程。导致进入就绪态。</li>
<li>终止用系统调用、不能继续执行的异常。导致进入终止态。</li>
</ol>
</li>
<li>虽然进程切换一定发生在中断&#x2F;异常&#x2F;系统调用的处理过程中，但并不意味所有的中断&#x2F;异常都会引起进程切换（有些时候OS处理完中断，会立即恢复原进程的处理）。<ul>
<li>进程切换只会发生在内核态。</li>
</ul>
</li>
<li>一个进程的上下文可以分为三个部分：用户级上下文、寄存器上下文以及系统级上下文<ul>
<li>用户级上下文： 正文、数据、用户堆栈以及共享存储区； </li>
<li>寄存器上下文： 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)； </li>
<li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈</li>
</ul>
</li>
</ul>
<blockquote>
<p>系统调用进行的是模式切换(mode switch)。模式切换与进程切换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是进程寄存器上下文的切换。<br>当进程调用系统调用或者发生中断时，CPU从用户态切换成内核态，此时，无论是系统调用程序还是中断服务程序，都处于当前进程的上下文中，并没有发生进程上下文切换。<br>当系统调用或中断处理程序返回时，CPU要从内核态切换回用户态，此时会执行操作系统的调用程序。如果发现就绪队列中有比当前进程更高的优先级的进程，则会发生进程切换：当前进程信息被保存，切换到就绪队列中的那个高优先级进程；否则，直接返回当前进程的用户模式，不会发生上下文切换</p>
</blockquote>
<blockquote>
<p>当进行系统调用的时候，当前进程的时间片就停止了，由内核去完成系统调用，当我们系统调用返回的时候，时间片就可以重新开始计时，无论怎么样，系统调用以后，一定是有时间让内核把信息，返回给用户，系统调用的结果会保存在eax寄存器中。<br>如果系统刚调用完毕，准备返回用户空间，就在此时，发生了进程切换，那么别的进程就会改掉eax的值，那么当我下次进行恢复的时候，还得重新调用系统调用，这样子的话，对于系统的资源就太浪费了；所以说进行系统调用的返回值一定是返回给用户的，当用户把eax寄存器的值保存起来以后，标志着系统调用完毕，接下来切不切换进程就没有啥影响了。</p>
</blockquote>
<hr>
<h4 id="6-进程间的通信"><a href="#6-进程间的通信" class="headerlink" title="6. 进程间的通信"></a>6. 进程间的通信</h4><ul>
<li><p>PV操作（P、V原语，属于信号量机制）是通过硬件实现的低级通信方式；缺点：效率低、通信对用户不透明。高级通信方式有三种：共享存储、消息传递和管道通信（优点：隐藏了实现细节）：</p>
</li>
<li><p>共享存储：使用同步互斥工具，对一块可直接访问的共享空间进行读写控制，要通过特殊的系统调用来实现（因为一般进程空间是独立地，不会访问其他进程的空间）。</p>
</li>
<li><p>消息传递：以格式化的消息为单位（计网中称为报文）进行传递。系统提供了“发送消息（Send）”和“接受消息（Receive）”两个原语，应用广泛，能很好地支持多处理机系统、分布式系统和计算机网络。</p>
<ul>
<li>直接通信方式：发送进程将消息挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息；</li>
<li>间接通信方式，又称为信箱通信方式：发送进程将消息发送到某一个中间实体中，接收进程从中间实体（被称为信箱）取得消息（消息在信箱中可以安全的保存，只允许核准的目标用户<strong>随时</strong>读取）。采用间接通信方式可实现实时通信，又可实现非实时通信。分为三种信箱：<ul>
<li>私有信箱。由用户创建信箱，并作为该进程的一部分，其他用户只能向该信箱发消息，而无法取消息。可采用单向通信链路的信箱来实现，当该信箱的进程结束时，进程PCB消失，信箱随之消失。</li>
<li>公用信箱。由OS创建，提供给OS核准的用户使用，采用双向通信链路的信箱来实现。通常公用信箱在系统运行期间始终存在。</li>
<li>共享信箱。创建时或创建后指明为共享的，同时需指出共享进程（用户）的名字。</li>
</ul>
</li>
</ul>
</li>
<li><p>管道通信：用于连接一个读进程和一个写进程以实现通信的一个共享文件，即pipe文件。推荐阅读：<a href="http://lib.csdn.net/article/operatingsystem/22086">【Linux0.11 内核源码剖析】进程间通信——管道（pipe）</a>。管道机制必须提供三方面能力：</p>
<ol>
<li>① 互斥。当一个进程正在对pipe进行读&#x2F;写操作时，另一个进程必须等待。</li>
<li>② 同步。当写（输入）进程把一定数量数据写入pipe后，便去睡眠等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读到一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒。</li>
<li>③ 确定对方的存在。只有确定对方已存在时，才能进行通信。</li>
</ol>
<ul>
<li>管道有一个固定的缓冲区，所以需要限制管道的大小；</li>
<li>管道读数据是一次性操作，一旦数据被读取，它就要从管道中被抛弃，释放空间以便写更多的数据；</li>
<li>管道只能采用半双工通信，某一时刻只能单向传输。若要实现父子通信，必须定义两个管道。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>operationSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概论练习题之一</title>
    <url>/2018/08/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<h1 id="数据库第一套卷"><a href="#数据库第一套卷" class="headerlink" title="数据库第一套卷"></a>数据库第一套卷</h1><h2 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h2><h3 id="1-关系代数的四个组合操作是：选择、投影、连接、除法"><a href="#1-关系代数的四个组合操作是：选择、投影、连接、除法" class="headerlink" title="1. 关系代数的四个组合操作是：选择、投影、连接、除法"></a>1. 关系代数的四个组合操作是：选择、投影、连接、除法</h3><p>理解：</p>
<ul>
<li>选择是按照某条件，筛选出部分行，这些行具有所有列的属性；</li>
<li>投影是选取部分属性，形成新的表格，并去除重复记录；</li>
<li>连接是按照公共属性，将多表的属性列汇总在一张表里；</li>
<li>除法是A÷B时，A{X,Y},B{Y,Z},将A的X上各值看作一个整体{a1,a2,a3…}进行分组，如果某组，例如a1对应的A.Y能够包含所有的B.Y组合的情况，那么a1就是结果</li>
</ul>
<hr>
<h3 id="2-SQL的DML操作有：排序插入修改等，但索引属于DDL操作"><a href="#2-SQL的DML操作有：排序插入修改等，但索引属于DDL操作" class="headerlink" title="2. SQL的DML操作有：排序插入修改等，但索引属于DDL操作"></a>2. SQL的DML操作有：排序插入修改等，但索引属于DDL操作</h3><ul>
<li>DML即数据操作语言</li>
<li>DDL包括模式定义、表定义、视图和索引的定义</li>
</ul>
<hr>
<h3 id="3-关系数据模型的三个组成部分：数据结构、数据操作、完整性约束"><a href="#3-关系数据模型的三个组成部分：数据结构、数据操作、完整性约束" class="headerlink" title="3. 关系数据模型的三个组成部分：数据结构、数据操作、完整性约束"></a>3. 关系数据模型的三个组成部分：数据结构、数据操作、完整性约束</h3><ul>
<li>数据结构。所描述对象类型的集合，是对系统静态特性的描述。通常可分为层次结构、网状结构和关系结构，并以此为模型命名（层次模型、网状模型、关系模型）</li>
<li>数据操作。主要有查询和更新两大操作。是对系统动态特性的描述。</li>
<li>完整性约束。是用来限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li>
</ul>
<span id="more"></span>


<hr>
<h3 id="4-关系数据库的规范化理论指出，关系数据库中的关系应满足一定的要求，最起码的要求是要达到1NF（第一范式），即满足：每一个分量必须是不可分的数据项。"><a href="#4-关系数据库的规范化理论指出，关系数据库中的关系应满足一定的要求，最起码的要求是要达到1NF（第一范式），即满足：每一个分量必须是不可分的数据项。" class="headerlink" title="4. 关系数据库的规范化理论指出，关系数据库中的关系应满足一定的要求，最起码的要求是要达到1NF（第一范式），即满足：每一个分量必须是不可分的数据项。"></a>4. 关系数据库的规范化理论指出，关系数据库中的关系应满足一定的要求，最起码的要求是要达到1NF（第一范式），即满足：每一个分量必须是不可分的数据项。</h3><ul>
<li>推荐阅读：<a href="https://blog.csdn.net/douunderstand/article/details/70159540">MySQL （4） 第一范式 第二范式 第三范式 BC范式</a></li>
<li>[理解]1NF。表是平表，表中不能嵌套表。</li>
<li>[扩展]2NF。首先属于1NF，然后每一个非主属性完全函数依赖于码。（去掉码的冗余，不依赖于码的某一部分的属性，而是依赖于码的全部属性）。同时得出结论：如果属于1NF且码只有一个单一字段时，它一定符合2NF。</li>
<li>Y对X完全函数依赖 ：X的所有元素同时确定Y，缺一个都不行。</li>
<li>3NF。首先属于2NF，然后每一个非主属性不传递依赖于码。任何非主属性不依赖于其他非主属性。</li>
<li>传递依赖：在一个关系模式S-L中，Sno-&gt;Sdept,Sdept-&gt;Sloc，可得Sno-(传递)-&gt;Sloc，因此此S-L具有传递依赖，不属于3NF，改进：将S-L模式分解为S-D（Sno-&gt;Sdept）和D-L（Sdept-&gt;Sloc）两个模式。</li>
<li>但3NF并不彻底，可能存在主属性对码的部分依赖和传递依赖。使用BCNF补漏。</li>
<li>BCNF。首先属于<strong>1NF</strong>，若每一个函数依赖X-&gt;Y，若Y不属于X时X必含有候选码，则此关系模式属于BCNF。（每个决定因素必须包含键码）</li>
<li>如果R属于BCNF，则R一定属于3NF；反之不一定成立。如果R属于3NF，且R只有一个候选码，则R属于BCNF。</li>
<li>多值依赖。参见《数据库系统概论》第4版（王珊 萨师煊）P179页</li>
<li>4NF。即使达到了BCNF，但如果存在多值依赖，仍然有大量数据冗余，所以可以用投影分解的方式来消去非平凡且非函数依赖的多值依赖。</li>
<li>连续依赖、5NF等此处略去不谈。</li>
</ul>
<hr>
<h3 id="5-子模式DDL用来描述：数据库的局部逻辑结构"><a href="#5-子模式DDL用来描述：数据库的局部逻辑结构" class="headerlink" title="5. 子模式DDL用来描述：数据库的局部逻辑结构"></a>5. 子模式DDL用来描述：数据库的局部逻辑结构</h3><ul>
<li>子模式就是外模式，输入局部逻辑</li>
</ul>
<hr>
<h3 id="6-设有关系R（S，D，M）-F-x3D-S-gt-D-D-gt-M-。则关系R最多满足：3NF"><a href="#6-设有关系R（S，D，M）-F-x3D-S-gt-D-D-gt-M-。则关系R最多满足：3NF" class="headerlink" title="6. 设有关系R（S，D，M） F&#x3D; {S-&gt;D,D-&gt;M}。则关系R最多满足：3NF"></a>6. 设有关系R（S，D，M） F&#x3D; {S-&gt;D,D-&gt;M}。则关系R最多满足：3NF</h3><ul>
<li>明显存在传递依赖所以不可能是BCNF及以上，但D、M可能是主属性，所以可能可以满足3NF。若是非主属性，那就不符合3NF，最多是2NF。由以上分析知，关系R最多满足3NF</li>
</ul>
<hr>
<h3 id="7-DBMS在运行过程中建立的日志文件，主要用于对数据库的：数据库恢复"><a href="#7-DBMS在运行过程中建立的日志文件，主要用于对数据库的：数据库恢复" class="headerlink" title="7. DBMS在运行过程中建立的日志文件，主要用于对数据库的：数据库恢复"></a>7. DBMS在运行过程中建立的日志文件，主要用于对数据库的：数据库恢复</h3><p>日志文件的具体作用：</p>
<ol>
<li>事务故障恢复和系统故障恢复必须用日志文件；</li>
<li>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库；</li>
<li>在静态转储方式中，也可以建立日志文件。当数据库毁坏后可重新装入后援副本把数据可恢复到转储结束时刻的正确状态，然后利用日志文件，把已完成的事务进行重做处理，对故障发生时尚未完成的事务进行撤销处理。</li>
</ol>
<ul>
<li>转储：DBA将整个数据库复制到磁带或另一个磁盘上保存起来的过程。</li>
<li>静态转储：在系统中无运行事务时进行转储，转储开始时数据库处于一致性状态。降低了数据库的可用性，转储必须等待用户事务结束，新的事务必须等待转储结束。</li>
<li>动态转储：转储操作与用户事务并发进行，转储期间允许对数据库进行存取或修改，提高了可用性，但转储结束时后援副本的数据并不能保证正确有效，为此，必须把转储期间各事务对数据库的修改活动记录下来建立日志文件。</li>
<li>海量转储：每次转储全部数据库。</li>
<li>增量转储：每次只转储上一次转储后更新的数据。</li>
</ul>
<hr>
<h3 id="8-设R-U-是一个关系模式，X-gt-Y是一个FD，如果对任何W属于X，W-gt-Y都不成立，则称X-gt-Y是：完全依赖"><a href="#8-设R-U-是一个关系模式，X-gt-Y是一个FD，如果对任何W属于X，W-gt-Y都不成立，则称X-gt-Y是：完全依赖" class="headerlink" title="8. 设R(U)是一个关系模式，X-&gt;Y是一个FD，如果对任何W属于X，W-&gt;Y都不成立，则称X-&gt;Y是：完全依赖"></a>8. 设R(U)是一个关系模式，X-&gt;Y是一个FD，如果对任何W属于X，W-&gt;Y都不成立，则称X-&gt;Y是：完全依赖</h3><ul>
<li>FD：Functional Dependency，函数依赖</li>
</ul>
<hr>
<h3 id="9-若事务T1已经给数据A加上了共享锁，则事务T2-只能对A加共享锁"><a href="#9-若事务T1已经给数据A加上了共享锁，则事务T2-只能对A加共享锁" class="headerlink" title="9. 若事务T1已经给数据A加上了共享锁，则事务T2:只能对A加共享锁"></a>9. 若事务T1已经给数据A加上了共享锁，则事务T2:只能对A加共享锁</h3><ul>
<li>若事务T1对数据A加上了S锁，那么T1可以读A但不能修改A；其他事务只能对A加S锁不能加X锁，直到T1释放S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li>
</ul>
<hr>
<h3 id="10-公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类型是：一对多"><a href="#10-公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类型是：一对多" class="headerlink" title="10. 公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类型是：一对多"></a>10. 公司中有多个部门和多名职员，每个职员只能属于一个部门，一个部门可以有多名职员，从职员到部门的联系类型是：一对多</h3><ul>
<li>两个实体型之间的联系只有三种：一对一、一对多、多对多</li>
</ul>
<hr>
<h3 id="11-在下面的两个关系中，职工号和部门号分别为职工关系和部门关系的主码。在这两个关系的属性中，只有一个属性是外码，它是：职工关系的部门号"><a href="#11-在下面的两个关系中，职工号和部门号分别为职工关系和部门关系的主码。在这两个关系的属性中，只有一个属性是外码，它是：职工关系的部门号" class="headerlink" title="11. 在下面的两个关系中，职工号和部门号分别为职工关系和部门关系的主码。在这两个关系的属性中，只有一个属性是外码，它是：职工关系的部门号"></a>11. 在下面的两个关系中，职工号和部门号分别为职工关系和部门关系的主码。在这两个关系的属性中，只有一个属性是外码，它是：职工关系的部门号</h3><blockquote>
<p>职工（职工号、职工名、部门号、职务、工资）<br>部门（部门号、部门名、部门人数、工资总额）</p>
</blockquote>
<hr>
<h3 id="12-将查询SC表的权限授予用户U，并允许这个用户有转授权，其SQL语句是：GRANT-SELECT-ON-SC-TO-U-WITH-GRANT-OPTION"><a href="#12-将查询SC表的权限授予用户U，并允许这个用户有转授权，其SQL语句是：GRANT-SELECT-ON-SC-TO-U-WITH-GRANT-OPTION" class="headerlink" title="12. 将查询SC表的权限授予用户U，并允许这个用户有转授权，其SQL语句是：GRANT SELECT ON SC TO U WITH GRANT OPTION"></a>12. 将查询SC表的权限授予用户U，并允许这个用户有转授权，其SQL语句是：<code>GRANT SELECT ON SC TO U WITH GRANT OPTION</code></h3><hr>
<h3 id="13-要保证数据库的逻辑独立性，需要修改的是：模式与外模式之间的映射"><a href="#13-要保证数据库的逻辑独立性，需要修改的是：模式与外模式之间的映射" class="headerlink" title="13. 要保证数据库的逻辑独立性，需要修改的是：模式与外模式之间的映射"></a>13. 要保证数据库的逻辑独立性，需要修改的是：模式与外模式之间的映射</h3><ul>
<li>分析详见问答题2</li>
</ul>
<hr>
<h3 id="14-在DBS中，DBMS和OS之间的关系是：DBMS调用OS"><a href="#14-在DBS中，DBMS和OS之间的关系是：DBMS调用OS" class="headerlink" title="14. 在DBS中，DBMS和OS之间的关系是：DBMS调用OS"></a>14. 在DBS中，DBMS和OS之间的关系是：DBMS调用OS</h3><ul>
<li>DBMS是位于用户与操作系统之间的一层数据管理软件，安装在OS之上的，必须调用OS才能将命令送入裸机执行；</li>
<li>DBMS的数据管理可以用OS的文件管理，也可以向OS申请空间自己管理；</li>
<li>两者都是系统软件，不过OS更底层</li>
</ul>
<hr>
<h3 id="15-如果关系R中有4个属性和3个元组，关系S中有3个属性和5个元组，则R×S的属性个数和元组个数分别是：7和15"><a href="#15-如果关系R中有4个属性和3个元组，关系S中有3个属性和5个元组，则R×S的属性个数和元组个数分别是：7和15" class="headerlink" title="15. 如果关系R中有4个属性和3个元组，关系S中有3个属性和5个元组，则R×S的属性个数和元组个数分别是：7和15"></a>15. 如果关系R中有4个属性和3个元组，关系S中有3个属性和5个元组，则R×S的属性个数和元组个数分别是：7和15</h3><ul>
<li>笛卡尔积的列数为m+n，本题中为4+3&#x3D;7；</li>
<li>笛卡尔积的元组数为k1×k2，本题中为3×5&#x3D;15</li>
</ul>
<hr>
<h3 id="16-一个m-n联系转换为一个关系模式。关系的码为：各实体码的组合"><a href="#16-一个m-n联系转换为一个关系模式。关系的码为：各实体码的组合" class="headerlink" title="16. 一个m:n联系转换为一个关系模式。关系的码为：各实体码的组合"></a>16. 一个m:n联系转换为一个关系模式。关系的码为：各实体码的组合</h3><ul>
<li>实体之间的联系类型有：1:1，1:n，m:n三种</li>
<li>没看懂，留个坑，回头补，参考《数据库系统概论》第4版（王珊 萨师煊）P225页</li>
</ul>
<hr>
<h3 id="17-恢复和并发控制的基本单位是：事务"><a href="#17-恢复和并发控制的基本单位是：事务" class="headerlink" title="17. 恢复和并发控制的基本单位是：事务"></a>17. 恢复和并发控制的基本单位是：事务</h3><ul>
<li>事务是恢复和并发控制的基本单位</li>
<li>保证事务ACID特性是事务管理的重要任务。事务ACID特性遭到破坏的因素有：<ol>
<li>多个事务并行运行时，不同事务的操作交叉执行；</li>
<li>事务在运行过程中被强行停止。</li>
</ol>
</li>
<li>为了降低以上两种情况的影响，DBMS设立了恢复机制和并发控制机制</li>
</ul>
<hr>
<h3 id="18-假设有如下事务：T1：在检查点之前提交；T2：在检查点之前开始执行，在检查点之后故障点之前提交；T3：在检查点之前开始执行，在故障点时还未完成；T4：在检查点之后开始执行，在故障点之前提交；T5：在检查点之后开始执行，在故障点时还未完成。在利用具有检查点的恢复技术进行恢复时，需要REDO的是：T2和T4"><a href="#18-假设有如下事务：T1：在检查点之前提交；T2：在检查点之前开始执行，在检查点之后故障点之前提交；T3：在检查点之前开始执行，在故障点时还未完成；T4：在检查点之后开始执行，在故障点之前提交；T5：在检查点之后开始执行，在故障点时还未完成。在利用具有检查点的恢复技术进行恢复时，需要REDO的是：T2和T4" class="headerlink" title="18. 假设有如下事务：T1：在检查点之前提交；T2：在检查点之前开始执行，在检查点之后故障点之前提交；T3：在检查点之前开始执行，在故障点时还未完成；T4：在检查点之后开始执行，在故障点之前提交；T5：在检查点之后开始执行，在故障点时还未完成。在利用具有检查点的恢复技术进行恢复时，需要REDO的是：T2和T4"></a>18. 假设有如下事务：T1：在检查点之前提交；T2：在检查点之前开始执行，在检查点之后故障点之前提交；T3：在检查点之前开始执行，在故障点时还未完成；T4：在检查点之后开始执行，在故障点之前提交；T5：在检查点之后开始执行，在故障点时还未完成。在利用具有检查点的恢复技术进行恢复时，需要REDO的是：T2和T4</h3><ul>
<li>参考本卷问答题第5题的解析</li>
</ul>
<hr>
<h3 id="19-下面的结论不正确的是：D"><a href="#19-下面的结论不正确的是：D" class="headerlink" title="19. 下面的结论不正确的是：D"></a>19. 下面的结论不正确的是：D</h3><blockquote>
<p>A. 若R.A-&gt;R.B，R.B-&gt;R.C 则R.A-&gt;R.C<br>B. 若R.A-&gt;R.B，R.A-&gt;R.C 则R.A-&gt;R.(B,C)<br>C. 若R.B-&gt;R.A，R.C-&gt;R.A 则R.(B,C)-&gt;R.A<br>D. 若R.(B,C)-&gt;R.A则R.B-&gt;R.A，R.C-&gt;R.A</p>
</blockquote>
<p>easy  解略  </p>
<hr>
<h3 id="20-已知有关系模型R（sno-sname-age），其中sno表示学生的学号，类型Char-8-，前4位表示入学年份。查询所有2003年入学的学生姓名（sname），SQL语句是：SELECT-sname-FROM-R-WHERE-sno-LIKE-39-2003-39"><a href="#20-已知有关系模型R（sno-sname-age），其中sno表示学生的学号，类型Char-8-，前4位表示入学年份。查询所有2003年入学的学生姓名（sname），SQL语句是：SELECT-sname-FROM-R-WHERE-sno-LIKE-39-2003-39" class="headerlink" title="20. 已知有关系模型R（sno,sname,age），其中sno表示学生的学号，类型Char(8)，前4位表示入学年份。查询所有2003年入学的学生姓名（sname），SQL语句是：SELECT sname FROM  R  WHERE sno LIKE &#39;2003%&#39;;"></a>20. 已知有关系模型R（sno,sname,age），其中sno表示学生的学号，类型Char(8)，前4位表示入学年份。查询所有2003年入学的学生姓名（sname），SQL语句是：<code>SELECT sname FROM  R  WHERE sno LIKE &#39;2003%&#39;;</code></h3><p>easy  解略  </p>
<hr>
<hr>
<h2 id="二-、判断题"><a href="#二-、判断题" class="headerlink" title="二 、判断题"></a>二 、判断题</h2><h3 id="1-SQL中的触发器机制是一种安全性控制机制"><a href="#1-SQL中的触发器机制是一种安全性控制机制" class="headerlink" title="1. SQL中的触发器机制是一种安全性控制机制"></a>1. SQL中的触发器机制是一种安全性控制机制</h3><ul>
<li>错。触发器定义之后，任何用户对表的增删改操作均由服务器自动激活相应的触发器，在DBMS核心层进行集中的完整性控制。</li>
</ul>
<h3 id="2-关系模式的各级范式之间满足的关系式1NF-∈-2NF-∈-3NF-∈-BCNF"><a href="#2-关系模式的各级范式之间满足的关系式1NF-∈-2NF-∈-3NF-∈-BCNF" class="headerlink" title="2. 关系模式的各级范式之间满足的关系式1NF ∈ 2NF ∈ 3NF ∈ BCNF"></a>2. 关系模式的各级范式之间满足的关系式1NF ∈ 2NF ∈ 3NF ∈ BCNF</h3><ul>
<li>错。5NF ∈ 4NF ∈ BCNF ∈ 3NF ∈ 2NF ∈ 1NF</li>
</ul>
<h3 id="3-关系代数、元组关系演算和域演算三种语言在表达能力上是完全等价的"><a href="#3-关系代数、元组关系演算和域演算三种语言在表达能力上是完全等价的" class="headerlink" title="3. 关系代数、元组关系演算和域演算三种语言在表达能力上是完全等价的"></a>3. 关系代数、元组关系演算和域演算三种语言在表达能力上是完全等价的</h3><ul>
<li>对。参考《数据库系统概论》第4版（王珊 萨师煊）P48页，原话。</li>
</ul>
<h3 id="4-在关系模式R中，函数依赖X-gt-Y的语义在R的某一关系中，若两个元组的X值相等，则Y也相等"><a href="#4-在关系模式R中，函数依赖X-gt-Y的语义在R的某一关系中，若两个元组的X值相等，则Y也相等" class="headerlink" title="4. 在关系模式R中，函数依赖X-&gt;Y的语义在R的某一关系中，若两个元组的X值相等，则Y也相等"></a>4. 在关系模式R中，函数依赖X-&gt;Y的语义在R的某一关系中，若两个元组的X值相等，则Y也相等</h3><ul>
<li>对。参见函数依赖的定义。参考《数据库系统概论》第4版（王珊 萨师煊）P172页</li>
</ul>
<h3 id="5-数据库设计时应遵循规范化原则，并且规范化程度与数据库性能成正比"><a href="#5-数据库设计时应遵循规范化原则，并且规范化程度与数据库性能成正比" class="headerlink" title="5. 数据库设计时应遵循规范化原则，并且规范化程度与数据库性能成正比"></a>5. 数据库设计时应遵循规范化原则，并且规范化程度与数据库性能成正比</h3><ul>
<li>错。规范化理论为数据库设计提供了理论的指南和工具，但仅仅是指南和工具。并不是规范化程度越高，模式就越好，而必须结合应用环境和现实世界的具体情况合理的选择数据库模式。</li>
</ul>
<h3 id="6-对于一个处理少量元组的用户事务，以元组为封锁粒度比较合适"><a href="#6-对于一个处理少量元组的用户事务，以元组为封锁粒度比较合适" class="headerlink" title="6. 对于一个处理少量元组的用户事务，以元组为封锁粒度比较合适"></a>6. 对于一个处理少量元组的用户事务，以元组为封锁粒度比较合适</h3><ul>
<li>对。</li>
<li>选择封锁粒度时应该同时考虑封锁开销和并发度两个因素。</li>
<li>需要处理大量元组的事务可以以关系为封锁粒度；</li>
<li>需要处理多个关系的大量元组的事务可以以数据库为封锁粒度；</li>
<li>处理少量元组的用户事务，以元组为封锁粒度比较合适</li>
</ul>
<h3 id="7-用SQL语言进行数据操作需要了解存取路径"><a href="#7-用SQL语言进行数据操作需要了解存取路径" class="headerlink" title="7. 用SQL语言进行数据操作需要了解存取路径"></a>7. 用SQL语言进行数据操作需要了解存取路径</h3><ul>
<li>错。物理独立性，无需了解存取路径</li>
</ul>
<h3 id="8-数据库中只存放视图的定义而不存放视图对应的数据"><a href="#8-数据库中只存放视图的定义而不存放视图对应的数据" class="headerlink" title="8. 数据库中只存放视图的定义而不存放视图对应的数据"></a>8. 数据库中只存放视图的定义而不存放视图对应的数据</h3><ul>
<li>对。视图跟基本表不同，它是虚表</li>
</ul>
<h3 id="9-无论在什么情况下，X-gt-Y都是非平凡函数依赖，而Y-gt-X都是平凡的函数依赖"><a href="#9-无论在什么情况下，X-gt-Y都是非平凡函数依赖，而Y-gt-X都是平凡的函数依赖" class="headerlink" title="9. 无论在什么情况下，X-&gt;Y都是非平凡函数依赖，而Y-&gt;X都是平凡的函数依赖"></a>9. 无论在什么情况下，X-&gt;Y都是非平凡函数依赖，而Y-&gt;X都是平凡的函数依赖</h3><ul>
<li>错。简直胡扯</li>
</ul>
<h3 id="10-要保证数据库的逻辑独立性，需要修改的是模式与内模之间的映射"><a href="#10-要保证数据库的逻辑独立性，需要修改的是模式与内模之间的映射" class="headerlink" title="10. 要保证数据库的逻辑独立性，需要修改的是模式与内模之间的映射"></a>10. 要保证数据库的逻辑独立性，需要修改的是模式与内模之间的映射</h3><ul>
<li>错。应该是外模式与模式的映射</li>
</ul>
<hr>
<hr>
<h2 id="三、问答题"><a href="#三、问答题" class="headerlink" title="三、问答题"></a>三、问答题</h2><h3 id="1-DBMS的功能有哪些？有哪些部分组成？"><a href="#1-DBMS的功能有哪些？有哪些部分组成？" class="headerlink" title="1. DBMS的功能有哪些？有哪些部分组成？"></a>1. DBMS的功能有哪些？有哪些部分组成？</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li>数据定义功能；</li>
<li>数据组织、存储和管理，包括安全性保护、完整性检查、并发控制、数据库恢复等功能；</li>
<li>数据操纵功能；</li>
<li>数据库的事务管理和运行管理；</li>
<li>数据库的建立和维护功能；</li>
<li>其他功能—— DBMS与其他软件系统的通信功能，数据转换功能等；</li>
</ol>
<h4 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h4><ul>
<li>数据库系统由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员组成</li>
</ul>
<hr>
<h3 id="2-简述数据库的三层模式和两级独立性，两级独立性是如何实现的？"><a href="#2-简述数据库的三层模式和两级独立性，两级独立性是如何实现的？" class="headerlink" title="2. 简述数据库的三层模式和两级独立性，两级独立性是如何实现的？"></a>2. 简述数据库的三层模式和两级独立性，两级独立性是如何实现的？</h3><h4 id="三层模式"><a href="#三层模式" class="headerlink" title="三层模式"></a>三层模式</h4><ul>
<li>三层模式是指数据库系统是由<strong>外模式、模式、内模式</strong>三级构成。</li>
<li>内模式——即存储模式，是数据在数据库内部的表示方式。例如，存储方式是堆存储，或某属性的升序存储，或属性值聚簇存储？索引按照B+树，还是Hash索引？数据是否压缩存储，是否加密等。一个数据库只有一个内模式。</li>
<li>模式——即逻辑模式，是三级模式的中间层，是数据库数据在逻辑级上的视图。定义模式时，不仅要定义数据的逻辑结构，例如数据记录由哪些数据项构成、数据项名字、类型、取值范围等，而且要定义与数据有关的安全性、完整性要求。一个数据库只有一个模式。</li>
<li>外模式——即子模式，是数据库用户能够看见并使用的数据视图，如果不同用户在应用需求、看待数据的方式、对数据保密的要求等方面存在差异，其外模式描述就是不同的。即使对同一数据，在外模式中的结构、类型、长度、保密级别都可以不同。但一个应用程序只能使用一个外模式。</li>
</ul>
<h4 id="两级独立性"><a href="#两级独立性" class="headerlink" title="两级独立性"></a>两级独立性</h4><ul>
<li><strong>物理独立性</strong>和<strong>逻辑独立性</strong>。</li>
<li>物理独立性指的是应用程序与数据存放在相互独立的磁盘地址，应用程序或数据的地址发生变化时都不影响对方，内模式与模式映像保证了其物理独立特性。</li>
<li>逻辑独立性指的数据与程序逻辑结构上的独立特性，数据或应用程序的逻辑结构发生变化性都不影响对方，外模式与模式映像保证了其逻辑独立性。</li>
</ul>
<h4 id="两级独立性的实现"><a href="#两级独立性的实现" class="headerlink" title="两级独立性的实现"></a>两级独立性的实现</h4><ul>
<li>两级独立性是通过二级映像功能来实现的。<ul>
<li><strong>外模式&#x2F;模式映像</strong></li>
<li><strong>模式&#x2F;内模式映像</strong></li>
</ul>
</li>
<li>外模式&#x2F;模式映像，一个模式可以有多个外模式，对应有多个此映像。当模式改变时（例如增加新的关系、属性或改变属性的数据类型等），由DBA对各个映像作相应改变，可以使外模式保持不变，从而应用程序不必修改，保证数据与程序的逻辑独立性。</li>
<li>模式&#x2F;内模式映像，此映像是唯一的，它定义了数据全局逻辑结构与存储结构之间的对应关系，当数据库的存储结构改变了，由DBA对此映像作相应改变，可以使模式保持不变，从而应用程序也不必改变，保证了数据与程序的物理独立性。</li>
</ul>
<hr>
<h3 id="3-事务有哪些重要性质？并对每个性质作简单描述"><a href="#3-事务有哪些重要性质？并对每个性质作简单描述" class="headerlink" title="3. 事务有哪些重要性质？并对每个性质作简单描述"></a>3. 事务有哪些重要性质？并对每个性质作简单描述</h3><h4 id="事务的性质"><a href="#事务的性质" class="headerlink" title="事务的性质"></a>事务的性质</h4><ul>
<li>事务具有<strong>原子性、一致性、隔离性、持续性</strong>，即ACID</li>
<li>原子性。事务中包含的诸操作要么都做，要么都不做。</li>
<li>一致性。与原子性密切相关，一个单独执行的事务应保证其执行结果的一致性。事务执行的结果是从一个一致性状态变到另一个一致性状态。如果数据库系统运行中发生故障，有些事务尚未完成就被迫中断，此时数据库处于不正确即不一致的状态。</li>
<li>隔离性。一个事务的执行不能被其他并发的事务干扰，即一个事务内部的操作及使用的数据对其他并发事务是隔离的。</li>
<li>持续性。即永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久的，即使随后系统出现故障也不会受到影响。</li>
</ul>
<hr>
<h3 id="4-设有关系R和S，计算R与S自然连接"><a href="#4-设有关系R和S，计算R与S自然连接" class="headerlink" title="4. 设有关系R和S，计算R与S自然连接"></a>4. 设有关系R和S，计算R与S自然连接</h3><table>
<thead>
<tr>
<th align="center">R</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center"></th>
<th align="center">S</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">b</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">c</td>
<td align="center">b</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">e</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">d</td>
<td align="center">e</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">b</td>
<td align="center">d</td>
</tr>
</tbody></table>
<p>  答案：</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">b</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">b</td>
<td align="center">d</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">e</td>
<td align="center">a</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-考虑事务T1、T2、T3的以下日志记录，假设系统刚好在最后一条日志记录之后就崩溃了，请指出在恢复过程中的重做事务集和撤销事务集？"><a href="#5-考虑事务T1、T2、T3的以下日志记录，假设系统刚好在最后一条日志记录之后就崩溃了，请指出在恢复过程中的重做事务集和撤销事务集？" class="headerlink" title="5. 考虑事务T1、T2、T3的以下日志记录，假设系统刚好在最后一条日志记录之后就崩溃了，请指出在恢复过程中的重做事务集和撤销事务集？"></a>5. 考虑事务T1、T2、T3的以下日志记录，假设系统刚好在最后一条日志记录之后就崩溃了，请指出在恢复过程中的重做事务集和撤销事务集？</h3><blockquote>
<p>&lt;T1,start&gt;<br>  &lt;T1,B,10,20&gt;<br>  &lt;T2,start&gt;<br>  &lt;T1,commit&gt;<br>  &lt;T2,C,0,20&gt;<br>  &lt;T3,start&gt;<br>  &lt;T3,B,10,20&gt;<br>  &lt;checkpoint{T2,T3,T4}&gt;(检查点时刻)<br>  &lt;T3,C,10,20&gt;<br>  &lt;T4,start&gt;<br>  &lt;T3,commit&gt;<br>  &lt;T4,D,10,0&gt;<br>  &lt;T4,commit&gt;</p>
</blockquote>
<p>分析：系统崩溃发生的是系统故障，此时缓存丢失。</p>
<ol>
<li>数据库为了提高性能，数据页在内存修改后并不是每次都会刷到磁盘上。checkpoint之前的数据页保证一定落盘了，这样之前的日志就没有用了，允许被覆盖</li>
<li>正向扫描日志文件，找到既有begin又有commit的 事务标记计入redo队列；找到仅有begin而无commit的事务计入undo队列；</li>
<li>反向扫描日志文件，对undo队列标记的事务执行逆操作，将日志记录更新前的值写入DB；</li>
<li>正向扫描日志文件，将日志记录更新后的值写入DB中</li>
<li>T1在checkpoint之前完成commit，无需理会；</li>
<li>T2在checkpoint时未commit，系统故障前仍未commit，所以在undo队列；</li>
<li>T3在checkpoint时未commit，系统故障前commit，所以在redo队列；</li>
<li>T4在checkpoint时未start，系统故障前start并commit，所以在redo队列；</li>
</ol>
<p>答案：REDO队列中有T3和T4，UNDO队列中有T2.</p>
<hr>
<h3 id="6-试简要叙述数据库设计的全过程包括哪些阶段？"><a href="#6-试简要叙述数据库设计的全过程包括哪些阶段？" class="headerlink" title="6. 试简要叙述数据库设计的全过程包括哪些阶段？"></a>6. 试简要叙述数据库设计的全过程包括哪些阶段？</h3><ol>
<li>需求分析阶段。准确了解和分析用户需求，包括数据与处理。</li>
<li>概念结构设计阶段。对用户需求进行综合、归纳与抽象。</li>
<li>逻辑结构设计阶段。将概念结构转换为某个DBMS所支持的数据模型，并优化。</li>
<li>物理设计阶段。为逻辑数据模型选取一个最适合应用环境的物理结构，包括存储结构和存取方法。</li>
<li>数据库实施阶段。运用SQL等语言，建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</li>
<li>数据库运行和维护阶段。正式运行时不断的评价、调整和修改。</li>
</ol>
<hr>
<h3 id="7-什么是日志文件，为什么登记日志时必须先写日志后写数据库？"><a href="#7-什么是日志文件，为什么登记日志时必须先写日志后写数据库？" class="headerlink" title="7. 什么是日志文件，为什么登记日志时必须先写日志后写数据库？"></a>7. 什么是日志文件，为什么登记日志时必须先写日志后写数据库？</h3><h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><ul>
<li>用来记录事务对数据库的更新操作的文件，主要有两种格式：<ol>
<li>以记录为单位的日志文件</li>
<li>以数据块为单位的日志文件</li>
</ol>
</li>
<li>登记日志必须遵守两条原则：<ol>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库</li>
</ol>
</li>
</ul>
<h4 id="为什么先写日志后写数据库"><a href="#为什么先写日志后写数据库" class="headerlink" title="为什么先写日志后写数据库?"></a>为什么先写日志后写数据库?</h4><ul>
<li>把对数据的修改写到数据库中和把表示这个修改的日志记录写到日志文件中是两个不同的操作，有可能在两个操作之间出现故障。</li>
<li>如果先写了数据库修改，而因为故障没在运行记录中登记这个修改，那么以后将无法恢复这个修改了。</li>
<li>如果先写日志但因为故障没有修改数据库，按日志文件恢复时只不过多执行一次不必要的UNDO操作，并不会影响数据库的正确性。</li>
<li>所以为了安全，首先把日志记录写到日志文件中，然后写数据库的修改。</li>
</ul>
<hr>
<h3 id="8-设教学数据库中有三个基本表，请用SQL语句表达下列查询。"><a href="#8-设教学数据库中有三个基本表，请用SQL语句表达下列查询。" class="headerlink" title="8.设教学数据库中有三个基本表，请用SQL语句表达下列查询。"></a>8.设教学数据库中有三个基本表，请用SQL语句表达下列查询。</h3><blockquote>
<p>学生表S(S#,SNAME,AGE,SEX)<br>选课表SC(S#,C#,GRADE)<br>课程表C(C#,CNAME,TEACHER)</p>
</blockquote>
<h4 id="1-查询数据库课程成绩在90分以上的学生姓名"><a href="#1-查询数据库课程成绩在90分以上的学生姓名" class="headerlink" title="(1)查询数据库课程成绩在90分以上的学生姓名"></a>(1)查询数据库课程成绩在90分以上的学生姓名</h4>  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SELECT</span> SNAME </span><br><span class="line">FROM S </span><br><span class="line"><span class="built_in">WHERE</span> S<span class="comment"># IN </span></span><br><span class="line">    (<span class="built_in">SELECT</span> S<span class="comment"># </span></span><br><span class="line">    FROM <span class="built_in">SC</span> </span><br><span class="line">    <span class="built_in">WHERE</span> GRADE &gt; <span class="number">90</span> AND C<span class="comment"># = </span></span><br><span class="line">        (<span class="built_in">SELECT</span> C<span class="comment"># </span></span><br><span class="line">        FROM C </span><br><span class="line">        <span class="built_in">WHERE</span> CNAME = <span class="string">&quot;数据库&quot;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="2-查询年龄大于23的女学生的学号和姓名"><a href="#2-查询年龄大于23的女学生的学号和姓名" class="headerlink" title="(2)查询年龄大于23的女学生的学号和姓名"></a>(2)查询年龄大于23的女学生的学号和姓名</h4>  <figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SELECT</span> S<span class="meta">#,SNAME</span></span><br><span class="line">FROM S</span><br><span class="line"><span class="built_in">WHERE</span> SEX  = <span class="string">&quot;女” AND AGE &gt; 23;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-查询”李梅”学生所学课程的课程名与任课老师名"><a href="#3-查询”李梅”学生所学课程的课程名与任课老师名" class="headerlink" title="(3)查询”李梅”学生所学课程的课程名与任课老师名"></a>(3)查询”李梅”学生所学课程的课程名与任课老师名</h4>  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SELECT</span> CNAME,TEACHER</span><br><span class="line">FROM C</span><br><span class="line"><span class="built_in">WHERE</span> C<span class="comment"># IN </span></span><br><span class="line">    (<span class="built_in">SELECT</span> C<span class="comment"># </span></span><br><span class="line">    FROM <span class="built_in">SC</span></span><br><span class="line">    <span class="built_in">WHERE</span> S<span class="comment"># = </span></span><br><span class="line">        (<span class="built_in">SELECT</span> S<span class="comment">#</span></span><br><span class="line">        FROM S</span><br><span class="line">        <span class="built_in">WHERE</span> SNAME = <span class="string">&quot;李梅&quot;</span>));</span><br></pre></td></tr></table></figure>
<hr>
<hr>
<h2 id="四、综合题"><a href="#四、综合题" class="headerlink" title="四、综合题"></a>四、综合题</h2><h3 id="1-设关系模式R（ABCD），R上的FD集F-x3D-A-gt-B-B-gt-C-A-gt-D-D-gt-C-ρ-x3D-AB-AC-BD-是R的一个分解。"><a href="#1-设关系模式R（ABCD），R上的FD集F-x3D-A-gt-B-B-gt-C-A-gt-D-D-gt-C-ρ-x3D-AB-AC-BD-是R的一个分解。" class="headerlink" title="1. 设关系模式R（ABCD），R上的FD集F&#x3D;{A-&gt;B,B-&gt;C,A-&gt;D,D-&gt;C},ρ&#x3D;{AB,AC,BD}是R的一个分解。"></a>1. 设关系模式R（ABCD），R上的FD集F&#x3D;{A-&gt;B,B-&gt;C,A-&gt;D,D-&gt;C},ρ&#x3D;{AB,AC,BD}是R的一个分解。</h3><h4 id="1-相对于F，ρ是无损分解吗？"><a href="#1-相对于F，ρ是无损分解吗？" class="headerlink" title="(1)相对于F，ρ是无损分解吗？"></a>(1)相对于F，ρ是无损分解吗？</h4><ul>
<li>不是无损分解</li>
<li>推荐阅读：<a href="https://www.cnblogs.com/3013218061shang/p/5573461.html">模式分解—无损连接性的判断方法（转）</a></li>
<li>具体步骤如下 ：</li>
</ul>
<ol>
<li>步骤一，最初</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AB</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center">b13</td>
<td align="center">b14</td>
</tr>
<tr>
<td align="center">AC</td>
<td align="center">a1</td>
<td align="center">b22</td>
<td align="center">a3</td>
<td align="center">b24</td>
</tr>
<tr>
<td align="center">BD</td>
<td align="center">b31</td>
<td align="center">a2</td>
<td align="center">b33</td>
<td align="center">a4</td>
</tr>
</tbody></table>
<ol start="2">
<li>步骤二 ，开始一次扫描，A-&gt;B后</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AB</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center">b13</td>
<td align="center">b14</td>
</tr>
<tr>
<td align="center">AC</td>
<td align="center">a1</td>
<td align="center"><strong>a2</strong></td>
<td align="center">a3</td>
<td align="center">b24</td>
</tr>
<tr>
<td align="center">BD</td>
<td align="center">b31</td>
<td align="center">a2</td>
<td align="center">b33</td>
<td align="center">a4</td>
</tr>
</tbody></table>
<ol start="3">
<li>步骤三，B-&gt;C后</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AB</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center"><strong>a3</strong></td>
<td align="center">b14</td>
</tr>
<tr>
<td align="center">AC</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center">a3</td>
<td align="center">b24</td>
</tr>
<tr>
<td align="center">BD</td>
<td align="center">b31</td>
<td align="center">a2</td>
<td align="center"><strong>a3</strong></td>
<td align="center">a4</td>
</tr>
</tbody></table>
<ol start="4">
<li>步骤四，A-&gt;D后</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AB</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center">a3</td>
<td align="center">b14</td>
</tr>
<tr>
<td align="center">AC</td>
<td align="center">a1</td>
<td align="center">a2</td>
<td align="center">a3</td>
<td align="center"><strong>b14</strong></td>
</tr>
<tr>
<td align="center">BD</td>
<td align="center">b31</td>
<td align="center">a2</td>
<td align="center">a3</td>
<td align="center"><strong>b14</strong></td>
</tr>
</tbody></table>
<ol start="5">
<li>步骤五，D-&gt;C后无变化，一次扫描结束，但扫描前后表发生了变化</li>
<li>步骤六 ，开始二次扫描，A-&gt;B后，B-&gt;C后，A-&gt;D后，D-&gt;C后，结束二次扫描，扫描前后并无变化，也未得到某行成为(a1,a2,…,an)的结果</li>
<li>以上说明有损</li>
</ol>
<h4 id="2-求F在ρ的每个子模式上的投影？ρ是否保持FD？"><a href="#2-求F在ρ的每个子模式上的投影？ρ是否保持FD？" class="headerlink" title="(2)求F在ρ的每个子模式上的投影？ρ是否保持FD？"></a>(2)求F在ρ的每个子模式上的投影？ρ是否保持FD？</h4><ul>
<li><p>F在AB上的投影为{A-&gt;B}</p>
</li>
<li><p>F在AC上的投影为{A-&gt;C}</p>
</li>
<li><p>F在BD上的投影为空</p>
</li>
<li><p>ρ不能保持FD</p>
</li>
</ul>
<hr>
<h3 id="2-现有如下关系模式：其中，Teacher（Tno-Tame-Tel-department，Bno-Bname-BorrowDate-Rdate-Backup）。Tno——教师编号-Tame——教师姓名-Tel——电话-department——所在部门，Bno——借阅图书编号-Bname——书名-BorrowDate——借书日期-Rdate——还书日期-Backup——备注。该关系模式的属性之间具有通常的语义，例如：教师编号函数决定教师姓名，即教师编号是惟一的，图书编号是惟一的，等等。请回答下述问题："><a href="#2-现有如下关系模式：其中，Teacher（Tno-Tame-Tel-department，Bno-Bname-BorrowDate-Rdate-Backup）。Tno——教师编号-Tame——教师姓名-Tel——电话-department——所在部门，Bno——借阅图书编号-Bname——书名-BorrowDate——借书日期-Rdate——还书日期-Backup——备注。该关系模式的属性之间具有通常的语义，例如：教师编号函数决定教师姓名，即教师编号是惟一的，图书编号是惟一的，等等。请回答下述问题：" class="headerlink" title="2.现有如下关系模式：其中，Teacher（Tno,Tame,Tel,department，Bno,Bname,BorrowDate,Rdate,Backup）。Tno——教师编号,Tame——教师姓名,Tel——电话,department——所在部门，Bno——借阅图书编号,Bname——书名,BorrowDate——借书日期,Rdate——还书日期,Backup——备注。该关系模式的属性之间具有通常的语义，例如：教师编号函数决定教师姓名，即教师编号是惟一的，图书编号是惟一的，等等。请回答下述问题："></a>2.现有如下关系模式：其中，Teacher（Tno,Tame,Tel,department，Bno,Bname,BorrowDate,Rdate,Backup）。Tno——教师编号,Tame——教师姓名,Tel——电话,department——所在部门，Bno——借阅图书编号,Bname——书名,BorrowDate——借书日期,Rdate——还书日期,Backup——备注。该关系模式的属性之间具有通常的语义，例如：教师编号函数决定教师姓名，即教师编号是惟一的，图书编号是惟一的，等等。请回答下述问题：</h3><h4 id="1-教师编号是候选码吗？说明判断理由"><a href="#1-教师编号是候选码吗？说明判断理由" class="headerlink" title="(1)教师编号是候选码吗？说明判断理由"></a>(1)教师编号是候选码吗？说明判断理由</h4><ul>
<li>不是，教师编号无法唯一标识此元组，因为事实允许同一名教师借阅多本图书</li>
</ul>
<h4 id="2-写出该关系模式的主码"><a href="#2-写出该关系模式的主码" class="headerlink" title="(2)写出该关系模式的主码"></a>(2)写出该关系模式的主码</h4><ul>
<li>主码是（教师编号Tno、借阅图书编号Bno、借书日期）</li>
</ul>
<h4 id="3-该关系模式中是否存在部分函数依赖？如果存在，请写出其中两个"><a href="#3-该关系模式中是否存在部分函数依赖？如果存在，请写出其中两个" class="headerlink" title="(3)该关系模式中是否存在部分函数依赖？如果存在，请写出其中两个"></a>(3)该关系模式中是否存在部分函数依赖？如果存在，请写出其中两个</h4><ul>
<li>主码和教师姓名是部分函数依赖；</li>
<li>主码和书名是部分函数依赖；</li>
<li>主码和所在部门是部分函数依赖</li>
<li>etc</li>
</ul>
<h4 id="4-该关系模式最高满足第几范式？并说明理由。"><a href="#4-该关系模式最高满足第几范式？并说明理由。" class="headerlink" title="(4)该关系模式最高满足第几范式？并说明理由。"></a>(4)该关系模式最高满足第几范式？并说明理由。</h4><ul>
<li>存在非主属性对主码的部分依赖，所以不能是2NF或更高，故此关系模式最高为1NF</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统概论练习题之二</title>
    <url>/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="数据库第二套卷"><a href="#数据库第二套卷" class="headerlink" title="数据库第二套卷"></a>数据库第二套卷</h1><h2 id="一、选择题"><a href="#一、选择题" class="headerlink" title="一、选择题"></a>一、选择题</h2><h3 id="1-建立两个表的一对多联系，是通过什么索引实现的：“一方”表的主索引或候选索引；“多方”表的普通索引"><a href="#1-建立两个表的一对多联系，是通过什么索引实现的：“一方”表的主索引或候选索引；“多方”表的普通索引" class="headerlink" title="1. 建立两个表的一对多联系，是通过什么索引实现的：“一方”表的主索引或候选索引；“多方”表的普通索引"></a>1. 建立两个表的一对多联系，是通过什么索引实现的：“一方”表的主索引或候选索引；“多方”表的普通索引</h3><p>一方的主键作为多方的外键</p>
<hr>
<h3 id="2-设有关系R1和R2，经过关系运算得到结果S，则S是：一个关系"><a href="#2-设有关系R1和R2，经过关系运算得到结果S，则S是：一个关系" class="headerlink" title="2. 设有关系R1和R2，经过关系运算得到结果S，则S是：一个关系"></a>2. 设有关系R1和R2，经过关系运算得到结果S，则S是：一个关系</h3><hr>
<h3 id="3-使用CREATE-SCHEMA语句建立的是：数据库模式"><a href="#3-使用CREATE-SCHEMA语句建立的是：数据库模式" class="headerlink" title="3. 使用CREATE SCHEMA语句建立的是：数据库模式"></a>3. 使用CREATE SCHEMA语句建立的是：数据库模式</h3><ul>
<li>数据模型有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</li>
<li>schema只涉及型的描述，不涉及具体的值。</li>
</ul>
<span id="more"></span>


<hr>
<h3 id="4-能够消除冗余的键的范式是：4NF"><a href="#4-能够消除冗余的键的范式是：4NF" class="headerlink" title="4. 能够消除冗余的键的范式是：4NF"></a>4. 能够消除冗余的键的范式是：4NF</h3><hr>
<h3 id="5-全局E-R模型的设计，需要消除属性冲突、命名冲突和：结构冲突"><a href="#5-全局E-R模型的设计，需要消除属性冲突、命名冲突和：结构冲突" class="headerlink" title="5. 全局E-R模型的设计，需要消除属性冲突、命名冲突和：结构冲突"></a>5. 全局E-R模型的设计，需要消除属性冲突、命名冲突和：结构冲突</h3><ul>
<li>属性冲突：包括类型、取值范围、取值单位的冲突；</li>
<li>结构冲突：例如同一对象在一个局部E-R图中作为实体，而在另一个局部E-R图中作为属性，同一实体在不同的E-R图中的属性个数和类型不同等；</li>
<li>命名冲突：包括实体类型名、联系类型名之间异名同义，或同名异义等。</li>
</ul>
<hr>
<h3 id="6-数据库概念设计的E-R方法中，用属性描述实体的特征，属性在E-R图中，用什么表示：椭圆形"><a href="#6-数据库概念设计的E-R方法中，用属性描述实体的特征，属性在E-R图中，用什么表示：椭圆形" class="headerlink" title="6. 数据库概念设计的E-R方法中，用属性描述实体的特征，属性在E-R图中，用什么表示：椭圆形"></a>6. 数据库概念设计的E-R方法中，用属性描述实体的特征，属性在E-R图中，用什么表示：椭圆形</h3><p>实体–矩形； 属性–椭圆形； 关系–菱形</p>
<hr>
<h3 id="7-视图设计一般有-3-种设计次序，属于视图设计的有：自顶而下、自底而上、由里向外"><a href="#7-视图设计一般有-3-种设计次序，属于视图设计的有：自顶而下、自底而上、由里向外" class="headerlink" title="7. 视图设计一般有 3 种设计次序，属于视图设计的有：自顶而下、自底而上、由里向外"></a>7. 视图设计一般有 3 种设计次序，属于视图设计的有：自顶而下、自底而上、由里向外</h3><p>通常有如下几种方法： </p>
<ol>
<li>自顶向下。先全局框架，然后逐步细化 </li>
<li>自底向上。先局部概念结构，再集成为全局结构 </li>
<li>由里向外。先核心结构，再向外扩张 </li>
<li>混合策略。1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构</li>
</ol>
<hr>
<h3 id="8-在下列的-SQL-语句中，属于数据控制的是：di"><a href="#8-在下列的-SQL-语句中，属于数据控制的是：di" class="headerlink" title="8. 在下列的 SQL 语句中，属于数据控制的是：di"></a>8. 在下列的 SQL 语句中，属于数据控制的是：di</h3><blockquote>
<p>a、CREATE  b、SELECT  c、UPDATE  d、GRANT  e、DROP f、DELETE g、ALTER h、INSERT i、REVOKE</p>
</blockquote>
<ul>
<li>查询：SELECT</li>
<li>操纵：UPDATE，INSERT，DELETE</li>
<li>定义：CREATE，DROP</li>
<li>控制：COMMIT，ROLLBACK，GRANT等</li>
</ul>
<hr>
<h3 id="9-声明一个名为books-cursor的游标-和名为-book-name的游标变量，以下是正确语句：fetch-next-from-books-cursor-into-book-name"><a href="#9-声明一个名为books-cursor的游标-和名为-book-name的游标变量，以下是正确语句：fetch-next-from-books-cursor-into-book-name" class="headerlink" title="9. 声明一个名为books_cursor的游标,和名为@book_name的游标变量，以下是正确语句：fetch next from books_cursor into @book_name"></a>9. 声明一个名为books_cursor的游标,和名为@book_name的游标变量，以下是正确语句：<code>fetch next from books_cursor into @book_name</code></h3><ul>
<li><p>游标向下移动一行，获取的数据存入定义的游标变量里。可参考代码实例：<a href="https://www.cnblogs.com/SparkOng/p/4971518.html">SQL Cursor 基本用法</a></p>
</li>
<li><p>游标和主变量的存在是为了实现嵌入式SQL与主语言（比如JAVA、C++等）的通信。</p>
</li>
<li><p>主变量：SQL语句使用的主语言的程序变量简称为主变量。</p>
</li>
<li><p>SQL是面向集合的，主语言是面向记录的，所以引入游标来协调。应用程序可以根据需要滚动或浏览其中的数据。</p>
</li>
<li><p>游标是系统为用户开设的一个数据缓冲区，存放SQL的执行结果，每一个游标区都有一个名字。用户可以通过游标逐一获取记录，并赋值给主变量，交由主语言进一步处理。</p>
</li>
<li><p>使用游标的步骤：</p>
<ol>
<li>使用游标前必须声明；没有检索，但要定义要使用的select语句；</li>
<li>一旦声明后，必须打开游标以供使用，用步骤1定义的select语句把数据实际检索出来；</li>
<li>对于填有数据的游标，根据需要取出各行；</li>
<li>结束游标的使用时，必须关闭游标。</li>
</ol>
</li>
<li><p>游标变量是一个指针，在运行时刻与不同的SQL语句关联，在运行时取不同的SQL语句，可以引用不同的工作区</p>
</li>
</ul>
<p><img src="/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/1.png" alt="cursor"></p>
<hr>
<h3 id="10-以下属于RDBMS的是-postgresql、mysql、oracle"><a href="#10-以下属于RDBMS的是-postgresql、mysql、oracle" class="headerlink" title="10. 以下属于RDBMS的是:postgresql、mysql、oracle"></a>10. 以下属于RDBMS的是:postgresql、mysql、oracle</h3><ul>
<li>RDBMS即关系数据库管理系统(Relational Database Management System) 。是SQL 的基础，同样也是所有现代数据库系统的基础，比如MS SQL Server, IBM DB2, Oracle, MySQL 以及Microsoft Access。</li>
<li>Hadoop是分布式数据库。</li>
</ul>
<hr>
<h3 id="11-下列数据模型中，数据独立性最高的是：B"><a href="#11-下列数据模型中，数据独立性最高的是：B" class="headerlink" title="11. 下列数据模型中，数据独立性最高的是：B"></a>11. 下列数据模型中，数据独立性最高的是：B</h3><blockquote>
<p>A. 网状数据模型<br>B. 关系数据模型<br>C. 层次数据模型<br>D. 非关系模型</p>
</blockquote>
<p>关系数据库系统提供三级模式与二级映像，可以实现数据库的逻辑独立性与物理独立性，因而具有最高的数据独立性。</p>
<hr>
<h3 id="12-下列关于数据库执行SQL语句的操作步骤描述正确的是：D"><a href="#12-下列关于数据库执行SQL语句的操作步骤描述正确的是：D" class="headerlink" title="12. 下列关于数据库执行SQL语句的操作步骤描述正确的是：D"></a>12. 下列关于数据库执行SQL语句的操作步骤描述正确的是：D</h3><blockquote>
<p>A. 解析并编译SQL语句<br>B. 确定并优化数据获取路径<br>C. 执行SQL，获取并返回数据<br>D. 以上都正确</p>
</blockquote>
<p>sql语句本质上就好比一个java文件，都是要经历先解析编译后，处理优化，最后执行返回结果的过程</p>
<hr>
<h3 id="13-用于连接两个字符串的运算符是-amp"><a href="#13-用于连接两个字符串的运算符是-amp" class="headerlink" title="13. 用于连接两个字符串的运算符是: &amp;"></a>13. 用于连接两个字符串的运算符是: &amp;</h3><ul>
<li>连接运算符主要用于连接字符串，其运算符有两个：+，&amp;;</li>
<li>&amp;用来强调两个表达式作为字符串连接，如“hello”&amp;23&amp;”word”，结果为“hello23word”</li>
<li>+连接两个字符串，要求+两端的类型必须一致，如“hello”+23+”word”，结果会报错“类型不匹配”</li>
<li>因此一般使用&amp;连接两个字符串</li>
</ul>
<hr>
<h3 id="14-在SQL的授权语句中使用“ALL-PRIVILEGES”，表示：所有的操作权限"><a href="#14-在SQL的授权语句中使用“ALL-PRIVILEGES”，表示：所有的操作权限" class="headerlink" title="14. 在SQL的授权语句中使用“ALL PRIVILEGES”，表示：所有的操作权限"></a>14. 在SQL的授权语句中使用“ALL PRIVILEGES”，表示：所有的操作权限</h3><hr>
<h3 id="15-R为4元关系R（A，B，C，D），S为3元关系S（B，C，D），则R×S构成的结果集为几元关系：七元。"><a href="#15-R为4元关系R（A，B，C，D），S为3元关系S（B，C，D），则R×S构成的结果集为几元关系：七元。" class="headerlink" title="15. R为4元关系R（A，B，C，D），S为3元关系S（B，C，D），则R×S构成的结果集为几元关系：七元。"></a>15. R为4元关系R（A，B，C，D），S为3元关系S（B，C，D），则R×S构成的结果集为几元关系：七元。</h3><p>RS（A,B,C,D,B,C,D）</p>
<hr>
<h3 id="16-规范化过程主要是为解决数据库逻辑结构中的插入异常、删除异常和：冗余度大"><a href="#16-规范化过程主要是为解决数据库逻辑结构中的插入异常、删除异常和：冗余度大" class="headerlink" title="16. 规范化过程主要是为解决数据库逻辑结构中的插入异常、删除异常和：冗余度大"></a>16. 规范化过程主要是为解决数据库逻辑结构中的插入异常、删除异常和：冗余度大</h3><hr>
<h3 id="17-假设关系模式R属于3NF：仍存在一定的插入和删除异常"><a href="#17-假设关系模式R属于3NF：仍存在一定的插入和删除异常" class="headerlink" title="17. 假设关系模式R属于3NF：仍存在一定的插入和删除异常"></a>17. 假设关系模式R属于3NF：仍存在一定的插入和删除异常</h3><p>若关系模型R∈2NF，且每一个非主属性都不传递于码（任何非主属性不依赖于其他非主属性），则R∈ 3NF。3NF就是不允许关系模式的属性之间有这样的非平凡的函数依赖X→Y，其中X不包括码，Y是非主属性。X不包含有两种情况，一种情况X是码的真子集，这是2NF不允许，另一种情况X不是码的真子集，这是3NF不允许的。在3NF中，仍存在一定的插入和删除异常。</p>
<hr>
<h3 id="18-设有关系：教师（教师号、姓名、职称、基本工资），已知不同职称的基本工资不同，将该关系规范到第三范式为：教师1（教师号、姓名、职称），教师2（职称、基本工资）"><a href="#18-设有关系：教师（教师号、姓名、职称、基本工资），已知不同职称的基本工资不同，将该关系规范到第三范式为：教师1（教师号、姓名、职称），教师2（职称、基本工资）" class="headerlink" title="18. 设有关系：教师（教师号、姓名、职称、基本工资），已知不同职称的基本工资不同，将该关系规范到第三范式为：教师1（教师号、姓名、职称），教师2（职称、基本工资）"></a>18. 设有关系：教师（教师号、姓名、职称、基本工资），已知不同职称的基本工资不同，将该关系规范到第三范式为：教师1（教师号、姓名、职称），教师2（职称、基本工资）</h3><hr>
<h3 id="19-能够实现实体完整性控制的关键字是：B"><a href="#19-能够实现实体完整性控制的关键字是：B" class="headerlink" title="19. 能够实现实体完整性控制的关键字是：B"></a>19. 能够实现实体完整性控制的关键字是：B</h3><blockquote>
<p>A. foreign key<br>B. primary key<br>C. references<br>D. A、C均可</p>
</blockquote>
<p>关系模型的实体完整性在CREATE TABLE中用PRIMARY KEY定义。<br>《数据库系统概论（第4版）》王珊 萨师煊，P152原话</p>
<hr>
<h3 id="20-SQL-Server提供的单行注释语句是：-开头的或-包围的"><a href="#20-SQL-Server提供的单行注释语句是：-开头的或-包围的" class="headerlink" title="20. SQL Server提供的单行注释语句是：--开头的或/**/包围的"></a>20. SQL Server提供的单行注释语句是：<code>--</code>开头的或<code>/**/</code>包围的</h3><hr>
<h3 id="21-当一条SELECT语句访问一张大表里的有限几行数据时，SQL-Server2000通常会：为数据加上行级锁"><a href="#21-当一条SELECT语句访问一张大表里的有限几行数据时，SQL-Server2000通常会：为数据加上行级锁" class="headerlink" title="21. 当一条SELECT语句访问一张大表里的有限几行数据时，SQL Server2000通常会：为数据加上行级锁"></a>21. 当一条SELECT语句访问一张大表里的有限几行数据时，SQL Server2000通常会：为数据加上行级锁</h3><p>对行的操作</p>
<hr>
<h3 id="22-已经关系R-x3D-A-B-C-D-E-F-F-x3D-A-gt-C-BC-gt-DE-D-gt-E-CF-gt-B-。则（AB）F的闭包是：ABCDE"><a href="#22-已经关系R-x3D-A-B-C-D-E-F-F-x3D-A-gt-C-BC-gt-DE-D-gt-E-CF-gt-B-。则（AB）F的闭包是：ABCDE" class="headerlink" title="22. 已经关系R&#x3D;(A,B,C,D,E,F),F&#x3D;(A-&gt;C,BC-&gt;DE,D-&gt;E,CF-&gt;B)。则（AB）F的闭包是：ABCDE"></a>22. 已经关系R&#x3D;(A,B,C,D,E,F),F&#x3D;(A-&gt;C,BC-&gt;DE,D-&gt;E,CF-&gt;B)。则（AB）F的闭包是：ABCDE</h3><p>差不多就是封闭集合的意思。推荐阅读：<a href="https://blog.csdn.net/duyusean/article/details/52625361">【数据库】—闭包</a></p>
<hr>
<hr>
<h2 id="二、判断题"><a href="#二、判断题" class="headerlink" title="二、判断题"></a>二、判断题</h2><h3 id="1-任何一个二目关系是属于2NF的。对"><a href="#1-任何一个二目关系是属于2NF的。对" class="headerlink" title="1. 任何一个二目关系是属于2NF的。对"></a>1. 任何一个二目关系是属于2NF的。对</h3><p>二目关系属于3NF</p>
<h3 id="2-数据库事务的原子性是指事务在执行过程中不能出现中断。错。"><a href="#2-数据库事务的原子性是指事务在执行过程中不能出现中断。错。" class="headerlink" title="2. 数据库事务的原子性是指事务在执行过程中不能出现中断。错。"></a>2. 数据库事务的原子性是指事务在执行过程中不能出现中断。错。</h3><p>原子性是指，事务中的诸操作，要么都做，要么都不做。</p>
<h3 id="3-关系R2-x3D-（A-B-C-D-E），F-x3D-AB-CE-E-AB-C-D-是3NF。"><a href="#3-关系R2-x3D-（A-B-C-D-E），F-x3D-AB-CE-E-AB-C-D-是3NF。" class="headerlink" title="3. 关系R2&#x3D;（A,B,C,D,E），F&#x3D;(AB,CE,E,AB,C,D)是3NF。"></a>3. 关系R2&#x3D;（A,B,C,D,E），F&#x3D;(AB,CE,E,AB,C,D)是3NF。</h3><p>错的吧，函数依赖都没提，此题存疑。</p>
<h3 id="4-在确定关系的候选码时，如果属性X在函数依赖的左右都不出现，则候选码中必不包含X。错。"><a href="#4-在确定关系的候选码时，如果属性X在函数依赖的左右都不出现，则候选码中必不包含X。错。" class="headerlink" title="4. 在确定关系的候选码时，如果属性X在函数依赖的左右都不出现，则候选码中必不包含X。错。"></a>4. 在确定关系的候选码时，如果属性X在函数依赖的左右都不出现，则候选码中必不包含X。错。</h3><p>在确定关系的候选码时,如果属性X在函数依赖的左右都不出现,则候选码中必包含X,因为只有X能够函数决定X。</p>
<h3 id="5-字段或记录的有效性规则的设置是在数据库设计器中进行。错。"><a href="#5-字段或记录的有效性规则的设置是在数据库设计器中进行。错。" class="headerlink" title="5. 字段或记录的有效性规则的设置是在数据库设计器中进行。错。"></a>5. 字段或记录的有效性规则的设置是在数据库设计器中进行。错。</h3><p>应该是表设计器。</p>
<h3 id="6-视图创建完毕后，数据字典中存放的是所引用的基本表的定义。错。"><a href="#6-视图创建完毕后，数据字典中存放的是所引用的基本表的定义。错。" class="headerlink" title="6. 视图创建完毕后，数据字典中存放的是所引用的基本表的定义。错。"></a>6. 视图创建完毕后，数据字典中存放的是所引用的基本表的定义。错。</h3><p>应该是视图的定义。</p>
<h3 id="7-关系运算中花费时间可能最长的运算是笛卡尔积。对。"><a href="#7-关系运算中花费时间可能最长的运算是笛卡尔积。对。" class="headerlink" title="7. 关系运算中花费时间可能最长的运算是笛卡尔积。对。"></a>7. 关系运算中花费时间可能最长的运算是笛卡尔积。对。</h3><hr>
<hr>
<h2 id="三、问答题"><a href="#三、问答题" class="headerlink" title="三、问答题"></a>三、问答题</h2><h3 id="1-在供应商、零件数据库中有以下3个关系模式"><a href="#1-在供应商、零件数据库中有以下3个关系模式" class="headerlink" title="1. 在供应商、零件数据库中有以下3个关系模式"></a>1. 在供应商、零件数据库中有以下3个关系模式</h3><blockquote>
<p>供应商：S（Sno，Sname，City，Status）<br>零件：P（Pno，Pname，Weight，Color，City）<br>供应货：SP（Sno，Pno，Qty）<br>各属性的含义可由属性名体现，不再重复，供应货关系SP表示某供应商Sno，供应了Pno零件，数量为Qty。<br>用SQL语言完成以下操作：</p>
</blockquote>
<h4 id="求供应红色零件的供应商"><a href="#求供应红色零件的供应商" class="headerlink" title="求供应红色零件的供应商"></a>求供应红色零件的供应商</h4><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> Sno</span><br><span class="line">	<span class="keyword">FROM</span> SP</span><br><span class="line">	<span class="keyword">WHERE</span> Pno <span class="keyword">IN</span> (</span><br><span class="line">		<span class="keyword">SELECT</span> Pno</span><br><span class="line">		<span class="keyword">FROM</span> P</span><br><span class="line">		<span class="keyword">WHERE</span> Color=<span class="string">&quot;RED&quot;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="求北京供应商的号码、名字和状况（Status）"><a href="#求北京供应商的号码、名字和状况（Status）" class="headerlink" title="求北京供应商的号码、名字和状况（Status）"></a>求北京供应商的号码、名字和状况（Status）</h4><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno,Sname,Status</span><br><span class="line"><span class="keyword">FROM</span> S</span><br><span class="line"><span class="keyword">WHERE</span> City=<span class="string">&quot;BEIJING&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="求零件P2的总供应量"><a href="#求零件P2的总供应量" class="headerlink" title="求零件P2的总供应量"></a>求零件P2的总供应量</h4><figure class="highlight sas"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="meta">SUM</span>(Qty)</span><br><span class="line"><span class="keyword">FROM</span> SP</span><br><span class="line"><span class="keyword">WHERE</span> Pno I<span class="meta">N</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> Pno</span><br><span class="line">	<span class="keyword">FROM</span> P</span><br><span class="line">	<span class="keyword">WHERE</span> Pname=<span class="string">&quot;P2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="把零件P2的重量增加5，颜色改为黄色"><a href="#把零件P2的重量增加5，颜色改为黄色" class="headerlink" title="把零件P2的重量增加5，颜色改为黄色"></a>把零件P2的重量增加5，颜色改为黄色</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">TABLE</span> P</span><br><span class="line"><span class="keyword">SET</span> Weight=Weight+<span class="number">5</span>,Color=&quot;YELLOW&quot;</span><br><span class="line"><span class="keyword">WHERE</span> Pname=&quot;P2&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-某学校有若干系，每个系有若干学生，若干课程，每个学生选修若干课程，每门课有若干学生选修，每一门课可以为不同的系开设，今要建立该校学生选修课程的数据库。请你设计ER图和关系模型。"><a href="#2-某学校有若干系，每个系有若干学生，若干课程，每个学生选修若干课程，每门课有若干学生选修，每一门课可以为不同的系开设，今要建立该校学生选修课程的数据库。请你设计ER图和关系模型。" class="headerlink" title="2. 某学校有若干系，每个系有若干学生，若干课程，每个学生选修若干课程，每门课有若干学生选修，每一门课可以为不同的系开设，今要建立该校学生选修课程的数据库。请你设计ER图和关系模型。"></a>2. 某学校有若干系，每个系有若干学生，若干课程，每个学生选修若干课程，每门课有若干学生选修，每一门课可以为不同的系开设，今要建立该校学生选修课程的数据库。请你设计ER图和关系模型。</h3><ul>
<li>ER图略。</li>
<li>学生（学号，姓名，系号）；选课（学号，课程号）</li>
<li>课程（课程号，课程名称） 开设（课程号，系号）</li>
<li>系（系号，系名）</li>
</ul>
<hr>
<h3 id="3-试论述关系数据库系统中视图（view）的定义，引进View的概念有什么优点"><a href="#3-试论述关系数据库系统中视图（view）的定义，引进View的概念有什么优点" class="headerlink" title="3. 试论述关系数据库系统中视图（view）的定义，引进View的概念有什么优点"></a>3. 试论述关系数据库系统中视图（view）的定义，引进View的概念有什么优点</h3><ul>
<li>定义：从一个或几个基本表导出的虚表。</li>
<li>优点：<ol>
<li>能够简化用户的操作；</li>
<li>使用户能以多种角度看待同一数据；</li>
<li>对重构数据库提供了一定程度的逻辑独立性；</li>
<li>对机密数据提供安全保护；</li>
<li>适当的利用视图可以更清晰的表达查询。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-假设存款余额x-x3D-1000元，甲事务取走存款300元，乙事务取走存款200元，如何实现这两个事务的并发控制，两个事务执行时间如下："><a href="#4-假设存款余额x-x3D-1000元，甲事务取走存款300元，乙事务取走存款200元，如何实现这两个事务的并发控制，两个事务执行时间如下：" class="headerlink" title="4. 假设存款余额x&#x3D;1000元，甲事务取走存款300元，乙事务取走存款200元，如何实现这两个事务的并发控制，两个事务执行时间如下："></a>4. 假设存款余额x&#x3D;1000元，甲事务取走存款300元，乙事务取走存款200元，如何实现这两个事务的并发控制，两个事务执行时间如下：</h3><table>
<thead>
<tr>
<th align="center">甲事务</th>
<th align="center">时间</th>
<th align="center">乙事务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读x</td>
<td align="center">t1</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">t2</td>
<td align="center">读x</td>
</tr>
<tr>
<td align="center">更新x&#x3D;x-300</td>
<td align="center">t3</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">t4</td>
<td align="center">更新x&#x3D;x-200</td>
</tr>
</tbody></table>
<ol>
<li>t1时刻，甲为数据x加上X锁；</li>
<li>t2时刻，乙取数据x时遇上X锁，无法操作；</li>
<li>t3时刻，甲对数据x完成更新，之后释放X锁，此时x&#x3D;700；</li>
<li>t4时刻，乙取数据x，此时x没有被其他事务上锁，乙为其加上X锁，之后乙完成读x，此时x&#x3D;700，更新x的操作，x&#x3D;500，操作结束后释放X锁。</li>
</ol>
<ul>
<li>一般有加锁、时间戳、乐观控制法（相对于悲观加锁或时间戳）</li>
<li>简单记忆：<strong>读取频繁乐观锁，写入频繁悲观锁；乐观锁取数据时认为别人不会修改，悲观锁取数据时认为别人会修改</strong>；</li>
<li>乐观控制：当悲观法对效率影响过大，或者在不会出现冲突的事务处理（如只读型事务）中，加锁就没有必要了，可以采用乐观并发控制。乐观控制分为三个阶段：读取阶段、校验阶段、写入阶段。<ul>
<li>读取阶段。事务将数据写入本地缓存，此时不进行任何校验；</li>
<li>校验阶段。系统对所有事务进行同步校验；</li>
<li>写入阶段。数据将被最终提交。</li>
</ul>
</li>
<li>乐观锁的两种方式：version和CAS操作方式<ul>
<li>CAS：compare and swap ，涉及3个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，相等则更新，不相等则重试。</li>
<li>version：DB表中增加version字段，数据被修改时version++。当线程A要更新数据时，在读数据的同时也会读version；在提交更新时，若刚读到的version与当前DB中的version相等时才更新，否则retry更新操作，直到成功。</li>
</ul>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">//<span class="keyword">version</span>法核心<span class="keyword">SQL</span>代码：</span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">SET</span> x=x+<span class="number">1</span>,version=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">WHERE</span> id=#&#123;id&#125; <span class="keyword">AND</span> version=#&#123;<span class="keyword">version</span>&#125; </span><br></pre></td></tr></table></figure>


<hr>
<h3 id="5-试述数据模型中完整性约束条件的概念，并给出关系模型中的完整性约束。"><a href="#5-试述数据模型中完整性约束条件的概念，并给出关系模型中的完整性约束。" class="headerlink" title="5. 试述数据模型中完整性约束条件的概念，并给出关系模型中的完整性约束。"></a>5. 试述数据模型中完整性约束条件的概念，并给出关系模型中的完整性约束。</h3><ul>
<li>数据的完整性约束条件是一组完整性规则。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定复合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效、相容。</li>
<li>关系模型中有三类完整性约束：实体完整性、参照完整性、用户定义的完整性。<ul>
<li>实体完整性：若属性A是基本关系R的主属性，则A不能取空值。</li>
<li>参照完整性：定义主码和外码之间的引用规则。</li>
<li>用户定义的完整性：针对某一具体关系数据库的约束条件，反映某一具体应用所涉及的数据必须满足的语义要求。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-活锁产生的原因是什么？解决办法是什么？"><a href="#6-活锁产生的原因是什么？解决办法是什么？" class="headerlink" title="6. 活锁产生的原因是什么？解决办法是什么？"></a>6. 活锁产生的原因是什么？解决办法是什么？</h3><ul>
<li>原因：当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。</li>
<li>避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。</li>
</ul>
<hr>
<h3 id="7-设有三个关系：S-S-Sname-Age-Sex-C-C-Cname-Teacher-SC-S-C-Grade-试用关系代数表达式表示以下查询语句："><a href="#7-设有三个关系：S-S-Sname-Age-Sex-C-C-Cname-Teacher-SC-S-C-Grade-试用关系代数表达式表示以下查询语句：" class="headerlink" title="7. 设有三个关系：S(S#,Sname,Age,Sex) C(C#,Cname,Teacher) SC(S#,C#,Grade) 试用关系代数表达式表示以下查询语句："></a>7. 设有三个关系：S(S#,Sname,Age,Sex) C(C#,Cname,Teacher) SC(S#,C#,Grade) 试用关系代数表达式表示以下查询语句：</h3><h4 id="检索至少选修两门课程的学生学号（S-）"><a href="#检索至少选修两门课程的学生学号（S-）" class="headerlink" title="检索至少选修两门课程的学生学号（S#）"></a>检索至少选修两门课程的学生学号（S#）</h4><p><img src="/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/2.jpg" alt="2"></p>
<p>1~6是指笛卡尔后的列的编号</p>
<h4 id="检索全部学生都选修的课程的课程号（C-）和课程名（Cname）"><a href="#检索全部学生都选修的课程的课程号（C-）和课程名（Cname）" class="headerlink" title="检索全部学生都选修的课程的课程号（C#）和课程名（Cname）"></a>检索全部学生都选修的课程的课程号（C#）和课程名（Cname）</h4><p><img src="/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/3.png"></p>
<h4 id="检索选修课程包含“陈军”老师所授课程之一的学生学号（S-）"><a href="#检索选修课程包含“陈军”老师所授课程之一的学生学号（S-）" class="headerlink" title="检索选修课程包含“陈军”老师所授课程之一的学生学号（S#）"></a>检索选修课程包含“陈军”老师所授课程之一的学生学号（S#）</h4><p><img src="/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/4.png"></p>
<h4 id="检索选修课程号为k1和k5的学生学号（S-）"><a href="#检索选修课程号为k1和k5的学生学号（S-）" class="headerlink" title="检索选修课程号为k1和k5的学生学号（S#）"></a>检索选修课程号为k1和k5的学生学号（S#）</h4><p><img src="/2018/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%BA%8C/5.png"></p>
<hr>
<h3 id="8-大量包含用户账号、明文密码、身份证和邮箱在内的12306用户数据被泄露。请从技术上分析数据库系统可能发生了什么问题？要防止这类问题，有什么技术思路？"><a href="#8-大量包含用户账号、明文密码、身份证和邮箱在内的12306用户数据被泄露。请从技术上分析数据库系统可能发生了什么问题？要防止这类问题，有什么技术思路？" class="headerlink" title="8. 大量包含用户账号、明文密码、身份证和邮箱在内的12306用户数据被泄露。请从技术上分析数据库系统可能发生了什么问题？要防止这类问题，有什么技术思路？"></a>8. 大量包含用户账号、明文密码、身份证和邮箱在内的12306用户数据被泄露。请从技术上分析数据库系统可能发生了什么问题？要防止这类问题，有什么技术思路？</h3><ul>
<li>撞库攻击。撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。很多用户在不同网站使用的是相同的帐号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网址，这就可以理解为撞库攻击。</li>
<li>撞库可以通过数据库安全防护技术解决，数据库安全技术主要包括：数据库漏扫、数据库加密、数据库防火墙、数据脱敏、数据库安全审计系统。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>日志结构化存储</title>
    <url>/2021/01/09/%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84%E5%8C%96%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>日志结构化存储系统的基础组织是一个日志，即一个只可添加数据输入的序列。每当你有新的数据要写入的时候，你只需要简单的添加它到日志的末尾，而不需要在磁盘中为它寻找一个位置。</p>
<span id="more"></span>

<h3 id="日志分段压缩-amp-合并"><a href="#日志分段压缩-amp-合并" class="headerlink" title="日志分段压缩&amp;合并"></a>日志分段压缩&amp;合并</h3><ol>
<li>提前说明：这些日志就是真实的日志，放在 disk 上的，其中 key-value 可以简单理解成文件中的每个字符串和偏移量。只是即使同样的“abc”字符串，出现在日志的不同位置，也不能理解为相同的 key，明白？！！有一种“哈希映射”的做法，将所有 key 都缓存到内存中，即使大内存的机器也不一定能做到，只适合部分场景，比如 Bitcash存储引擎，适合 value 经常更新的场景。</li>
<li>始终追加写入同一个日志文件并不可取，会耗尽磁盘空间。</li>
<li>解决办法：日志分成特定大小的段，到达该长度时关闭该文件，开始写入新的文件，对旧文件压缩。<ol>
<li>压缩意味着key-value 的历史值被抛弃，只保留每个 key 的最新值。</li>
<li>压缩过的段如果 size 小，可以多段合并。此时 compact 和 merge 操作同时进行，技术点上，很类似于 copy on write &#x2F;不可变类的修改过程 ——使用旧文件满足压缩时刻的读写请求，压缩合并在后台进行，完成后，再将读写请求定位到新文件，并删除旧文件。</li>
</ol>
</li>
</ol>
<p>下面的 SSTables 和 LSM 树都是日志分段压缩&amp;合并技术基础上演进的。</p>
<h3 id="SSTables"><a href="#SSTables" class="headerlink" title="SSTables"></a>SSTables</h3><ol>
<li>Sorted String Tables。排序字符串表。放在 disk 上的！！！</li>
<li>在日志分段压缩合并时，使用归并排序的技术，保证key有序。同时需要被合并的各段（即 SSTables）也是有序的才行。</li>
<li>如果合并时，多段存在相同的 key，那么仅保留时间最新的 key 对应的 value 值。</li>
<li>不需要将索引中的所有 key 取到内存中，利用排序特性，可以索引到临近的 key 值，然后再进行扫描。每千字节的段文件只需要一个键就足够了，因为几千字节很快可以被扫描。</li>
<li>因为索引的稀疏性，读操作始终要扫描多个 key-value，所以将这些记录分组压缩到块中，索引的每个条目都指向压缩块的开始处。（有点类似于磁盘上使用的 B 树，但 B 树一般固定大小，约 4KB，此 SSTable 的大小并不固定）</li>
</ol>
<p>SSTables 的构建和更新</p>
<ol>
<li>保证 key 有序的办法：磁盘上使用 B 树，内存中使用平衡树（ AVL 或者红黑树等）。使用后可以使用任意顺序插入，然后按序读取。</li>
<li>步骤：<ol>
<li>写入时，写到内存中的平衡树中，这种树也称为内存表。</li>
<li>内存表当 size到一定阈值时，作为 SSTable 写入disk。此时发生的写操作，会作用到下一个新的内存表实例中。</li>
<li>读操作时，先查找内存表，否则去最新的磁盘段，否则去旧一些的磁盘段，依此类推。</li>
</ol>
</li>
</ol>
<h3 id="LSM-树与-B-树对比"><a href="#LSM-树与-B-树对比" class="headerlink" title="LSM 树与 B 树对比"></a>LSM 树与 B 树对比</h3><p>LSM 树基本思想：保存一系列在后台合并的 SSTables，可以支持非常高的写入吞吐量。</p>
<p>写放大：一种现象，比如一次写库操作，需要写多次磁盘。写放大会导致性能代价，存储引擎写入 disk 的次数越多，可用磁盘带宽内每秒写入次数越少。</p>
<ol>
<li>许多 B 树尝试布局树，使得叶子页面按顺序出现在 disk 上，但随着树的增长，维持这个顺序是很困难的。LSM 树在合并过程中一次又一次地重写存储的大部分，所以它们更容易使顺序键在 disk 上彼此靠近。</li>
<li>LSM 树写入更快，读取较慢，因为可能需要查多个 SSTables。B 树读取更快。</li>
<li>B 树的写操作需要①写 redo；②写入树页面，如果发生分裂，要写更多。LSM 树对 SSTable 压缩合并时也会发生写放大，但写放大比 B 树小，支持更高的写入吞吐量，这是因为顺序写入紧凑的 SSTable文件，而不是树中的几个整页面，主要是“顺序写”的优势。</li>
<li>LSM 的查询时间不可预测，B 树可预测。</li>
<li>LSM 的压缩过程对磁盘吞吐量也有影响，如果数据库较大，压缩可能占用过多的磁盘写入带宽。压缩如果赶不上写入速率时，即写入吞吐量较高时，也会拖慢磁盘读取速度。</li>
<li>B 树的一个优点是每个键只存在于索引的一个位置，在需要提供事务支持的业务中，通过键做事务隔离就很合适了。</li>
</ol>
<p>在 B 树中，基于列的存储时，如果在中间新加一列，这可能不得不重写所有的列文件。通过 LSM 树可以很好地处理这个问题，因为写操作会首先进入内存的存储中，然后添加到一个已排序的数据结构中，在内存中基于行或者列已经不影响速度了。等积累足够的写入数据后，它们会跟磁盘上的列文件合并。</p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>BigData</tag>
      </tags>
  </entry>
  <entry>
    <title>机床数据采集</title>
    <url>/2022/02/25/%E6%9C%BA%E5%BA%8A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<p>数采、DNC等</p>
<span id="more"></span>

<h1 id="数采"><a href="#数采" class="headerlink" title="数采"></a>数采</h1><p>国内常见的数控系统（CNC）：fanuc(发那科)，siemens（西门子）,Mitsubishi（三菱），mazak（马扎克），Heidenhain（海德汉），HASS(哈斯)，brother(兄弟)，OKUMA（大隈），Toshiba（东芝)，丰田等，国内品牌：华中数控，广州数控，台湾新代等。</p>
<p>数采分三个方面：</p>
<ol>
<li><p>PLC 设备</p>
<p>PLC 设备呢，通信来讲比较简单，原因是资料较多，很多协议是可以找到的，但是它的难点在于通信端口是否被占用，PLC 是否被加密，这些呢也能想办法解决，总体来说采集相对简单。</p>
</li>
<li><p>电气仪表</p>
<p>一般使用 Modbus RTU&#x2F;TCP、或者其他公开的自定义协议。</p>
</li>
<li><p>CNC 设备</p>
<p>CNC 设备采集比起PLC 难度要高很多首先是很多系统没有通信协议，这个就很麻烦，现在常见的 系统 发那科、西门子、三菱、哈斯、海德汉、马扎克、兄弟、等系统 只有发那科提供了开发用的SDK。</p>
<p>下面进行总结一下：</p>
<ul>
<li>发那科  :使用官方提供SDK 进行开发</li>
<li>西门子：1.开通 OPCUA 授权后进行开发 2.使用S7 底层协议 不进行授权也可以进行采集开发</li>
<li>三菱：常见的系统是M70 M80 官方也是提供了开发包，而且也已经有人写出了Demo 开发起来也是比较容易</li>
<li>哈斯：开发比较容易，一个串口助手就搞定了</li>
<li>海德汉：1.开通18号授权 使用官方SDK 开发。2.直接采集PLC 采集设备状态</li>
<li>兄弟机：1.针对兄弟机可以使用官方提供dll 进行开发，2.使用官方提供的报文采集</li>
<li>马扎克：1.开通MTConnect 协议采集2.使用二次开发包进行采集</li>
</ul>
</li>
</ol>
<p>接口方式：</p>
<ol>
<li>以太网接口</li>
<li>串口</li>
</ol>
<h1 id="DNC"><a href="#DNC" class="headerlink" title="DNC"></a>DNC</h1><h2 id="西门子"><a href="#西门子" class="headerlink" title="西门子"></a>西门子</h2><ol>
<li>西门子828D中，nckfs目录有什么用?</li>
</ol>
<p>在西门子828D系统中，nckfs目录是NC Kern File System的缩写，是NC核心文件系统目录。该目录下存放了与机床数控核心相关的系统文件和数据。具体来说，nckfs目录下包括：</p>
<ul>
<li>NC核心文件：如核心程序文件（core），文件系统镜像文件（image），日志文件（log）等。</li>
<li>程序、数据等应用文件：如NC程序文件（.NC），宏程序文件（.MPF）、数据文件（.DAT）等。</li>
<li>一些配置文件：如开关机程序文件（autoexec.nc）、用户管理文件（user.dat）等。</li>
</ul>
<p>这些文件都是机床控制系统正常运行的必备文件，因此nckfs目录及其下面的文件都非常重要。在一些情况下，如系统升级或备份，可能需要访问或备份这些文件，但建议仅在了解系统操作和相关知识的情况下进行操作，以免意外损坏文件导致系统故障。</p>
<ol start="2">
<li><p>西门子828D中，NCPROG是外接文件系统吗<br>在西门子828D系统中，NCPROG 是机床控制器中的一个文件系统，用于存储数控程序文件。它通常是通过外部设备（如USB存储设备）进行管理和维护，但本身并不是外接文件系统。</p>
</li>
<li><p>西门子828D中，<code>nckfs/_N_SPF_DIR</code>目录有什么用<br>【存疑】西门子828D系统中，<code>nckfs/_N_SPF_DIR</code>是用于存储子程序的目录。其中，NCK程序的名称必须符合<code>*.spf</code>格式，否则将无法在系统中识别。该目录还包括两个文件：一个是目录文件夹<code>_N_SPF_DIR</code>，另一个是缩略图<code>_N_SPF_DIR.THM</code>。这些文件的作用是在NC程序选择器中提供缩略图和NC程序名称的信息。</p>
</li>
<li><p>西门子828D中，<code>nckfs/_N_MPF_DIR/</code>目录有什么用<br>【存疑】在西门子828D系统中，<code>nckfs/_N_MPF_DIR/</code>目录存储的是主程序文件，即NC文件。这些文件通常是通过NCK面板或通过FTP传输到数控系统中，然后由系统加载以执行加工程序。在该目录下可以存储多个NC文件，按照文件名的字母顺序排列。一般来说，数控系统会自动加载最新的NC文件，如果需要运行其他NC文件，可以通过NCK面板进行选择，或通过程序代码进行切换。</p>
</li>
<li><p>DNC中Tap是什么类型文件<br>Tap（.tap）是一种ASCII格式的CNC程序文件，通常用于数字控制系统（DNC）中。它是一种纯文本文件，可以由任何文本编辑器打开和编辑。Tap文件包含机器指令，用于控制CNC机床的运动。这些文件可以通过串行端口或网络连接发送到CNC控制器，以便实现自动化的CNC编程和加工过程。</p>
</li>
</ol>
<p>实际文件 <code>/nckfs/_N_MPF_DIR/_N_O88889_MPF</code> ，对应面板 <code>NC/零件程序/O88889</code></p>
<ol start="6">
<li>西门子828D中，零件程序、子程序、工件各自是什么意思？该怎么区分？</li>
</ol>
<ul>
<li>零件程序是直接加工某个零件所需的完整程序。</li>
<li>子程序是一部分程序，可以在多个工件程序中重复使用。</li>
<li>工件程序是由一个或多个零件程序和子程序组成的完整程序，用于加工整个工件。<ul>
<li>文件名：零件程序以“.mpf”为后缀名，子程序以“.spf”为后缀名，工件通常没有特定的后缀名。</li>
<li>调用子程序时，要以<code>//B</code> 开头，<code>//END</code>结尾，中间SUB(Identifier) ，其中Identifier是子程序的程序名</li>
</ul>
</li>
</ul>
<h3 id="程序存储"><a href="#程序存储" class="headerlink" title="程序存储"></a>程序存储</h3><p><img src="/2022/02/25/%E6%9C%BA%E5%BA%8A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1.png"></p>
<blockquote>
<ol>
<li>NC；2. 本地驱动（CompactFlash卡或硬盘驱动器）；3. USB设备；4. 网络驱动</li>
</ol>
</blockquote>
<ol start="7">
<li><p>放置在828D外部U盘中的NC程序，能直接被执行吗？<br>【存疑】是的，828D控制器可以直接执行存储在外部U盘中的NC程序。您只需确保将NC程序正确地放置在U盘根目录下的“PROGRAM”文件夹中，然后在机床控制面板上进入NCPROG菜单，即可在NC程序列表中看到已经添加的NC程序。从列表中选择程序并运行即可执行NC程序。</p>
</li>
<li><p>接上，但是来自官方文档《SINUMERIK, Manual, Mold-Making with 3- to 5-Axis Simultaneous Milling》P33：例如主程序中的SAMPLE。根据控件和数据存储位置的不同，调用会有所不同。</p>
</li>
</ol>
<ul>
<li>子程序在HMI用户存储器（NC）上：CALL“SAMPLE”。</li>
<li>子程序在CompactFlash卡上的目录中：EXTCALL“CF_card:&#x2F;PROGRAMS&#x2F;SAMPLE.SPF”。</li>
<li>子程序在本地驱动器上：EXTCALL”local_drive:&#x2F;PROGRAMS&#x2F;SAMPLE.SPF“。</li>
<li>子程序在U盘上：EXTCALL”USB:&#x2F;MOLD_DDIE&#x2F;CAM_ROUGH.SPF“。</li>
<li>与以太网连接的网络和机器数据SD 42700中的路径，例如在服务器“&#x2F;&#x2F;R4711&#x2F;工件&#x2F;子程序”上。默认设置是可选的。使用EXTCALL进行调用时，可以首先指定目录：EXTCALL“SAMPLE.SPF”。</li>
</ul>
<p>【存疑】CF_CARD: &#x2F;MPF.DIR&#x2F;XYZ.MPF (points to &#x2F;user&#x2F;sinumerik&#x2F;data&#x2F;prog)</p>
<h3 id="《SINUMERIK-Integrate-Run-MyScreens-Programming-Manual-》"><a href="#《SINUMERIK-Integrate-Run-MyScreens-Programming-Manual-》" class="headerlink" title="《SINUMERIK Integrate Run MyScreens Programming Manual 》"></a>《SINUMERIK Integrate Run MyScreens Programming Manual 》</h3><p>P365目录</p>
<p>P1038～P1050<br>调用子程序</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">//B(PROG1) <span class="comment">; Block start</span></span><br><span class="line">SUB(UP1) <span class="comment">; Start of subprogram</span></span><br><span class="line">  ...  </span><br><span class="line">  REG[<span class="number">0</span>] <span class="operator">=</span> <span class="number">5</span> <span class="comment">; Assign value 5 to register 0</span></span><br><span class="line">  ...  </span><br><span class="line">END_SUB <span class="comment">; End of subprogram</span></span><br><span class="line">SUB(UP2) <span class="comment">; Start of subprogram</span></span><br><span class="line">  IF VAR1.val<span class="operator">=</span><span class="operator">=</span><span class="string">&quot;Otto&quot;</span>  </span><br><span class="line">    VAR1.val<span class="operator">=</span><span class="string">&quot;Hans&quot;</span>  </span><br><span class="line">    RETURN  </span><br><span class="line">  ENDIF  </span><br><span class="line">  VAR1.val<span class="operator">=</span><span class="string">&quot;Otto&quot;</span>  </span><br><span class="line">END_SUB <span class="comment">; End of subprogram</span></span><br><span class="line">//END <span class="comment">; Block end</span></span><br></pre></td></tr></table></figure>


<p>复制程序</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> Flash内部传</span><br><span class="line">CP(<span class="string">&quot;//NC/MPF.DIR/HOHO.MPF&quot;</span>,<span class="string">&quot;//NC/MPF.DIR/ASLAN.MPF&quot;</span>,VAR1)</span><br><span class="line"><span class="regexp">//</span> 从CF拷贝到Flash</span><br><span class="line">CP(<span class="string">&quot;CF_CARD:/wks.dir/MESS_BILD.WPD/MESS_BILD.MPF&quot;</span>,<span class="string">&quot;//NC/WKS.DIR/AAA.WPD/HOHO2.MPF&quot;</span>,VAR1)</span><br><span class="line"><span class="regexp">//</span> Flash内部传</span><br><span class="line">CP(<span class="string">&quot;//NC/MPF.DIR/HOHO.MPF&quot;</span>,<span class="string">&quot;//NC/MPF.DIR/ASLAN.MPF&quot;</span>) ; WPD must exist</span><br></pre></td></tr></table></figure>


<h3 id="《SINUMERIK-840D-sl通用型》"><a href="#《SINUMERIK-840D-sl通用型》" class="headerlink" title="《SINUMERIK 840D sl通用型》"></a>《SINUMERIK 840D sl通用型》</h3><p>P331</p>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间《MySQL实战45讲》学习笔记</title>
    <url>/2020/04/19/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E3%80%8AMySQL%E5%AE%9E%E6%88%9845%E8%AE%B2%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><a href="https://time.geekbang.org/column/intro/139">MySQL实战45讲 林晓斌</a></p>
<h3 id="MySQL的事务启动方式"><a href="#MySQL的事务启动方式" class="headerlink" title="MySQL的事务启动方式"></a>MySQL的事务启动方式</h3><ol>
<li>显示启动事务：begin&#x2F;start transaction - commit&#x2F;rollback</li>
<li>隐式启动事务：配置 set autocommit&#x3D;0，随便执行一个 select就可以启动事务，不会自动提交，直到主动 commit&#x2F;rollback 或断开连接。注：这种方式容易导致长连接。</li>
</ol>
<p>建议采用第一种，考虑多一次交互的问题，使用commit work and chain 语法代替 commit，表示提交当前的同时开启下一段事务。使用以下命令监控超过 60s 的事务。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h3 id="springboot-开启事务以及手动提交事务"><a href="#springboot-开启事务以及手动提交事务" class="headerlink" title="springboot 开启事务以及手动提交事务"></a>springboot 开启事务以及手动提交事务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要在服务类上加上两个注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DataSourceTransactionManager dataSourceTransactionManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">TransactionDefinition transactionDefinition;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动开启事务</span></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">transactionStatus</span> <span class="operator">=</span> dataSourceTransactionManager.getTransaction(transactionDefinition);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动提交事务</span></span><br><span class="line">dataSourceTransactionManager.commit(transactionStatus);<span class="comment">//提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动回滚事务</span></span><br><span class="line">dataSourceTransactionManager.rollback(transactionStatus); <span class="comment">//最好是放在catch 里面,防止程序异常而事务一直卡在哪里未提交</span></span><br></pre></td></tr></table></figure>



<h3 id="索引模型"><a href="#索引模型" class="headerlink" title="索引模型"></a>索引模型</h3><p>MySQL 索引模型，常见的三种：哈希、有序数组、搜索树。</p>
<ol>
<li><p>哈希：O(1)时间复杂度，但 key 较分散，不适合区间查询。</p>
</li>
<li><p>有序数组：使用二分法，O(logN)时间复杂度，适合区间查询，但更新数据时过于麻烦，适合读多写少的场景。</p>
</li>
<li><p>搜索树，考虑到写盘问题，MySQL 使用多叉搜索树，对于一个 InnoDB 的整数索引，N 叉可以是 1200，如果树高度是 4，那么可以存储 1200^3的数字，高达 17 亿。</p>
</li>
<li><p>其他：跳表、<a href="https://blog.csdn.net/las723/article/details/93767240">LSM树</a>等，不做赘述。</p>
</li>
</ol>
<p>InnoDB 使用 B+树做引擎，在 create Table 时，字段 k 设为索引：<code>index(k)</code>。主键索引的叶子节点存的是整行的值，称为聚簇索引；非主键索引的叶节点存的是主键值，称为二级索引（命中非主键索引时需要先查二级索引 B+树，再查主键索引 B+树，称为<strong>回表</strong>操作）。</p>
<p>一般都采用自增主键（非业务含义的键作为主键），但 K-V 形式的索引例外，即如果仅有一个唯一索引的场景，可以不需要自增主键，只需要业务键创建索引，这样能避免不必要的回表动作。</p>
<p>覆盖索引：使用覆盖索引可以避免一些不必要的回表。在非主键索引查询时，就已经获取到了所需要的字段信息，没必要再去查一遍主键 B+树。使用较冗余的方式实现一些高频请求的效率提升。</p>
<p>联合索引的<strong>最左前缀</strong>，不仅可以按字段粒度进行最左匹配，甚至可以按字符模糊查询的粒度进行最左匹配。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">索引:        （<span class="type">name</span>，age）</span><br><span class="line">查询 <span class="keyword">where</span>:   <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> &quot;张%&quot;</span><br><span class="line">说明:         也能用上该索引</span><br></pre></td></tr></table></figure>



<hr>
<p>全局锁，命令是 Flush tables with read lock (FTWRL)，对整个数据库实例加锁。场景：全局逻辑备份，可以保证在备份时做到一致性视图。</p>
<blockquote>
<p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p>
<p>但是，并不是所有数据库引擎都是支持事务的，比如MyISAM场景下，就需要使用 FTWRL 来做全局备份了。</p>
</blockquote>
<hr>
<p>表级锁有两种，第一种表锁 lock，第二种元数据锁（meta data lock，MDL)。</p>
<ul>
<li><p>表锁，lock tables … read&#x2F;write。</p>
</li>
<li><p>MDL，分为读写锁（针对 meta data 的），当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。读读不互斥，但读写、写写互斥。而且申请MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁。一旦出现写锁等待，不但当前操作会被阻塞，同时还会阻塞后续该表的所有操作。</p>
<ul>
<li><strong>MDL 通常用作避免 DML 和 DDL 冲突的工具。</strong></li>
<li>如果 MDL 写锁执行时长过长，那么后续的所有读写请求都会被阻塞。</li>
</ul>
</li>
<li><p>解决办法：MDL 写操作如果在队列等待过久，就放弃该申请，后期再尝试。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 设置 MDL 写操作的等待时间</span><br><span class="line">ALTER TABLE tbl_name NOWAIT add column ...</span><br><span class="line">ALTER TABLE tbl_name WAIT N add column ... </span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<blockquote>
<p>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p>
<p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</p>
</blockquote>
<p>并发场景下，行级锁容易出现多个线程循环资源等待的问题，即死锁。解法一般有常规两种，加强一种：</p>
<ol>
<li><p>超时释放，innodb_lock_wait_timeout参数，默认 50s，但并发场景不能忍受，所以选解法二。</p>
</li>
<li><p>主动死锁检测，innodb_deadlock_detect参数，默认 on，每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。但存在较严重 CPU 资源的消耗。</p>
</li>
<li><p>主动死锁检测前提下，控制并发度。对于同一行的更新操作，在进入引擎之前排队，避免在 InnoDB 中过多的死锁检测。</p>
<ol>
<li><blockquote>
<p>你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。这样每次要给影院账户加金额的时候，随机选其中一条记录来加。这样每次冲突概率变成原来的 1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的 CPU 消耗。</p>
<p>相当于子账户的概念，原理上就是分段汇总，Java原子类LongAdder也使用了这个原理。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<p>好例子(直接抄)：</p>
<blockquote>
<p>当备库用–single-transaction 做逻辑备份的时候，如果从主库的 binlog 传来一个 DDL 语句会怎么样？假设这个 DDL 是针对表 t1 的</p>
<p> 这里把备份过程中几个关键的语句列出来：</p>
<p>Q1:SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br>Q2:START TRANSACTION  WITH CONSISTENT SNAPSHOT；<br>&#x2F;* other tables <em>&#x2F;<br>Q3:SAVEPOINT sp;<br>&#x2F;</em> 时刻 1 <em>&#x2F;<br>Q4:show create table <code>t1</code>;<br>&#x2F;</em> 时刻 2 <em>&#x2F;<br>Q5:SELECT * FROM <code>t1</code>;<br>&#x2F;</em> 时刻 3 <em>&#x2F;<br>Q6:ROLLBACK TO SAVEPOINT sp;<br>&#x2F;</em> 时刻 4 <em>&#x2F;<br>&#x2F;</em> other tables *&#x2F;</p>
</blockquote>
<blockquote>
<p>在备份开始的时候，为了确保 RR（可重复读）隔离级别，再设置一次 RR 隔离级别 (Q1);</p>
<p>启动事务，这里用 WITH CONSISTENT SNAPSHOT 确保这个语句执行完就可以得到一个一致性视图（Q2)；</p>
<p>设置一个保存点，这个很重要（Q3）；</p>
<p>show create 是为了拿到表结构 (Q4)，然后正式导数据 （Q5），</p>
<p>回滚到 SAVEPOINT sp，在这里的作用是释放 t1 的 MDL 锁 （Q6）。</p>
<ol>
<li>如果在 Q4 语句执行之前到达，现象：没有影响，备份拿到的是 DDL 后的表结构。</li>
<li>如果在“时刻 2”到达，则表结构被改过，Q5 执行的时候，报 Table definition has changed, please retry transaction，现象：mysqldump 终止；</li>
<li>如果在“时刻 2”和“时刻 3”之间到达，mysqldump 占着 t1 的 MDL 读锁，binlog 被阻塞，现象：主从延迟，直到 Q6 执行完成。</li>
<li>从“时刻 4”开始，mysqldump 释放了 MDL 读锁，现象：没有影响，备份拿到的是 DDL 前的表结构。</li>
</ol>
</blockquote>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>mySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列笔记1</title>
    <url>/2019/01/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="0-知识图谱："><a href="#0-知识图谱：" class="headerlink" title="0.知识图谱："></a>0.知识图谱：</h1><h1 id="1-分布式系统"><a href="#1-分布式系统" class="headerlink" title="1. 分布式系统"></a>1. 分布式系统</h1><h2 id="1-为什么要进行系统拆分？"><a href="#1-为什么要进行系统拆分？" class="headerlink" title="1. 为什么要进行系统拆分？"></a>1. 为什么要进行系统拆分？</h2><h2 id="2-分布式服务框架"><a href="#2-分布式服务框架" class="headerlink" title="2. 分布式服务框架"></a>2. 分布式服务框架</h2><h2 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h2><h2 id="4-分布式事务"><a href="#4-分布式事务" class="headerlink" title="4. 分布式事务"></a>4. 分布式事务</h2><h2 id="5-分布式会话"><a href="#5-分布式会话" class="headerlink" title="5. 分布式会话"></a>5. 分布式会话</h2><span id="more"></span>

<h1 id="2-高并发架构"><a href="#2-高并发架构" class="headerlink" title="2. 高并发架构"></a>2. 高并发架构</h1><h2 id="1-如何设计高并发系统"><a href="#1-如何设计高并发系统" class="headerlink" title="1. 如何设计高并发系统"></a>1. 如何设计高并发系统</h2><h2 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2. 消息队列"></a>2. 消息队列</h2><h2 id="3-搜索引擎"><a href="#3-搜索引擎" class="headerlink" title="3. 搜索引擎"></a>3. 搜索引擎</h2><h2 id="4-缓存"><a href="#4-缓存" class="headerlink" title="4. 缓存"></a>4. 缓存</h2><h2 id="5-分库分表"><a href="#5-分库分表" class="headerlink" title="5. 分库分表"></a>5. 分库分表</h2><h2 id="6-读写分离"><a href="#6-读写分离" class="headerlink" title="6. 读写分离"></a>6. 读写分离</h2><h1 id="3-高可用架构"><a href="#3-高可用架构" class="headerlink" title="3. 高可用架构"></a>3. 高可用架构</h1><h2 id="1-如何设计高可用系统"><a href="#1-如何设计高可用系统" class="headerlink" title="1. 如何设计高可用系统"></a>1. 如何设计高可用系统</h2><h2 id="2-限流"><a href="#2-限流" class="headerlink" title="2. 限流"></a>2. 限流</h2><h2 id="3-熔断"><a href="#3-熔断" class="headerlink" title="3. 熔断"></a>3. 熔断</h2><h2 id="4-降级"><a href="#4-降级" class="headerlink" title="4. 降级"></a>4. 降级</h2>]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习入门到跑路</title>
    <url>/2021/06/21/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E5%88%B0%E8%B7%91%E8%B7%AF/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="简单说下RNN与-LSTM-有什么区别？"><a href="#简单说下RNN与-LSTM-有什么区别？" class="headerlink" title="简单说下RNN与 LSTM 有什么区别？"></a>简单说下RNN与 LSTM 有什么区别？</h4><p>lee:写的太好，强推：<a href="https://www.jianshu.com/p/4b4701beba92">如何简单的理解LSTM——其实没有那么复杂</a></p>
<p><a href="https://blog.csdn.net/hfutdog/article/details/96479716">RNN与LSTM的区别</a></p>
<p>指 LSTM 与标准 RNN的区别， LSTM 是一种使用细胞状态的特殊 RNN。</p>
<ol>
<li>RNN处理一定的短依赖，但 LSTM 可以处理短期、长期依赖。<ul>
<li>序列长时，序列后部的梯度很难反向传播到前面的序列（梯度消失）。</li>
</ul>
</li>
<li>激活函数不同，RNN 只有 tanh，但 LSTM 引入 sigmoid 并结合 tanh，添加求和操作，减少梯度消失和梯度爆炸的可能性。</li>
<li>RNN 没有细胞状态，LSTM 通过细胞状态记忆信息。</li>
</ol>
<h4 id="时间序列异常检测？"><a href="#时间序列异常检测？" class="headerlink" title="时间序列异常检测？"></a>时间序列异常检测？</h4><ul>
<li>时间序列异常检测是指发现序列数据中与正常行为显著不同的潜在模式。</li>
<li>在处理时序数据时，卷积网络通常通过在数据上滑动一个一维的卷积滤波器来预测序列的未来元素。递归神经网络(RNN)由于能够存储时间序列中的历史信息，在序列任务中得到了广泛应用。长短期记忆(LSTM)神经网络和门控循环单元克服了RNN中的消失梯度问题，并成功地应用于语音和自然语言处理中。</li>
</ul>
<h4 id="什么是transformer，以及什么是-self-attention？"><a href="#什么是transformer，以及什么是-self-attention？" class="headerlink" title="什么是transformer，以及什么是 self-attention？"></a>什么是transformer，以及什么是 self-attention？</h4><p><a href="https://blog.csdn.net/weixin_40871455/article/details/86084560">transformer 模型（self-attention自注意力）</a>、<a href="http://jalammar.github.io/illustrated-transformer/">The Illustrated Transformer</a></p>
<p>self-attention 分为以下步骤：</p>
<ol>
<li>从每个Encoder的输入向量上创建3个向量。对于每个单词，我们创建一个Query向量，一个Key向量和一个Value向量。这些向量是通过词嵌入乘以我们训练过程中创建的3个训练矩阵而产生的。</li>
<li>计算得分（中间值）。每个单词的 self-attention 的计算：当前单词的query向量和其他各个key向量点积。</li>
<li>计算最终得分。第 2 步的得分除以<strong>根号dk</strong>（即 key 向量的维度开根号），再将得到的数值通过softmax函数标准化，使得最后的列表和为1。这个softmax的分数决定了当前单词在每个句子中每个单词位置的表示程度。</li>
<li>将每个Value向量乘以softmax后的得分。这里实际上的意义在于保存对当前词的关注度不变的情况下，降低对不相关词的关注。</li>
<li>累加加权值的向量。 这会在此位置产生self-attention层的输出（对于第一个单词）。</li>
</ol>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>深入拆解Tomcat-Jetty核心笔记</title>
    <url>/2020/09/07/%E6%B7%B1%E5%85%A5%E6%8B%86%E8%A7%A3Tomcat-Jetty%E6%A0%B8%E5%BF%83%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>主要记录自极客时间《深入拆解 Tomcat &amp; Jetty》专栏，内含扩展阅读与个人理解。</p>
<span id="more"></span>





]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习名词辨析</title>
    <url>/2019/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%90%8D%E8%AF%8D%E8%BE%A8%E6%9E%90/</url>
    <content><![CDATA[<h1 id="深度学习名词辨析"><a href="#深度学习名词辨析" class="headerlink" title="深度学习名词辨析"></a>深度学习名词辨析</h1><p>本文参考自：《Python 深度学习》2018 版</p>
<p>本文也会进行系列更新</p>
<p>注：以下名词并不权威，多是以直白的语言阐述的个人理解，仅供参考。</p>
<ol>
<li>经典的程序设计：input：规则和数据，output：答案。但机器学习是一种新的编程范式：input：数据和答案，output：规则。</li>
<li>表示：input 数据的有用表示(即某种表现方式，通过变换数据做到，目的是使 input 更适合当前的任务)。机器学习模型就是为了能够为 input 的数据自动寻找到合适的表示。例：坐标变换，见下图：</li>
</ol>
<span id="more"></span>



<p><img src="/2019/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%90%8D%E8%AF%8D%E8%BE%A8%E6%9E%90/1-4.png"></p>
<pre><code> 4. 操作空间：自动寻找表示的过程，通常只能是遍历一组预定义好的操作，这组操作就是假设空间。
      
      
  1. 利用反馈信号来寻找哪个操作更有效。
  
</code></pre>
<ol start="5">
<li>每个操作使用”权重”，即一串数字，来进行参数化。</li>
</ol>
<pre><code> 5. 深度学习：一系列连续的表示层，深度从数十层到数百层不等。
      
      
      1. 分层通常由**神经网络**的模型来学习得到。[理解]分层可以类比为多级蒸馏，每次蒸馏后，信息纯度越来越高，信息价值也就越高。
      2. 深度学习能够让特征工程自动化。
      3. 模型在同一时间共同学习所有的表示层，而不是依此连续学习。并且使用单一反馈信号来监督。
  
 6. 学习：将预期 output 跟当前 output 的差距进行比较得出衡量结果，进而优化算法。
      
      
  1. 学习的目的就是，为神经网络的所有层找到一组权重值，使得每个 input 都能够获得目标 output。
  
</code></pre>
<ol start="8">
<li><p>结果的衡量方式：使用神经网络损失函数（loss function），也叫目标函数。损失函数的 input 是预测值跟真实值，output 就是一个其偏差，偏差会转化为一个距离值。</p>
</li>
<li><p>优化过程：将距离值作为反馈信号，对权重值进行微调，以降低偏差。这种调节由<strong>优化器optimizer</strong>完成，实现了所谓的<strong>反向传播backpropagation</strong>。</p>
</li>
<li><p><strong>支持向量机SVM的目标：解决分类问题，为两个不同类别的两组数据点之间找到良好的决策边界</strong>。做法：</p>
<pre><code>    1. 数据映射到新的高维表示，决策边界用一个超平面来表示；
    2. 尽量让超平面与每个类别最近的数据点之间的距离最大化。
</code></pre>
<ul>
<li>SVM 缺点：难以计算。</li>
<li>缺点的应对办法：使用 kernel function（人为选择而非机器学习而来），将原始空间的任意两点映射为这两点在目标表示空间中的距离。</li>
</ul>
</li>
<li><p><a href="https://www.cnblogs.com/fionacai/p/5894142.html">决策树</a>：针对一个一个特征进行划分处理，更加接近人的思维按时，可以产生可视化的分类规则，产生的模型具有可解释性。</p>
<pre><code>     1. 决策树的学习：自顶而下递归，以信息熵为度量构造一颗熵值下降最快的树，到叶子节点处熵值为 0。
     2. 随机森林：利用样本的随机和特征的随机，建立多棵决策树，这些树形成随机森林，通过投票表决结果，决定数据属于哪一类。
     3. 梯度提升机：较少的决策树就能够获得较高的准确率，在最优化目标函数的过程中导出的。[与随机森林的对比](https://yq.aliyun.com/articles/216164)。
</code></pre>
</li>
<li><p><a href="https://www.cnblogs.com/alexcai/p/5506806.html">深度卷积神经网络算法</a>，应用在 CV、NLP 等感知任务的领域。</p>
</li>
</ol>
<p><img src="/2019/05/18/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%90%8D%E8%AF%8D%E8%BE%A8%E6%9E%90/1-2-6.png"></p>
<ol start="15">
<li>过拟合：[理解]机器学习模型在新数据上的性能比在训练数据上要差。比如，训练精度 99.9%，但是测试精度只有 60%，说明学习模型出现了<strong>过拟合</strong>。</li>
<li><strong>张量</strong>：一种几乎总是存储数值的数据结构(通常存储的类型有：float32、uint8、float64 ，少量情况下的 char 等)，是矩阵向任意维度的推广。<ol>
<li>具有<strong>维度&#x2F;阶</strong>的概念，也就是某一张量中轴的个数，称为 <code>ndim</code>。</li>
<li>零维张量也叫<strong>标量</strong>，是仅包含一个数字的张量。</li>
<li>一维张量也叫<strong>向量</strong>，其实就是一个一维数字数组。</li>
<li>二维张量也叫<strong>矩阵</strong>，二维数字数组。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>DL</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网云服务平台核心一</title>
    <url>/2022/01/04/%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E4%B8%80/</url>
    <content><![CDATA[<p>名词解释和一般核心结构</p>
<span id="more"></span>

<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>AM：通信中的 AM 是指调幅信号，在有线电或无线电通信和广播中应用甚广。</p>
<p>CTP：CTP协议(CollectionTreeProtocol)通常用来收集传感器组成的网络中从周围环境探测到的数据信息,多个物联网传感器组成树形结构,它们之中有一个根节点,<strong>所有传感器收集到的周围传感数据信息将通过CTP协议流向根节点</strong>。根节点一般为边界路由器,它通过收集到数据信息通过串口转发给互联网端。是TinyOS 使用的汇聚树协议，它提供到网络中根节点的尽力、任意播数据报通信。<strong>用于数据采集</strong>。</p>
<p>DIP：DIP协议(DisseminationProtocol）通常用于<strong>向物理自组网中下发命令</strong>,例如控制开关、下发运行参数设置更新等。互联网设备通过串口和边界路由器相连,将需要的命令数据化并由边界路由器转发,使自组网层传感器收到数据并更新设置。</p>
<p>物联网网关接入公共网络的方式：主要 Ethernet 和 Wifi</p>
<ul>
<li>2G、3G、PSTN、LTE、LAN、DSL：</li>
</ul>
<p>设备与网关通信的方式：RS485&#x2F;232、Ethernet、Wifi、Zigbee、Bluetooth、GPRS、RF433。</p>
<p><img src="/2022/01/04/%E7%89%A9%E8%81%94%E7%BD%91%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%B9%B3%E5%8F%B0%E6%A0%B8%E5%BF%83%E4%B8%80/%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE.png"></p>
<h3 id="网关中间件"><a href="#网关中间件" class="headerlink" title="网关中间件"></a>网关中间件</h3><p>《基于 Web 的泛在网关中间件中关键技术的研究和实现_昌煦超》</p>
<p>《物联网设备接入管理平台关键技术研究与实现_盛俊阳》</p>
<p>网关中间件(Middleware)是指一些软件和工具的结合体,通过它,能够屏蔽底层硬件和网络的复杂性以及异构性,从而方便各种应用来获取和管理各种传感器的数据和系统资源。简单来说,网关中间件是连接硬件设备和业务应用的桥梁。<strong>物联网网关分为硬件部分和软件部分，软件部分可以认为是网关中间件。</strong></p>
<p>特点：数据量压力大，资源受限（能源、计算能力、内存、通信带宽），对服务质量的要求不一。</p>
<ul>
<li>QoS服务质量： QoS包括服务延迟,丢包率,数据精确度,差异化服务等。</li>
</ul>
<p>通过引入智能网关，<strong>赋予终端设备网络通信能力和智能计算能力</strong>，实现物联网终端设备数据采集上报和网络通信功能。</p>
<h3 id="设备接入"><a href="#设备接入" class="headerlink" title="设备接入"></a>设备接入</h3><p>《物联网设备接入管理平台关键技术研究与实现_盛俊阳》</p>
<p>对独立设备普遍采用直连+SDK，对非独立设备采用间接接入网关+SDK+网络；通讯方式采用现有的 MQTT 或者 WIFI，只有华为采用了NB-IoT，身份验证依赖于较为简单的 ID+Token，稍微复杂一点的采用私钥加密，需要添加证书才能进行数据通讯用到的较少。</p>
<p>设备是否具有 IP</p>
<ol>
<li>具有 IP：直连设备。车载终端、工业传感器、芯片模组等。</li>
<li>不具有 IP：非直连设备，通过网关实现 IP 能力。传感器、ZigBee、智能硬件等。</li>
</ol>
<h3 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h3><p>《物联网设备接入管理平台关键技术研究与实现_盛俊阳》</p>
<p>连接到云的设备执行<strong>全生命周期设备管理</strong>。</p>
<ol>
<li>设备联机、维护、网络连接、告警、报表分析、升级和注销，以及平台和设备两端的双向数据通道。</li>
</ol>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>《基于 Web 的泛在网关中间件中关键技术的研究和实现_昌煦超》</p>
<p>事件处理是一种对事件的数据流进行跟踪和分析(处理)并得出某种结论的方法。</p>
<ul>
<li>复杂事件处理(CEP),是<strong>将多个来源的数据相结合,并推断出一种适用于更复杂情况下的事件或模式</strong>。</li>
<li>其<strong>目标</strong>是找出有意义的事件,并尽快对它们做出回应。</li>
<li>事件通常被定义为“状态的变化”,比如当测量值超过预定阈值的时间,温度,或其他值。举个例子,假如一个监测系统同时接收到了成千上万的事件,在这些事件中有三种事件:教堂的钟声;一个穿燕尾服的男人和一个穿白色礼服的女人;漫天飞舞的花瓣。通过这些事件,监测系统就能推理出一个复杂事件:婚礼。</li>
<li>一个完整的CEP系统需要包括事件过滤器、事件缓冲区和事件构建器二个部分。</li>
</ul>
<h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><p>《基于 Web 的泛在网关中间件中关键技术的研究和实现_昌煦超》</p>
<ol>
<li>对子网中设备的管理：获取节点的标识，状态和属性,修改设备的配置信息,实现远程开&#x2F;关机,设备控制等等。</li>
<li>网关自身的管理：实现对网关的控制,问题诊断,配置,升级维护,修改网关的配置信息等功能。</li>
</ol>
<h3 id="访问安全"><a href="#访问安全" class="headerlink" title="访问安全"></a>访问安全</h3><p>《基于 Web 的泛在网关中间件中关键技术的研究和实现_昌煦超》</p>
<p>网关可作为client和server的身份出现,</p>
<ol>
<li>当作为client时,需要与平台交互以获取唯一标识和安全凭证;</li>
<li>作为server时,要能够对平台和app的请求进行安全认证(或者在资源受限的情况下通过第三方进行安全认证)。</li>
<li>特性：保密、完整、验证、不可抵赖、访问控制、可用性、隐私。</li>
</ol>
<h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p>《物联网设备接入管理平台关键技术研究与实现_盛俊阳》</p>
<ol>
<li>用户可以通过百度规则引擎设置消息处理规则，对匹配规则的消息采取相应的转发操作，如推送到手机 APP;设备消息也可以无缝转发到时间数据库，百度 Kafka 和存储对象中。</li>
<li>华为规则引擎是通过简单灵活的规则配置，触发设备，消息，通知。</li>
</ol>
<h3 id="IOT-数据分析"><a href="#IOT-数据分析" class="headerlink" title="IOT 数据分析"></a>IOT 数据分析</h3><p>《物联网设备接入管理平台关键技术研究与实现_盛俊阳》</p>
<p>华为IoT 数据分析表示具备高并发实时流处理功能，数据海量存储、云计算和数据 API 开放功能。</p>
<h3 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h3><p>MQTT  协议由 IBM 公司在 20 世纪末提出，组成结构主要有报文类型、可变报头以及消息负载，MQTT 是运行在 TCP 协议上的轻量级传输协议。支持 TLS。</p>
<h2 id="核心结构与流转"><a href="#核心结构与流转" class="headerlink" title="核心结构与流转"></a>核心结构与流转</h2><p>TinyOS：完整的物联网系统包括<strong>①物联网自组网</strong>和<strong>③互联网外网</strong>，中间是<strong>②边界路由器模块</strong>。</p>
<ul>
<li>①与②之间通常是基于 AM 的无线通信。</li>
<li>②与③之间通常是串口通信。</li>
</ul>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>登录_手机扫描pc二维码的原理梳理</title>
    <url>/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>先明确概念：</p>
<p>问：二维码是什么？</p>
<p>答：二维码其实就是一串字符串，条形码其实就是一串数字。二维码内容可以是惟一的 ID，也可以是包含该 ID 的地址。</p>
<p>问：app 首次进入时需要输入用户名密码登录，但之后不再需要就可以直接进入，这是为什么？</p>
<p>答：因为 token 机制。</p>
<span id="more"></span>

<h4 id="token-机制"><a href="#token-机制" class="headerlink" title="token 机制"></a>token 机制</h4><p><img src="/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/1.png"></p>
<p>需要注意的是：1. token 就是一个带有特殊含义的字符串。2. 校验时用到你的设备信息，这部分是唯一的，所以别人知道了你的 token ，但拿不到你的设备信息，也是白给。</p>
<h4 id="扫码登录简介"><a href="#扫码登录简介" class="headerlink" title="扫码登录简介"></a>扫码登录简介</h4><p><img src="/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/2.png"></p>
<p>归根结底，是在 pc 上生成 pc token 的过程。</p>
<ul>
<li><p>pc 的任务：<strong>接收用户登录请求</strong>，发送二维码生成请求，<strong>等待 token</strong>，接收 token 并<strong>完成登录</strong>。</p>
</li>
<li><p>服务器的任务：<strong>生成二维码</strong>，等待手机端扫码（主要是发来的身份信息）并<strong>生成临时 token</strong>并发回手机端，等待用户确认登录并<strong>生成 pc token</strong>并发回 pc 端。</p>
</li>
<li><p>手机端的任务：扫码，<strong>接收临时 token</strong> 并引导用户确认登录。</p>
</li>
</ul>
<h4 id="扫码登录三大细节"><a href="#扫码登录三大细节" class="headerlink" title="扫码登录三大细节"></a>扫码登录三大细节</h4><ol>
<li><p>pc 生成待扫描的二维码。</p>
<p><img src="/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/3_1.png"></p>
<p>值得注意的是：此时二维码和 pc 设备信息都传递给了 server端。拿到设备信息是为了验证的需要。此时系统并不知道访问者是谁。</p>
</li>
<li><p>手机端扫码。</p>
<p><img src="/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/3_2.png"></p>
<p>扫码时，server 可以拿到此二维码，也拿到了身份信息，server 明确了访问者。使用临时 token，是为了 userId 被传递时的安全考量。只待用户在手机上确认登录后，就可以生成 pc token 了。</p>
</li>
<li><p>用户点击确认，pc 端完成登录。</p>
<p><img src="/2020/04/21/%E7%99%BB%E5%BD%95-%E6%89%8B%E6%9C%BA%E6%89%AB%E6%8F%8Fpc%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86%E6%A2%B3%E7%90%86/3_3.png"></p>
<p>pc 会一直轮询 server 并同步更新二维码状态。</p>
</li>
</ol>
<blockquote>
<p>粘一下知乎中吕十田的科普解释：</p>
<p>1、你用浏览器打开<a href="https://link.zhihu.com/?target=http://wx.qq.com">http://wx.qq.com</a>的时候，微信给你随机分配了一个链接，【相当于给你开了间房，房号1024，注意，只给你房号，没给你钥匙】，用二维码包装着，并且设置了有效时间【10分钟你不进房间，就给你取消】。这里面没有用户什么事情，所以不存在UID（user ID），只是一个随机的字母和数字组合。<br>2、二维码的转码规则是统一的，所以意味着，只要是个二维码扫描软件，谁都能拿到这个链接，微信可以扫出来，我查查也可以扫出来。<br>3、所以拿到链接没有用，重要的是谁拿到链接，微信拿到了，就可以从微信客户端发一条信息给服务器，告诉服务器，现在是谁使用了某个链接，其他二维码扫描软件，不能和微信服务器通话，所以毫无价值。【你拿到了房号，就给酒店老板打个电话，说是我，老板就知道张三又来开房了，其他人没有老板电话，知道房号也没用】<br>4、这时候，在你刚打开的浏览器窗口里面，就知道并显示了你的信息，理论上可以直接打开聊天窗口，但是为了不突兀不尴尬，微信选择再让你在手机上做一个确认操作。【你站到你的房间门口了，老板也知道你是张三了，并且把你的那个好基友也放到了你房间里，但是谁知道你基友会在房间里干点啥？如果他正好弯腰在捡肥皂，这时候恰好你后面有人经过，房门大开大家尴尬不尴尬？所以还是老板考虑周到，他要你在电话里确认一下才给你开门，你大可以等后面没人了再开门进去】<br>5、好了，现在你可以进去好好享用你的基友了。</p>
</blockquote>
<p>本部分参考自</p>
<ol>
<li><p>极客时间江涌的<a href="https://time.geekbang.org/dailylesson/detail/100044032?utm_source=web&utm_medium=geektime&utm_campaign=306-presell&utm_content=pc0420&utm_term=pc_interstitial_250">《二维码扫描登录是什么原理？》</a></p>
</li>
<li><p>吕十田的知乎回答：<a href="https://www.zhihu.com/question/20368066/answer/23828176">微信扫描二维码登录网页是什么原理</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>method</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>笔经整理1</title>
    <url>/2019/01/15/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%861/</url>
    <content><![CDATA[<p><a href="https://leetcode.com/problemset/all/">Leetcode 笔试题1 </a></p>
<h1 id="题目来源：LeetCode"><a href="#题目来源：LeetCode" class="headerlink" title="题目来源：LeetCode"></a>题目来源：LeetCode</h1><h1 id="easy"><a href="#easy" class="headerlink" title="easy"></a>easy</h1><h2 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h2><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<blockquote>
<p>Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,<br>Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,<br>return [0, 1].</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">	Map&lt;<span class="type">Integer</span>,<span class="type">Integer</span>&gt; map = <span class="built_in">new</span> HashMap&lt;<span class="type">Integer</span>, <span class="type">Integer</span>&gt;();</span><br><span class="line">	<span class="type">int</span>[] result = <span class="built_in">new</span> <span class="type">int</span>[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">			result[<span class="number">0</span>] = map.<span class="keyword">get</span>(nums[i]);</span><br><span class="line">			result[<span class="number">1</span>] = i;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			map.put(target - nums[i],i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h2><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: 123<br>Output: 321</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: -123<br>Output: -321</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: 120<br>Output: 21</p>
</blockquote>
<p>Note:<br>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">	System.out.<span class="keyword">println</span>(<span class="keyword">new</span> Solution().<span class="keyword">reverse</span>(-<span class="number">123010</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Solution &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">reverse</span>(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">// 默认正数</span></span><br><span class="line">		<span class="keyword">boolean</span> carry = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">21</span>];</span><br><span class="line">		<span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">			x = -x;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(x == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			num[i++] = x%<span class="number">10</span>;</span><br><span class="line">			x/=<span class="number">10</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;i;++j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(num[j]==<span class="number">0</span> &amp;&amp; carry)&#123;</span><br><span class="line">				<span class="comment">// 首位是零</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			carry = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span>(result&gt;Integer.MAX_VALUE<span class="regexp">/10 || result &lt; Integer.MIN_VALUE/</span><span class="number">10</span>)&#123;</span><br><span class="line">			<span class="comment">//判断溢出</span></span><br><span class="line">				result = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			result = <span class="number">10</span>*result + num[j];</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag)</span><br><span class="line">			result = -result;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h2><p>Roman numerals are represented by seven different symbols: <code>I, V, X, L, C, D and M</code>.</p>
<blockquote>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as <code>XXVII</code>, which is <code>XX </code>+ <code>V</code> + <code>II</code>.</p>
</blockquote>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: “III”<br>Output: 3</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: “IV”<br>Output: 4</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: “IX”<br>Output: 9</p>
</blockquote>
<p>Example 4:</p>
<blockquote>
<p>Input: “LVIII”<br>Output: 58<br>Explanation: L &#x3D; 50, V&#x3D; 5, III &#x3D; 3.</p>
</blockquote>
<p>Example 5:</p>
<blockquote>
<p>Input: “MCMXCIV”<br>Output: 1994<br>Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</p>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> romanToInt(String s) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">int</span> <span class="keyword">sum</span> = <span class="number">0</span>,<span class="keyword">count</span> = <span class="number">0</span>,pre = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">				<span class="built_in">char</span> c = s.charAt(i);</span><br><span class="line">				<span class="keyword">switch</span> (c)&#123;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">5</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">10</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">50</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">100</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">500</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					<span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">						<span class="keyword">count</span> = <span class="number">1000</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">sum</span> += <span class="keyword">count</span>;</span><br><span class="line">				<span class="comment">// 如果后一位大于前一位，说明要扣掉双倍的 pre</span></span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">count</span> &gt; pre)&#123; </span><br><span class="line">					<span class="keyword">sum</span> -= <span class="number">2</span> * pre;</span><br><span class="line">				&#125;</span><br><span class="line">				pre = <span class="keyword">count</span>;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">sum</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：每一位比如 X、L、C、D、M都可以独立存在的，即可以独立表示为500这种，所以直接按位读取即可。</p>
<h2 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h2><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: [“flower”,”flow”,”flight”]<br>Output: “fl”</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: [“dog”,”racecar”,”car”]<br>Output: “”<br>Explanation: There is no common prefix among the input strings.</p>
</blockquote>
<p>Note:</p>
<blockquote>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> study0112_1 &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"><span class="comment">//		String[] strs = &#123;&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;&#125;;</span></span><br><span class="line">		String<span class="literal">[]</span> strs = &#123;<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;racecar&quot;</span>,<span class="string">&quot;car&quot;</span>&#125;;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">Solution()</span>.longest<span class="constructor">CommonPrefix(<span class="params">strs</span>)</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	static <span class="keyword">class</span> Solution &#123;</span><br><span class="line">		public <span class="constructor">Solution()</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		public String longest<span class="constructor">CommonPrefix(String[] <span class="params">strs</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(strs.length<span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">				return <span class="string">&quot;&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			String result = strs<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;strs.length-<span class="number">1</span>;++i)&#123;</span><br><span class="line">				result = get<span class="constructor">Prefix(<span class="params">result</span>,<span class="params">strs</span>[<span class="params">i</span>+1])</span>;</span><br><span class="line">				<span class="keyword">if</span>(result.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">					return <span class="string">&quot;&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 两两比较，拿相同前缀，使用StringBuilder缩短时间</span></span><br><span class="line">		public String get<span class="constructor">Prefix(String A,String B)</span>&#123;</span><br><span class="line">			<span class="built_in">int</span> i=<span class="number">0</span>;</span><br><span class="line">			StringBuilder common = <span class="keyword">new</span> <span class="constructor">StringBuilder(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">			<span class="keyword">while</span>(i&lt;<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>length<span class="literal">()</span><span class="operator"> &amp;&amp; </span>i&lt;<span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span>length<span class="literal">()</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span><span class="operator"> == </span><span class="module-access"><span class="module"><span class="identifier">B</span>.</span></span><span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>)&#123;</span><br><span class="line">					common.append(<span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span><span class="built_in">char</span><span class="constructor">At(<span class="params">i</span>)</span>);</span><br><span class="line">					i++;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return common==null?<span class="string">&quot;&quot;</span>:common.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38.Count and Say"></a>38.Count and Say</h2><p>The count-and-say sequence is the sequence of integers with the first five terms as following:</p>
<blockquote>
<ol>
<li><pre><code>1
</code></pre>
</li>
<li><pre><code>11
</code></pre>
</li>
<li><pre><code>21
</code></pre>
</li>
<li><pre><code>1211
</code></pre>
</li>
<li><pre><code>111221
</code></pre>
</li>
</ol>
</blockquote>
<p>1 is read off as “one 1” or 11.<br>11 is read off as “two 1s” or 21.<br>21 is read off as “one 2, then one 1” or 1211.</p>
<p>Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</p>
<p>Note: Each term of the sequence of integers will be represented as a string.</p>
<p> Example 1:</p>
<blockquote>
<p>Input: 1<br>Output: “1”</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: 4<br>Output: “1211”</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		System.out.<span class="built_in">println</span>(<span class="keyword">new</span> <span class="built_in">Solution</span>().<span class="built_in">countAndSay</span>(<span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">			<span class="type">String</span> result = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">			<span class="type">String</span> temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				<span class="comment">// 迭代 n-1 次</span></span><br><span class="line">				<span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; result.<span class="built_in">length</span>(); ++j) &#123;</span><br><span class="line">					<span class="keyword">if</span> (j == result.<span class="built_in">length</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">						<span class="comment">// 如果是最后一位，把 count 结果和最后一位字符加在末尾</span></span><br><span class="line">						temp += <span class="type">String</span>.<span class="built_in">valueOf</span>(count) + result.<span class="built_in">charAt</span>(j);</span><br><span class="line">					&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 如果 j+1 位与 j 位相同，计数器+1</span></span><br><span class="line">						<span class="comment">// 如果不同，把 count 结果，和 j 位字符一起加在末尾</span></span><br><span class="line">						<span class="keyword">if</span> (result.<span class="built_in">charAt</span>(j) == result.<span class="built_in">charAt</span>(j + <span class="number">1</span>)) &#123;</span><br><span class="line">							++count;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							temp += <span class="type">String</span>.<span class="built_in">valueOf</span>(count) + result.<span class="built_in">charAt</span>(j);</span><br><span class="line">							count = <span class="number">1</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				result = temp;</span><br><span class="line">				temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h1><h2 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h2><p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>Explanation: 342 + 465 &#x3D; 807.</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">		public ListNode add<span class="constructor">TwoNumbers(ListNode <span class="params">l1</span>, ListNode <span class="params">l2</span>)</span> &#123;</span><br><span class="line">			ListNode T1 = l1,T2 = l2,tail = <span class="keyword">new</span> <span class="constructor">ListNode(-1)</span>,temp = tail;</span><br><span class="line">			<span class="built_in">int</span> carry = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(T1!= null<span class="operator"> &amp;&amp; </span>T2!= null)&#123;</span><br><span class="line">				<span class="built_in">int</span> sum = <span class="module-access"><span class="module"><span class="identifier">T1</span>.</span></span><span class="keyword">val</span> + <span class="module-access"><span class="module"><span class="identifier">T2</span>.</span></span><span class="keyword">val</span> + carry;</span><br><span class="line">				<span class="keyword">if</span>(sum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">					carry = <span class="number">1</span>;</span><br><span class="line">					sum-=<span class="number">10</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					carry = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ListNode node = <span class="keyword">new</span> <span class="constructor">ListNode(<span class="params">sum</span>)</span>;</span><br><span class="line">				tail.next = node;</span><br><span class="line">				tail = node;</span><br><span class="line">				T1 = <span class="module-access"><span class="module"><span class="identifier">T1</span>.</span></span>next;</span><br><span class="line">				T2 = <span class="module-access"><span class="module"><span class="identifier">T2</span>.</span></span>next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(T1<span class="operator"> == </span>null<span class="operator"> &amp;&amp; </span>T2<span class="operator"> == </span>null)&#123;</span><br><span class="line">				<span class="comment">// 传入 carry 和尾指针</span></span><br><span class="line">				deal<span class="constructor">WithCarry(<span class="params">carry</span>,<span class="params">tail</span>)</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T1<span class="operator"> == </span>null)&#123;</span><br><span class="line">				<span class="keyword">while</span>(T2 != null)&#123;</span><br><span class="line">					<span class="built_in">int</span> sum = <span class="module-access"><span class="module"><span class="identifier">T2</span>.</span></span><span class="keyword">val</span> + carry;</span><br><span class="line">					<span class="keyword">if</span>(sum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">						carry = <span class="number">1</span>;</span><br><span class="line">						sum-=<span class="number">10</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						carry = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					ListNode node = <span class="keyword">new</span> <span class="constructor">ListNode(<span class="params">sum</span>)</span>;</span><br><span class="line">					tail.next = node;</span><br><span class="line">					tail = node;</span><br><span class="line">					T2 = <span class="module-access"><span class="module"><span class="identifier">T2</span>.</span></span>next;</span><br><span class="line">					<span class="keyword">if</span>(T2<span class="operator"> == </span>null)&#123;</span><br><span class="line">						deal<span class="constructor">WithCarry(<span class="params">carry</span>,<span class="params">tail</span>)</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(T1 != null)&#123;</span><br><span class="line">					<span class="built_in">int</span> sum = <span class="module-access"><span class="module"><span class="identifier">T1</span>.</span></span><span class="keyword">val</span> + carry;</span><br><span class="line">					<span class="keyword">if</span>(sum&gt;<span class="number">9</span>)&#123;</span><br><span class="line">						carry = <span class="number">1</span>;</span><br><span class="line">						sum-=<span class="number">10</span>;</span><br><span class="line">					&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">						carry = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					ListNode node = <span class="keyword">new</span> <span class="constructor">ListNode(<span class="params">sum</span>)</span>;</span><br><span class="line">					tail.next = node;</span><br><span class="line">					tail = node;</span><br><span class="line">					T1 = <span class="module-access"><span class="module"><span class="identifier">T1</span>.</span></span>next;</span><br><span class="line">					<span class="keyword">if</span>(T1<span class="operator"> == </span>null)&#123;</span><br><span class="line">						deal<span class="constructor">WithCarry(<span class="params">carry</span>,<span class="params">tail</span>)</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			ListNode result = temp.next; <span class="comment">// 排除首节点</span></span><br><span class="line">			return result;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void deal<span class="constructor">WithCarry(<span class="params">int</span> <span class="params">carry</span>,ListNode <span class="params">tail</span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 两个链的尾部都没有结点，但要处理 carry 的情况</span></span><br><span class="line">		<span class="keyword">if</span>(carry<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			tail.next = null;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			ListNode node = <span class="keyword">new</span> <span class="constructor">ListNode(<span class="params">carry</span>)</span>;</span><br><span class="line">			tail.next = node;</span><br><span class="line">			node.next = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public <span class="keyword">class</span> ListNode &#123;</span><br><span class="line">		<span class="built_in">int</span> <span class="keyword">val</span>;</span><br><span class="line">		ListNode next;</span><br><span class="line">		<span class="constructor">ListNode(<span class="params">int</span> <span class="params">x</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">val</span> = x;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h2><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3. </p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span>(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line"><span class="comment">//		String s = &quot;abcabcbb&quot;;</span></span><br><span class="line"><span class="comment">//		String s = &quot;bbbbbbb&quot;;</span></span><br><span class="line"><span class="comment">//		String s = &quot;pwwkew&quot;;</span></span><br><span class="line"><span class="comment">//		String s = &quot;dvdf&quot;;</span></span><br><span class="line"><span class="comment">//		String s = &quot;aabaab!bb&quot;;</span></span><br><span class="line">		<span class="built_in">String</span> s =<span class="string">&quot;asljlj&quot;</span>;</span><br><span class="line">		System.<span class="property">out</span>.<span class="property">println</span>(<span class="keyword">new </span><span class="class title_">Solution</span>().<span class="property">lengthOfLongestSubstring</span>(s));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span>(<span class="built_in">String</span> s) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">			Map&lt;<span class="built_in">String</span>,Integer&gt; <span class="built_in">map</span> = <span class="keyword">new </span><span class="class title_">HashMap</span>&lt;<span class="built_in">String</span>, Integer&gt;();</span><br><span class="line">			Map&lt;Integer,<span class="built_in">String</span>&gt; reverseMap = <span class="keyword">new </span><span class="class title_">HashMap</span>&lt;Integer, <span class="built_in">String</span>&gt;();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="property">length</span>();++i)&#123;</span><br><span class="line">			 	<span class="built_in">String</span> <span class="built_in">str</span> = s.<span class="property">substring</span>(i,i+<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>.<span class="property">containsKey</span>(<span class="built_in">str</span>))&#123;</span><br><span class="line">					<span class="comment">// 找到重复char，把char及前面的全部从map中删除，后面的重新编号</span></span><br><span class="line">					<span class="type">int</span> idx = <span class="built_in">map</span>.<span class="property">get</span>(<span class="built_in">str</span>);</span><br><span class="line">					<span class="type">int</span> temp = idx;</span><br><span class="line">					<span class="type">int</span> <span class="built_in">size</span> = <span class="built_in">map</span>.<span class="property">size</span>();</span><br><span class="line">					<span class="type">int</span> value = temp;</span><br><span class="line">					<span class="keyword">for</span>(;value&gt;<span class="number">0</span>;--value)&#123;</span><br><span class="line">						<span class="built_in">String</span> <span class="built_in">key</span> = reverseMap.<span class="property">get</span>(value);</span><br><span class="line">						<span class="built_in">map</span>.<span class="property">remove</span>(<span class="built_in">key</span>);</span><br><span class="line">						reverseMap.<span class="property">remove</span>(value);</span><br><span class="line">					&#125;</span><br><span class="line">					temp++;</span><br><span class="line">					<span class="keyword">for</span>(;temp&lt;=<span class="built_in">size</span>;++temp)&#123;</span><br><span class="line">						<span class="built_in">String</span> <span class="built_in">key</span> = reverseMap.<span class="property">get</span>(temp);</span><br><span class="line">						<span class="type">int</span> k = <span class="built_in">map</span>.<span class="property">get</span>(<span class="built_in">key</span>) - idx;</span><br><span class="line">						<span class="built_in">map</span>.<span class="property">put</span>(<span class="built_in">key</span>,k);</span><br><span class="line">						reverseMap.<span class="property">remove</span>(temp);</span><br><span class="line">						reverseMap.<span class="property">put</span>(k,<span class="built_in">key</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="built_in">map</span>.<span class="property">put</span>(<span class="built_in">str</span>,<span class="built_in">map</span>.<span class="property">size</span>()+<span class="number">1</span>);</span><br><span class="line">					reverseMap.<span class="property">put</span>(reverseMap.<span class="property">size</span>()+<span class="number">1</span>,<span class="built_in">str</span>);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					 <span class="built_in">map</span>.<span class="property">put</span>(<span class="built_in">str</span>,<span class="built_in">map</span>.<span class="property">size</span>()+<span class="number">1</span>);</span><br><span class="line">					 reverseMap.<span class="property">put</span>(reverseMap.<span class="property">size</span>()+<span class="number">1</span>,<span class="built_in">str</span>);</span><br><span class="line">				 &#125;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">map</span>.<span class="property">size</span>() &gt; <span class="built_in">max</span>)&#123;</span><br><span class="line">					<span class="built_in">max</span> = <span class="built_in">map</span>.<span class="property">size</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			 &#125;</span><br><span class="line">			 <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>维持一个最大值，遍历整个字符串，遍历经过的那个字符作为 subString 的末尾，将重复的char及更前面的全部删掉（使用 map和反map进行编号与定位）。</li>
<li>将重复处到遍历点之间重新编号（从1 开始）。</li>
</ol>
<h2 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h2><blockquote>
<p>Input: “babad”<br>Output: “bab”</p>
</blockquote>
<p>Note: “aba” is also a valid answer.</p>
<p>思路：最长回文子串：</p>
<ol>
<li>维护一个二维数组dp[i][j]，保存的是i、j的长度。</li>
<li>如果不是回文串，保存的是0.</li>
<li>先对1位、2位进行存入数组，之后就可以叠加了。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">package com.examination.learn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">static</span> <span class="type">int</span>[][] dp;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> str = sc.<span class="built_in">nextLine</span>();</span><br><span class="line">		dp = <span class="keyword">new</span> <span class="type">int</span>[str.<span class="built_in">length</span>()][str.<span class="built_in">length</span>()];</span><br><span class="line">		<span class="type">String</span> result = <span class="built_in">longestPalindrome</span>(str);</span><br><span class="line">		System.out.<span class="built_in">println</span>(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">String</span> <span class="title">longestPalindrome</span><span class="params">(<span class="type">String</span> s)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> resultX = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> resultY = <span class="number">0</span>; <span class="comment">// 直接用resultX、Y来保存最大的角标。</span></span><br><span class="line">		<span class="keyword">if</span>(s.<span class="built_in">isEmpty</span>())&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); ++i) &#123;</span><br><span class="line">			dp[i][i] = <span class="number">1</span>;</span><br><span class="line">			resultX = i;</span><br><span class="line">			resultY = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (s.<span class="built_in">charAt</span>(i) == s.<span class="built_in">charAt</span>(j)) &#123;</span><br><span class="line">				dp[i][j] = <span class="number">2</span>;</span><br><span class="line">				resultX = i;</span><br><span class="line">				resultY = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> step = <span class="number">3</span>; step &lt;= s.<span class="built_in">length</span>(); step++) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= s.<span class="built_in">length</span>() - step; ++i) &#123;</span><br><span class="line">				<span class="type">int</span> j = i + step - <span class="number">1</span>; <span class="comment">//i、j 分别是首末两位</span></span><br><span class="line">				<span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">					dp[i][j] = <span class="number">0</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (s.<span class="built_in">charAt</span>(i) == s.<span class="built_in">charAt</span>(j)) &#123;</span><br><span class="line">						dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">						resultX = i;</span><br><span class="line">						resultY = j;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						dp[i][j] = <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">String</span> result = s.<span class="built_in">substring</span>(resultX, resultY + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h2><p>阿拉伯数字转罗马数字</p>
<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>
<blockquote>
<p>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000</p>
</blockquote>
<p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>
<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>
<p>I can be placed before V (5) and X (10) to make 4 and 9.<br>X can be placed before L (50) and C (100) to make 40 and 90.<br>C can be placed before D (500) and M (1000) to make 400 and 900.<br>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: 3<br>Output: “III”</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: 4<br>Output: “IV”</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: 9<br>Output: “IX”</p>
</blockquote>
<p>Example 4:</p>
<blockquote>
<p>Input: 58<br>Output: “LVIII”<br>Explanation: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</p>
</blockquote>
<p>Example 5:</p>
<blockquote>
<p>Input: 1994<br>Output: “MCMXCIV”<br>Explanation: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90 and IV &#x3D; 4.</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">	System.out.<span class="built_in">println</span>(<span class="keyword">new</span> <span class="built_in">Solution</span>().<span class="built_in">intToRoman</span>(<span class="number">58</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span>[] values = &#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="type">String</span>[] strs = &#123;<span class="string">&quot;M&quot;</span>,<span class="string">&quot;CM&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;CD&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;XC&quot;</span>,<span class="string">&quot;L&quot;</span>,<span class="string">&quot;XL&quot;</span>,<span class="string">&quot;X&quot;</span>,<span class="string">&quot;IX&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;IV&quot;</span>,<span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">		StringBuilder result = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;values.length;++i)&#123;</span><br><span class="line">			<span class="keyword">while</span>(num&gt;=values[i])&#123;</span><br><span class="line">				num -= values[i];</span><br><span class="line">				result.<span class="built_in">append</span>(strs[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result.<span class="built_in">toString</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h2><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c &#x3D; 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>Note:</p>
<p>The solution set must not contain duplicate triplets.</p>
<p>Example:</p>
<blockquote>
<p>Given array nums &#x3D; [-1, 0, 1, 2, -1, -4],</p>
</blockquote>
<blockquote>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">	<span class="built_in">int</span><span class="literal">[]</span> nums = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">Solution()</span>.three<span class="constructor">Sum(<span class="params">nums</span>)</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">class</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">	public List&lt;List&lt;Integer&gt;&gt; three<span class="constructor">Sum(<span class="params">int</span>[] <span class="params">nums</span>)</span> &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(nums);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">i</span> - <span class="number">1</span>]</span>) &#123;</span><br><span class="line">				continue;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>, k = nums.length - <span class="number">1</span>; j &lt; k; ) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">i</span>]</span> + nums<span class="literal">[<span class="identifier">j</span>]</span> + nums<span class="literal">[<span class="identifier">k</span>]</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">list</span>.add(<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span><span class="keyword">as</span><span class="constructor">List(<span class="params">nums</span>[<span class="params">i</span>], <span class="params">nums</span>[<span class="params">j</span>], <span class="params">nums</span>[<span class="params">k</span>])</span>);</span><br><span class="line">					++j;</span><br><span class="line">					--k;</span><br><span class="line">					<span class="keyword">while</span> (j &lt; k<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">j</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">j</span> - <span class="number">1</span>]</span>) ++j;</span><br><span class="line">					<span class="keyword">while</span> (j &lt; k<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">k</span>]</span><span class="operator"> == </span>nums<span class="literal">[<span class="identifier">k</span> + <span class="number">1</span>]</span>) --k;</span><br><span class="line"></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums<span class="literal">[<span class="identifier">i</span>]</span> + nums<span class="literal">[<span class="identifier">j</span>]</span> + nums<span class="literal">[<span class="identifier">k</span>]</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					--k;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					++j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33.Search in Rotated Sorted Array"></a>33.Search in Rotated Sorted Array</h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>
<p>(i.e.,<code>[0,1,2,4,5,6,7]</code>might become <code>[4,5,6,7,0,1,2]</code>).</p>
<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>
<p>You may assume no duplicate exists in the array.</p>
<p>Your algorithm’s runtime complexity must be in the order of <code>O(log n)</code>.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>Output: 4</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>Output: -1</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    	public <span class="constructor">Solution()</span>&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 为满足题设要求，将四个参数的方法包装成两个参数的方法</span></span><br><span class="line">		public <span class="built_in">int</span> search(<span class="built_in">int</span><span class="literal">[]</span> nums,<span class="built_in">int</span> target)&#123;</span><br><span class="line">			return search(<span class="number">0</span>,nums.length-<span class="number">1</span>,nums,target);</span><br><span class="line">		&#125;</span><br><span class="line">		public <span class="built_in">int</span> search(<span class="built_in">int</span> i,<span class="built_in">int</span> j,<span class="built_in">int</span><span class="literal">[]</span> nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">			<span class="built_in">int</span> mid = (i+j)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;j)&#123;</span><br><span class="line">				return -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i<span class="operator"> == </span>j)&#123;</span><br><span class="line">				return nums<span class="literal">[<span class="identifier">i</span>]</span><span class="operator"> == </span>target ? i : -<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(nums<span class="literal">[<span class="identifier">i</span>]</span>&lt;nums<span class="literal">[<span class="identifier">mid</span>]</span>)&#123;</span><br><span class="line">				<span class="comment">// 前半部分有序</span></span><br><span class="line">				<span class="built_in">int</span> result = binary<span class="constructor">Search(<span class="params">i</span>,<span class="params">mid</span>,<span class="params">nums</span>,<span class="params">target</span>)</span>;</span><br><span class="line">				<span class="keyword">if</span>(result!=-<span class="number">1</span>)&#123;</span><br><span class="line">					return result;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					return search(mid+<span class="number">1</span>,j,nums,target);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">// 后半部分有序</span></span><br><span class="line">				<span class="built_in">int</span> result = binary<span class="constructor">Search(<span class="params">mid</span>+1,<span class="params">j</span>,<span class="params">nums</span>,<span class="params">target</span>)</span>;</span><br><span class="line">				<span class="keyword">if</span>(result != -<span class="number">1</span>)&#123;</span><br><span class="line">					return result; <span class="comment">// 二分</span></span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					return search(i,mid,nums,target); <span class="comment">// 递归 search 方法</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		public <span class="built_in">int</span> binary<span class="constructor">Search(<span class="params">int</span> <span class="params">i</span>,<span class="params">int</span> <span class="params">j</span>,<span class="params">int</span>[] <span class="params">nums</span>,<span class="params">int</span> <span class="params">target</span>)</span>&#123;</span><br><span class="line">			<span class="built_in">int</span> mid;</span><br><span class="line">			<span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(i<span class="operator"> == </span>j<span class="operator"> &amp;&amp; </span>nums<span class="literal">[<span class="identifier">i</span>]</span>!=target)</span><br><span class="line">					return -<span class="number">1</span>;</span><br><span class="line">				mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span>(nums<span class="literal">[<span class="identifier">mid</span>]</span>&lt;target)&#123;</span><br><span class="line">					i = mid+<span class="number">1</span>;</span><br><span class="line">					return binary<span class="constructor">Search(<span class="params">i</span>,<span class="params">j</span>,<span class="params">nums</span>,<span class="params">target</span>)</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums<span class="literal">[<span class="identifier">mid</span>]</span>&gt;target)&#123;</span><br><span class="line">					j = mid;</span><br><span class="line">					return binary<span class="constructor">Search(<span class="params">i</span>,<span class="params">j</span>,<span class="params">nums</span>,<span class="params">target</span>)</span>;</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					return mid;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			return -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&lt;!--评价--&gt;</span><br><span class="line">Runtime: <span class="number">11</span> ms, faster than <span class="number">80.79</span>% <span class="keyword">of</span> Java online submissions <span class="keyword">for</span> Search <span class="keyword">in</span> Rotated Sorted Array.</span><br></pre></td></tr></table></figure>

<p>说明：对于循环数组的二分查找，要求时间复杂度为O(logN)。</p>
<p>思路（分治、递归）：</p>
<ul>
<li>实现一个方法A：将数组第一个元素与mid比较，如果小于 mid ，说明数组的前一半有序；如果大于mid，说明数组后一半有序。</li>
<li>那么有序的一半采用常规二分，无序的一半依然是循环数组，将递归方法A。</li>
</ul>
<h1 id="hard"><a href="#hard" class="headerlink" title="hard"></a>hard</h1><h2 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h2><p>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<blockquote>
<p>nums1 &#x3D; [1, 3]<br>nums2 &#x3D; [2]</p>
</blockquote>
<p>The median is 2.0</p>
<p>Example 2:</p>
<blockquote>
<p>nums1 &#x3D; [1, 2]<br>nums2 &#x3D; [3, 4]</p>
</blockquote>
<p>The median is (2 + 3)&#x2F;2 &#x3D; 2.5</p>
<p>说明：</p>
<ol>
<li>标准答案居然是直接 sort ！！！ hard 界的耻辱！</li>
<li>所以我留下了不同的解法，如下</li>
<li>以下代码虽然没有 AC ，但我解决的是找中位数的问题，表示解决的很满意。</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">int</span><span class="literal">[]</span> nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">	<span class="built_in">int</span><span class="literal">[]</span> nums2 = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">	<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="keyword">new</span> <span class="constructor">Solution()</span>.find<span class="constructor">MedianSortedArrays(<span class="params">nums1</span>, <span class="params">nums2</span>)</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static <span class="keyword">class</span> Solution &#123;</span><br><span class="line">	public double find<span class="constructor">MedianSortedArrays(<span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span>[] <span class="params">nums2</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// 考虑到某个数组为空的场景</span></span><br><span class="line">		<span class="keyword">if</span> (nums1.length<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			return find<span class="constructor">Mid(<span class="params">nums1</span>)</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums2.length<span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			return find<span class="constructor">Mid(<span class="params">nums2</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		return find<span class="constructor">MedianSortedArrays(0, <span class="params">nums1</span>.<span class="params">length</span> - 1, 0, <span class="params">nums2</span>.<span class="params">length</span> - 1, <span class="params">nums1</span>, <span class="params">nums2</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double find<span class="constructor">MedianSortedArrays(<span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">j</span>, <span class="params">int</span> <span class="params">m</span>, <span class="params">int</span> <span class="params">n</span>, <span class="params">int</span>[] <span class="params">nums1</span>, <span class="params">int</span>[] <span class="params">nums2</span>)</span> &#123;</span><br><span class="line">		double result = <span class="number">0.0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i<span class="operator"> == </span>j<span class="operator"> || </span>m<span class="operator"> == </span>n) &#123;</span><br><span class="line">			<span class="comment">// 如果某个数组仅有一个元素，直接排序找中位数</span></span><br><span class="line">			result = sort(i, j, m, n, nums1, nums2);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums1<span class="literal">[(<span class="identifier">i</span> + <span class="identifier">j</span>) <span class="operator">/</span> <span class="number">2</span>]</span> &lt; nums2<span class="literal">[(<span class="identifier">m</span> + <span class="identifier">n</span>) <span class="operator">/</span> <span class="number">2</span>]</span>) &#123;</span><br><span class="line">			<span class="comment">// 砍掉nums1 的左边一半和 nums2 的右边一半</span></span><br><span class="line">			<span class="comment">// 考虑数组中剩下的元素个数，给予不同的策略</span></span><br><span class="line">				return find<span class="constructor">MedianSortedArrays((<span class="params">j</span> - <span class="params">i</span>)</span> % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span> ? (i + j)<span class="operator"> / </span><span class="number">2</span> : (i + j)<span class="operator"> / </span><span class="number">2</span> + <span class="number">1</span>, j, m, (m + n)<span class="operator"> / </span><span class="number">2</span>, nums1, nums2);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1<span class="literal">[(<span class="identifier">i</span> + <span class="identifier">j</span>) <span class="operator">/</span> <span class="number">2</span>]</span> &gt; nums2<span class="literal">[(<span class="identifier">m</span> + <span class="identifier">n</span>) <span class="operator">/</span> <span class="number">2</span>]</span>) &#123;</span><br><span class="line">				return find<span class="constructor">MedianSortedArrays(<span class="params">i</span>, (<span class="params">i</span> + <span class="params">j</span>)</span><span class="operator"> / </span><span class="number">2</span>, (n - m) % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span> ? (m + n)<span class="operator"> / </span><span class="number">2</span> : (m + n)<span class="operator"> / </span><span class="number">2</span> + <span class="number">1</span>, n, nums1, nums2);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				return find<span class="constructor">Mid(<span class="params">nums1</span>)</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double sort(<span class="built_in">int</span> i, <span class="built_in">int</span> j, <span class="built_in">int</span> m, <span class="built_in">int</span> n, <span class="built_in">int</span><span class="literal">[]</span> nums1, <span class="built_in">int</span><span class="literal">[]</span> nums2) &#123;</span><br><span class="line">		<span class="comment">// 将两个数组直接 sort 排序后返回中位数</span></span><br><span class="line">		<span class="built_in">int</span> size = j - i + n - m + <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">int</span><span class="literal">[]</span> xx = <span class="keyword">new</span> <span class="built_in">int</span><span class="literal">[<span class="identifier">size</span>]</span>;</span><br><span class="line">		<span class="built_in">int</span> u = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> t = i; t &lt;= j; ++t) &#123;</span><br><span class="line">			xx<span class="literal">[<span class="identifier">u</span><span class="operator">++</span>]</span> = nums1<span class="literal">[<span class="identifier">t</span>]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">int</span> t = m; t &lt;= n; ++t) &#123;</span><br><span class="line">			xx<span class="literal">[<span class="identifier">u</span><span class="operator">++</span>]</span> = nums2<span class="literal">[<span class="identifier">t</span>]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>sort(xx);</span><br><span class="line">		return find<span class="constructor">Mid(<span class="params">xx</span>)</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public double find<span class="constructor">Mid(<span class="params">int</span>[] <span class="params">num</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 传入一个数组，根据奇偶，返回中位数或者计算后的结果</span></span><br><span class="line">		<span class="built_in">int</span> size = num.length;</span><br><span class="line">		<span class="keyword">if</span> (size % <span class="number">2</span><span class="operator"> == </span><span class="number">0</span>) &#123;</span><br><span class="line">			return <span class="number">1.0</span><span class="operator"> * </span>(num<span class="literal">[<span class="identifier">size</span> <span class="operator">/</span> <span class="number">2</span> - <span class="number">1</span>]</span> + num<span class="literal">[<span class="identifier">size</span> <span class="operator">/</span> <span class="number">2</span>]</span>)<span class="operator"> / </span><span class="number">2</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			return <span class="number">1.0</span><span class="operator"> * </span>num<span class="literal">[<span class="identifier">size</span> <span class="operator">/</span> <span class="number">2</span>]</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>笔经整理2</title>
    <url>/2019/02/17/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%862/</url>
    <content><![CDATA[<h1 id="题目来源：牛客网"><a href="#题目来源：牛客网" class="headerlink" title="题目来源：牛客网"></a>题目来源：牛客网</h1><h2 id="1-编程题-连续最大和"><a href="#1-编程题-连续最大和" class="headerlink" title="1. [编程题] 连续最大和"></a>1. [编程题] 连续最大和</h2><blockquote>
<p>时间限制：1秒<br>空间限制：32768K</p>
</blockquote>
<p>一个数组有 N 个元素，求连续子数组的最大和。 例如：[-1,2,1]，和最大的连续子数组为[2,1]，其和为 3</p>
<p>输入描述:<br>输入为两行。 第一行一个整数n(1 &lt;&#x3D; n &lt;&#x3D; 100000)，表示一共有n个元素 第二行为n个数，即每个元素,每个整数都在32位int范围内。以空格分隔。</p>
<p>输出描述:<br>所有连续子数组中和最大的值。</p>
<p>输入例子1:</p>
<blockquote>
<p>3 -1 2 1</p>
</blockquote>
<p>输出例子1:</p>
<blockquote>
<p>3</p>
</blockquote>
<span id="more"></span>

<p>思路：</p>
<ol>
<li>维护一个长度为 n 的 num 数组，数组含义：以该元素为末尾的连续子集的最大和；</li>
<li>判断条件，如果 i-1 处的”最大和”加上num[i] 会使”最大和”有所增加，则更新”最大和”。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Scanner input = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> n = input.<span class="built_in">nextInt</span>();</span><br><span class="line">		<span class="type">int</span> max = <span class="number">-0x3ffffff</span>;</span><br><span class="line">		<span class="type">int</span>[] num = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">			<span class="type">int</span> t = input.<span class="built_in">nextInt</span>();</span><br><span class="line">			num[i] = t;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num[i] + num[i - <span class="number">1</span>] &gt; num[i]) &#123;</span><br><span class="line">					num[i] = num[i] + num[i - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (num[i] &gt; max) &#123;</span><br><span class="line">				max = num[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.<span class="built_in">println</span>(max);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-编程题-餐馆"><a href="#2-编程题-餐馆" class="headerlink" title="2. [编程题]餐馆"></a>2. [编程题]餐馆</h2><p>某餐馆有n张桌子，每张桌子有一个参数：a 可容纳的最大人数； 有m批客人，每批客人有两个参数:b人数，c预计消费金额。 在不允许拼桌的情况下，请实现一个算法选择其中一部分客人，使得总预计消费金额最大<br>输入描述:</p>
<blockquote>
<p>输入包括m+2行。 第一行两个整数n(1 &lt;&#x3D; n &lt;&#x3D; 50000),m(1 &lt;&#x3D; m &lt;&#x3D; 50000) 第二行为n个参数a,即每个桌子可容纳的最大人数,以空格分隔,范围均在32位int范围内。 接下来m行，每行两个参数b,c。分别表示第i批客人的人数和预计消费金额,以空格分隔,范围均在32位int范围内。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数,表示最大的总预计消费金额<br>示例1</p>
</blockquote>
<p>输入</p>
<blockquote>
<p>3 5 2 4 2 1 3 3 5 3 7 5 9 1 10</p>
</blockquote>
<p>输出</p>
<blockquote>
<p>20</p>
</blockquote>
<p>思路关键点：</p>
<ol>
<li>二维数组的 sort 方法（使用 Comparator）；</li>
<li>有序数组的二分查找</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">package org.written.program;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		Scanner input = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">input</span>.hasNext()) &#123;</span><br><span class="line">			<span class="type">int</span> n = <span class="keyword">input</span>.nextInt();</span><br><span class="line">			<span class="type">int</span> m = <span class="keyword">input</span>.nextInt();</span><br><span class="line">			<span class="type">int</span>[] desk = <span class="built_in">new</span> <span class="type">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				desk[i] = <span class="keyword">input</span>.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(desk);</span><br><span class="line">			<span class="type">int</span> maxDesk = desk[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span>[][] cus = <span class="built_in">new</span> <span class="type">int</span>[m][<span class="number">2</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">				cus[j][<span class="number">0</span>] = <span class="keyword">input</span>.nextInt();</span><br><span class="line">				cus[j][<span class="number">1</span>] = <span class="keyword">input</span>.nextInt();</span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(cus, <span class="built_in">new</span> Comparator&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				<span class="built_in">public</span> <span class="type">int</span> compare(<span class="type">int</span>[] a, <span class="type">int</span>[] b) &#123;</span><br><span class="line">					<span class="keyword">return</span> b[<span class="number">1</span>] - a[<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">//		计算最大金额</span><br><span class="line">			Long sum = <span class="number">0</span>l;</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span>;</span><br><span class="line">			<span class="type">boolean</span>[] tableNum = <span class="built_in">new</span> <span class="type">boolean</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cus[i][<span class="number">0</span>] &gt; maxDesk) &#123;</span><br><span class="line">					<span class="keyword">continue</span>; // 超过桌子容纳数量，跳过</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">index</span> = bs(desk, cus[i][<span class="number">0</span>]);</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">index</span> &lt; n &amp;&amp; tableNum[<span class="keyword">index</span>] == <span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">index</span>++;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">index</span> &lt; n) &#123;</span><br><span class="line">					sum += cus[i][<span class="number">1</span>];</span><br><span class="line">					tableNum[<span class="keyword">index</span>] = <span class="keyword">true</span>; // 去重</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println(sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">input</span>.<span class="keyword">close</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 二分查找</span><br><span class="line">	private static <span class="type">int</span> bs(<span class="type">int</span>[] num, <span class="type">int</span> tar) &#123;</span><br><span class="line">		<span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> high = num.length - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> mid;</span><br><span class="line">		<span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">			mid = (high + low) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (num[mid] &gt;= tar)</span><br><span class="line">				high = mid - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				low = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> low;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-最大乘积"><a href="#3-最大乘积" class="headerlink" title="3. 最大乘积"></a>3. 最大乘积</h2><p>给定一个无序数组，包含正数、负数和0，要求从中找出3个数的乘积，使得乘积最大，要求时间复杂度：O(n)，空间复杂度：O(1)</p>
<blockquote>
<p>输入描述:<br>无序整数数组A[n]</p>
</blockquote>
<blockquote>
<p>输出描述:<br>满足条件的最大乘积</p>
</blockquote>
<blockquote>
<p>输入例子1:<br>3 4 1 2</p>
</blockquote>
<blockquote>
<p>输出例子1:<br>24</p>
</blockquote>
<p>思路：听说用long就能解决，我这里用BigInteger算牛刀杀鸡了。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.math.BigInteger<span class="comment">;</span></span><br><span class="line">import java.util.Arrays<span class="comment">;</span></span><br><span class="line">import java.util.Scanner<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Scanner sc <span class="operator">=</span> new Scanner(System.in)<span class="comment">;</span></span><br><span class="line">		while (sc.hasNext()) &#123;</span><br><span class="line">			String str <span class="operator">=</span> sc.nextLine()<span class="comment">;</span></span><br><span class="line">			String[] strings <span class="operator">=</span> str.split(<span class="string">&quot;\\s+&quot;</span>)<span class="comment">;</span></span><br><span class="line">			if (strings <span class="operator">=</span><span class="operator">=</span> null) &#123;</span><br><span class="line">				continue<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">			if (strings.length &lt; <span class="number">3</span>) &#123;</span><br><span class="line">				continue<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">			BigInteger[] arg <span class="operator">=</span> new BigInteger[strings.length]<span class="comment">;</span></span><br><span class="line">			for (int i <span class="operator">=</span> <span class="number">0</span><span class="comment">; i &lt; arg.length; ++i) &#123;</span></span><br><span class="line">				arg[i] <span class="operator">=</span> BigInteger.valueOf(new Long(strings[i]))<span class="comment">;</span></span><br><span class="line">			&#125;</span><br><span class="line">			Arrays.sort(arg)<span class="comment">;</span></span><br><span class="line">			BigInteger max <span class="operator">=</span> BigInteger.valueOf(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">			max <span class="operator">=</span> arg[<span class="number">0</span>].multiply(arg[<span class="number">1</span>]).multiply(arg[<span class="number">2</span>]).max(max)<span class="comment">;</span></span><br><span class="line">			max <span class="operator">=</span> arg[<span class="number">0</span>].multiply(arg[<span class="number">1</span>]).multiply(arg[arg.length - <span class="number">1</span>]).max(max)<span class="comment">;</span></span><br><span class="line">			max <span class="operator">=</span> arg[<span class="number">0</span>].multiply(arg[arg.length - <span class="number">2</span>]).multiply(arg[arg.length - <span class="number">1</span>]).max(max)<span class="comment">;</span></span><br><span class="line">			max <span class="operator">=</span> arg[arg.length - <span class="number">3</span>].multiply(arg[arg.length - <span class="number">2</span>]).multiply(arg[arg.length - <span class="number">1</span>]).max(max)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">			System.out.println(max)<span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="私下练习（蛮好的题目）："><a href="#私下练习（蛮好的题目）：" class="headerlink" title="私下练习（蛮好的题目）："></a>私下练习（蛮好的题目）：</h1><h3 id="1-试题一"><a href="#1-试题一" class="headerlink" title="1. 试题一"></a>1. 试题一</h3><p>自定义函数，实现求解任意整数的幂运算，例如2^9, 3^(-5).</p>
<p>最佳要求：时间复杂度log N.</p>
<h3 id="2-试题二"><a href="#2-试题二" class="headerlink" title="2. 试题二"></a>2. 试题二</h3><p>给定一个m位的正整数n，2≤m≤15，可以通过交换任意两个数位上数字的位置使其尽可能比原来数字大。求k次交换后，可以获得最大的数字。</p>
<p>注意：每次交换时，不能使第一个数位上的数字为0.</p>
<p>例如：输入1374，2 输出为7413，表示1374经过两次数位交换，可以获得的最大数字为7413。</p>
<h3 id="3-试题三"><a href="#3-试题三" class="headerlink" title="3. 试题三"></a>3. 试题三</h3><p>给定任意一维数组，如{1, 4, 3, 5, 9, 12, 11, 14, 17}。该数组可能是有序的，也可能是无序的。请写一个函数，求出将该数组变成有序数组时，最少需要重新排序的元素个数。例如{1, 4, 3, 5, 9, 12, 11, 14, 17}，输出结果为：6，需要对{4, 3, 5, 9, 12, 11}重新排序。</p>
<p>最佳要求：时间复杂度O(N)，空间复杂度O(1)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义函数，实现求解任意整数的幂运算，例如2^9, 3^(-5).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳要求：时间复杂度log N.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Question1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">			<span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// true 表示 b 为正数</span></span><br><span class="line">			<span class="keyword">if</span> (b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				b = -b;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> getPower(a, b);</span><br><span class="line">			<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">				System.out.println(<span class="number">1.0</span> / result);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速降幂</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getPower</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">				result = a * result;</span><br><span class="line">			&#125;</span><br><span class="line">			a = a * a;</span><br><span class="line">			b = b &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 题目二：</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定一个m位的正整数n，2≤m≤15，可以通过交换任意两个数位上数字的位置使其尽可能比原来数字大。求k次交换后，可以获得最大的数字。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 注意：每次交换时，不能使第一个数位上的数字为0.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 例如：输入1374，2 输出为7413，表示1374经过两次数位交换，可以获得的最大数字为7413。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Question2 &#123;</span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">		Scanner sc = <span class="built_in">new</span> Scanner(<span class="keyword">System</span>.<span class="keyword">in</span>);</span><br><span class="line">		<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">			<span class="type">int</span> m = sc.nextInt();</span><br><span class="line">			<span class="type">int</span> n = sc.nextInt();</span><br><span class="line">			<span class="type">int</span> length = String.valueOf(m).length();</span><br><span class="line">			<span class="type">int</span>[] num = <span class="built_in">new</span> <span class="type">int</span>[length];</span><br><span class="line">			// 转换为数组</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; <span class="comment">--i) &#123;</span></span><br><span class="line">				num[i] = m % <span class="number">10</span>;</span><br><span class="line">				m /= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> count = <span class="number">0</span>;// 交换计数</span><br><span class="line">			<span class="type">int</span> <span class="keyword">index</span> = <span class="number">0</span>;// 遍历索引</span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (count &gt;= n || <span class="keyword">index</span> &gt;= length) &#123;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 找到最大数及角标</span><br><span class="line">				<span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">				<span class="type">int</span> maxIndex = <span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="keyword">index</span> + <span class="number">1</span>; i &lt; length; ++i) &#123;</span><br><span class="line">					<span class="keyword">if</span> (num[i] &gt; max) &#123;</span><br><span class="line">						max = num[i];</span><br><span class="line">						maxIndex = i;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (maxIndex != <span class="number">-1</span>) &#123;</span><br><span class="line">					// 交换</span><br><span class="line">					exchange(num, <span class="keyword">index</span>, maxIndex);</span><br><span class="line">					++count;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				++<span class="keyword">index</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">				<span class="keyword">System</span>.<span class="keyword">out</span>.print(num[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">System</span>.<span class="keyword">out</span>.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">public</span> static <span class="type">void</span> exchange(<span class="type">int</span>[] num, <span class="type">int</span> <span class="keyword">index</span>, <span class="type">int</span> maxIndex) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">index</span> == maxIndex) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="keyword">temp</span> = num[<span class="keyword">index</span>];</span><br><span class="line">		num[<span class="keyword">index</span>] = num[maxIndex];</span><br><span class="line">		num[maxIndex] = <span class="keyword">temp</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<hr>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 题目三：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">static</span> java.lang.Math.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给定任意一维数组，如&#123;1, 4, 3, 5, 9, 12, 11, 14, 17&#125;。</span></span><br><span class="line"><span class="comment"> * 该数组可能是有序的，也可能是无序的。请写一个函数，求出将该数组变成有序数组时，最少需要重新排序的元素个数。</span></span><br><span class="line"><span class="comment"> * 例如&#123;1, 4, 3, 5, 9, 12, 11, 14, 17&#125;，输出结果为：6，需要对&#123;4, 3, 5, 9, 12, 11&#125;重新排序。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 最佳要求：时间复杂度O(N)，空间复杂度O(1)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Question3</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> <span class="built_in">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">String</span> input = sc.<span class="built_in">nextLine</span>();</span><br><span class="line">		<span class="type">String</span>[] strs = input.<span class="built_in">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		<span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="type">int</span>[strs.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.length; ++i) &#123;</span><br><span class="line">			nums[i] = Integer.<span class="built_in">parseInt</span>(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> flag = <span class="literal">true</span>; <span class="comment">// 默认增序</span></span><br><span class="line">		<span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="comment">// 降序</span></span><br><span class="line">			flag = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> maxIndex = flag ? <span class="number">0</span> : nums.length - <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> minIndex = flag ? nums.length - <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> max = nums[maxIndex];</span><br><span class="line">		<span class="type">int</span> min = nums[minIndex];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">				<span class="type">int</span> j = nums.length - i - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] &gt;= max) &#123;</span><br><span class="line">					max = nums[i];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					maxIndex = i;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums[j] &lt; min) &#123;</span><br><span class="line">					min = nums[j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">				<span class="type">int</span> j = nums.length - i - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (nums[j] &gt;= max) &#123;</span><br><span class="line">					max = nums[j];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					maxIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (nums[i] &lt; min) &#123;</span><br><span class="line">					min = nums[i];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					minIndex = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> result = <span class="built_in">abs</span>(maxIndex - minIndex) + <span class="number">1</span>;</span><br><span class="line">		System.out.<span class="built_in">println</span>(result);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>笔经整理3</title>
    <url>/2019/07/12/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%863/</url>
    <content><![CDATA[<h1 id="题目来源：力扣-462-x2F-840-x2F-1006-x2F-433-x2F-112-x2F-78-x2F-784-x2F-875"><a href="#题目来源：力扣-462-x2F-840-x2F-1006-x2F-433-x2F-112-x2F-78-x2F-784-x2F-875" class="headerlink" title="题目来源：力扣 462&#x2F;840&#x2F;1006&#x2F;433&#x2F;112&#x2F;78&#x2F;784&#x2F;875"></a>题目来源：力扣 462&#x2F;840&#x2F;1006&#x2F;433&#x2F;112&#x2F;78&#x2F;784&#x2F;875</h1><h4 id="力扣462-最少移动次数使数组元素相等-II"><a href="#力扣462-最少移动次数使数组元素相等-II" class="headerlink" title="力扣462. 最少移动次数使数组元素相等 II"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements-ii/">力扣462. 最少移动次数使数组元素相等 II</a></h4><p>给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。</p>
<p>例如:</p>
<p>输入:<br>[1,2,3]</p>
<p>输出:<br>2</p>
<p>说明：<br>只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： </p>
<p>[1,2,3]  &#x3D;&gt;  [2,2,3]  &#x3D;&gt;  [2,2,2]</p>
<span id="more"></span>



<p>思路：排序后，中位数就是所求 target，然后计算其他成员距此 target 的距离之和。</p>
<p>如果中位数是两个，两个都可以是 target，最终结果都一样，所以任选其一即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 最少移动次数使数组元素相等II &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">		Assert.assertEquals(<span class="number">2</span>, minMoves2(nums));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == nums || nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(nums);</span><br><span class="line">		<span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">			ret += Math.abs(target - nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="力扣-840-矩阵中的幻方"><a href="#力扣-840-矩阵中的幻方" class="headerlink" title="力扣 840. 矩阵中的幻方"></a><a href="https://leetcode-cn.com/problems/magic-squares-in-grid/">力扣 840. 矩阵中的幻方</a></h4><p>3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。</p>
<p>给定一个由整数组成的 grid，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。</p>
<p>示例：</p>
<p>输入: [[4,3,8,4],<br>      [9,5,1,9],<br>      [2,7,6,2]]<br>输出: 1<br>解释:<br>下面的子矩阵是一个 3 x 3 的幻方：<br>438<br>951<br>276</p>
<p>而这一个不是：<br>384<br>519<br>762</p>
<p>总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。<br>提示:</p>
<p>1 &lt;&#x3D; grid.length &lt;&#x3D; 10<br>1 &lt;&#x3D; grid[0].length &lt;&#x3D; 10<br>0 &lt;&#x3D; grid[i][j] &lt;&#x3D; 15</p>
<p>思路：</p>
<ol>
<li>这题不难，就是恶心，注意点：数值需要保证在 1~9 之前，数值需要各不相同</li>
<li>正中心的数据就必须是 5 了（本解法未体现），但是暴力穷举的逻辑还是免不了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 矩阵中的幻方 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[][] grid = &#123;&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>&#125;, &#123;<span class="number">9</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> numMagicSquaresInside(grid);</span><br><span class="line">		Assert.assertEquals(<span class="number">1</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[][] grid = &#123;&#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;, &#123;<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> numMagicSquaresInside(grid);</span><br><span class="line">		Assert.assertEquals(<span class="number">0</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[][] grid = &#123;&#123;<span class="number">10</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> numMagicSquaresInside(grid);</span><br><span class="line">		Assert.assertEquals(<span class="number">0</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMagicSquaresInside</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">		<span class="keyword">if</span> (m &lt; <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">		<span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isGrid(grid, i, j)) &#123;</span><br><span class="line">					ret++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isGrid</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> isSameValue(grid, x, y);</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>];</span><br><span class="line">		sum[<span class="number">0</span>] = grid[x - <span class="number">1</span>][y - <span class="number">1</span>] + grid[x - <span class="number">1</span>][y] + grid[x - <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">		sum[<span class="number">1</span>] = grid[x][y - <span class="number">1</span>] + grid[x][y] + grid[x][y + <span class="number">1</span>];</span><br><span class="line">		sum[<span class="number">2</span>] = grid[x + <span class="number">1</span>][y - <span class="number">1</span>] + grid[x + <span class="number">1</span>][y] + grid[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		sum[<span class="number">3</span>] = grid[x - <span class="number">1</span>][y - <span class="number">1</span>] + grid[x][y - <span class="number">1</span>] + grid[x + <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line">		sum[<span class="number">4</span>] = grid[x - <span class="number">1</span>][y] + grid[x][y] + grid[x + <span class="number">1</span>][y];</span><br><span class="line">		sum[<span class="number">5</span>] = grid[x - <span class="number">1</span>][y + <span class="number">1</span>] + grid[x][y + <span class="number">1</span>] + grid[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		sum[<span class="number">6</span>] = grid[x - <span class="number">1</span>][y - <span class="number">1</span>] + grid[x][y] + grid[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">		sum[<span class="number">7</span>] = grid[x - <span class="number">1</span>][y + <span class="number">1</span>] + grid[x][y] + grid[x + <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sum.length; i++) &#123;</span><br><span class="line">			flag = (sum[i - <span class="number">1</span>] == sum[i]);</span><br><span class="line">			<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameValue</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> grid[x + i][y + j];</span><br><span class="line">				<span class="keyword">if</span> (temp &lt; <span class="number">1</span> || temp &gt; <span class="number">9</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					map.put(temp, <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="力扣-1006-笨阶乘"><a href="#力扣-1006-笨阶乘" class="headerlink" title="力扣 1006. 笨阶乘"></a><a href="https://leetcode-cn.com/problems/clumsy-factorial/">力扣 1006. 笨阶乘</a></h4><p>通常，正整数 n 的阶乘是所有小于或等于 n 的正整数的乘积。例如，factorial(10) &#x3D; 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1。</p>
<p>相反，我们设计了一个笨阶乘 clumsy：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(&#x2F;)，加法(+)和减法(-)。</p>
<p>例如，clumsy(10) &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>
<p>另外，我们使用的除法是地板除法（floor division），所以 10 * 9 &#x2F; 8 等于 11。这保证结果是一个整数。</p>
<p>实现上面定义的笨函数：给定一个整数 N，它返回 N 的笨阶乘。</p>
<p>示例 1：</p>
<p>输入：4<br>输出：7<br>解释：7 &#x3D; 4 * 3 &#x2F; 2 + 1<br>示例 2：</p>
<p>输入：10<br>输出：12<br>解释：12 &#x3D; 10 * 9 &#x2F; 8 + 7 - 6 * 5 &#x2F; 4 + 3 - 2 * 1</p>
<p>思路：</p>
<ol>
<li><p>当 N&gt;4时，N * (N-1)&#x2F;(N-2) &#x3D; N + 1 始终成立，所以<code>(N+1) - N * (N-1)/(N-2) = N + 1</code>总是等于 0，所以可以做适当的消项</p>
</li>
<li><p>当 N&gt;4 时，结果分别是 N+1,N+2,N+2,N-1</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 笨阶乘 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> clumsy(<span class="number">4</span>);</span><br><span class="line">		Assert.assertEquals(<span class="number">7</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> clumsy(<span class="number">10</span>);</span><br><span class="line">		Assert.assertEquals(<span class="number">12</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当 N&gt;3 时，N * (N-1)/(N-2) = N + 1 始终成立</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">clumsy</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] smallNum = &#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>&#125;;</span><br><span class="line">		<span class="type">int</span>[] num = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">		<span class="keyword">return</span> N &gt; <span class="number">4</span> ? N + num[N % <span class="number">4</span>] : smallNum[N % <span class="number">4</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h4><p>一条基因序列由一个带有8个字符的字符串表示，其中每个字符都属于 “A”, “C”, “G”, “T”中的任意一个。</p>
<p>假设我们要调查一个基因序列的变化。一次基因变化意味着这个基因序列中的一个字符发生了变化。</p>
<p>例如，基因序列由”AACCGGTT” 变化至 “AACCGGTA” 即发生了一次基因变化。</p>
<p>与此同时，每一次基因变化的结果，都需要是一个合法的基因串，即该结果属于一个基因库。</p>
<p>现在给定3个参数 — start, end, bank，分别代表起始基因序列，目标基因序列及基因库，请找出能够使起始基因序列变化为目标基因序列所需的最少变化次数。如果无法实现目标变化，请返回 -1。</p>
<p>注意:</p>
<p>起始基因序列默认是合法的，但是它并不一定会出现在基因库中。<br>所有的目标基因序列必须是合法的。<br>假定起始基因序列与目标基因序列是不一样的。</p>
<p>思路：BFS 的经典问题，还是很简单的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 最小基因变化 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;AACCGGTT&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="string">&quot;AACCGGTA&quot;</span>;</span><br><span class="line">		String[] bank = &#123;<span class="string">&quot;AACCGGTA&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> minMutation(start, end, bank);</span><br><span class="line">		Assert.assertEquals(<span class="number">1</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;AACCGGTT&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="string">&quot;AAACGGTA&quot;</span>;</span><br><span class="line">		String[] bank = &#123;<span class="string">&quot;AACCGGTA&quot;</span>, <span class="string">&quot;AACCGCTA&quot;</span>, <span class="string">&quot;AAACGGTA&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> minMutation(start, end, bank);</span><br><span class="line">		Assert.assertEquals(<span class="number">2</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">start</span> <span class="operator">=</span> <span class="string">&quot;AAAAACCC&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> <span class="string">&quot;AACCCCCC&quot;</span>;</span><br><span class="line">		String[] bank = &#123;<span class="string">&quot;AAAACCCC&quot;</span>, <span class="string">&quot;AAACCCCC&quot;</span>, <span class="string">&quot;AACCCCCC&quot;</span>&#125;;</span><br><span class="line">		<span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> minMutation(start, end, bank);</span><br><span class="line">		Assert.assertEquals(<span class="number">3</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMutation</span><span class="params">(String start, String end, String[] bank)</span> &#123;</span><br><span class="line">		List&lt;String&gt; bankList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(bank));</span><br><span class="line">		Collections.sort(bankList);</span><br><span class="line">		<span class="keyword">if</span> (!bankList.contains(end)) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; stage1 = findStage1List(start, bankList);</span><br><span class="line">		Queue&lt;String&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;() &#123;&#123;addAll(stage1);&#125;&#125;;</span><br><span class="line">		Map&lt;String, Integer&gt; visitMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		stage1.forEach(str -&gt; visitMap.put(str, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">top</span> <span class="operator">=</span> q.poll();</span><br><span class="line">			<span class="keyword">if</span> (end.equals(top)) &#123;</span><br><span class="line">				<span class="keyword">return</span> visitMap.get(top);</span><br><span class="line">			&#125;</span><br><span class="line">			List&lt;String&gt; nextList = findStage1List(top, bankList);</span><br><span class="line">			<span class="keyword">for</span> (String str : nextList) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!visitMap.containsKey(str)) &#123;</span><br><span class="line">					visitMap.put(str, visitMap.get(top) + <span class="number">1</span>);</span><br><span class="line">					q.add(str);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找相差一个字符的字符串列表</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; <span class="title function_">findStage1List</span><span class="params">(String start, List&lt;String&gt; bankList)</span> &#123;</span><br><span class="line">		List&lt;String&gt; firstStageList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String bank : bankList) &#123;</span><br><span class="line">			<span class="keyword">if</span> (only1diff(start, bank)) &#123;</span><br><span class="line">				firstStageList.add(bank);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> firstStageList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否只差一个字符</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">only1diff</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == str1 || <span class="literal">null</span> == str2 || str1.length() != str2.length()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length(); ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (str1.charAt(i) != str2.charAt(i)) &#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h4><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<p>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
</code></pre>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p>
<p>思路：太简单了，不值一提，不过 sum 逐级减值是个不错的思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 路径总和 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root11</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">11</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root13</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">13</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root4II</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">8</span>);</span><br><span class="line">		<span class="type">TreeNode</span> <span class="variable">root5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">		root11.left = root7;</span><br><span class="line">		root11.right = root2;</span><br><span class="line">		root4.right = root1;</span><br><span class="line">		root4II.left = root11;</span><br><span class="line">		root8.left = root13;</span><br><span class="line">		root8.right = root4;</span><br><span class="line">		root5.left = root4II;</span><br><span class="line">		root5.right = root8;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">ret</span> <span class="operator">=</span> hasPathSum(root5, sum);</span><br><span class="line">		Assert.assertEquals(<span class="literal">true</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; sum - root.val == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Definition for a binary tree node.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(<span class="type">int</span> x) &#123;</span><br><span class="line">			val = x;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<p>输入: nums &#x3D; [1,2,3]<br>输出:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<p>思路： set 去重，回溯法求解，简单</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 子集 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = subsets(nums);</span><br><span class="line">		result.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		List&lt;Integer&gt; numList = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">		Collections.sort(numList);</span><br><span class="line">		Set&lt;Set&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Set&lt;Integer&gt; singleSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		subsets(numList, singleSet, ret);</span><br><span class="line">		List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		ret.forEach( set -&gt; &#123;</span><br><span class="line">			List&lt;Integer&gt; list = set.stream().collect(Collectors.toList());</span><br><span class="line">			result.add(list);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">subsets</span><span class="params">(List&lt;Integer&gt; numList, Set&lt;Integer&gt; singleSet, Set&lt;Set&lt;Integer&gt;&gt; ret)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (numList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			Set&lt;Integer&gt; tempSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(singleSet);</span><br><span class="line">			ret.add(tempSet);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">firstNum</span> <span class="operator">=</span> numList.get(<span class="number">0</span>);</span><br><span class="line">		numList.remove(<span class="number">0</span>);</span><br><span class="line">		singleSet.add(firstNum);</span><br><span class="line">		subsets(numList,singleSet,ret);</span><br><span class="line">		singleSet.remove(singleSet.remove(firstNum));</span><br><span class="line">		subsets(numList,singleSet,ret);</span><br><span class="line">		numList.add(<span class="number">0</span>,firstNum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode-cn.com/problems/letter-case-permutation/">784. 字母大小写全排列</a></h4><p>给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p>
<p>示例:<br>输入: S &#x3D; “a1b2”<br>输出: [“a1b2”, “a1B2”, “A1b2”, “A1B2”]</p>
<p>输入: S &#x3D; “3z4”<br>输出: [“3z4”, “3Z4”]</p>
<p>输入: S &#x3D; “12345”<br>输出: [“12345”]<br>注意：</p>
<p>S 的长度不超过12。<br>S 仅由数字和字母组成。</p>
<p>思路：回溯法的思想。<code>Character.isUpperCase()</code>记得巧用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 字母大小写全排列 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a1b2&quot;</span>;</span><br><span class="line">		List&lt;String&gt; ret = letterCasePermutation(s);</span><br><span class="line">		ret.forEach(System.out::println); <span class="comment">// [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">		List&lt;String&gt; ret = letterCasePermutation(s);</span><br><span class="line">		ret.forEach(System.out::println); <span class="comment">// [&quot;12345&quot;]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult3</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;3z4&quot;</span>;</span><br><span class="line">		List&lt;String&gt; ret = letterCasePermutation(s);</span><br><span class="line">		ret.forEach(System.out::println); <span class="comment">// [&quot;3z4&quot;, &quot;3Z4&quot;]</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCasePermutation</span><span class="params">(String S)</span> &#123;</span><br><span class="line">		List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		letterCasePermutation(ret, S, str, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">letterCasePermutation</span><span class="params">(List&lt;String&gt; ret, String S, String str, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (index == S.length()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(str);</span><br><span class="line">			ret.add(temp);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> S.charAt(index);</span><br><span class="line">		str += c;</span><br><span class="line">		letterCasePermutation(ret, S, str, index + <span class="number">1</span>);</span><br><span class="line">		str = str.substring(<span class="number">0</span>, str.length() - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (Character.isAlphabetic(c)) &#123;</span><br><span class="line">			str += changeCase(c);</span><br><span class="line">			letterCasePermutation(ret, S, str, index + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换大小写</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">char</span> <span class="title function_">changeCase</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (Character.isUpperCase(c)) &#123;</span><br><span class="line">			<span class="keyword">return</span> Character.toLowerCase(c);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Character.toUpperCase(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="875-爱吃香蕉的珂珂"><a href="#875-爱吃香蕉的珂珂" class="headerlink" title="875. 爱吃香蕉的珂珂"></a><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></h4><p>珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>
<p>珂珂可以决定她吃香蕉的速度 K （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  </p>
<p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>
<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>
<p>示例 1：</p>
<p>输入: piles &#x3D; [3,6,7,11], H &#x3D; 8<br>输出: 4<br>示例 2：</p>
<p>输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 5<br>输出: 30<br>示例 3：</p>
<p>输入: piles &#x3D; [30,11,23,4,20], H &#x3D; 6<br>输出: 23</p>
<p>思路：二分查找，不然容易超时</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 爱吃香蕉的珂珂 &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult1</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] piles = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">		Assert.assertEquals(<span class="number">4</span>, minEatingSpeed(piles, <span class="number">8</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult2</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] piles2 = &#123;<span class="number">30</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">20</span>&#125;;</span><br><span class="line">		Assert.assertEquals(<span class="number">30</span>, minEatingSpeed(piles2, <span class="number">5</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testResult3</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] piles2 = &#123;<span class="number">30</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">20</span>&#125;;</span><br><span class="line">		Assert.assertEquals(<span class="number">23</span>, minEatingSpeed(piles2, <span class="number">6</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H)</span> &#123;</span><br><span class="line">		Arrays.sort(piles);</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = piles[piles.length-<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i+j)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(canEatOver(piles,H,mid))&#123;</span><br><span class="line">				j = mid;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				i = mid+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canEatOver</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> H, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">			sum += Math.ceil(<span class="number">1.0</span> * pile / i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum &lt;= H;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制笔记</title>
    <url>/2018/12/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="1-六种主动使用类的场景"><a href="#1-六种主动使用类的场景" class="headerlink" title="1. 六种主动使用类的场景"></a>1. 六种主动使用类的场景</h1><p>按照 JVM 规范，每个类或者接口被 Java 程序首次主动使用时，才会对其进行初始化。</p>
<p>以下六种操作会导致类的初始化，除了这六种，其他情况都属于被动使用，不会导致类的加载和初始化。</p>
<ol>
<li>通过 new 关键词。</li>
<li>访问类的静态变量（但 final 修饰的静态变量实质上是静态常量，不属于此范畴，不会初始化类）。</li>
<li>访问类的静态方法。</li>
<li>对类进行反射操作。</li>
<li>初始化子类会导致父类的初始化。</li>
<li>启动类。也就是 main 函数所在的类会被初始化。</li>
</ol>
<span id="more"></span>

<h1 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h1><p>分成三个阶段：加载阶段、连接阶段、初始化阶段。</p>
<h2 id="2-1-加载阶段"><a href="#2-1-加载阶段" class="headerlink" title="2.1 加载阶段"></a>2.1 加载阶段</h2><p>① 查找并加载类的二进制数据文件（即 class 文件）读取到内存中；② 然后将字节流代表的静态存储结构转换成<strong>方法区中运行时的数据结构</strong>；③ 并且在堆内存中生成一个该类的 Class 对象，作为访问方法区数据结构的入口。</p>
<h2 id="2-2-连接阶段"><a href="#2-2-连接阶段" class="headerlink" title="2.2 连接阶段"></a>2.2 连接阶段</h2><p>细分为三个阶段：验证、准备、解析。</p>
<h3 id="2-2-1-验证"><a href="#2-2-1-验证" class="headerlink" title="2.2.1 验证"></a>2.2.1 验证</h3><p>概述：确保类文件的正确性，比如 class 的版本、class 文件的魔术因子是否正确。</p>
<p>主要验证：</p>
<ol>
<li>文件格式验证。确定文件类型、JDK 版本号、文件完整性、变量类型是否被支持、引用指向是否正确等。</li>
<li>元数据验证。对 class 字节流进行语义分析，确保 class 字节流符合 JVM 规范的要求。	<ul>
<li>比如检查类的父类、是否继承了 final 类，是否为抽象类，方法重载的合法性等。</li>
</ul>
</li>
<li>字节码验证。主要验证程序的控制流程，比如循环、分支等。<ul>
<li>保证线程在程序计数器中的指令不会跳转到不合法的字节码指令中去。</li>
<li>保证类型转换合法。</li>
<li>保证虚拟机栈中的操作栈类型和指令代码能够正确执行。</li>
</ul>
</li>
<li>符号引用验证。验证符号引用转换成直接引用时的合法性，保证解析动作的顺利执行。</li>
</ol>
<h3 id="2-2-2-准备"><a href="#2-2-2-准备" class="headerlink" title="2.2.2 准备"></a>2.2.2 准备</h3><p>为类的静态变量分配内存，并且为其初始化默认值（而非程序编写时的赋值）。</p>
<blockquote>
<p>类变量的内存会被分配到方法区中，实例变量会被分配到堆内存中。</p>
</blockquote>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedPrepare</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> a = <span class="number">10</span>; <span class="comment">// 准备阶段，a 是 0（Int 的 default 值）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="built_in">int</span> b = <span class="number">10</span>; </span><br><span class="line">	<span class="comment">// 准备阶段，b 就是 10，因为 b 是静态常量，本就没有连接阶段</span></span><br><span class="line">	<span class="comment">// ，在编译阶段就被赋值 10 了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-3-解析"><a href="#2-2-3-解析" class="headerlink" title="2.2.3 解析"></a>2.2.3 解析</h3><p>概述：把类中的符号引用转换为直接引用。</p>
<ul>
<li>比如一些成员对象某 object，可以访问它的可见的属性和方法，但在 class 字节码中不是这样。</li>
<li>在 class 字节码中，它被编译成符号引用。在类解析时，需要转换成直接引用，才能正确地找到对应堆内存中的该 object 数据结构。</li>
</ul>
<p>解析过程主要针对类接口、字段、类方法和接口方法这四类进行。</p>
<ol>
<li>类接口：如果是  object ，需要对这个 object 类先进行加载，会经历 classLoader 全过程。</li>
<li>字段的解析：根据继承关系自下而上地查找，找到了就可以返回字段的引用。</li>
<li>类方法的解析：根据继承关系自下而上地查找，如果找到了方法描述和目标方法完全一致的方法（不能是接口方法），则返回这个方法的引用。</li>
<li>接口方法的解析：根据继承关系自下而上地查找，如果找到了方法描述和目标方法完全一致的方法（不能是类方法），则返回这个方法的引用。</li>
</ol>
<h2 id="2-3-初始化阶段"><a href="#2-3-初始化阶段" class="headerlink" title="2.3 初始化阶段"></a>2.3 初始化阶段</h2><p>概述：为类的静态变量赋予正确的初始值。</p>
<p>Tips：</p>
<ol>
<li>赋值的是<code>&lt;clinit&gt;()</code>方法，它是在编译阶段生成的，已经包含在 class 文件中了，而且能够保证顺序性。</li>
<li>父类的静态变量总是能够得到优先赋值。</li>
<li>如果某个类既没有静态代码块，也没有静态变量，那么它就没有生成<code>&lt;clinit&gt;()</code>方法的必要了。</li>
</ol>
<p>Ps：Clinit方法，推荐阅读：<a href="http://www.importnew.com/20054.html">类加载过程</a>的<code>&lt;clinit&gt;()</code>部分，提炼如下：</p>
<ol>
<li>由编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>合并产生的。</li>
<li>虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。</li>
<li><code>&lt;clinit&gt;()</code>方法可以保证百分之百同步，因为如果有多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都需要阻塞等待。</li>
</ol>
<h1 id="3-JVM-的类加载器"><a href="#3-JVM-的类加载器" class="headerlink" title="3. JVM 的类加载器"></a>3. JVM 的类加载器</h1><p> 有三种：BootStrap ClassLoader、Ext ClassLoader、Application ClassLoader。</p>
<p><img src="/2018/12/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/1.png" alt="1"></p>
<ol>
<li>BootStrap ClassLoader.通过<code>-Xbootclasspath</code>指定被 JVM 认可的类库路径</li>
<li>Ext ClassLoader.通过<code>java.ext.dirs</code>加载指定路径重的类库</li>
<li>Application ClassLoader.加载<code>classpath</code>上的类库</li>
</ol>
<h2 id="3-1-自定义类加载器"><a href="#3-1-自定义类加载器" class="headerlink" title="3.1 自定义类加载器"></a>3.1 自定义类加载器</h2><p>需要继承 ClassLoader 或其子类。要覆写<code>findClass()</code>方法。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; find<span class="constructor">Class(String <span class="params">name</span>)</span> throws ClassNotFoundException&#123;</span><br><span class="line">	<span class="comment">// 读取 class 的二进制数据</span></span><br><span class="line">	byte<span class="literal">[]</span> classBytes = this.read<span class="constructor">ClassBytes(<span class="params">name</span>)</span>;</span><br><span class="line">	<span class="keyword">if</span>(null<span class="operator"> == </span>classBytes<span class="operator"> || </span>classBytes.length<span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">		throw <span class="keyword">new</span> <span class="constructor">ClassNotFoundException(<span class="string">&quot;Can not load the class&quot;</span>+<span class="params">name</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// classLoader.defineClass()方法，将字节数组转化成 class 的 instance</span></span><br><span class="line">	<span class="comment">// 参数：要定义的类的名称，二进制字节数组，数组偏移量，偏移量开始多长的 byte </span></span><br><span class="line">	return this.define<span class="constructor">Class(<span class="params">name</span>,<span class="params">classBytes</span>,0,<span class="params">classBytes</span>.<span class="params">length</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 class 文件读入内存</span></span><br><span class="line"><span class="keyword">private</span> byte<span class="literal">[]</span> read<span class="constructor">ClassBytes(String <span class="params">name</span>)</span> throws ClassNotFoundException&#123;</span><br><span class="line">	String classPath = name.replace(<span class="string">&quot;.&quot;</span>,<span class="string">&quot;/&quot;</span>);</span><br><span class="line">	Path classFullPath = classDir.resolve(<span class="module-access"><span class="module"><span class="identifier">Paths</span>.</span></span>get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">	<span class="keyword">if</span>(!classFullPath.<span class="keyword">to</span><span class="constructor">File()</span>.exists<span class="literal">()</span>)</span><br><span class="line">		throw <span class="keyword">new</span> <span class="constructor">ClassNotFoundException(<span class="string">&quot;The class &quot;</span> + <span class="params">name</span> + <span class="string">&quot; not found.&quot;</span>)</span>;</span><br><span class="line">	<span class="comment">// 字节数组输出流</span></span><br><span class="line">	<span class="keyword">try</span>(ByteArrayOutPutStream baos = <span class="keyword">new</span> <span class="constructor">ByteArrayOutputStream()</span>)&#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Files</span>.</span></span>copy(classFullPath,baos);</span><br><span class="line">		return baos.<span class="keyword">to</span><span class="constructor">ByteArray()</span>;</span><br><span class="line">	&#125;catch(IOException e)&#123;</span><br><span class="line">		throw <span class="keyword">new</span> <span class="constructor">ClassNotFoundException(<span class="string">&quot;load the class &quot;</span> + <span class="params">name</span> + <span class="string">&quot; occur error.&quot;</span>,<span class="params">e</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-1-跳过双亲委托机制的两种方法"><a href="#3-1-1-跳过双亲委托机制的两种方法" class="headerlink" title="3.1.1 跳过双亲委托机制的两种方法"></a>3.1.1 跳过双亲委托机制的两种方法</h3><p>应用在自定义类加载器上：</p>
<ol>
<li>将扩展类加载器作为 MyClassLoader（自定义）的父加载器。<ul>
<li>会跳过 Application ClassLoader。</li>
</ul>
</li>
<li>在构造 MyClassLoader 的时候，指定其父类加载器为 null。</li>
</ol>
<h3 id="3-1-2-破坏双亲委托机制的方法"><a href="#3-1-2-破坏双亲委托机制的方法" class="headerlink" title="3.1.2 破坏双亲委托机制的方法"></a>3.1.2 破坏双亲委托机制的方法</h3><p>应用在自定义类加载器上：</p>
<ul>
<li>在自定义的类加载上（或其子类），重写<code>loadClass()</code>方法。</li>
<li>在该方法中：<ol>
<li>先对类的全路径名称加锁，保证仅被加载一次，线程安全；</li>
<li>查看缓存中是否有该类，若无进入下一步；</li>
<li>判断类的全路径是否以 java 和 javax 开头，若是，则委托给系统类加载器；</li>
<li>若不是，可尝试以自定义的类加载器加载。</li>
<li>若尝试失败，可继续委托给其父类加载器或者系统加载器进行加载。</li>
</ol>
</li>
</ul>
<h3 id="3-1-3-类加载器的命名空间"><a href="#3-1-3-类加载器的命名空间" class="headerlink" title="3.1.3 类加载器的命名空间"></a>3.1.3 类加载器的命名空间</h3><ul>
<li>每一个类加载器都有各自的命名空间，其中的每一个 class 都是独一无二的。</li>
<li>但是使用不同的类加载器，或者同一个类加载器的不同实例，去加载同一个 class ，会在堆内存和方法区产生多个 class 对象。</li>
</ul>
<p>【准确说法】<strong>同一个 class 实例在同一个类加载器命名空间之下是唯一的。</strong></p>
<h3 id="3-1-4-运行时包"><a href="#3-1-4-运行时包" class="headerlink" title="3.1.4 运行时包"></a>3.1.4 运行时包</h3><ul>
<li>编写代码时，包名和类名构成类的全限定名称。</li>
<li>在 JVM 运行时，class 会有一个运行时包，由类加载器的命名空间和类的全限定名称共同组成。比如：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">BootstrapClassLoader<span class="selector-class">.ExtClassLoader</span><span class="selector-class">.AppClassLoader</span><span class="selector-class">.MyClassLoader</span><span class="selector-class">.top</span><span class="selector-class">.likehui</span><span class="selector-class">.service</span>.test</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5-初始类加载器"><a href="#3-1-5-初始类加载器" class="headerlink" title="3.1.5 初始类加载器"></a>3.1.5 初始类加载器</h3><ul>
<li>如果某个类 C 被类加载器 CL 加载，那么 CL 就被称为 C 的初始类加载器。</li>
<li>JVM 为每个类加载器维护了一个列表，记录了将该类加载器作为初始加载器的所有 class。</li>
<li>在类的加载过程中，所有参与的类加载器，即使没有亲自加载过该类，都会标识为该类的初始类加载器。</li>
</ul>
<h3 id="3-1-6-类的卸载"><a href="#3-1-6-类的卸载" class="headerlink" title="3.1.6 类的卸载"></a>3.1.6 类的卸载</h3><p>满足以下三个条件时，一个 Class 会被 GC 回收，即被卸载。</p>
<ol>
<li>该类所有的实例都已经被 GC；</li>
<li>加载该类的 ClassLoader 实例被回收；</li>
<li>该类的 class 实例没有在别的地方被引用。</li>
</ol>
<p><img src="/2018/12/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/2.png" alt="2"></p>
<p>【重要】此时方法区中关于这个废弃类的信息等数据也会被卸载（应该是有目的性的那种，而不是范围性的 GC，两者有较大区别）</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议之抓包大作战</title>
    <url>/2019/04/05/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B9%8B%E6%8A%93%E5%8C%85%E5%A4%A7%E4%BD%9C%E6%88%98/</url>
    <content><![CDATA[<h1 id="网络协议之抓包大作战"><a href="#网络协议之抓包大作战" class="headerlink" title="网络协议之抓包大作战"></a>网络协议之抓包大作战</h1><p>使用 Wireshark工具抓包，学习网络协议</p>
<ol>
<li>ping测试 -&gt; 拆解 IPv4、ICMP 协议</li>
<li>Http测试 -&gt; 拆解 TCP、HTTP协议</li>
</ol>
<p>为避免过早陷入网络协议的细节，建议提前阅读<a href="https://blog.csdn.net/xiexievv/article/details/45225921">各种协议头部结构体</a>中的插图</p>
<span id="more"></span>

<h2 id="1-Ping-gt-拆解-IPv4、ICMP-协议"><a href="#1-Ping-gt-拆解-IPv4、ICMP-协议" class="headerlink" title="1. Ping -&gt; 拆解 IPv4、ICMP 协议"></a>1. Ping -&gt; 拆解 IPv4、ICMP 协议</h2><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">【终端】<span class="comment"></span></span><br><span class="line"><span class="comment">// 终端执行 Ping 命令：</span></span><br><span class="line"> lee@localhost  ~  ping baidu.com</span><br><span class="line">PING baidu.com (<span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span>): <span class="number">56</span> data <span class="keyword">bytes</span></span><br><span class="line"><span class="number">64</span> <span class="keyword">bytes</span> <span class="built_in">from</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span>: icmp_seq=<span class="number">0</span> ttl=<span class="number">49</span> <span class="built_in">time</span>=<span class="number">32.353</span> ms</span><br><span class="line"><span class="number">64</span> <span class="keyword">bytes</span> <span class="built_in">from</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span>: icmp_seq=<span class="number">1</span> ttl=<span class="number">49</span> <span class="built_in">time</span>=<span class="number">31.132</span> ms</span><br><span class="line"><span class="number">64</span> <span class="keyword">bytes</span> <span class="built_in">from</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span>: icmp_seq=<span class="number">2</span> ttl=<span class="number">49</span> <span class="built_in">time</span>=<span class="number">31.420</span> ms</span><br><span class="line"><span class="number">64</span> <span class="keyword">bytes</span> <span class="built_in">from</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span>: icmp_seq=<span class="number">3</span> ttl=<span class="number">49</span> <span class="built_in">time</span>=<span class="number">36.666</span> ms</span><br><span class="line">^C</span><br><span class="line"><span class="comment">--- baidu.com ping statistics ---</span></span><br><span class="line"><span class="number">4</span> packets transmitted, <span class="number">4</span> packets received, <span class="number">0.0</span>% packet loss</span><br><span class="line"><span class="built_in">round</span>-trip <span class="built_in">min</span>/<span class="built_in">avg</span>/<span class="built_in">max</span>/stddev = <span class="number">31.132</span>/<span class="number">32.893</span>/<span class="number">36.666</span>/<span class="number">2.225</span> ms</span><br></pre></td></tr></table></figure>


<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">【抓包流水】</span><br><span class="line"><span class="regexp">//</span> 抓包查看分组列表：</span><br><span class="line"><span class="regexp">//</span> 注：本机 IP：[本机 IP 和谐和谐]</span><br><span class="line"><span class="string">&quot;No.&quot;</span>,<span class="string">&quot;Time&quot;</span>,<span class="string">&quot;Source&quot;</span>,<span class="string">&quot;Destination&quot;</span>,<span class="string">&quot;Protocol&quot;</span>,<span class="string">&quot;Length&quot;</span>,<span class="string">&quot;Info&quot;</span></span><br><span class="line"><span class="string">&quot;8&quot;</span>,<span class="string">&quot;6.484284&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;221.12.33.227&quot;</span>,<span class="string">&quot;DNS&quot;</span>,<span class="string">&quot;69&quot;</span>,<span class="string">&quot;Standard query 0x624f A baidu.com&quot;</span></span><br><span class="line"><span class="string">&quot;9&quot;</span>,<span class="string">&quot;6.489842&quot;</span>,<span class="string">&quot;221.12.33.227&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;DNS&quot;</span>,<span class="string">&quot;271&quot;</span>,<span class="string">&quot;Standard query response 0x624f A baidu.com A 220.181.57.216 ... ...&quot;</span></span><br><span class="line"><span class="string">&quot;10&quot;</span>,<span class="string">&quot;6.490159&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) request  id=0x7853, seq=0/0, ttl=64 (reply in 11)&quot;</span></span><br><span class="line"><span class="string">&quot;11&quot;</span>,<span class="string">&quot;6.522460&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) reply    id=0x7853, seq=0/0, ttl=49 (request in 10)&quot;</span></span><br><span class="line"><span class="string">&quot;13&quot;</span>,<span class="string">&quot;7.492527&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) request  id=0x7853, seq=1/256, ttl=64 (reply in 14)&quot;</span></span><br><span class="line"><span class="string">&quot;14&quot;</span>,<span class="string">&quot;7.523576&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) reply    id=0x7853, seq=1/256, ttl=49 (request in 13)&quot;</span></span><br><span class="line"><span class="string">&quot;27&quot;</span>,<span class="string">&quot;8.494129&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) request  id=0x7853, seq=2/512, ttl=64 (reply in 28)&quot;</span></span><br><span class="line"><span class="string">&quot;28&quot;</span>,<span class="string">&quot;8.525455&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) reply    id=0x7853, seq=2/512, ttl=49 (request in 27)&quot;</span></span><br><span class="line"><span class="string">&quot;50&quot;</span>,<span class="string">&quot;9.495770&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) request  id=0x7853, seq=3/768, ttl=64 (reply in 51)&quot;</span></span><br><span class="line"><span class="string">&quot;51&quot;</span>,<span class="string">&quot;9.532351&quot;</span>,<span class="string">&quot;220.181.57.216&quot;</span>,<span class="string">&quot;[本机 IP 和谐和谐]&quot;</span>,<span class="string">&quot;ICMP&quot;</span>,<span class="string">&quot;98&quot;</span>,<span class="string">&quot;Echo (ping) reply    id=0x7853, seq=3/768, ttl=49 (request in 50)&quot;</span></span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ol>
<li>在 Ping baidu.com 时，首先进行 DNS 查询 IP 地址，</li>
<li>然后获取到若干个包，都是基于 <a href="https://blog.csdn.net/u011784495/article/details/71743516">ICMP 协议</a> 的。<ul>
<li><strong>ICMP消息是以未确认的IPv4数据报传送的，它们自己也不可靠。</strong></li>
<li>按以太网首部、IPv4、ICMP 顺序拆解，如下：</li>
</ul>
</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">【协议详情】</span></span><br><span class="line"><span class="string">//（以上面的</span> <span class="string">No.11</span> <span class="string">ICMP</span> <span class="string">的</span> <span class="string">reply</span> <span class="string">为例）</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">算是信息总览吧（包括</span> <span class="string">Wireshark</span> <span class="string">的着色标记等），没有体现在字节上（即不占物理空间）</span></span><br><span class="line"><span class="attr">Frame 10:</span> <span class="number">98</span> <span class="string">bytes</span> <span class="string">on</span> <span class="string">wire</span> <span class="string">(784</span> <span class="string">bits),</span> <span class="number">98</span> <span class="string">bytes</span> <span class="string">captured</span> <span class="string">(784</span> <span class="string">bits)</span> <span class="string">on</span> <span class="string">interface</span> <span class="number">0</span></span><br><span class="line"><span class="attr">Interface id:</span> <span class="number">0</span> <span class="string">(en0)</span></span><br><span class="line">	<span class="attr">Interface name:</span> <span class="string">en0</span></span><br><span class="line">	<span class="attr">Interface description:</span> <span class="string">Wi-Fi</span></span><br><span class="line"><span class="attr">Encapsulation type:</span> <span class="string">Ethernet</span> <span class="string">(1)</span></span><br><span class="line"><span class="attr">Arrival Time:</span> <span class="string">Apr</span>  <span class="number">5</span><span class="string">,</span> <span class="number">2019 18:03:13.866956000 </span><span class="string">CST</span></span><br><span class="line">[<span class="attr">Time shift for this packet:</span> <span class="number">0.000000000</span> <span class="string">seconds</span>]</span><br><span class="line"><span class="attr">Epoch Time:</span> <span class="number">1554458593.866956000</span> <span class="string">seconds</span></span><br><span class="line">[<span class="attr">Time delta from previous captured frame:</span> <span class="number">0.000317000</span> <span class="string">seconds</span>]</span><br><span class="line">[<span class="attr">Time delta from previous displayed frame:</span> <span class="number">0.000317000</span> <span class="string">seconds</span>]</span><br><span class="line">[<span class="attr">Time since reference or first frame:</span> <span class="number">6.490159000</span> <span class="string">seconds</span>]</span><br><span class="line"><span class="attr">Frame Number:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">Frame Length:</span> <span class="number">98</span> <span class="string">bytes</span> <span class="string">(784</span> <span class="string">bits)</span></span><br><span class="line"><span class="attr">Capture Length:</span> <span class="number">98</span> <span class="string">bytes</span> <span class="string">(784</span> <span class="string">bits)</span></span><br><span class="line">[<span class="attr">Frame is marked:</span> <span class="literal">False</span>]</span><br><span class="line">[<span class="attr">Frame is ignored:</span> <span class="literal">False</span>]</span><br><span class="line">[<span class="attr">Protocols in frame:</span> <span class="string">eth:ethertype:ip:icmp:data</span>] <span class="string">//</span> <span class="string">说明本数据帧中涉及到的哪些协议</span></span><br><span class="line">[<span class="attr">Coloring Rule Name:</span> <span class="string">ICMP</span>]</span><br><span class="line">[<span class="attr">Coloring Rule String:</span> <span class="string">icmp</span> <span class="string">||</span> <span class="string">icmpv6</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">以太网首部</span></span><br><span class="line"><span class="string">Ethernet</span> <span class="string">II,</span> <span class="attr">Src:</span> <span class="string">Apple_ec:6d:8d</span> <span class="string">([本机</span> <span class="string">mac</span> <span class="string">和谐和谐]),</span> <span class="attr">Dst:</span> <span class="string">Cisco_28:dc:80</span> <span class="string">(10:8c:cf:28:dc:80)</span></span><br><span class="line">	<span class="attr">Destination:</span> <span class="string">Cisco_28:dc:80</span> <span class="string">(10:8c:cf:28:dc:80)</span> <span class="string">//</span> <span class="number">6</span><span class="string">个字节，代表目的地</span> <span class="string">mac</span> <span class="string">地址</span></span><br><span class="line">		<span class="attr">Address:</span> <span class="string">Cisco_28:dc:80</span> <span class="string">(10:8c:cf:28:dc:80)</span></span><br><span class="line">		<span class="string">....</span> <span class="string">..0.</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">LG bit:</span> <span class="string">Globally</span> <span class="string">unique</span> <span class="string">address</span> <span class="string">(factory</span> <span class="string">default)</span></span><br><span class="line">		<span class="string">....</span> <span class="string">...0</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">IG bit:</span> <span class="string">Individual</span> <span class="string">address</span> <span class="string">(unicast)</span></span><br><span class="line">	<span class="attr">Source:</span> <span class="string">Apple_ec:6d:8d</span> <span class="string">([本机</span> <span class="string">mac</span> <span class="string">和谐和谐])</span>  <span class="string">//</span> <span class="number">6</span><span class="string">个字节，代表源</span> <span class="string">mac</span> <span class="string">地址</span></span><br><span class="line">		<span class="attr">Address:</span> <span class="string">Apple_ec:6d:8d</span> <span class="string">([本机</span> <span class="string">mac</span> <span class="string">和谐和谐])</span></span><br><span class="line">		<span class="string">....</span> <span class="string">..0.</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">LG bit:</span> <span class="string">Globally</span> <span class="string">unique</span> <span class="string">address</span> <span class="string">(factory</span> <span class="string">default)</span></span><br><span class="line">		<span class="string">....</span> <span class="string">...0</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">IG bit:</span> <span class="string">Individual</span> <span class="string">address</span> <span class="string">(unicast)</span></span><br><span class="line">	<span class="attr">Type:</span> <span class="string">IPv4</span> <span class="string">(0x0800)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">IPv4</span> <span class="string">协议</span>  <span class="string">可以参考本站另一篇博客:</span> </span><br><span class="line">[<span class="string">IPv4数据报格式</span>]<span class="string">(http://likehui.fun/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-1/)</span> </span><br><span class="line"></span><br><span class="line"><span class="string">Internet</span> <span class="string">Protocol</span> <span class="string">Version</span> <span class="number">4</span><span class="string">,</span> <span class="attr">Src:</span> [<span class="string">本机</span> <span class="string">IP</span> <span class="string">和谐和谐</span>]<span class="string">,</span> <span class="attr">Dst:</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br><span class="line"><span class="number">0100</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Version:</span> <span class="number">4</span></span><br><span class="line"><span class="string">....</span> <span class="number">0101</span> <span class="string">=</span> <span class="attr">Header Length:</span> <span class="number">20</span> <span class="string">bytes</span> <span class="string">(5)</span></span><br><span class="line"><span class="attr">Differentiated Services Field:</span> <span class="number">0x00</span> <span class="string">(DSCP:</span> <span class="string">CS0,</span> <span class="attr">ECN:</span> <span class="string">Not-ECT)</span> <span class="string">//</span> <span class="string">服务类型（定义优先级、低延时、高吞吐量等等）</span></span><br><span class="line">	<span class="number">0000 </span><span class="number">00</span><span class="string">..</span> <span class="string">=</span> <span class="attr">Differentiated Services Codepoint:</span> <span class="string">Default</span> <span class="string">(0)</span></span><br><span class="line">	<span class="string">....</span> <span class="string">..00</span> <span class="string">=</span> <span class="attr">Explicit Congestion Notification:</span> <span class="string">Not</span> <span class="string">ECN-Capable</span> <span class="string">Transport</span> <span class="string">(0)</span></span><br><span class="line"><span class="attr">Total Length:</span> <span class="number">84</span></span><br><span class="line"><span class="attr">Identification:</span> <span class="number">0xe203</span> <span class="string">(57859)</span>  <span class="string">//</span> <span class="string">同一个原始数据报的唯一编号（因为分片，多个</span> <span class="string">IP</span> <span class="string">报可以归属于同一个原始数据报）</span></span><br><span class="line"><span class="attr">Flags:</span> <span class="number">0x0000</span></span><br><span class="line">	<span class="number">0</span><span class="string">...</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Reserved bit:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">未投入使用</span></span><br><span class="line">	<span class="number">.0</span><span class="string">..</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="string">Don&#x27;t</span> <span class="attr">fragment:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">不对数据分片</span></span><br><span class="line">	<span class="string">..0.</span> <span class="string">....</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">More fragments:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="number">1</span><span class="string">表示还有分片，0表再无分片</span></span><br><span class="line">	<span class="string">...0</span> <span class="number">0000 </span><span class="number">0000 </span><span class="number">0000</span> <span class="string">=</span> <span class="attr">Fragment offset:</span> <span class="number">0</span> <span class="string">//</span> <span class="string">分片偏移，相对于原始数据报</span></span><br><span class="line"><span class="attr">Time to live:</span> <span class="number">64</span> <span class="string">//</span> <span class="string">经过一个路由器此数字减一，若发现为0，路由器将丢弃此包</span></span><br><span class="line"><span class="attr">Protocol:</span> <span class="string">ICMP</span> <span class="string">(1)</span> <span class="string">//</span> <span class="number">1</span><span class="string">表示ICMP，2表示IGMP，6表示TCP，17表示UDP，89表示OSPF</span></span><br><span class="line"><span class="attr">Header checksum:</span> <span class="number">0xb2f0</span> [<span class="string">validation</span> <span class="string">disabled</span>]</span><br><span class="line">[<span class="attr">Header checksum status:</span> <span class="string">Unverified</span>]</span><br><span class="line"><span class="attr">Source:</span> [<span class="string">本机</span> <span class="string">IP</span> <span class="string">和谐和谐</span>]</span><br><span class="line"><span class="attr">Destination:</span> <span class="number">220.181</span><span class="number">.57</span><span class="number">.216</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">ICMP</span> <span class="string">协议</span></span><br><span class="line"><span class="string">//</span> <span class="string">Internet</span> <span class="string">Control</span> <span class="string">Message</span> <span class="string">Protocol</span> </span><br><span class="line"><span class="attr">Type:</span> <span class="number">0</span> <span class="string">(Echo</span> <span class="string">(ping)</span> <span class="string">reply)</span> <span class="string">//</span> <span class="string">如果是</span> <span class="string">ping</span> <span class="string">的</span> <span class="string">request，此处</span> <span class="string">Type</span> <span class="string">是8，占1byte，1~127</span> <span class="string">差错报文，128</span> <span class="string">以上信息报文</span></span><br><span class="line"><span class="attr">Code:</span> <span class="number">0</span> <span class="string">//</span> <span class="string">占1byte，它与类型字段一起共同标识了ICMP报文的详细类型</span></span><br><span class="line"><span class="attr">Checksum:</span> <span class="number">0xdda4</span> [<span class="string">correct</span>]</span><br><span class="line">[<span class="attr">Checksum Status:</span> <span class="string">Good</span>]</span><br><span class="line"><span class="string">Identifier</span> <span class="string">(BE):</span> <span class="number">30803</span> <span class="string">(0x7853)</span> <span class="string">//</span> <span class="string">BE、LE</span> <span class="string">是</span> <span class="string">wireshark</span> <span class="string">软件</span> <span class="string">对</span> <span class="string">linux</span> <span class="string">和</span> <span class="string">window</span> <span class="string">系统的做出的标识（区别大端、小端），可以不予理会。</span></span><br><span class="line"><span class="string">Identifier</span> <span class="string">(LE):</span> <span class="number">21368</span> <span class="string">(0x5378)</span></span><br><span class="line"><span class="string">Sequence</span> <span class="string">number</span> <span class="string">(BE):</span> <span class="number">0</span> <span class="string">(0x0000)</span></span><br><span class="line"><span class="string">Sequence</span> <span class="string">number</span> <span class="string">(LE):</span> <span class="number">0</span> <span class="string">(0x0000)</span></span><br><span class="line">[<span class="attr">Request frame:</span> <span class="number">10</span>]</span><br><span class="line">[<span class="attr">Response time:</span> <span class="number">32.301</span> <span class="string">ms</span>] <span class="string">//</span> <span class="string">如果是</span> <span class="string">ping</span> <span class="string">的</span> <span class="string">request，则无此</span> <span class="string">response</span> <span class="string">time</span> <span class="string">参数</span></span><br><span class="line"><span class="attr">Timestamp from icmp data:</span> <span class="string">Apr</span>  <span class="number">5</span><span class="string">,</span> <span class="number">2019 18:03:13.866927000 </span><span class="string">CST</span></span><br><span class="line">[<span class="string">Timestamp</span> <span class="string">from</span> <span class="string">icmp</span> <span class="string">data</span> <span class="string">(relative):</span> <span class="number">0.032330000</span> <span class="string">seconds</span>]</span><br><span class="line"><span class="string">Data</span> <span class="string">(48</span> <span class="string">bytes)</span></span><br><span class="line">	<span class="attr">Data:</span> <span class="string">08090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f…</span></span><br><span class="line">	[<span class="attr">Length:</span> <span class="number">48</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-访问Http-gt-拆解-TCP、HTTP协议"><a href="#2-访问Http-gt-拆解-TCP、HTTP协议" class="headerlink" title="2. 访问Http -&gt; 拆解 TCP、HTTP协议"></a>2. 访问Http -&gt; 拆解 TCP、HTTP协议</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">【抓包流水】</span><br><span class="line"><span class="regexp">//</span> 访问 http:<span class="regexp">//</span>www.cst.zju.edu.cn/网站</span><br><span class="line"><span class="string">&quot;No.&quot;</span>,<span class="string">&quot;Time&quot;</span>,<span class="string">&quot;Source&quot;</span>,<span class="string">&quot;Destination&quot;</span>,<span class="string">&quot;Protocol&quot;</span>,<span class="string">&quot;Length&quot;</span>,<span class="string">&quot;Info&quot;</span></span><br><span class="line"><span class="string">&quot;1008&quot;</span>,<span class="string">&quot;149.200741&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;78&quot;</span>,<span class="string">&quot;57206 → 80 [SYN] Seq=0 Win=65535 Len=0 MSS=1460 WS=32 TSval=980646922 TSecr=0 SACK_PERM=1&quot;</span></span><br><span class="line"><span class="string">&quot;1009&quot;</span>,<span class="string">&quot;149.249935&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;74&quot;</span>,<span class="string">&quot;80 → 57206 [SYN, ACK] Seq=0 Ack=1 Win=14480 Len=0 MSS=1460 SACK_PERM=1 TSval=4012697143 TSecr=980646922 WS=128&quot;</span></span><br><span class="line"><span class="string">&quot;1010&quot;</span>,<span class="string">&quot;149.250013&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;66&quot;</span>,<span class="string">&quot;57206 → 80 [ACK] Seq=1 Ack=1 Win=131744 Len=0 TSval=980646971 TSecr=4012697143&quot;</span></span><br><span class="line"><span class="string">&quot;1011&quot;</span>,<span class="string">&quot;149.250191&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;HTTP&quot;</span>,<span class="string">&quot;468&quot;</span>,<span class="string">&quot;GET / HTTP/1.1 &quot;</span></span><br><span class="line"><span class="string">&quot;1013&quot;</span>,<span class="string">&quot;149.305859&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;66&quot;</span>,<span class="string">&quot;80 → 57206 [ACK] Seq=1 Ack=403 Win=15616 Len=0 TSval=4012697199 TSecr=980646971&quot;</span></span><br><span class="line"><span class="string">&quot;1014&quot;</span>,<span class="string">&quot;149.371354&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;1514&quot;</span>,<span class="string">&quot;80 → 57206 [ACK] Seq=1 Ack=403 Win=15616 Len=1448 TSval=4012697262 TSecr=980646971 [TCP segment of a reassembled PDU]&quot;</span></span><br><span class="line"><span class="string">&quot;1015&quot;</span>,<span class="string">&quot;149.371367&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;1514&quot;</span>,<span class="string">&quot;80 → 57206 [ACK] Seq=1449 Ack=403 Win=15616 Len=1448 TSval=4012697262 TSecr=980646971 [TCP segment of a reassembled PDU]&quot;</span></span><br><span class="line"><span class="string">&quot;1016&quot;</span>,<span class="string">&quot;149.371458&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;1514&quot;</span>,<span class="string">&quot;80 → 57206 [ACK] Seq=2897 Ack=403 Win=15616 Len=1448 TSval=4012697262 TSecr=980646971 [TCP segment of a reassembled PDU]&quot;</span></span><br><span class="line"><span class="string">&quot;1017&quot;</span>,<span class="string">&quot;149.371524&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;66&quot;</span>,<span class="string">&quot;57206 → 80 [ACK] Seq=403 Ack=2897 Win=128864 Len=0 TSval=980647090 TSecr=4012697262&quot;</span></span><br><span class="line"><span class="string">&quot;1018&quot;</span>,<span class="string">&quot;149.371568&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;66&quot;</span>,<span class="string">&quot;57206 → 80 [ACK] Seq=403 Ack=4345 Win=130816 Len=0 TSval=980647090 TSecr=4012697262&quot;</span></span><br><span class="line"><span class="string">&quot;1019&quot;</span>,<span class="string">&quot;149.371969&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;HTTP&quot;</span>,<span class="string">&quot;950&quot;</span>,<span class="string">&quot;[TCP Previous segment not captured] Continuation&quot;</span></span><br><span class="line"><span class="string">&quot;1020&quot;</span>,<span class="string">&quot;149.372023&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;78&quot;</span>,<span class="string">&quot;[TCP Dup ACK 1018#1] 57206 → 80 [ACK] Seq=403 Ack=4345 Win=130816 Len=0 TSval=980647090 TSecr=4012697262 SLE=8689 SRE=9573&quot;</span></span><br><span class="line"><span class="string">&quot;1021&quot;</span>,<span class="string">&quot;149.372272&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;1514&quot;</span>,<span class="string">&quot;[TCP Out-Of-Order] 80 → 57206 [ACK] Seq=4345 Ack=403 Win=15616 Len=1448 TSval=4012697262 TSecr=980646971&quot;</span></span><br><span class="line"><span class="string">&quot;1022&quot;</span>,<span class="string">&quot;149.372278&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;1514&quot;</span>,<span class="string">&quot;[TCP Out-Of-Order] 80 → 57206 [ACK] Seq=5793 Ack=403 Win=15616 Len=1448 TSval=4012697262 TSecr=980646971&quot;</span></span><br><span class="line"><span class="string">&quot;1023&quot;</span>,<span class="string">&quot;149.372335&quot;</span>,<span class="string">&quot;[本机 ip 和谐和谐]&quot;</span>,<span class="string">&quot;210.32.0.218&quot;</span>,<span class="string">&quot;TCP&quot;</span>,<span class="string">&quot;78&quot;</span>,<span class="string">&quot;57206 → 80 [ACK] Seq=403 Ack=5793 Win=129376 Len=0 TSval=980647090 TSecr=4012697262 SLE=8689 SRE=9573&quot;</span></span><br><span class="line">。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按编号分别解释：</p>
<ul>
<li>1008：Client -&gt; Server三次握手之一</li>
<li>1009：Server -&gt; Client 三次握手之二</li>
<li>1010：Client -&gt; Server 三次握手之三</li>
<li>1011：三次握手结束，Client -&gt; Server 发送 Http 的 Get 请求，从 IP 请求头我们知道此 Http 不分片，此协议见下方代码。</li>
<li>1013：Server -&gt; Client ，回应 Get 请求，即回应 1011。</li>
<li>1014、1015、1016，Server -&gt; Client 发送常规数据，长度都是 1514。</li>
<li>1017：Client -&gt; Server ，Ack 2897，同时回应了1014、1015.</li>
<li>1018：Client -&gt; Server, Ack 4345,作为 1016 的回应。</li>
<li>1019：Server -&gt; Client，但是中途出现丢包（5793<del>8689 的数据包丢了），此1019包数据seq为 8689</del>9573，缓存在 Client 端的窗口中。</li>
<li>1020：Client -&gt; Server ，重复包，相当于又发了一次1018。</li>
<li>1021：Server -&gt; Client，因为网络问题，导致包抵达时间不同，延时长、包丢失等。这里可以明显看到 Ack&#x3D;403 有问题，因为 Client 发来的 403 早就到达 Server 了。</li>
<li>1022：Sever -&gt; Client，乱序，理由同上。</li>
<li>1023：Client -&gt; Server，告知需要5793的数据，结合 SLE&#x3D;8689 SRE&#x3D;9573 说明：我等你的5793后面的数据，但是 8689~9573 之间的数据我已经缓存了，用不着再发。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">【协议详情】</span></span><br><span class="line"><span class="string">...</span> <span class="string">编号1011，即</span> <span class="string">Http</span> <span class="string">的</span> <span class="string">Get</span> <span class="string">请求，client</span> <span class="string">发往</span> <span class="string">server，下面的以太网头和</span> <span class="string">IPv4</span> <span class="string">省略</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">TCP</span></span><br><span class="line"><span class="string">Transmission</span> <span class="string">Control</span> <span class="string">Protocol,</span> <span class="attr">Src Port:</span> <span class="number">57206</span><span class="string">,</span> <span class="attr">Dst Port:</span> <span class="number">80</span><span class="string">,</span> <span class="attr">Seq:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Ack:</span> <span class="number">1</span><span class="string">,</span> <span class="attr">Len:</span> <span class="number">402</span></span><br><span class="line"><span class="attr">Source Port:</span> <span class="number">57206</span> <span class="string">//占</span> <span class="number">2</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Destination Port:</span> <span class="number">80</span>  <span class="string">//占</span> <span class="number">2</span> <span class="string">bytes</span></span><br><span class="line">[<span class="attr">Stream index:</span> <span class="number">56</span>]</span><br><span class="line">[<span class="attr">TCP Segment Len:</span> <span class="number">402</span>]</span><br><span class="line"><span class="attr">Sequence number:</span> <span class="number">1</span>    <span class="string">(relative</span> <span class="string">sequence</span> <span class="string">number)</span> <span class="string">//占</span> <span class="number">4</span> <span class="string">bytes</span></span><br><span class="line">[<span class="attr">Next sequence number:</span> <span class="number">403</span>    <span class="string">(relative</span> <span class="string">sequence</span> <span class="string">number)</span>]</span><br><span class="line"><span class="attr">Acknowledgment number:</span> <span class="number">1</span>    <span class="string">(relative</span> <span class="string">ack</span> <span class="string">number)</span> <span class="string">//占</span> <span class="number">4</span> <span class="string">bytes</span></span><br><span class="line"><span class="number">1000</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Header Length:</span> <span class="number">32</span> <span class="string">bytes</span> <span class="string">(8)</span> <span class="string">//</span> <span class="string">占</span> <span class="number">4</span> <span class="string">bits，此处的</span> <span class="number">8</span> <span class="string">表示长度</span> <span class="number">32</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Flags:</span> <span class="number">0x018</span> <span class="string">(PSH,</span> <span class="string">ACK)</span></span><br><span class="line">	<span class="number">000</span><span class="string">.</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Reserved:</span> <span class="string">Not</span> <span class="string">set</span>  <span class="string">//</span> <span class="string">保留字符</span></span><br><span class="line">	<span class="string">...0</span> <span class="string">....</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Nonce:</span> <span class="string">Not</span> <span class="string">set</span>  <span class="string">//</span> <span class="string">保留字符</span></span><br><span class="line">	<span class="string">....</span> <span class="number">0</span><span class="string">...</span> <span class="string">....</span> <span class="string">=</span> <span class="string">Congestion</span> <span class="string">Window</span> <span class="string">Reduced</span> <span class="string">(CWR):</span> <span class="string">Not</span> <span class="string">set</span>  <span class="string">//</span> <span class="string">保留字符，CWR，拥塞窗口减少，接收者如果发现此处为1，可能就会缩小窗口的大小</span></span><br><span class="line">	<span class="string">....</span> <span class="number">.0</span><span class="string">..</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">ECN-Echo:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">保留字符，ECE，若被设置为1，在路由过程中，可能被不支持</span> <span class="string">ECN</span> <span class="string">的</span> <span class="string">router</span> <span class="string">给丢掉了</span></span><br><span class="line">	<span class="string">....</span> <span class="string">..0.</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Urgent:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">紧急标志，此报文时紧急报文优先发送，不再按序发送。激活紧急指针，与后面的紧急指针（Urgent</span> <span class="string">pointer）配合，向后偏移至此报文处，发送此报文。</span></span><br><span class="line">	<span class="string">....</span> <span class="string">...1</span> <span class="string">....</span> <span class="string">=</span> <span class="attr">Acknowledgment:</span> <span class="string">Set</span> <span class="string">//</span> <span class="string">确认标志</span></span><br><span class="line">	<span class="string">....</span> <span class="string">....</span> <span class="number">1</span><span class="string">...</span> <span class="string">=</span> <span class="attr">Push:</span> <span class="string">Set</span> <span class="string">//</span> <span class="string">推，表示发送方通知接收方传输层应该尽快的将这个报文段交给应用层，而不是等缓冲区满了才交付。</span></span><br><span class="line">	<span class="string">....</span> <span class="string">....</span> <span class="number">.0</span><span class="string">..</span> <span class="string">=</span> <span class="attr">Reset:</span> <span class="string">Not</span> <span class="string">set</span>  <span class="string">//</span> <span class="string">重置连接</span></span><br><span class="line">	<span class="string">....</span> <span class="string">....</span> <span class="string">..0.</span> <span class="string">=</span> <span class="attr">Syn:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">同步标志</span></span><br><span class="line">	<span class="string">....</span> <span class="string">....</span> <span class="string">...0</span> <span class="string">=</span> <span class="attr">Fin:</span> <span class="string">Not</span> <span class="string">set</span> <span class="string">//</span> <span class="string">完成标志</span></span><br><span class="line">	[<span class="attr">TCP Flags:</span> <span class="string">·······AP···</span>]</span><br><span class="line"><span class="attr">Window size value:</span> <span class="number">4117</span> <span class="string">//</span> <span class="string">占</span> <span class="number">2</span> <span class="string">bytes</span></span><br><span class="line">[<span class="attr">Calculated window size:</span> <span class="number">131744</span>]</span><br><span class="line">[<span class="attr">Window size scaling factor:</span> <span class="number">32</span>]</span><br><span class="line"><span class="attr">Checksum:</span> <span class="number">0x2eb2</span> [<span class="string">unverified</span>] <span class="string">//</span> <span class="string">占</span> <span class="number">2</span> <span class="string">bytes</span></span><br><span class="line">[<span class="attr">Checksum Status:</span> <span class="string">Unverified</span>]</span><br><span class="line"><span class="attr">Urgent pointer:</span> <span class="number">0</span> <span class="string">//</span> <span class="string">占</span> <span class="number">2</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Options:</span> <span class="string">(12</span> <span class="string">bytes),</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(NOP),</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(NOP),</span> <span class="string">Timestamps</span></span><br><span class="line">	<span class="string">TCP</span> <span class="string">Option</span> <span class="bullet">-</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(NOP)</span>  <span class="string">//</span> <span class="number">0</span><span class="string">.</span> <span class="string">代表选项表结束;</span> <span class="number">1</span><span class="string">.代表无操作;</span> <span class="number">2</span><span class="string">.代表MSS;</span> <span class="number">3</span><span class="string">.代表窗口扩大因子;</span> <span class="number">8</span><span class="string">.代表时间戳</span></span><br><span class="line">		<span class="attr">Kind:</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(1)</span></span><br><span class="line">	<span class="string">TCP</span> <span class="string">Option</span> <span class="bullet">-</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(NOP)</span></span><br><span class="line">		<span class="attr">Kind:</span> <span class="literal">No</span><span class="string">-Operation</span> <span class="string">(1)</span></span><br><span class="line">	<span class="attr">TCP Option - Timestamps:</span> <span class="string">TSval</span> <span class="number">980646971</span><span class="string">,</span> <span class="string">TSecr</span> <span class="number">4012697143</span></span><br><span class="line">		<span class="attr">Kind:</span> <span class="string">Time</span> <span class="string">Stamp</span> <span class="string">Option</span> <span class="string">(8)</span></span><br><span class="line">		<span class="attr">Length:</span> <span class="number">10</span></span><br><span class="line">		<span class="attr">Timestamp value:</span> <span class="number">980646971</span></span><br><span class="line">		<span class="attr">Timestamp echo reply:</span> <span class="number">4012697143</span></span><br><span class="line">[<span class="string">SEQ/ACK</span> <span class="string">analysis</span>]  <span class="string">//</span> <span class="string">相当于wireshark</span> <span class="string">的状态解读，不占物理空间</span></span><br><span class="line">	[<span class="attr">iRTT:</span> <span class="number">0.049272000</span> <span class="string">seconds</span>]</span><br><span class="line">	[<span class="attr">Bytes in flight:</span> <span class="number">402</span>]</span><br><span class="line">	[<span class="attr">Bytes sent since last PSH flag:</span> <span class="number">402</span>]</span><br><span class="line">[<span class="string">Timestamps</span>]</span><br><span class="line">	[<span class="attr">Time since first frame in this TCP stream:</span> <span class="number">0.049450000</span> <span class="string">seconds</span>]</span><br><span class="line">	[<span class="attr">Time since previous frame in this TCP stream:</span> <span class="number">0.000178000</span> <span class="string">seconds</span>]</span><br><span class="line"><span class="string">TCP</span> <span class="string">payload</span> <span class="string">(402</span> <span class="string">bytes)</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">HTTP</span></span><br><span class="line"><span class="string">Hypertext</span> <span class="string">Transfer</span> <span class="string">Protocol</span></span><br><span class="line"><span class="string">GET</span> <span class="string">/</span> <span class="string">HTTP/1.1\r\n</span></span><br><span class="line">	[<span class="string">Expert</span> <span class="string">Info</span> <span class="string">(Chat/Sequence):</span> <span class="string">GET</span> <span class="string">/</span> <span class="string">HTTP/1.1\r\n</span>]</span><br><span class="line">		[<span class="string">GET</span> <span class="string">/</span> <span class="string">HTTP/1.1\r\n</span>]</span><br><span class="line">		[<span class="attr">Severity level:</span> <span class="string">Chat</span>]</span><br><span class="line">		[<span class="attr">Group:</span> <span class="string">Sequence</span>]</span><br><span class="line">	<span class="attr">Request Method:</span> <span class="string">GET</span></span><br><span class="line">	<span class="attr">Request URI:</span> <span class="string">/</span></span><br><span class="line">	<span class="attr">Request Version:</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">www.cst.zju.edu.cn\r\n</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive\r\n</span></span><br><span class="line"><span class="attr">Upgrade-Insecure-Requests:</span> <span class="number">1</span><span class="string">\r\n</span></span><br><span class="line"><span class="attr">User-Agent:</span> [<span class="string">本机信息</span> <span class="string">和谐和谐</span>]</span><br><span class="line"><span class="attr">Accept:</span> <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\r\n</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate\r\n</span></span><br><span class="line"><span class="attr">Accept-Language:</span> <span class="string">en,zh-CN;q=0.9,zh;q=0.8\r\n</span></span><br><span class="line"><span class="string">\r\n</span></span><br><span class="line">[<span class="attr">Full request URI:</span> <span class="string">http://www.cst.zju.edu.cn/</span>]</span><br><span class="line">[<span class="string">HTTP</span> <span class="string">request</span> <span class="number">1</span><span class="string">/8</span>]</span><br><span class="line">[<span class="attr">Next request in frame:</span> <span class="number">1028</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>推荐阅读：<a href="https://blog.csdn.net/javajiawei/article/details/81987949">聊一聊TCP协议中的push标志位</a><br><a href="https://blog.csdn.net/wang7dao/article/details/16805337">Wireshark 抓包工具–TCP 数据包解读</a></p>
<ul>
<li><p>由于 SYN包是用来初始化连接的, 它不可能和 FIN和RST标记一起出现。</p>
</li>
<li><p>为什么正常包的长度是1514？	</p>
<ol>
<li>首先最大帧的长度应该是1526字节，1526 bytes &#x3D; 前同步码（7 bytes）+ 帧开始定界符（1 byte）+ MTU + FCS（4 bytes） 。</li>
<li>但是抓包拿到的包是已经去掉了前导同步码和帧开始定界符，已经经过CRC 验证后的了，所以只能拿到1514字节。</li>
<li>1514 bytes &#x3D; 源 mac （6  bytes）+ 目的 mac （6  bytes） + 长度 （2  bytes） + MTU （1500  bytes）</li>
<li>MTU 是最大传输单元，MTU &#x3D; IP 头（20 Bytes）+ Data。</li>
<li>以1015包为例，Data 占1448bytes，TCP 头部32bytes，IP 头部20bytes，汇总就是1500字节。</li>
</ol>
</li>
</ul>
<p>参考解答：<a href="https://blog.csdn.net/wangcg123/article/details/70347680">MTU问题，为何抓包到1514</a></p>
<p>超 np 的 TCP 协议解读：<a href="https://www.cnblogs.com/Adoryn/p/4134981.html">TCP协议解析</a></p>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>笔经整理4</title>
    <url>/2019/07/27/%E7%AC%94%E7%BB%8F%E6%95%B4%E7%90%864/</url>
    <content><![CDATA[<h1 id="题目来源：牛客网"><a href="#题目来源：牛客网" class="headerlink" title="题目来源：牛客网"></a>题目来源：牛客网</h1><p><a href="https://www.nowcoder.com/test/question/8d677d9c6af643f28c2153ee4e435ea4?pid=10628824&tid=25414682">1.列表补全</a></p>
<p>在商城的某个位置有一个商品列表，该列表是由L1、L2两个子列表拼接而成。当用户浏览并翻页时，需要从列表L1、L2中获取商品进行展示。展示规则如下：</p>
<ol>
<li><p>用户可以进行多次翻页，用offset表示用户在之前页面已经浏览的商品数量，比如offset为4，表示用户已经看了4个商品</p>
</li>
<li><p>n表示当前页面需要展示的商品数量</p>
</li>
<li><p>展示商品时首先使用列表L1，如果列表L1长度不够，再从列表L2中选取商品</p>
</li>
<li><p>从列表L2中补全商品时，也可能存在数量不足的情况</p>
</li>
</ol>
<p>请根据上述规则，计算列表L1和L2中哪些商品在当前页面被展示了</p>
<span id="more"></span>



<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">每个测试输入包含<span class="number">1</span>个测试用例，包含四个整数，分别表示偏移量<span class="built_in">offset</span>、元素数量<span class="built_in">n</span>，列表<span class="symbol">L1</span>的长度<span class="symbol">l1</span>，列表<span class="symbol">L2</span>的长度<span class="symbol">l2</span>。</span><br></pre></td></tr></table></figure>

<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">在一行内输出四个整数分别表示<span class="symbol">L1</span>和<span class="symbol">L2</span>的区间start1，end1，start2，end2，每个数字之间有一个空格。</span><br><span class="line">注意，区间段使用半开半闭区间表示，即包含起点，不包含终点。如果某个列表的区间为空，使用[<span class="number">0</span>, <span class="number">0</span>)表示，如果某个列表被跳过，使用[<span class="built_in">len</span>, <span class="built_in">len</span>)表示，<span class="built_in">len</span>表示列表的长度。</span><br></pre></td></tr></table></figure>

<h5 id="输入例子1"><a href="#输入例子1" class="headerlink" title="输入例子1:"></a><strong>输入例子1:</strong></h5><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="输出例子1"><a href="#输出例子1" class="headerlink" title="输出例子1:"></a><strong>输出例子1:</strong></h5><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">			<span class="type">int</span> h1, t1, h2, t2;</span><br><span class="line">			<span class="keyword">if</span> (offset &lt; l1) &#123;</span><br><span class="line">				h1 = offset;</span><br><span class="line">				t1 = Math.min(offset + n, l1);</span><br><span class="line">				h2 = <span class="number">0</span>;</span><br><span class="line">				t2 = Math.max(Math.min(l2, offset + n - l1), <span class="number">0</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (offset &lt; l1 + l2) &#123;</span><br><span class="line">				h1 = l1;</span><br><span class="line">				t1 = l1;</span><br><span class="line">				h2 = offset - l1;</span><br><span class="line">				t2 = Math.max(Math.min(l2, offset + n - l1), <span class="number">0</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				h1 = l1;</span><br><span class="line">				t1 = l1;</span><br><span class="line">				h2 = l2;</span><br><span class="line">				t2 = l2;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s %s %s %s&quot;</span>, h1, t1, h2, t2);</span><br><span class="line">			System.out.println(ret);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.nowcoder.com/practice/9407e24a70b04fedba4ab3bd3ae29704?tpId=98&tqId=32832&tPage=1&rp=1&ru=/ta/2019test&qru=/ta/2019test/question-ranking">2.俄罗斯方块</a></p>
<p>小易有一个古老的游戏机，上面有着经典的游戏俄罗斯方块。因为它比较古老，所以规则和一般的俄罗斯方块不同。<br>荧幕上一共有 n 列，每次都会有一个 1 x 1 的方块随机落下，在同一列中，后落下的方块会叠在先前的方块之上，当一整行方块都被占满时，这一行会被消去，并得到1分。<br>有一天，小易又开了一局游戏，当玩到第 m 个方块落下时他觉得太无聊就关掉了，小易希望你告诉他这局游戏他获得的分数。</p>
<p>输入描述:</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">第一行两个数 <span class="built_in">n</span>, m</span><br><span class="line">第二行 m 个数，<span class="symbol">c1</span>, <span class="symbol">c2</span>, ... , cm ， ci 表示第 i 个方块落在第几列</span><br><span class="line">其中 <span class="number">1</span> &lt;= <span class="built_in">n</span>, m &lt;= <span class="number">1000</span>, <span class="number">1</span> &lt;= ci &lt;= <span class="built_in">n</span></span><br></pre></td></tr></table></figure>

<p>输出描述:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">小易这局游戏获得的分数</span><br></pre></td></tr></table></figure>

<p>示例1</p>
<p>输入</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p>思路：统计个数找最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// column </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt(); <span class="comment">// num</span></span><br><span class="line">            Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                    map.put(temp,map.get(temp)+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(temp,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>)map.keySet().stream().filter(x -&gt; x&gt;=<span class="number">1</span> &amp;&amp; x&lt;=n).count();</span><br><span class="line">            <span class="type">int</span> result;</span><br><span class="line">            <span class="keyword">if</span>(num!=n)&#123;</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result = map.values().stream().sorted().collect(Collectors.toList()).get(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>由前序数组、中序数组转换成二叉树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 前序中序拿到转换二叉树 &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">line0</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">			<span class="type">String</span> <span class="variable">line1</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">			String[] pres = line0.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">			String[] mids = line1.split(<span class="string">&quot;\\s&quot;</span>);</span><br><span class="line">			<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> pres.length;</span><br><span class="line">			<span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">			<span class="type">int</span>[] mid = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">				pre[i] = Integer.parseInt(pres[i]);</span><br><span class="line">				mid[i] = Integer.parseInt(mids[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">treeNode</span> <span class="variable">root</span> <span class="operator">=</span> transferTree(pre, mid, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">			System.out.println(root);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> treeNode <span class="title function_">transferTree</span><span class="params">(<span class="type">int</span>[] pre, <span class="type">int</span>[] mid, <span class="type">int</span> preL, <span class="type">int</span> preR, <span class="type">int</span> midL, <span class="type">int</span> midR)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (preL &gt; preR) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> findX(mid, pre[preL]);</span><br><span class="line">		<span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> x - midL;</span><br><span class="line">		<span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> midR - x;</span><br><span class="line">		<span class="type">treeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">treeNode</span>(pre[preL]);</span><br><span class="line">		root.setLeft(transferTree(pre, mid, preL + <span class="number">1</span>, preL + leftLength, midL, x - <span class="number">1</span>));</span><br><span class="line">		root.setRight(transferTree(pre, mid, preR - rightLength + <span class="number">1</span>, preR, x + <span class="number">1</span>, midR));</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findX</span><span class="params">(<span class="type">int</span>[] itemList, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; itemList.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (itemList[i] == target) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">treeNode</span> &#123;</span><br><span class="line">		<span class="type">int</span> val;</span><br><span class="line">		treeNode left, right;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">treeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.val = val;</span><br><span class="line">			<span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">			<span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(treeNode left)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.left = left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(treeNode right)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.right = right;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><p>分治思想的绝好例子：二维平面上有 n 个点，如何快速计算出两个距离最近的点对？</p>
<p><a href="https://www.cnblogs.com/hellohacker/p/5827222.html">分治算法应用-最近点对的最小距离-hdu 1007 Quoit Design</a></p>
<p>todo</p>
<hr>
<h3 id="LinkedHashMap-的好例子"><a href="#LinkedHashMap-的好例子" class="headerlink" title="LinkedHashMap 的好例子"></a>LinkedHashMap 的好例子</h3><p><a href="https://www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720?tpId=13&tqId=11207&rp=3&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking">字符流中第一个不重复的字符</a></p>
<ol>
<li>用 linkedHashMap 既做 hash 判重，又记录了插入顺序。</li>
<li>需要 iterator 进行递推</li>
</ol>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h4 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述:"></a>输出描述:</h4><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: offer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: maidong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-08-11 21:04</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 字符流中第一个不重复的字符 &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Insert</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Character.toString(ch);</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(str)) &#123;</span><br><span class="line">            map.put(str, map.get(str) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(str, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">FirstAppearingOnce</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Entry&lt;String, Integer&gt;&gt; it = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">            <span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> it.next();</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String) entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>) entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Character.valueOf(key.charAt(<span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第三章(2)</title>
    <url>/2018/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-2/</url>
    <content><![CDATA[<h1 id="计算机网络——数据链路层（2）"><a href="#计算机网络——数据链路层（2）" class="headerlink" title="计算机网络——数据链路层（2）"></a>计算机网络——数据链路层（2）</h1><h2 id="介质访问控制（Medium-Access-Control，MAC）"><a href="#介质访问控制（Medium-Access-Control，MAC）" class="headerlink" title="介质访问控制（Medium Access Control，MAC）"></a>介质访问控制（Medium Access Control，MAC）</h2><p>[定义]介质访问控制子层，是属于数据链路层的一个子层。任务是协调活动结点的传输，用来让使用介质的每一个结点能够隔离同一信道中其他结点的信号。常见的控制方法有：信道划分介质访问控制、随机访问介质访问控制和轮询访问介质访问控制：</p>
<h3 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h3><p>将每一个设备与统一信道其他设备的通信，彼此隔离开。把时域和频域资源（信号的两个属性，简单理解就是时间和频段）合理地分配给网络上的设备。</p>
<h4 id="多路复用。"><a href="#多路复用。" class="headerlink" title="多路复用。"></a>多路复用。</h4><ul>
<li>概念：当传输介质的带宽超过单一信号需要的带宽时，可以通过利用一条介质携带多个传输信号的方法来提高传输系统的利用率。</li>
<li>实质：通过分时、分频、分码等方法把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道，实际上就是把广播信道转变为点对<br>点信道。</li>
<li>分类：频分多路复用（FDM）、时分多路复用（TDM）、波分多路复用（WDM）、码分多路复用（CDM）</li>
</ul>
<span id="more"></span>

<h4 id="频分多路复用（FDM）"><a href="#频分多路复用（FDM）" class="headerlink" title="频分多路复用（FDM）"></a>频分多路复用（FDM）</h4><ul>
<li>将多路基带信号<strong>调频</strong>到不同频率载波上，再进行叠加形成复合信号的技术；</li>
<li>物理信道的带宽分割成若干个子信道，每个子信道传输一种信号；</li>
<li>每个子信道带宽没必要完全相同，但总和必须不超过总带宽；而且为了防止子信道之间的干扰，相邻信道间需要加入“保护频带”</li>
<li>优点：充分利用了带宽，技术较成熟。</li>
</ul>
<h4 id="时分多路复用（TDM）"><a href="#时分多路复用（TDM）" class="headerlink" title="时分多路复用（TDM）"></a>时分多路复用（TDM）</h4><ul>
<li>将一条物理信道，按照时间非诚若干个时间片，轮流分配给多个信号使用，每个时间片由一个信号占用；</li>
<li>微观的并发、宏观的并行。</li>
<li>但由于计算机数据的突发性，一个用户对已经分配到的子信道的利用率不高。采用统计时分多路复用（STDM）进行改进优化。</li>
<li>统计时分多路复用（STDM）：采用STDM帧，不是固定分配时隙，而是按需动态地分配时隙，当终端有数据要传输时才会分配到时间片，提高了线路的利用率。</li>
</ul>
<h4 id="波分多路复用（WDM）"><a href="#波分多路复用（WDM）" class="headerlink" title="波分多路复用（WDM）"></a>波分多路复用（WDM）</h4><ul>
<li>利用光的频分多路复用，在一根光纤中传输多种不同波长（频率）的光信号，由于波长（频率）不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来；</li>
<li>光波处于高频段，有很高的带宽，可以实现很多路的波分复用。</li>
</ul>
<h4 id="码分多路复用（CDM）"><a href="#码分多路复用（CDM）" class="headerlink" title="码分多路复用（CDM）"></a>码分多路复用（CDM）</h4><ul>
<li>既共享信道的频率，又共享信道的时间，是靠不同的编码来区分各路原始信号的一种复用方式。</li>
<li>推荐阅读：<a href="https://blog.csdn.net/u011240016/article/details/52705205">CDM(码分多路复用技术)总结</a></li>
<li>优点：频谱利用率高、抗干扰能力强、保密性强、语音质量好；可以减少投资和降低运行成本，主要用于无线通信系统，特别是移动通信系统。</li>
</ul>
<h3 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h3><ul>
<li>每个信号独占时间和频率，但需要抢夺，用户发送消息是随机的，不用规定次序。但为了解决碰撞的问题，用户需要按照一定的规则反复地重传它的帧，直到该帧无碰撞的通过。</li>
<li>核心思想：胜利者通过争用获得信道，从而获得信息的发送权。</li>
<li>实质：一种将广播信道转化为点到点信道的行为。</li>
<li>协议有：ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议等。</li>
</ul>
<h4 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h4><ul>
<li>Additive Link On-line HAwaii system；</li>
<li>分为纯ALOHA协议和时隙ALOHA两种；<ul>
<li>纯ALOHA协议：每一个站均自由地发送数据帧，如果一段时间内没有收到确认，站点认为发生了冲突，然后会等待一段时间后再发送数据（冲突双方都会等待一段随机的时间），直至发送成功。ALOHA网络吞吐量很低，所以用时隙ALOHA协议来优化。</li>
<li>时隙ALOHA协议：将各站的时间同步起来（不再自由了，发件时间受限，但仍然不用理会其他站点），将时间划分为一段段等长的时隙Slot，规定只能在每个时隙开始时才能发送一个帧。时隙长度一般比帧传递时间略长。一旦发生碰撞，处理方式与纯ALOHA协议的相同，但时隙ALOHA协议的网络吞吐量比纯LOHA协议大了1倍。</li>
</ul>
</li>
</ul>
<h4 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h4><ul>
<li>载波监听多路访问，Carrier Sense Multiple Access</li>
<li>发送前监听一下共用的信道，发现信道空闲后再发送。</li>
<li>在ALOHA协议基础上，增加了一个载波侦听装置。</li>
<li>根据侦听方式和侦听到忙道后处理方式的不同，分为三种不同的CSMA协议<ul>
<li>1-坚持CSMA。1指监听到闲，一定立即发送数据。效果受传播延迟影响较大。</li>
<li>非坚持CSMA。减少了多个信道等待空闲后同时发送数据导致冲突的概率，但也使得网络中的平均延时增加了。</li>
<li>p-坚持CSMA。是前两种的折中方案。</li>
<li>三者比较如下：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">信道状态</th>
<th align="center">1-坚持型</th>
<th align="center">非坚持型</th>
<th align="center">p-坚持型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">空闲</td>
<td align="center">立即发送数据</td>
<td align="center">立即发送数据</td>
<td align="center">以概率p发送数据，以概率1-p推迟到下一个时隙</td>
</tr>
<tr>
<td align="center">忙</td>
<td align="center">继续坚持监听信道</td>
<td align="center">放弃监听，等待一个随机的时间后再监听</td>
<td align="center">放弃监听，等待一个随机的时间后再监听</td>
</tr>
</tbody></table>
<h4 id="CSMA-x2F-CD协议"><a href="#CSMA-x2F-CD协议" class="headerlink" title="CSMA&#x2F;CD协议"></a>CSMA&#x2F;CD协议</h4><ul>
<li>载波监听多路访问&#x2F;碰撞检测，Carrier Sense Multiple Access with Collision Detection</li>
<li>在CSMA的基础上（依旧是发送前先监听），扩展了边发边侦听，以便判断自己在发送数据时其他站点是否也在发送数据（通过检测信道上信号电压的变化情况）；</li>
<li>工作流程概括：“先听后发、边听边发、冲突停发、随机重发”；</li>
<li>与CSMA不同之处：<ul>
<li>传输过程中，适配器（即网卡）检测来自其他适配器的信号能量的出现。如果在帧的整个传输过程中，都没有检测到其他信号能量，则顺利完成帧的传输；如果检测到了，那么适配器立即停止该帧的传输，取而代之一个48比特的拥塞信号；</li>
<li>在中止之后，适配器采用二进制指数退避算法（没必要了解太仔细，一个随机数而已）来等待一段随机时间后继续监听空闲。<ul>
<li>二进制指数退避算法：基本退避时间为2τ（下一段会解释），参数n（重传10次以下时，n表示重传次数；次数超过10后，n只能取10），退避时间是[0~2^n-1]中随机一个数k和2τ的乘积，即2kτ。重传超过16次后若仍不能成功，会认为此帧永远无法传输，向高层报告出错。</li>
<li>使用此算法，可使重传需要推迟的平均时间随重传次数的增大而增大，实现动态退避，减小发生碰撞的概率。</li>
</ul>
</li>
<li>发送点在最多经过2τ时间（τ为端到端单程传播时延）就会知道是否发生碰撞，2τ称为争用期（或冲突窗口、碰撞窗口）。</li>
<li>为了确保发送站在<strong>发送数据的同时能检测到可能存在的冲突</strong>，单帧的传输时延（搬货上车的耗时）至少两倍于信号在总线中的传播时延（轮子真正跑路的耗时）。<ul>
<li>因此单帧的长度不能低于一个最小值（比它短的当作无效帧处理，比如因冲撞而终止的帧），最小帧长&#x3D;总线传播时延×数据传输速率×2。</li>
<li>以太网规定51.2μs为争用期的长度。对于10Mb&#x2F;s以太网，争用期内可发送512bit（即64B）。如果前64B没有发生冲突，则信道被成功抢占，之后也不会发生冲突，此64B即最小帧长。</li>
<li>如果要发送一个正常帧，但帧长小于64B，MAC子层会在data区后面加一个整数字节的填充字段，使长度不低于64B。</li>
</ul>
</li>
</ul>
</li>
<li>只能用在半双工通信，不可能进行全双工通信</li>
<li>总线的传播时延对CSMA&#x2F;CD影响很大</li>
</ul>
<h4 id="CSMA-x2F-CA协议"><a href="#CSMA-x2F-CA协议" class="headerlink" title="CSMA&#x2F;CA协议"></a>CSMA&#x2F;CA协议</h4><ul>
<li>CA：Collision Avoidance，碰撞避免</li>
<li>CSMA&#x2F;CD协议很好地应用在有线连接的局域网，但在无线局域网环境下很难实现，有两个问题：① 接收信号的强度远小于发送信号的强度，要实现碰撞检测硬件花费过大；② 无线下，并非所有的站点都能够听见对方，即“隐蔽站”的问题。由此引入CA协议，尽量减少碰撞发生的概率。</li>
<li>基本思想：发送数据前先广播告知其他结点，在某一段时间内不要发送数据，以免出现碰撞。</li>
<li>机制：预约信道、ACK帧、RTS&#x2F;CTS帧：<ul>
<li>预约信道：必须实现。发送方向其他站点通知自己传输数据需要的时间长度，以便让其他站点在这段时间不发送数据；</li>
<li>ACK帧：必须实现。所有站点在正确接收到发给自己的数据帧（除了广播帧和组播帧）后，都需要响应一个ACK帧，若发送方未在一段时间内收到ACK帧，将进行帧的重发。</li>
<li>RTS&#x2F;CTS帧：可选实现，主要解决“隐蔽站”问题。</li>
</ul>
</li>
<li>流程：<ul>
<li>送出数据前，监听媒体状态，等没有人使用媒体，维持一段时间后，再等待一段随机的时间后依然没有人使用，才送出数据。由于每个设备采用的随机时间不同，所以可以减少冲突的机会。</li>
<li>送出数据前，先送一段小小的请求传送报文(RTS : Request to Send)给目标端，等待目标端回应 CTS: Clear to Send 报文后，才开始传送。 利用RTS-CTS握手(handshake)程序，确保接下来传送资料时，不会被碰撞。 同时由于RTS-CTS封包都很小，让传送的无效开销变小。</li>
<li>CSMA&#x2F;CA通过这两种方式来提供无线的共享访问，这种显式的ACK机制在处理无线问题时非常有效。然而不管是对于802.11还是802.3来说，这种方式都增加了额外的负担，所以802.11网络和类似的Ethernet网比较总是在性能上稍逊一筹。</li>
</ul>
</li>
</ul>
<h3 id="轮询访问介质访问控制：令牌传递协议"><a href="#轮询访问介质访问控制：令牌传递协议" class="headerlink" title="轮询访问介质访问控制：令牌传递协议"></a>轮询访问介质访问控制：令牌传递协议</h3><ul>
<li>轮询访问中，用户不能随机发送消息，需要通过一个集中控制的监控站，以循环的方式轮询每个节点，再决定信道的分配（没被分配到信道的结点不能发消息）。</li>
<li>主要协议是令牌传递协议，主要使用在令牌环局域网中。 </li>
<li>希望发送数据帧的结点，需要等待令牌，一旦收到令牌就可以开始发送；一直到发送结束后，该结点释放令牌，以便让其他结点使用。</li>
<li>数据帧需要包含目的结点的地址，但帧在环上传递时所有结点都进行帧的转发，直到发送结点收到自己的帧后，才可以撤销发送该帧（帧经过目的结点时，会被附上“响应比特”）。</li>
<li>令牌在设备间的传递通路在逻辑上必须是一个环。</li>
<li>轮询介质访问控制非常适合负载很高的广播信道（大概率出现多个结点在同时刻发送数据的信道）。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第三章-3</title>
    <url>/2018/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-3/</url>
    <content><![CDATA[<h1 id="计算机网络——数据链路层（3）"><a href="#计算机网络——数据链路层（3）" class="headerlink" title="计算机网络——数据链路层（3）"></a>计算机网络——数据链路层（3）</h1><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">广域网</th>
<th align="center">局域网</th>
</tr>
</thead>
<tbody><tr>
<td align="center">覆盖范围</td>
<td align="center">很广，通常跨区域</td>
<td align="center">较小，通常在一个区域内</td>
</tr>
<tr>
<td align="center">连接方式</td>
<td align="center">节点之间都是点对点连接，但为了提高网络的可靠性，一个结点交换机往往与多个结点交换机相连</td>
<td align="center">普遍采用多点接入技术</td>
</tr>
<tr>
<td align="center">OSI层次</td>
<td align="center">三层：物理层、数据链路层，网络层</td>
<td align="center">两层：物理层，数据链路层</td>
</tr>
<tr>
<td align="center">联系和相似点</td>
<td align="center">1.广域网和局域网都是互联网的重要组成构件，从互联网的角度上看，二者平等（不是包含关系）；</td>
<td align="center">2.连接在一个广域网或一个局域网上的主机在该网内进行通信时，只需要使用其网络的物理地址即可</td>
</tr>
<tr>
<td align="center">着重点</td>
<td align="center">强调资源共享</td>
<td align="center">强调数据传输</td>
</tr>
</tbody></table>
<ul>
<li>局域网使用的协议主要在数据链路层（少量在物理层），即数据的控制信息主要是数据链路层协议的控制信息。广域网协议主要在网络层。</li>
</ul>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>在一个较小的地理范围内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的的计算机互联网络。</p>
<span id="more"></span>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li>为一个单位所拥有（范围和站点数量有限）；</li>
<li>所有站共享较高的总带宽（数据传输速率高）；</li>
<li>较低的时延和较低的误码率；</li>
<li>各站为平等关系；</li>
<li>能进行广播和组播。</li>
</ol>
<p>特性由三个要素决定：</p>
<ol>
<li>拓扑结构（星型、环形、总线型、星形和总线复合型）</li>
<li>传播介质（双绞线、铜缆、光纤等，双绞线为主）</li>
<li>介质访问控制方式（决定性）（CSMA&#x2F;CD、令牌总线和令牌环，前两种用于总线型局域网，第三种用于环形局域网）</li>
</ol>
<p>三种特殊的局域网实现：以太网、令牌网、FDDI（光纤分布数字接口）</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">逻辑拓扑</th>
<th align="center">物理拓扑</th>
<th align="center">信息发送方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">以太网</td>
<td align="center">总线型</td>
<td align="center">星型</td>
<td align="center">广播式</td>
</tr>
<tr>
<td align="center">令牌环（Token Ring,IEEE802.5）</td>
<td align="center">环形</td>
<td align="center">星型</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">FDDI（光纤分布数字接口，IEEE802.8）</td>
<td align="center">环形</td>
<td align="center">双环形</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>IEEE802标准将数据链路层分成两个子层：逻辑链路控制子层和介质访问控制子层：</p>
<ul>
<li>介质访问控制子层（MAC），向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，功能：组帧和拆卸帧、比特传输差错检测、透明传输、寻址、竞争处理。</li>
<li>逻辑链路控制子层（LLC），与传输媒体无关，向网络层提供无确认无连接、面向连接、带确认无连接、告诉传送4种不同的链接服务类型。LLC作用已不大，目前不少网卡仅有MAC协议而无LLC协议。功能：建立和释放数据链路层的逻辑连接、提供和高层的接口、差错控制、给帧加序号。</li>
</ul>
<h3 id="以太网与IEEE-802-3"><a href="#以太网与IEEE-802-3" class="headerlink" title="以太网与IEEE 802.3"></a>以太网与IEEE 802.3</h3><ul>
<li>IEEE 802.3标准是一种<strong>基带总线型</strong>的局域网标准。采用CSMA&#x2F;CD方式。</li>
<li>采用两项措施简化通信：<ul>
<li>无连接的工作方式。不对发送的数据帧编号。</li>
<li>不要求接收方发送确认，提供不可靠服务，对于差错的纠正则由高层完成。</li>
</ul>
</li>
<li>常用传输介质由4种：粗缆、细缆、双绞线和光纤。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">10BASE5</th>
<th align="center">10BASE2</th>
<th align="center">10BASE-T</th>
<th align="center">10BASE-FL</th>
</tr>
</thead>
<tbody><tr>
<td align="center">传输媒体</td>
<td align="center">基带同轴电缆（粗缆）</td>
<td align="center">基带同轴电缆（细缆）</td>
<td align="center">非屏蔽双绞线</td>
<td align="center">光纤对（850nm）</td>
</tr>
<tr>
<td align="center">编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
<td align="center">曼彻斯特编码</td>
</tr>
<tr>
<td align="center">拓扑结构</td>
<td align="center">总线型</td>
<td align="center">总线型</td>
<td align="center">星型</td>
<td align="center">点对点</td>
</tr>
<tr>
<td align="center">最大段长</td>
<td align="center">500m</td>
<td align="center">185m</td>
<td align="center">100m</td>
<td align="center">2000m</td>
</tr>
<tr>
<td align="center">最多结点数量</td>
<td align="center">100</td>
<td align="center">30</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
</tbody></table>
<ul>
<li><p>网卡具有唯一的MAC地址（即以太网地址）。功能：</p>
<ul>
<li>是局域网中连接计算机和传输介质的接口；</li>
<li>不仅能实现与局域网传输介质之间的物理连接和电信号匹配；</li>
<li>还涉及帧的发送与接收、帧的封装和拆装；</li>
<li>介质访问控制、数据的编码与解码以及数据缓存的功能。</li>
</ul>
</li>
<li><p>MAC帧格式有两种标准：DIX Ethernet V2标准和IEEE802.3标准，以前者为例：</p>
<ul>
<li>MAC帧格式&#x3D;前导码+MAC帧；</li>
<li>前导码&#x3D;前同步码（7B，实现时钟同步）+帧开始定界符（1B）；</li>
<li>MAC帧&#x3D;目的地址（6B）+原地址（6B）+类型（2B，指出data区的数据应交给哪个协议实体处理）+data区（46~1500B，包含高层协议消息，若不足46B则填充）+FCS（4B，校验码，除了前导码外，都属于娇艳的范围）；</li>
<li>IEEE 802.3对比DIX不同之处：帧起始标志；长度域代替类型域。</li>
</ul>
</li>
<li><p>高速以太网：速率超过100Mb&#x2F;s，并且可以从10Mb&#x2F;s向10Gb&#x2F;s演进，说明：可拓展、灵活、易于安装、稳健性好。常见的有：100BASE-T（可全双工，可半双工）、吉比特以太网（又名千兆以太网，可全双工可半双工）、10吉比特以太网（只全双工）。</p>
</li>
</ul>
<h3 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h3><ul>
<li>IEEE 802.11是无线局域网的一系列协议标准，包括802.11a和802.11b等</li>
<li>除了基本的协调访问问题，还进行了以下控制：<ul>
<li>错误控制。为了克服通道固有的不可靠性；</li>
<li>适宜的寻址和关联规程。为了处理站点的可携带型和移动性；</li>
<li>互联过程。为了扩展无线站的通信范围；</li>
<li>允许用户在移动的同时可以通信。</li>
</ul>
</li>
<li>采用CSMA&#x2F;CA协议进行介质访问控制。但在无线局域网中，即使在发送过程中发生了碰撞，也要把整个帧发送完毕。因此一旦出现碰撞，在这个帧的发送时间内信道资源都被浪费了。</li>
<li>无线局域网分为两大类：有固定基础设施和无固定基础设施的<ul>
<li>有固定基础设施：由基本服务集（BSS）作为最小构件，一般包括一个基站和若干个移动站，此基站也被称为接入点（AP，作用类似网桥）。若干个BSS可以通过分配系统（DS）连接成扩展的服务集（ESS）。ESS再通过门桥（Portal）为无线用户提供到非802.11无线局域网的接入。</li>
<li>无固定基础设施的无线局域网自组织网络：无AP，这些结点地位平等，都具有路由器的功能。具有自己特定的路由选择协议，可以不和因特网连接，把移动性扩展到无线领域中的自治系统。区别于移动IP，移动IP技术使漫游的主机用多种方式连接到因特网，是基于固定互联网中的各种路由选择协议。</li>
</ul>
</li>
</ul>
<h3 id="令牌环网"><a href="#令牌环网" class="headerlink" title="令牌环网"></a>令牌环网</h3><ul>
<li>TCU：令牌环网的每一站通过电缆与环接口干线耦合器TCU相连。多站之间通过TCU相连。TCU的作用是：传递所有经过的帧、为接入站发送和接收数据提供接口。TCU有两种状态：收听状态和发送状态。</li>
<li>令牌环网的原理可查看上一篇博客——<a href="http://likehui.fun/2018/08/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0-2/">数据链路层（2）</a></li>
<li>令牌环网中令牌和数据传递过程：<ol>
<li>当网络空闲时，环路中只有令牌帧在循环传递；</li>
<li>令牌传递到有数据要发送的站点处，该站点就修改令牌中的一个标志位，并在令牌中附上自己需要传输的数据，这时令牌帧就变成了数据帧，然后将数据帧发送出去；</li>
<li>数据帧沿着环路传输，接收到的站点一边转发数据，一边查看帧的目的地地址。如果目的地址跟自己匹配，接收站就复制该帧；</li>
<li>数据帧沿着环路传输，知道到达该帧的源站点，源站点不再转发。同时发送方检验数据帧是否有错，若有错则重发；</li>
<li>源站点发送完数据后，会重新产生一个令牌。</li>
</ol>
</li>
</ul>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><ul>
<li>定义：覆盖范围很广（远超一个城市）的长距离网络。</li>
<li>任务：通过长距离运送主机所发送的数据。</li>
<li>各结点交换机链路：都是高速链路，距离可以是几千公里的光缆线路，也可以是几万公里的点对点卫星链路。结点交换机执行分组存储转发的功能，结点之间都是点对点连接，但为了提高网络的可靠性，通常一个结点交换机与多个结点交换机连接。</li>
<li>首要问题：通信容量必须足够大，以便支持日益增长的通信量。</li>
</ul>
<h3 id="结点交换机与路由器？"><a href="#结点交换机与路由器？" class="headerlink" title="结点交换机与路由器？"></a>结点交换机与路由器？</h3><ul>
<li>共同点：两者都是用来转发分组；</li>
<li>结点交换机：在单个网络中转发分组；</li>
<li>路由器：在多个网络构成的互联网中转发分组</li>
</ul>
<h3 id="广域网与互联网？"><a href="#广域网与互联网？" class="headerlink" title="广域网与互联网？"></a>广域网与互联网？</h3><ul>
<li>广域网不等同于互联网，互联网是可以通过路由器连接广域网和局域网的，</li>
<li>局域网可以通过广域网与另一个相隔很远的局域网进行通信</li>
</ul>
<h3 id="路由选择和转发："><a href="#路由选择和转发：" class="headerlink" title="路由选择和转发："></a>路由选择和转发：</h3><ul>
<li>路由选择：使用路由选择协议，负责搜索分组从某个结点到目的结点的最佳传输路由，以便构造路由表；</li>
<li>转发：从路由表再构造出转发分组的转发表</li>
<li>广域网的路由选择和转发是由结点交换机完成的，操作局限在在单个网络中。</li>
<li>最常用的两种数据链路层控制协议：PPP协议和HDLC协议</li>
</ul>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ul>
<li>Point-to-Point Protocol；</li>
<li>定义：使用串行线路通信的<strong>面向字节</strong>（帧全长是整数个字节）的协议，应用在直接连接两个结点的链路上。</li>
<li>设计目的：通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。</li>
<li>推荐阅读：<a href="https://blog.csdn.net/u011240016/article/details/52745628">广域网协议之PPP，HDLC</a></li>
<li>组成部分：链路控制协议LCP、网络控制协议NCP、将IP数据报封装到串行链路的方法</li>
<li>适用范围：异步线路&#x2F;同步线路，Modem链路，路由器到路由器等</li>
<li>PPP帧的格式：7EF+FFA+03C+协议+data+FCS+7EF<ul>
<li>7EF即7E（01111110）标志字段，帧前后各一个字节，若出现在信息字段则需要字节填充，控制转义字节是7D（01111101）</li>
<li>FFA即地址字段，1个字节；</li>
<li>03C即控制字段，1个字节；</li>
<li>协议段，说明信息段运载的是什么分类的分组，2个字节；</li>
<li>data，即信息段，长度0~1500字节，因不采用CSMA&#x2F;CD协议，所以无需限制长度下限；</li>
<li>FCS即帧检验序列，对A+C+协议+信息进行检验；</li>
<li>尾部7EF同首部相同功能。</li>
</ul>
</li>
<li>注意：<ul>
<li>PPP提供差错检验，但不提供纠错功能，是不可靠的传输协议，不使用序号和确认机制；</li>
<li>不支持多点线路；</li>
<li>只支持全双工链路；</li>
<li>PPP两端可以运行不同的网络层协议；</li>
<li>PPP面向字节，有两种实现透明传输的方法：异步线路采用字节填充法；同步线路利用硬件实现比特填充。</li>
</ul>
</li>
</ul>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><ul>
<li>定义：ISO制定的，<strong>面向比特</strong>的数据链路层协议。</li>
<li>特点：不依赖于任何一种字符编码集；数据报文可透明传输，“0比特插入法”易于通过硬件实现；全双工通信，有较高的数据链路传输效率；帧采用CRC检验；对信息帧编号，可防止漏发或重发，传输可靠性高；传输控制功能和处理功能分离，具有较大的灵活性；</li>
<li>两种配置：非平衡配置和平衡配置：<ul>
<li>非平衡配置：由一个主站控制整个链路的工作；</li>
<li>平衡配置：链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许</li>
</ul>
</li>
<li>三种站：主站、从站和复合站：<ul>
<li>主站：主要功能是发送命令帧、接收响应帧，并负责对整个链路控制系统的初启、流程的控制、差错检测及恢复等；</li>
<li>从站：接收从主站发来的命令帧、向主站发送响应帧，配合主站参与差错恢复等链路控制；</li>
<li>复合站：既能发送、又能接收命令帧和响应帧，并且负责整个链路的控制。</li>
</ul>
</li>
<li>数据操作方式：正常响应方式，异步平衡方式，异步响应方式<ul>
<li>正常响应方式：非平衡结构操作方式，主站发送数据，从站响应传输（需要得到主站的许可）</li>
<li>异步平衡方式：平衡结构操作方式，每一个复合站都可以进行对其他站的数据传输；</li>
<li>异步响应方式：非平衡结构操作方式，从站在没有接到主站的允许下就可以传输。</li>
</ul>
</li>
<li>HDLC帧的格式：F+A+C+data+FCS+F：<ul>
<li>标志F，8bit，01111110；</li>
<li>地址字段A，8bit；</li>
<li>控制字段C，8bit，根据C中第1、2位的取值，可将HDLC分为3类：<ul>
<li>信息帧（I），第1位是0，用来传输信息，或使用捎带技术对数据进行确认；</li>
<li>监督帧（S），第1、2位分别是1、0，用于流量控制和差错控制，执行对信息帧的确认、请求重发和请求暂停发送等功能；</li>
<li>无编号帧（U），第1、2位都是1，用于提供对链路的建立、拆除等多种控制功能；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="PPP和HDLC？"><a href="#PPP和HDLC？" class="headerlink" title="PPP和HDLC？"></a>PPP和HDLC？</h3><ul>
<li>PPP面向字节、HDLC面向比特；</li>
<li>PPP帧比HDLC多了2字节的协议字段。当协议字段值为0x0021时，表示信息段为IP数据报；</li>
<li>PPP不使用序号和确认机制，只保证无差错接收，端到端的差错检验由高层协议负责。HDLC的信息帧使用了编号和确认机制，能够提供可靠地传输。</li>
</ul>
<h2 id="数据链路层的设备"><a href="#数据链路层的设备" class="headerlink" title="数据链路层的设备"></a>数据链路层的设备</h2><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><ul>
<li>网桥将两个或多个以太网连接起来，构成一个覆盖范围更大的以太网。原本的以太网就可称为一个网段。</li>
<li>网桥工作在数据链路层的MAC层，可以使以太网各网段成为隔离开的碰撞域。</li>
<li>功能：<ul>
<li>具备寻址和路径选择能力；</li>
<li>从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧；</li>
<li>在不同或相同类型的LAN之间存储或转发帧，必要时进行链路层上的协议转换（一般的存储转发设备都可以进行协议转换）</li>
<li>对接收到的帧不做任何修改，只对帧的封装格式进行很少的修改；</li>
<li>可以通过帧翻译互联不同类型的局域网，即把原协议的信息段内容作为另一个协议的信息部分封装在帧中；</li>
<li>具有足够大的缓冲区</li>
</ul>
</li>
<li>优点：过滤通信量、扩大了物理范围、可使用不同的物理层、可互联不同类型的局域网、提高了可靠性、性能得到改善</li>
<li>缺点： 增加时延；MAC子层没有流量控制功能；不同MAC子层的网段桥接在一起时，需要进行帧格式的转换；可能出现广播风暴</li>
<li>两种不同的路径选择算法：透明网桥和源路由网桥</li>
</ul>
<table>
<thead>
<tr>
<th align="center">特点</th>
<th align="center">透明网桥</th>
<th align="center">源路由网桥</th>
</tr>
</thead>
<tbody><tr>
<td align="center">面向</td>
<td align="center">无连接</td>
<td align="center">连接</td>
</tr>
<tr>
<td align="center">透明性</td>
<td align="center">完全透明</td>
<td align="center">不透明</td>
</tr>
<tr>
<td align="center">配置方式</td>
<td align="center">自动</td>
<td align="center">手动</td>
</tr>
<tr>
<td align="center">路由</td>
<td align="center">次优化</td>
<td align="center">优化</td>
</tr>
<tr>
<td align="center">定位</td>
<td align="center">逆向学习</td>
<td align="center">发查找帧</td>
</tr>
<tr>
<td align="center">失效处理</td>
<td align="center">网桥处理</td>
<td align="center">主机处理</td>
</tr>
<tr>
<td align="center">复杂性</td>
<td align="center">在网桥中</td>
<td align="center">在主机中</td>
</tr>
</tbody></table>
<h4 id="透明网桥"><a href="#透明网桥" class="headerlink" title="透明网桥"></a>透明网桥</h4><ul>
<li>混杂方式工作，它接收与之连接的所有LAN传送的每一帧；<ul>
<li>若源LAN和目的LAN相同，丢弃该帧；</li>
<li>若源LAN和目的LAN不同，转发该帧；</li>
<li>若目的LAN未知，扩散该帧；</li>
</ul>
</li>
<li>网桥刚连接时，转发表是空的，网桥采用自学习算法处理收到的帧；</li>
<li>自学习算法：网桥每收到一个帧A，都会记下源地址和进入网桥时选择的端口，写入转发表中。如果有更新就及时更新。</li>
</ul>
<h4 id="源路由网桥"><a href="#源路由网桥" class="headerlink" title="源路由网桥"></a>源路由网桥</h4><ul>
<li>路由选择由发送数据帧的源站负责，网桥只根据数据</li>
<li>工作原理：<ul>
<li>源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。</li>
<li>源站以广播方式向欲通信的目的站发送一个发现帧（Discovery Frame），每个发现帧都记录所经过的路由。</li>
<li>发现帧到达目的站时就沿各自的路由返回源站。</li>
<li>源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。</li>
<li>凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息。</li>
</ul>
</li>
</ul>
<h3 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h3><ul>
<li><p>局域网交换机又称以太网交换机。类似于多端口的网桥，工作在数据链路层，能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽。</p>
</li>
<li><p>可以很方便的实现虚拟局域网（VLAN），VLAN可以隔离冲突域，也可以隔离广播域；</p>
</li>
<li><p>原理：检测从以太端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表对比，若数据帧的MAC地址不在查找表中，则将该地址加入查找表中，并将数据帧发送给响应的目的端口。</p>
</li>
<li><p>特点：</p>
<ol>
<li>交换机的每个端口直接与单个主机相连，一般工作在全双工；</li>
<li>能同时连通很多对的端口，使每一对相互通信的主机都能够像独占通信媒体那样，无碰撞地传输数据；</li>
<li>即插即用，帧的转发表也是通过自学习算法自动建立起来的；</li>
<li>使用了专用的交换结构芯片，交换效率高；</li>
<li>交换机独占传输媒体的带宽；</li>
</ol>
</li>
<li><p>两种交换方式：直通式交换机、存储转法式交换机:</p>
<ul>
<li>直通式交换机：只检查帧的目的地址；</li>
<li>存储转发式交换机：先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，检查无误后通过查找表转换成输出端口将该帧发送出去；如果发现帧有误，则将帧丢弃。优点：可靠性高，并能支持不同速度端口间的转换；缺点是延迟较大。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第三章练习</title>
    <url>/2018/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络——数据链路层（1）"><a href="#计算机网络——数据链路层（1）" class="headerlink" title="计算机网络——数据链路层（1）"></a>计算机网络——数据链路层（1）</h1><h2 id="专有名词解析"><a href="#专有名词解析" class="headerlink" title="专有名词解析"></a>专有名词解析</h2><h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p>数据链路层连接的建立、维持和释放的过程。</p>
<h4 id="帧定界"><a href="#帧定界" class="headerlink" title="帧定界"></a>帧定界</h4><p>将分组信息封装成帧，帧的首部和尾部含有很多控制信息，具有确认帧的界限的作用，所以叫帧定界。</p>
<h4 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h4><p>接收方从二进制比特流中能够区分出帧的开始和结束。</p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>无论什么样的比特组合都能够在链路上传输。即，即使数据中恰好出现与帧定界符相同的比特组合的情况，都能够很好地解决。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>对发送方的发送速率进行限制，使之适应接收方的接收能力。常见的方式有停止-等待协议和滑动窗口协议等：</p>
<span id="more"></span>
<ul>
<li>停止-等待协议。一帧一帧的发送接收，发送方等到上一帧的响应信号后，才开始下一帧的发送，效率极低。<ul>
<li>可能出现的差错：① 帧丢失；② 帧破坏（破坏的帧被接收端检出后直接丢弃，发送端的计时器被触发后重发相同的帧）；③ 数据帧正确但确认帧被破坏，发送端会重发相同帧，接收端拒收该帧，并重传确认帧。</li>
<li>为了超时重发和判定重复帧的需要，发送方和接收方都需要设置一个帧缓冲区。发送方在发送完一帧后，必须在帧缓冲区中保留此帧副本，若出差错则重传，若接收该帧的确认帧ACK则清除副本。</li>
</ul>
</li>
<li>滑动窗口协议。<ul>
<li>发送方维护的一组队列（存储着允许发送的帧的序号），称为发送窗口；对应的是接收窗口。两者的窗口大小不一定完全相同。</li>
<li>窗口大小即没有收到接收方的确认消息前，还可以发送多少帧。接收端收到一帧时，窗口滑动一帧（要求此帧落在接收窗口内，否则丢弃），同时响应一条确认消息；窗口发送端收到一条确认消息，则窗口滑动一帧。</li>
<li>特点：<ul>
<li>接收窗口向前滑动时，发送窗口才有可能滑动；</li>
<li>当接收窗口为1时，可保证帧有序；</li>
<li>两个窗口都为1时，等价于停-等协议；</li>
<li>发送窗口&gt;1，接受窗口&#x3D;1，等价于后退N帧协议（接受帧只允许按顺序接受帧）；</li>
<li>发送、接收窗口均&gt;1，等价于选择重传协议；</li>
<li>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定不变的（区别于传输层的滑动窗口协议）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h4><p>采用确认和超时重传两种机制。传统的自动重传请求分为三种：停等式ARQ（配合停-等协议）、后退N帧ARQ、选择性重传ARQ。后两者配合滑动窗口协议。【可参考上一段“流量控制”，以下是扩展细节】</p>
<ul>
<li>多帧滑动窗口与后退N帧协议（GBN）。当接受方检测出失序后，要求发送方重发最后一个正确接收的信息帧之后的所有未被确认的帧。对某一数据帧的确认就表明该数据帧和以前所有的数据帧均被正确地收到了。（举例：1<del>6帧发送出去，第1帧确认并且发送端接收ack1成功，但接收端发现第2帧有误，然后会拒收2</del>6帧，并响应一个ack1告知发送端）。推荐阅读：<a href="https://blog.csdn.net/jxq0816/article/details/52454459">后退N帧协议（GBN）</a></li>
<li>若采用n个比特对帧编号，那么发送窗口的尺寸要在[1-(2^n - 1)]之间，否则接收方无法分辨新旧帧<ul>
<li>不设为2^n是为了错位，若n为2，则窗口最大设为3（正向举例），此时帧编号为0、1、2、3。</li>
<li>情况1：0、1、2三帧发到接收端，接收端依次返回ack，然后发送端发送新帧，编号3、0、1；</li>
<li>情况2：0、1、2三帧发到接收端，接收端返回的ack丢失，由于超时重发机制，发送端发送旧帧，编号0、1、2；</li>
<li>两种情况下新旧帧的编号不一致，接收方可以区分。</li>
<li>若窗口最大设为2^n，则无法区分新旧帧，造成严重后果。</li>
</ul>
</li>
<li>后退N帧协议优点：提高了信道的利用率；缺点：重传时传送了部分正确数据帧。综上，若传输质量很差，其效率不一定优于停-等协议。</li>
<li>选择重传协议（SR）。推荐阅读：<a href="https://blog.csdn.net/Jaihk662/article/details/80383124">选择性重传</a>。<ul>
<li>接收窗口存储差错帧后继的所有正确帧；</li>
<li>发送方只重传差错帧；</li>
<li>接收方接收重传帧，按正确顺序将分组提交网络层。</li>
<li>特点：<ul>
<li>发送窗口和接收窗口大小相同，一般设为2^(n-1)，n为帧编号的比特数；</li>
<li>接收方缓存区相对较大，因为要用来排序；</li>
<li>每个发送缓存区对应着一个计时器；</li>
<li>当接收方怀疑帧出错时，会发一个否定帧NAK给发送方，要求发送方对NAK中的指定帧进行重传。</li>
<li>对比后退N帧，选择重传协议适合出错率较高的信道。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2018/08/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BB%83%E4%B9%A0/1.png" alt="SR"></p>
<h4 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h4><p>按照一定的规则，将网络层递交的分组组装成帧（组帧有首部和尾部，但分组&#x2F;数据报是帧的data部，不需要尾部定界）。方式：</p>
<ul>
<li>字符计数法（首部指明帧内字符个数）</li>
<li>字符填充的首尾定界法（特定字符来定界，data区若出现相同编码则加上转义符）</li>
<li><strong>比特填充</strong>的首尾定界法（使用01111110即7E标定帧的始末，data区如果遇到5个连续的1则添一个0，接收方采用逆操作）</li>
<li><strong>违规编码法</strong>（曼彻斯特编码中，采用高-高或低-低的违规方式来定界帧）</li>
</ul>
<h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><p>传输中的差错都是由噪声引起的。噪声来源有两种：信道固有、持续存在的随机热噪声（可通过提高信噪比来尽量避免）；另一类是外界短暂出现的冲击噪声（难以避免）。差错分为位错和帧错：</p>
<ul>
<li>位错：某些位出现差错，使用循环冗余校验（CRC）来发现位错，使用自动重传请求（ARQ）来重传该帧。</li>
<li>帧错：帧的丢失、重复和失序的问题。在数据链路层引入定时器和编号机制，可以保证每一帧都唯一正确地交付给目的结点。</li>
</ul>
<h4 id="差错控制-1"><a href="#差错控制-1" class="headerlink" title="差错控制"></a>差错控制</h4><p>分为检错编码和纠错编码：</p>
<ul>
<li>检错编码采用奇偶校验码（例如奇校验码：n-1个信息元和1个校验元，这n个码字中总共奇数个“1”）和循环校验码（CRC，m bit的帧和r bit的帧检验序列（FCS），此m+r能被某提前约好的多项式（例如1101，要求首尾必须是1）整除）。</li>
<li>纠错编码，常用海明编码，2的幂次位是校验码P（1，2，4，8…），其他是信息位D（3，5，6，7）。	P1&#x3D;P1；P2&#x3D;P2；D3&#x3D;P1+P2；P4&#x3D;P4；D5&#x3D;P1+P4；D6&#x3D;P2+P4；D7&#x3D;P1+P2+P4。<ul>
<li>发送时，已知信息为D，根据规则：P1与D3、D5、D7有关且异或为0；P2与D3、D6、D7有关且异或为0；类推规则。可以计算出P1、P2等。</li>
<li>纠错时，检查各校验码，若有3位校验码（P1、P2、P4），读出来是110，但是异或关系有误，则110&#x3D;&#x3D;6，书名第6位（即D6有误，取反即可）。</li>
</ul>
</li>
</ul>
<h4 id="信道效率和吞吐率"><a href="#信道效率和吞吐率" class="headerlink" title="信道效率和吞吐率"></a>信道效率和吞吐率</h4><ul>
<li>信道效率即信道利用率。发送方在一个发送时间周期内，有效地发送数据所需要的时间占整个发送周期的比率。</li>
<li>信道吞吐率为信道效率×发送方的发送速率。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第二章练习</title>
    <url>/2018/08/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="计算机网络第二章——物理层"><a href="#计算机网络第二章——物理层" class="headerlink" title="计算机网络第二章——物理层"></a>计算机网络第二章——物理层</h1><h4 id="1-什么是奈氏准则，什么是香农定理"><a href="#1-什么是奈氏准则，什么是香农定理" class="headerlink" title="1. 什么是奈氏准则，什么是香农定理?"></a>1. 什么是奈氏准则，什么是香农定理?</h4><ul>
<li>推荐阅读：<a href="https://blog.csdn.net/Dallin0408/article/details/59510405">奈氏准则和香农公式</a></li>
<li>奈氏准则：<ul>
<li>在理想低通（只允许低频通过）的信道中，极限码元传输率为2W Baud。W是理想低通信道的带宽，单位Hz；Baud是单位波特，一个Baud表示一秒一个码元（一秒变化一次电平，变化次数而非周期数）。整体理解就是：每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元。</li>
<li>比特率bps（bit per second），每秒传输数据的位数。</li>
<li>比特率&#x3D;log(2)V×波特率</li>
<li>极限数据传输率为2Wlog(2)V。一秒一个码元等价于一秒log(2)V个单位的数据，其中V是指每个码元离散电平的数量。</li>
</ul>
</li>
<li>信道容量：<ul>
<li>数据在信道中传输中，最高的比特率就叫做这个信道的容量，单位是bps</li>
<li>口语中也会把信道容量叫做“带宽”的，比如“带宽10M的网络”，“网络带宽是10M”等等。所以这两个概念也很容易混淆：我们平常所说的“带宽”不是带宽，而是信道容量。</li>
</ul>
</li>
<li>香农定理：<ul>
<li>信道的极限数据传输速率&#x3D;Wlog(2)[1+S&#x2F;N]，单位b&#x2F;s。其中，W是信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S&#x2F;N表示信噪比，即信号的平均功率和噪声的平均功率之比，常用分贝dB来表示，信噪比&#x3D;10log(10)(S&#x2F;N)，当S&#x2F;N为10时，信噪比为10dB，当S&#x2F;N为1000时，信噪比为30dB。</li>
<li>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</li>
<li>香农公式是用来估测，一个信道中能传输的数据的速度的上限</li>
<li>香农定理可以解释现代各种无线制式由于带宽不同，所支持的单载波最大吞吐量的不同。</li>
</ul>
</li>
</ul>
<span id="more"></span>


<hr>
<h4 id="2-数据变成信号的四种情况："><a href="#2-数据变成信号的四种情况：" class="headerlink" title="2. 数据变成信号的四种情况："></a>2. 数据变成信号的四种情况：</h4><pre><code>数字数据/模拟数据 -&gt; 数字信号/模拟信号
</code></pre>
<ol>
<li>数字数据编码为数字信号。<ul>
<li>通常有非归零码(简单的高低位)、曼彻斯特编码(高低位与时钟信号异或，<strong>应用于以太网</strong>，一个数据两个电平，波特率是数据率的两倍，差分曼彻斯特也是如此  )、差分曼彻斯特编码（与前一个码元比较）、<a href="https://www.cnblogs.com/laojie4321/archive/2012/04/09/2439470.html">4B&#x2F;5B编码</a>（用5bit表示4bit）</li>
<li><strong>属于基带传输，是原始的电脉冲信号，不经过调制解调，信号以脉冲的形式在信道上传输，设备花费少，适用于较小范围的数据传输。</strong></li>
</ul>
</li>
<li>数字数据调制为模拟信号<ul>
<li>对应调制解调器，走模拟通信信道</li>
<li>基本调制方法有：幅移键控（振幅，抗干扰能力差），频移键控（频率，应用较多），相移键控（相位，分绝对调相和相对调相），正交振幅调制（振幅和相位的结合叠加信号）</li>
<li><strong>属于频带传输，对数字信号进行某种变换，将代表数据的二进制“1”和“0”，变换成具有一定频带范围的模拟信号，以适应在模拟信道上传输。长途信道是无法传输原始电脉冲信号的</strong></li>
<li>最后还有一类叫做宽带传输，指比音频（4KHZ）带宽还要宽的频带，包括了大部分电磁波频谱的频带。使用这种宽频带进行传输的系统就称为宽带传输系统，它可以容纳所有的广播，并且还可以进行高速率的数据传输。</li>
</ul>
</li>
<li>模拟数据编码为数字信号<ul>
<li>常用的是对音频信号进行编码的脉码调制（PCM），应用采样定理</li>
<li>脉冲编码调制PCM就是把一个时间连续，取值连续的模拟信号变换成时间离散，取值离散的数字信号后在信道中传输。脉冲编码调制就是对模拟信号先抽样，再对样值幅度量化，编码的过程。</li>
<li>抽样，就是对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号，抽样必须遵循奈奎斯特抽样定理（也叫采样定理）。该模拟信号经过抽样后还应当包含原信号中所有信息，也就是说能无失真的恢复原模拟信号。</li>
<li>量化，就是把经过抽样得到的瞬时值将其幅度离散，即用一组规定的电平，把瞬时抽样值用最接近的电平值来表示,通常是用二进制表示。</li>
<li>量化误差：量化后的信号和抽样信号的差值。量化误差在接收端表现为噪声，称为量化噪声。 量化级数越多误差越小，相应的二进制码位数越多，要求传输速率越高，频带越宽。 </li>
<li>一个模拟信号经过抽样量化后，得到已量化的脉冲幅度调制信号，它仅为有限个数值。	</li>
<li>编码，就是用一组二进制码组来表示每一个有固定电平的量化值。然而，实际上量化是在编码过程中同时完成的，故编码过程也称为模&#x2F;数变换，可记作A&#x2F;D。</li>
</ul>
</li>
<li>模拟数据调制为模拟信号<ul>
<li>频分（FDM）复用技术，电话机与本地交换机所传输的信号就是采用模拟信号传输模拟数据的编码方式。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-比较电路交换、报文交换、分组交换"><a href="#3-比较电路交换、报文交换、分组交换" class="headerlink" title="3. 比较电路交换、报文交换、分组交换"></a>3. 比较电路交换、报文交换、分组交换</h4><ul>
<li>电路交换。要先建立一条专用（双方独占）的物理通信路径，<strong>用户始终占用端到端的固定传输带宽</strong>，分为三个阶段：连接建立、数据传输、连接释放。<ul>
<li>优点：通信时延小，有序传输，没有冲突，使用范围广（既适合模拟信号，又适合数字信号），实时性强，控制简单。</li>
<li>缺点：建立连接时间长，线路独占使用效率低，灵活性差（出现故障必须重新拨号等），难以规格化难以进行差错控制（无法纠正传输过程中发生的数据差错，如为保证数据无差错地传送，不建议采用电路交换）。</li>
<li>不采用存储转发的方式，任何中间结点都采用“直通式”收发数据。</li>
</ul>
</li>
<li>报文交换。报文携带目标地址、源地址等信息，在各交换节点采用存储转发的机制。<ul>
<li>优点：无需建立连接，动态分配线路，提高线路可靠性（故障时可更换线路），提高线路利用率，提供多目标服务（电路交换中很难做到）。不适合实时通信应用环境（如语音、视频等）。</li>
<li>缺点：由于采用存储转发机制，所以存在转发时延（包括接受报文，检验正确性、排队、发送时间等），报文交换对报文大小没有限制，需要网络结点有较大的缓存空间。</li>
</ul>
</li>
<li>分组交换。正在报文交换的基础上，解决了报文交换中大报文传输的问题。分组交换限制了每次传送的数据块大小的上限，把大的数据块分成合理大小的小数据块，并加上必要的控制信息。<ul>
<li>优点：在报文交换的基础上，简化了存储管理，交换结点的缓冲区大小固定，管理简化。加速传输，后一个分组的存储操作与前一个分组的转发操作并行，这种流水线的方式减少了报文的传输时间，因缓冲区不足等待发送的几率和时间也必然小很多。减少了出错几率和重发数据量。</li>
<li>缺点：传输时延比报文交换略短，但仍存在，而且结点交换机必须具有较强的处理能力。需要传输额外的信息量，总信息量多了5%~10%。当分组交换采用<strong>数据报</strong>的服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作。若采用<strong>虚电报</strong>的服务，虽无失序问题，但有呼叫建立、数据传输和虚电路释放三个过程。</li>
</ul>
</li>
<li>若传送数据量很大，且传送时间远大于呼叫时间，可以采用电路交换；当端到端的通路由很多段的链路组成时，采用分组交换较合适。针对计算机之间的突发式的数据通信，分组交换则更为合适。</li>
</ul>
<hr>
<h4 id="4-比较数据报和虚电路"><a href="#4-比较数据报和虚电路" class="headerlink" title="4. 比较数据报和虚电路"></a>4. 比较数据报和虚电路</h4><ul>
<li>这两个服务都属于分组交换，虚电路结合了部分电路交换的特色。</li>
<li>数据报服务：派出一堆小兵，每个带着双方地址，让他们独立送信。</li>
<li>虚电路：先修路到目的地，让一堆骡子每个带着路号，无脑沿路送信。</li>
<li>数据报中网络具有冗余路径，当故障时，可以相应地更新转发表。</li>
<li>虚电路的通信分为三个阶段：虚电路建立（时间开销）、数据传输、虚电路释放（时间开销）。虚电路每个结点维持一张虚电路表，包括了接收链路和发送链路上的虚电路号、前一个后一个结点的标识。</li>
<li>虚电路不只是临时性的，它提供的服务包括永久性虚电路（PVC）和交换性虚电路（SVC）。前者是提前定义好的，基本不需要任何建立时间的端点之间的连接；而后者是端点之间的一种临时性的连接，这些连接只持续所需的时间，并且当会话结束时就取消这种连接。</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">数据报服务</th>
<th align="center">虚电路服务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">连接的建立</td>
<td align="center">不要</td>
<td align="center">必须有</td>
</tr>
<tr>
<td align="center">目的地址</td>
<td align="center">每个分组都有完整的目的地址</td>
<td align="center">仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号</td>
</tr>
<tr>
<td align="center">路由选择</td>
<td align="center">每个分组独立地进行路由选择和转发</td>
<td align="center">属于同一条虚电路的分组按照同一路由转发</td>
</tr>
<tr>
<td align="center">分组顺序</td>
<td align="center">不保证分组的有序到达</td>
<td align="center">保证分组的有序到达</td>
</tr>
<tr>
<td align="center">可靠性</td>
<td align="center">不保证可靠通信，可靠性由用户主机来保证</td>
<td align="center">可靠性由网络保证</td>
</tr>
<tr>
<td align="center">对网络故障的适应性</td>
<td align="center">出故障的结点丢失分组，其他分组路径选择发生变化，可正常传输</td>
<td align="center">所有经过故障结点的虚电路均不能正常工作</td>
</tr>
<tr>
<td align="center">差错处理和流量控制</td>
<td align="center">由用户主机进行流量控制，不保证数据报的可靠性</td>
<td align="center">可由分组交换网负责，也可由用户主机负责</td>
</tr>
</tbody></table>
<hr>
<h4 id="5-主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均在10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为：1600ms、801ms"><a href="#5-主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均在10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为：1600ms、801ms" class="headerlink" title="5. 主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均在10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为：1600ms、801ms"></a>5. 主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均在10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间分别为：1600ms、801ms</h4><ul>
<li>对于报文交换，在结点处一次全文发送耗时为800ms，因为中间经过一次转发，所以总耗时为1600ms；</li>
<li>对于分组交换，分组分成800份；每份在结点处发送一次耗时为1ms，虽然存在中间结点，但源结点的发送和中间结点的转发并行，所以经过800ms后，最后一个组从源结点发出，再经过1ms到达目标结点，所以总耗时为801ms。</li>
</ul>
<hr>
<h4 id="6-物理层传输介质"><a href="#6-物理层传输介质" class="headerlink" title="6. 物理层传输介质"></a>6. 物理层传输介质</h4><ul>
<li>导向传输介质：双绞线、同轴电缆、光纤。<ul>
<li>双绞线分为含金属丝屏蔽层的屏蔽双绞线（STP），无屏蔽层的非屏蔽双绞线（UTP）。双绞线的带宽取决于铜线的粗细和传输的距离。模拟传输和数字传输都可以使用双绞线。</li>
<li>同轴电缆因为有外导体屏蔽层，其抗干扰能力较好，被广泛应用于较高速率的数据（更高屏蔽性，抗噪性高）。分为50Ω的基带同轴电缆和75Ω的宽带同轴电缆，前者主要用在局域网，后者用在有线电视系统。利用一根同轴电缆互联主机构成以太网，主机间是以半双工的方式通信。</li>
<li>光纤的宽带范围极大。如果有多条不同入射角的光纤在一条光纤中传输，这种光纤成为多模光纤，多模光纤只适用于近距离传输。如果光纤的直径减小到只有一个光的波长，就不会产生多次反射，这种叫做单模光纤，衰耗较小，适合远距离传输。要求其光源是定向性很好的激光二极管。</li>
</ul>
</li>
<li>非导向传输介质：无线电波、微波、红外线、激光。<ul>
<li>无线电波具有较强的穿透能力，信号向所有方向散播，被应用于通信领域，如无线手机通信、无线局域网WLAN。</li>
<li>微波、红外线和激光都是沿直线传播，具有很强的方向性。</li>
<li>卫星通信就是利用同步卫星作为中继转发微波信号，优点是通信容量大、距离远、覆盖广，缺点是端到端的传播延迟时间较长，而且受气候影响大、保密性差、误码率较高等</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-物理层接口的特性"><a href="#7-物理层接口的特性" class="headerlink" title="7. 物理层接口的特性"></a>7. 物理层接口的特性</h4><ul>
<li>物理层要为数据链路层提供统一的服务，所以要尽可能屏蔽各种物理设备的差异，对于传输媒体的接口的特性进行相关的规定。</li>
<li>机械特性：物理连接点，即接插设备。规定规格、引脚数量等。</li>
<li>电气特定：规定电压高低、阻抗匹配、传输速率和距离限制等。</li>
<li>功能特性：规定某一电平的电压表示何意义，接口部件的信号线的用途。</li>
<li>规程特性：定义各条物理线路的工作规程和时序关系。</li>
</ul>
<h4 id="8-中继器和集线器"><a href="#8-中继器和集线器" class="headerlink" title="8. 中继器和集线器"></a>8. 中继器和集线器</h4><ul>
<li>中继器，将从入口端进入的因噪声或其他原因造成失真和衰减的信号（数字信号，放大器处理的是模拟信号）进行信号再生，发送到出口端。中继器不能连接两个具有不同速率的局域网，中继器两端的网段一定是同一个协议（因为中继器没有存储转发功能）。中继器的个数遵守“5-4-3规则”：互相串联的中继器的个数不能超过4个，而且被4个中继器串联的5段通信介质中只有3个段可以挂接计算机，其余两个段只能用作扩展通信范围的链路段。</li>
<li>集线器。多端口的中继器，将输入的信号，整形放大后转发到其他所有处于工作状态的端口上（没有寻址功能）。主要应用在使用双绞线组建的共享网络中，是解决从服务器连接到桌面最经济的方案。只能够在半双工下工作，网络吞吐量受限。集线器在物理层上扩大了物理网络的覆盖范围，无法解决冲突域（第二层交换机可解决）与广播域（第三层交换机可解决）的问题，而且使冲突的概率更大了。</li>
<li>物理层设备还有转发器等</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义一个类加载器代码实现</title>
    <url>/2019/04/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="自定义一个类加载器代码实现"><a href="#自定义一个类加载器代码实现" class="headerlink" title="自定义一个类加载器代码实现"></a>自定义一个类加载器代码实现</h1><p>目标：</p>
<ul>
<li>自定义一个类加载器，对硬盘上的<code>某.class</code>文件进行加载。</li>
<li>代码验证此<code>某.class</code>文件是由那个类加载器完成加载的。</li>
<li>代码验证，通过 new 类加载的操作，能够实现热加载的功能。</li>
</ul>
<span id="more"></span>

<ol>
<li>首先写一个 <code>HelloWorld</code> 类，<code>javac</code> 拿到的 <code>.class</code>文件放入指定路径（自定义）中。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路径：/Users/lee/Desktop/gg/HelloWorld.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloWorld</span> &#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">&quot;starting...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">welcome</span>()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Hello lees&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>自定义一个类加载器，代码如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">defineNewClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">	 <span class="comment">// class 加载的默认路径</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Path</span> <span class="variable">DEFAULT_CLASS_DIR</span> <span class="operator">=</span> </span><br><span class="line">	Paths.get(<span class="string">&quot;/Users/lee/Desktop/gg&quot;</span>, <span class="string">&quot;classloader1&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Path classDir;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 三个重载的构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">defineNewClassLoader</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.classDir = DEFAULT_CLASS_DIR;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">defineNewClassLoader</span><span class="params">(String dir)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.classDir = Paths.get(dir);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">defineNewClassLoader</span><span class="params">(String dir, ClassLoader parent)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(parent);</span><br><span class="line">		<span class="built_in">this</span>.classDir = Paths.get(dir);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重写 findClass 方法，将 class 文件转换成字节数组，</span></span><br><span class="line">	<span class="comment">// 然后调用父类的 defineClass 方法。</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="type">byte</span>[] classBytes = <span class="built_in">this</span>.readClassBytes(name);</span><br><span class="line">		<span class="keyword">if</span> (<span class="literal">null</span> == classBytes || classBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;can not load the class: &quot;</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.defineClass(name, classBytes, <span class="number">0</span>, classBytes.length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 转换成字节数组的方法</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">byte</span>[] readClassBytes(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="comment">// 将包名分隔符转换成文件路径分隔符</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">		<span class="type">Path</span> <span class="variable">classFullPath</span> <span class="operator">=</span> classDir.resolve(Paths.get(classPath + <span class="string">&quot;.class&quot;</span>));</span><br><span class="line">		<span class="keyword">if</span> (!classFullPath.toFile().exists()) &#123;</span><br><span class="line">			<span class="comment">// path下不存在该文件</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;The class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">			Files.copy(classFullPath, baos); <span class="comment">// 字节迁移，bytes 从 File 移动到 stream</span></span><br><span class="line">			<span class="keyword">return</span> baos.toByteArray(); <span class="comment">//stream 转字节数组</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;load the class &quot;</span> + name + <span class="string">&quot; occur error.&quot;</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;My classLoader&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后写一个测试类：</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> MyClassLoaderTest &#123;</span><br><span class="line">	public static void main(String<span class="literal">[]</span> args) throws ClassNotFoundException,</span><br><span class="line">			IllegalAccessException,</span><br><span class="line">			InstantiationException,</span><br><span class="line">			NoSuchMethodException,</span><br><span class="line">			InvocationTargetException &#123;</span><br><span class="line">		<span class="comment">// new 出自定义的类加载器，拿到 Class&lt;?&gt; clazz 对象</span></span><br><span class="line">		defineNewClassLoader myClassLoader = <span class="keyword">new</span> define<span class="constructor">NewClassLoader()</span>;</span><br><span class="line">		Class&lt;?&gt; clazz = myClassLoader.load<span class="constructor">Class(<span class="string">&quot;org.written.program.多线程.HelloWorld&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将所需类加载打印到 console</span></span><br><span class="line">		print<span class="constructor">ClassLoader(<span class="params">myClassLoader</span>,<span class="params">clazz</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 执行 Method</span></span><br><span class="line">		execute<span class="constructor">Method(<span class="params">clazz</span>)</span>;</span><br><span class="line"></span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;=====================&quot;</span>);</span><br><span class="line">		<span class="comment">// 二次加载，查看打印效果</span></span><br><span class="line">		defineNewClassLoader myClassLoader2 = <span class="keyword">new</span> define<span class="constructor">NewClassLoader()</span>;</span><br><span class="line">		Class&lt;?&gt; clazz2 = myClassLoader2.load<span class="constructor">Class(<span class="string">&quot;org.written.program.多线程.HelloWorld&quot;</span>)</span>;</span><br><span class="line">		print<span class="constructor">ClassLoader(<span class="params">myClassLoader2</span>,<span class="params">clazz2</span>)</span>;</span><br><span class="line">		execute<span class="constructor">Method(<span class="params">clazz2</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static void print<span class="constructor">ClassLoader(<span class="params">defineNewClassLoader</span> <span class="params">classLoader</span>,Class&lt;?&gt; <span class="params">clazz</span>)</span> &#123;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;自定义 cl 的 cl 是：&quot;</span> + classLoader.get<span class="constructor">Class()</span>.get<span class="constructor">ClassLoader()</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;待处理的 clazz 的 cl 是：&quot;</span> + clazz.get<span class="constructor">ClassLoader()</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Test类的 cl 是：&quot;</span> + <span class="module-access"><span class="module"><span class="identifier">MyClassLoaderTest</span>.</span></span><span class="keyword">class</span>.get<span class="constructor">ClassLoader()</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> static void execute<span class="constructor">Method(Class&lt;?&gt; <span class="params">clazz</span>)</span> throws IllegalAccessException,</span><br><span class="line">			InstantiationException,</span><br><span class="line">			NoSuchMethodException,</span><br><span class="line">			InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">		Object helloWorld = clazz.<span class="keyword">new</span><span class="constructor">Instance()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(helloWorld);</span><br><span class="line">		Method welcomeMethod = clazz.get<span class="constructor">Method(<span class="string">&quot;welcome&quot;</span>)</span>;</span><br><span class="line">		String result = (String) welcomeMethod.invoke(helloWorld);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>console 输出结果为：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">自定义 cl 的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">待处理的 clazz 的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">Test类的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">starting...</span><br><span class="line">org.written.program.多线程.HelloWorld<span class="symbol">@34a245ab</span></span><br><span class="line">result:Hello lees</span><br><span class="line">=====================</span><br><span class="line">自定义 cl 的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">待处理的 clazz 的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">Test类的 cl 是：sun.misc.Launcher$AppClassLoader<span class="symbol">@18b4aac2</span></span><br><span class="line">org.written.program.多线程.HelloWorld<span class="symbol">@6e8cf4c6</span></span><br><span class="line">result:Hello lees</span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> <span class="keyword">exit</span> code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>若<code>executeMethod </code>方法被注释，那么 HelloWorld 类的静态代码块将不会被执行（仅完成加载，未进入初始化过程），即 <code>starting</code>不会被打印出来。</li>
<li>做了两次 new MyCL 的操作，发现它们的类加载器没变过，但是得到的 Class 类完全不同。说明，同一份<code>.class</code>文件，同样的全限定名称，MyCL不同时，也会加载两种类文件，实现了热加载的功能。</li>
</ul>
<p>整体流程如图：</p>
<p><img src="/2019/04/04/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/1.jpg"></p>
<p>分析：不管是 Test 主类、自定义类加载器类还是待处理的.class文件，这里都是通过 APPClassLoader 进行加载的，通过上边的 console 输出也能证明这一点。<br>我们定义的加载器，是作为初始类加载器使用的，真正发挥作用的还是 AppClassLoader。</p>
<p>参考文章：《Java 高并发编程详解》第10章164页</p>
]]></content>
      <categories>
        <category>submission</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第五章</title>
    <url>/2018/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机网络——传输层"><a href="#计算机网络——传输层" class="headerlink" title="计算机网络——传输层"></a>计算机网络——传输层</h1><ul>
<li>定位：传输层属于通信部分的最高层，也是用户功能中的最底层；</li>
<li>只有主机的协议栈才有传输层与应用层，路由器在分组&#x2F;转发时只用到了下三层的功能。</li>
</ul>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>提供应用进程之间的<strong>逻辑通信</strong>（端到端的通信，事实上并无直连）。即使网络层是不可靠的，但传输层同样可以为应用程序提供可靠地服务。</li>
<li>传输层用的复用和分用：<ul>
<li>复用：发送方的不同进程使用同一个传输层协议；</li>
<li>分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用程序。</li>
</ul>
</li>
<li>传输层可以对收到的报文进行差错检验（首部和数据部分），而网络层只检查IP数据报的首部。</li>
<li>可以同时提供两种传输协议，面向了连接的TCP和无连接的UDP。网络层只提供面向连接的服务（如虚电路）与无连接服务（数据报）的其中一种（不能同时存在）。</li>
</ol>
<span id="more"></span>

<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><ul>
<li>主机中应用进程的标识，但只适用于本计算机中。</li>
<li>作用：能够让应用层的各应用进程将数据通过端口向下交付，让传输层知道应当将报文段的数据向上交付给进程。</li>
<li>端口号，长度16bit，65536个（即2^16）。分为两类，服务端使用和客户端使用的两类：<ul>
<li>服务端使用的端口号，又可分为两类，熟知端口号和登记端口号：<ul>
<li>熟知端口号：0~1023，指派给TCP&#x2F;IP最重要的一些应用程序；</li>
<li>登记端口号：1024~49151，指派给没有熟知端口号的应用程序，需要在IANA上登记，以免重复</li>
</ul>
</li>
<li>客户端使用的端口号，49152~65535，仅在客户进程运行时临时分配，通信结束，端口号就不复存在了。</li>
</ul>
</li>
<li>套接字：即socket，是主机IP地址和端口号的组合。唯一标识了网络中的一个主机和其上的某一个应用（进程）。</li>
</ul>
<h3 id="无连接服务和面向连接服务"><a href="#无连接服务和面向连接服务" class="headerlink" title="无连接服务和面向连接服务"></a>无连接服务和面向连接服务</h3><ul>
<li>采用TCP时，传输层向上提供一条全双工的可靠逻辑信道，而采用UDP时，是一条不可靠的逻辑信道。</li>
<li>TCP不提供广播或组播服务，应用在FTP、HTTP、TELNET等场合。</li>
<li>UDP仅提供两个附加服务：多路复用和对数据的错误检查。应用在DNS、SNMP、RTP、TFTP等。</li>
</ul>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul>
<li>UDP的优点：<ul>
<li>无需建立连接。更快。</li>
<li>无连接状态，TCP需要维护的连接状态包括接收和发送缓存、拥塞控制和序号与确认号的参数；UDP不需要跟踪这些参数，因此在某些专用服务器上，能够支持更多的活动客户机。</li>
<li>分组首部开销小，首部仅8B，而TCP有20B。</li>
<li>应用层能够更好的控制发送的数据和发送时间。UDP没有拥塞控制，主机可以无视网络拥塞情况进行发送。某些不允许较大时延的应用会倾向于使用UDP。</li>
</ul>
</li>
<li>UDP是不可靠服务，但维护可靠性的工作必须要做，而且是由应用层来完成，应用实体可以根据应用的需求来灵活设计自己的可靠性机制。</li>
<li>[重点]UDP是面向报文的，发送方拿到应用层下放的报文，添加首部后直接下放到IP层（不合不拆）；接收方反过程。特点：一次交付<strong>一个完整</strong>的报文，因此UDP的报文不可分割。</li>
</ul>
<h3 id="UDP数据报格式"><a href="#UDP数据报格式" class="headerlink" title="UDP数据报格式"></a>UDP数据报格式</h3><ul>
<li>UDP数据报&#x3D;首部（8B）+数据（可以没有）</li>
<li>首部&#x3D;源端口号（如果不需要对方回信，写全0）+目的端口号+UDP长度（包括首部和数据）+UDP检验和（如果不需要检验，写全0），各2B</li>
<li>场景：如果接收方发现目的端口号无法对应出进程，会丢弃该报文，并由ICMP发送“端口不可达”差错报文给对方。</li>
</ul>
<h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h3><ul>
<li>采用二进制反码运算求和再取反的办法。</li>
<li>针对首部和数据部分。</li>
<li>UDP校验需要将IP伪首部、UDP首部、UDP数据分为16位的字（若干个16bit，如果总长度为奇数个字节，则在最后添加一个全为0的字节），然后进行二进制反码求和校验。</li>
<li>二进制反码求和：从低位到高位逐列进行求和（正常进位，如果最高位有进位，则最终结果加1），最终的结果取反码，就可以写入校验和字段中了。先相加后取反和先取反后相加，结果一样</li>
<li>IP伪首部&#x3D;源IP地址（4B）+目的IP地址（4B）+ 协议号（2B）+UDP长度（2B）。</li>
<li>[理解]伪首部是从数据报所在IP分组头中提取的，仅仅用来计算校验和。</li>
</ul>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul>
<li>特点：<ul>
<li>面向连接；</li>
<li>只能一对一；</li>
<li>提供可靠地交付服务，保证数据无差错、不丢失、不重复且有序；</li>
<li>提供全双工通信，允许双方在任何时候发送数据，为此TCP连接的两端都设有发送缓存和接收缓存。</li>
<li>发送缓存用来暂时存放的数据有：<ul>
<li>准备发送的数据；</li>
<li>已发送但未收到确认的数据；</li>
</ul>
</li>
<li>接受缓存用来暂存的数据有：<ul>
<li>按序到达，但未被接收应用程序读取的数据；</li>
<li>不按序达到的数据；</li>
</ul>
</li>
<li>面向字节流，TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。（对比报文流，报文流有边界）</li>
</ul>
</li>
</ul>
<h3 id="TCP首部"><a href="#TCP首部" class="headerlink" title="TCP首部"></a>TCP首部</h3><ul>
<li>TCP报文段&#x3D;TCP首部+数据</li>
</ul>
<p><img src="/2018/09/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E4%BA%94%E7%AB%A0/1.png" alt="TCP"></p>
<ul>
<li>TCP首部&#x3D;<ul>
<li>源端口（2B）</li>
<li>目的端口（2B）</li>
<li>序号（4B，标识在这个报文段中的第一个数据字节）</li>
<li>确认号（4B，上次成功收到的数据字节序号+1，即期望对方发送的字节序号）</li>
<li>数据偏移（首部长度，4bit，用来定位到本报的数据区）</li>
<li>保留字段（6bit，暂无用途，设全0）</li>
<li>紧急位URG（URG&#x3D;1时紧急指针有效）</li>
<li>确认位ACK（ACK&#x3D;1时确认序号才有效，交互时ACK一般都是1）</li>
<li>推送位PSH（强制刷出缓存，交付到上层）</li>
<li>复位位RST（重大故障，释放连接后重建连接）</li>
<li>同步位SYN（SYN&#x3D;1时，说明这是一个连接请求或连接接收报文）</li>
<li>终止位FIN（FIN&#x3D;1时，要求释放传输连接）</li>
<li>窗口字段（2B）（指明允许对方发送的数据量，高速对方发送量不能超过本方缓存空间）</li>
<li>检验和（2B）（与UDP的类似，只是协议号从17改成6）</li>
<li>紧急指针字段（16bit）（指明本报文中紧急数据共有多少字节，其中紧急数据在数据区的最前端）</li>
<li>选项字段（可变长，含MSS（最大报文段长度，即数据字段的最大长度，默认536B））</li>
<li>填充字段（把整个首部长度凑成4字节的整数倍）</li>
</ul>
</li>
</ul>
<h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><ul>
<li>TCP连接三阶段：连接建立、数据传送、连接释放。</li>
<li>解决问题：<ul>
<li>每一方都能确知对方存在；</li>
<li>双方协商一些参数，如最大窗口值，是否使用窗口扩大协议，时间戳选项，服务质量等；</li>
<li>对运输实体资源进行分配（如缓存大小、连接表中的项目）</li>
</ul>
</li>
<li>采用客户&#x2F;服务器方式，主动发起建立连接的进程叫做客户机。</li>
</ul>
<h4 id="三次握手和四次挥手"><a href="#三次握手和四次挥手" class="headerlink" title="三次握手和四次挥手"></a>三次握手和四次挥手</h4><ul>
<li>推荐阅读：<a href="https://www.jianshu.com/p/9968b16b607e">图解TCP协议中的三次握手和四次挥手</a></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>三次握手</span><br><span class="line">client:SYN=<span class="number">1</span>,seq=x; <span class="regexp">//</span>我是x，请求连接</span><br><span class="line"></span><br><span class="line">server:SYN=<span class="number">1</span>,ACK=<span class="number">1</span>,seq=y,ack=x+<span class="number">1</span>; <span class="regexp">//</span>收到，我是y，请让x+<span class="number">1</span>过来</span><br><span class="line"><span class="regexp">//</span>（server内心os：client的发送功能完好，自己接收功能完好）</span><br><span class="line"><span class="regexp">//</span>此时server会为该TCP链接分配TCP缓存和变量</span><br><span class="line"></span><br><span class="line">client:ACK=<span class="number">1</span>,seq=x+<span class="number">1</span>,ack=y+<span class="number">1</span>;<span class="regexp">//</span>收到，我是x+<span class="number">1</span>，请让y+<span class="number">1</span>过来</span><br><span class="line"><span class="regexp">//</span>（client内心os：client的发送接收功能完好，server发送接收功能完好，这事要告诉server）</span><br><span class="line"><span class="regexp">//</span>此时x+<span class="number">1</span>已经可以携带部分数据了</span><br><span class="line"><span class="regexp">//</span>此时client会为该TCP链接分配TCP缓存和变量</span><br><span class="line"><span class="regexp">//</span>以上几次交互会消耗掉序号（即x/y之类）</span><br></pre></td></tr></table></figure>
<ul>
<li>服务器端的资源是在第二次握手时分配的，使得它容易受到SYN洪泛攻击。</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>四次挥手</span><br><span class="line">client:FIN=<span class="number">1</span>,seq=u;<span class="regexp">//</span> 我是u，给server的数据传完了，我打算关连接了；</span><br><span class="line"></span><br><span class="line">server:ACK=<span class="number">1</span>,seq=v,ack=u+<span class="number">1</span>;<span class="regexp">//</span> 收到，我是v，请让u+<span class="number">1</span>过来</span><br><span class="line"><span class="regexp">//</span>此时client到server不再有数据传输，TCP处于半关闭状态</span><br><span class="line"></span><br><span class="line">server:FIN=<span class="number">1</span>,ACK=<span class="number">1</span>,seq=w,ack=u+<span class="number">1</span>;<span class="regexp">//</span> 收到，我是w，给client的数据传完了，我打算关连接了，请让u+<span class="number">1</span>过来</span><br><span class="line"></span><br><span class="line">client:ACK=<span class="number">1</span>,seq=u+<span class="number">1</span>,ack=w+<span class="number">1</span>;<span class="regexp">//</span> 收到，我是u+<span class="number">1</span>，下次让w+<span class="number">1</span>过来</span><br><span class="line"><span class="regexp">//</span>此时TCP连接尚未释放掉，需要等待计时器<span class="number">2</span>MSL后，连接才关闭</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>等待2MSL的原因：保证client发送的最后一个确认报文段能够达到server，如果不等，若此报文丢失，那么server将无法正常关闭，而且因为client的提前关闭，将无法重传。</li>
</ul>
<h4 id="TCP可靠连接的保证"><a href="#TCP可靠连接的保证" class="headerlink" title="TCP可靠连接的保证"></a>TCP可靠连接的保证</h4><ul>
<li>采用了校验、序号、确认、重传等机制。<ul>
<li>校验：方法同UDP，此处不赘述</li>
<li>序号：使用报文段的序号字段，标识字节流的顺序。</li>
<li>确认：使用报文段的确认字段，并使用累计确认的机制（举例：确认号12，意思是0~11我都确认没有问题，12有问题）。累计确认有后退重传N帧（GBN）的风格，但是，收到正确却失序的报文不会被丢弃，而是缓存起来，GBN会要求重传失序后的所有帧。</li>
<li>重传，出现超时和冗余ACK时会进行重传。<ul>
<li>超时，每发送一个报文段，会对该报文段设置计时器，如果计时器设置的重传时间到期但还没有收到确认，就要重传这一报文段。注：重传时间RTO采用自适应算法，参考往返时间RTT来进行校核（重传时间略大于RTT）。新RTT&#x3D;（1-a)×旧RTT+a×新RTT样本，a初始设为0.125；RTO&#x3D;RTT+4×RTTD，RTTD为RTT的偏差的加权平均值。</li>
<li>冗余ACK，比如发送方A发了1，2，3，4，5的TCP报文段，2丢了；因此3，4，5对于接收方B而言就是失序报文段，不是B所期望的下一个字节序号，此时B会发送一个2的冗余ACK（B收到3，4，5，均发送一个2的冗余ACK，TCP规定的：非期望，发冗余ACK）；之后A收到3个关于2的冗余ACK，会立即重传2号报文段（TCP规定3次相同的冗余ACK会立即触发重传，不用等待超时），即快速重传。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><ul>
<li>类似数据链路层的滑动窗口控制，区别在于是端到端的，而且窗口大小可以协调改变（数据链路层的窗口大小不能动态改变）</li>
<li>目的：消除发送方使接收方缓存区溢出的可能性。</li>
<li>rwnd和cwnd：	<ul>
<li>接收方在向发送方传递的消息首部中，设置窗口字段值，限制发送窗口的大小，这里的值称为“接收窗口rwnd”。</li>
<li>发送方根据自己对当前网络拥塞程序的估计而确定的窗口值，称为“拥塞窗口cwnd”</li>
<li>发送方的发送窗口的实际大小是rwnd和cwnd中的较小者。但一般情况下，接收方总是有足够大的缓存空间，所以主要看cwnd，即网络拥塞程度。</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制之慢开始-amp-拥塞避免"><a href="#TCP拥塞控制之慢开始-amp-拥塞避免" class="headerlink" title="TCP拥塞控制之慢开始&amp;拥塞避免"></a>TCP拥塞控制之慢开始&amp;拥塞避免</h4><ul>
<li>推荐阅读：<a href="https://blog.csdn.net/jtracydy/article/details/52366461">TCP拥塞控制-慢启动、拥塞避免、快重传、快启动</a></li>
<li>流程略，参考上文博客，下面谈谈理解：<ul>
<li>设定一个ssthresh作为慢开始转拥塞避免的转折点；</li>
<li>令cwnd&#x3D;1，然后逐步翻倍，大于或等于cwnd时，转换成拥塞避免方式（此方式下cwnd加一递增，慢）；</li>
<li>若出现超时现象，ssthresh变为当前cwnd的一半，而cwnd从1开始慢启动方式；</li>
<li>注意：若在翻倍过程中cwnd超过ssthresh，那么cwnd取ssthresh值。</li>
</ul>
</li>
</ul>
<h4 id="TCP拥塞控制之快重传-amp-快恢复"><a href="#TCP拥塞控制之快重传-amp-快恢复" class="headerlink" title="TCP拥塞控制之快重传&amp;快恢复"></a>TCP拥塞控制之快重传&amp;快恢复</h4><ul>
<li>使用冗余ACK来进行网络拥塞的检测。在超时机制的基础上引入冗余ACK，能够更早响应报文丢失的情况。</li>
<li>当发送端连续收到三个冗余ACK时，就执行ssthresh腰斩的过程，此时cwnd也会相应的变成与新的ssthresh一致的值（在慢开始中，ssthresh要找后，cwnd会从1开始），因此叫做快恢复。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第六章</title>
    <url>/2018/09/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机网络——应用层"><a href="#计算机网络——应用层" class="headerlink" title="计算机网络——应用层"></a>计算机网络——应用层</h1><h2 id="应用模型"><a href="#应用模型" class="headerlink" title="应用模型"></a>应用模型</h2><p>分为客户服务模型（Client&#x2F;Server,C&#x2F;S）和P2P模型两种</p>
<ul>
<li>C&#x2F;S模型是由主机提供服务，客户机请求服务。详细不解释。</li>
<li>P2P模型没有固定的客户和服务器的划分，每个结点既作为客户请求资源，又作为服务器提供资源。优点有：<ul>
<li>减轻了服务器的计算压力；</li>
<li>多个客户机可以直接共享文档（C&#x2F;S模式下各客户机无法直接通信）；</li>
<li>可扩展性好，传统服务器有响应和带宽的限制，因此只能接受一定数量的请求；</li>
<li>网络健壮性好，单个结点的失效不会影响其他部分的结点。</li>
</ul>
</li>
<li>P2P模式的缺点：<ul>
<li>会占用较多的内存，影响整机的速度；</li>
<li>经常进行P2P下载，会对硬盘造成较大的损伤；</li>
<li>P2P程序会使网络变得非常拥塞，因此遭到各大互联网服务提供商ISP的嫌弃。</li>
</ul>
</li>
</ul>
<span id="more"></span>


<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>来自C&#x2F;S模型，运行在UDP之上，使用53端口。三个部分：层次域名空间、域名服务器和解析器</p>
<h3 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h3><p>域名规则：</p>
<ul>
<li>标号，比如以<code>www.baidu.com</code>就有三个标号；</li>
<li>com是顶级域名，baidu是二级域名，www是三级域名；<ul>
<li>顶级域名分为三类：国家顶级域名（.cn、.us等）；通用顶级域名（.com、.net等）；基础结构域名（只有arpa，用于反向域名解析）</li>
</ul>
</li>
<li>标号中的英文不区分大小写；</li>
<li>标号中出连字符<code>-</code>外，不能使用其他标点符号；</li>
<li>每一个标号不能超过63个字符，完整域名不能超过255个字符；</li>
</ul>
<h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><ul>
<li>域名系统被设计成一个联机分布式的数据库系统，采用C&#x2F;S模型。</li>
<li>每一个域名服务器不但能保存<strong>一些</strong>域名到IP地址的解析，还必须具有连向其他域名服务器的信息。没有一台服务器具有因特网上所有主机的映射。域名服务器主要有四种类型：<ul>
<li>根域名服务器：全球共13个，取名从’A’到’M’，1个主根在美国，另外12个辅根中9个在美国，1个在英国，1个在瑞典，1个在日本。作用：用来管理顶级域名。并不提供直接转换成IP地址的功能。</li>
<li>顶级域名服务器：负责管理在该服务器注册的所有二级域名，可以给出应答，或下一步应当查找的域名服务器的IP地址。</li>
<li>授权域名服务器（权限域名服务器）：每一个主机都必须在授权域名服务器处登记。我也不晓得这个是啥，网上搜不到？</li>
<li>本地域名服务器：比如一个大学、一个系都能拥有一个本地域名服务器。</li>
</ul>
</li>
</ul>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul>
<li>域名 -&gt; IP地址为正向解析；IP地址 -&gt; 域名为反向解析。</li>
<li>两种解析方式，递归查询和递归与迭代结合查询，字面理解。前者给根域名服务器造成负载太大，几乎不采用。</li>
<li>本地域名服务器会将查询到的结果保存到本地缓存，方便下次查询。高速缓存在域名服务器中广泛被采用。</li>
</ul>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP提供的功能：</p>
<ul>
<li>不同种类的主机系统之间的文件传输；</li>
<li>以用户权限管理的方式提供用户对远程FTP上的文件的管理；</li>
<li>以匿名FTP的方式提供公用文件共享的管理。</li>
</ul>
<p>采用C&#x2F;S模型，使用TCP可靠传输。一个FTP服务器可以为多个客户进程提供服务。FTP的服务器进程分为<strong>两个部分</strong>：负责<strong>接收新请求</strong>的主进程（端口21），负责<strong>处理单个请求&#x2F;数据连接</strong>的若干个从属进程（端口20）。</p>
<ul>
<li>控制连接：只用来传输控制信息（如连接请求、传送请求等），以7位ASCII格式，在整个会话期间一直保持打开状态。</li>
<li>数据连接：服务器在收到文件传输请求后，创建数据传送进程和数据连接。在传送完毕后关闭数据连接并结束运行。</li>
<li>因为控制与数据传送分离，所以也称为带外传送。</li>
</ul>
<h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><ul>
<li><p>流程：</p>
<ol>
<li>发件人通过用户代理（UA，比如Foxmail），向发送方邮件服务器发送邮件（使用SMTP协议，push）；</li>
<li>发送方邮件服务器将邮件放入邮件缓存队列中，等待发送；</li>
<li>运行在发送方邮件服务器的SMTP客户进程，发现缓存中的待发送邮件后，向接收方邮件服务器的SMTP服务器进程发起建立TCP连接；</li>
<li>注：发送方邮件服务器的角色变动：收到UA发来的邮件时作为服务器方；向远程接收方发送邮件时作为客户方；</li>
<li>TCP连接建立后，SMTP客户进程开始向远程的SMTP服务器进程发送邮件（使用SMTP协议，push）。当所有的待发送邮件完成发送后，SMTP就关闭了该TCP连接；</li>
<li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱中，等待收信人在方便时进行读取；</li>
<li>收信人在打算收信时，调用自己的UA，取出邮件（使用POP3协议，pull）。</li>
</ol>
</li>
<li><p>邮件格式：邮件&#x3D;信封+内容（&#x3D;首部+主体）；</p>
<ul>
<li>必填字段：“To:”指明若干个收件人的电邮地址；“From:”指明发件人，该部分通常由UA填写。</li>
<li>可选字段：“Subject:”指明邮件主体；等等。</li>
</ul>
</li>
<li><p>MIME。推荐阅读：<a href="http://likehui.fun/2018/06/02/notes-for-HeadFirstServletsAndJsp4/">setContenttype()常用的内容类型</a></p>
<ul>
<li>传统的，不采用MIME的邮件，一般只能传送一定长度的ASCII码，对某些编码、格式支持的不好；</li>
<li>MIME拓展了SMTP协议的功能，特点：定位了许多邮件内容的格式；标准化了多媒体表示方式；定义了传送编码；定义了5个新首部（MIME版本、内容描述、内容标识、内容传送编码、内容类型）</li>
</ul>
</li>
</ul>
<h3 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h3><p>使用TCP连接，端口25<br>流程：</p>
<ol>
<li>背景：邮件已经抵达发送方邮件服务器的邮件缓存中了。</li>
<li>SMTP客户每隔一定时间对邮件缓存扫描一次，发现邮件，就利用端口25对接收方邮件服务器的SMTP服务器建立TCP连接。</li>
<li>连接建立后，接收方SMTP发出“220 Service ready”（服务就绪）。然后SMTP客户向SMTP服务器发送HELO命令（附上发送方的主机号，告知用户身份）。</li>
<li>SMTP不使用中间的邮件服务器，是通过TCP直接连接两端。</li>
<li>连接建立后发送邮件，发送过程如下：</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>连接建立后发送邮件的交互</span><br><span class="line">client:MAIL FROM：&lt;**@zju.edu.cn&gt;; <span class="regexp">//</span>MAIL命令开始，并告知发件人地址</span><br><span class="line">server:<span class="number">250</span> OK; <span class="regexp">//</span>准备好了</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(client: RCPT TO:&lt;收件人地址&gt; )</span><br><span class="line">	server: <span class="string">&quot;250 OK&quot;</span> or <span class="string">&quot;550 No such user here&quot;</span> <span class="regexp">//</span>每一个RCPT，都有一次交互</span><br><span class="line"><span class="regexp">//</span>弄清楚接收方是否已做好接受邮件的准备</span><br><span class="line"></span><br><span class="line">client:DATA+邮件正式内容; <span class="regexp">//</span>DATA内容</span><br><span class="line">server:<span class="number">354</span> Start mail input:end with&lt;CRLF&gt;.&lt;CRLF&gt; <span class="regexp">//</span>告知结束方式</span><br><span class="line"></span><br><span class="line">client:QUIT; <span class="regexp">//</span>发送完毕</span><br><span class="line">server:<span class="number">221</span>; <span class="regexp">//</span>服务关闭</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h3><ul>
<li>使用C&#x2F;S模式，TCP协议，端口110。</li>
<li>两种工作方式：“下载并保留”和“下载并删除模式”，留和删的指邮件服务器上的邮件。</li>
<li>另一种使用趋势：使用Hotmail、Gmail等时，收发邮件使用HTTP协议，只有在不同邮件服务器之间传送邮件才使用SMTP协议。</li>
</ul>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><ul>
<li>HTTP是面向事务的应用层协议，有两类：请求报文和响应报文。</li>
<li>HTTP的无状态特性：同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。服务器从不会记忆来的是否是老客户，服务过多少次。在实际应用中，状态的记忆由Cookie来完成。</li>
<li>非持久连接，持久连接（HTTP&#x2F;1.1支持）<ul>
<li>非持久连接：每一个网页元素对象的传输都需要建立一个TCP连接。请求一个文档所需时间为：该文档的传输时间+double*RTT；</li>
<li>持久连接：建立连接后，可以继续使用该连接传送后续内容。又分为非流水线和流水线两种方式：<ul>
<li>非流水线：客户在收到前一个响应后才能发起下一个请求（类似回合制游戏？你砍一刀，我回一剑？）</li>
<li>流水线：允许持续发送请求。</li>
</ul>
</li>
</ul>
</li>
<li>报文结构，每个字段都是一些ASCII码串，每个字段长度不确定。<ul>
<li>请求报文：方法+URL+版本+首部行+请求主体（大致结构，不详述）</li>
<li>相应报文：版本+状态码+短语+首部行+响应主体</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第四章-1</title>
    <url>/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-1/</url>
    <content><![CDATA[<h1 id="计算机网络——网络层（1）"><a href="#计算机网络——网络层（1）" class="headerlink" title="计算机网络——网络层（1）"></a>计算机网络——网络层（1）</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><ol>
<li>异构网络互联：[理解]将多个不同的计算机网络连起来</li>
<li>路由与转发：</li>
<li>拥塞控制</li>
</ol>
<h3 id="异构网络互联"><a href="#异构网络互联" class="headerlink" title="异构网络互联"></a>异构网络互联</h3><ul>
<li><p>定义：两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（即中间设备）相互联结起来，以构成更大的网络系统。通常指用路由器进行网络互联和路由选择。</p>
</li>
<li><p>中间设备：按层次划分：</p>
<ul>
<li>物理层：中继器、集线器；</li>
<li>数据链路层：网桥、交换机；</li>
<li>网络层：路由器；</li>
<li>网络层以上：网关。</li>
<li>注：物理层和数据链路层的中间设备，连起来的网络还是同一个网络，未达到互联的目的。</li>
</ul>
</li>
<li><p>效果：用因为网络层都采用了标准化协议（即IP协议），虽然互联起来的各种物理网络的异构性本来是客观存在的，但是<strong>通过IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</strong>，这种使用IP协议的虚拟互联网络可简称为IP网络。</p>
</li>
<li><p>好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节（如具体的编址方案、路由选择协议等）</p>
</li>
</ul>
<span id="more"></span>


<h3 id="路由与转发"><a href="#路由与转发" class="headerlink" title="路由与转发"></a>路由与转发</h3><ul>
<li>路由选择与转发是路由器的两个功能。路由器的介绍可先看：<a href="http://likehui.fun/2018/07/29/Note-for-Computer-Network-6/">Note for Computer Network 6</a>。路由器的详细介绍参考本站博客：（暂未提供，本章最后几节）。</li>
<li>路由选择是根据特定的路由选择协议构造出的路由表，同时更新维护路由表（经常或定期与相邻路由器交换路由信息）。<ul>
<li>路由选择协议，大概就是：按照分布式算法，再根据从相邻路由器得到的有关整个网络拓扑的变化情况，动态的改变所选择的路由。</li>
</ul>
</li>
<li>转发即分组转发，根据转发表将用户的IP报从合适的端口转发出去。关键操作是：转发表查询、转发以及相关的队列管理和任务调度等。</li>
<li>转发表是从路由表得来的，两者的倾向不同，路由表需要对网络拓扑变化的计算最优化，转发表需要使查找过程最优化。有关路由选择的原理时，往往对二者不作区分，统一使用路由表这一名词。</li>
</ul>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li>拥塞：出现过量的分组而引起网络性能下降的现象。通俗理解：是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。</li>
<li>现象：观察到网络吞吐量随网络负载的增大，吞吐量明显下降，说明可能出现了网络拥塞。</li>
<li>拥塞控制要解决的主要问题：如何获取网络中发生的拥塞信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失以及严重拥塞产生的网络死锁的现象。</li>
<li>控制办法：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。有两种办法：<ul>
<li>开环控制。设计网络时事先将有关发生拥塞的因素考虑周到，力求不产生拥塞。是一种静态的预防方法，系统运行后不再需要修改。理解：无需对当前网络状况的反馈。</li>
<li>闭环控制。采用监控网络系统去监视，及时检测到哪里发生拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行。是基于反馈环路的概念，是一种动态的方法。</li>
</ul>
</li>
</ul>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>按照能否随网络的通信量或拓扑<strong>自适应地</strong>进行调整变化来划分，分为静态路由算法和动态路由算法两类。</p>
<h3 id="静态路由算法"><a href="#静态路由算法" class="headerlink" title="静态路由算法"></a>静态路由算法</h3><ul>
<li>由网络管理员手工配置路由信息系，当拓扑结构或链路发生变化时，需要网络管理员手工去修改路由表中相关的静态路由信息。</li>
<li>特点：<ul>
<li>简便、可靠，在负荷稳定、拓扑变化不大的网络中运行效果很好，广泛应用在高度安全性的军事系统和较小的商业网络。</li>
<li>大型和复杂的网络不宜采用静态路由。（网管难以全面了解整个网络拓扑结构，如果拓扑结果出现变化，需要大范围调整，工作难度和复杂程度高）。</li>
</ul>
</li>
</ul>
<h3 id="动态路由算法"><a href="#动态路由算法" class="headerlink" title="动态路由算法"></a>动态路由算法</h3><ul>
<li>路由表是通过相互联接的路由器彼此交换信息，然后按照一定的算法优化出来的。</li>
<li>特点：<ul>
<li>能够有效改善网络性能，利用流量控制</li>
<li>算法复杂，会增加网络负荷，应对动态变化时，反应过快引起振荡，反应过慢影响网络路由的一致性；所以算法要仔细设计</li>
</ul>
</li>
<li>常用动态路由算法有两类，距离-向量路由算法和链路状态路由算法：</li>
</ul>
<h4 id="距离-向量路由算法"><a href="#距离-向量路由算法" class="headerlink" title="距离-向量路由算法"></a>距离-向量路由算法</h4><ul>
<li>所有结点都定期地将他们的整个路由选择表（包括目的地即下一结点和距离，距离在<strong>RIP算法</strong>中也叫跳数）传送给相邻结点</li>
<li>最常见的就是RIP算法，推荐阅读：<a href="https://blog.csdn.net/lycb_gz/article/details/1612254">RIP路由协议及工作原理</a>，下文也有详细解释。</li>
<li>结点的路由表在以下场景发生更新：<ul>
<li>被通告一条新的路由，本结点的路由选择表中不存在，需要加入进来；</li>
<li>发来的信息中有一条到达某目的地的路由，比当前使用的路由代价更小，更新进来。</li>
</ul>
</li>
<li>算法实质：迭代计算一条路由中的站段数或延迟时间，得到到达一个目标的最短路径。</li>
<li>特点：更新报文的大小与通信子网的结点个数成正比，在通信子网上传送的路由选择信息的数量很容易变得非常大。</li>
<li>“好消息传得快，坏消息传的慢”，慢收敛是导致发生路由回路问题的根本原因。</li>
</ul>
<h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h4><ul>
<li>要求结点具有完全的网络拓扑信息</li>
<li>推荐阅读：<a href="https://blog.csdn.net/wangquannetwork/article/details/45315233">距离矢量与链路状态的区别</a>，精华如下：<ul>
<li>距离矢量算法中。① 会将所有路由信息跟<strong>直连邻居</strong>共享；② 使用Bellman-Ford算法，容易产生环路、无穷大的问题，需要配合防环机制，并且网络规模越大，收敛速度越慢；③ 更新的是“路由条目”；④ 协议发送周期性完整表更新；</li>
<li>链路状态算法中。① 将<strong>直连的链路状态</strong>跟域(domain)内&#x2F;区域(area)内的所有路由器共享；② 使用强健的OSPF算法（如dijkstra），不易产生环路，收敛速度快；③ 更新的是“拓扑”；④ 非周期性部分表更新。</li>
</ul>
</li>
<li>特点：链路状态只涉及相邻路由器的连通状态，与整个互联网的规模并无直接关系，可以用于大型或路由信息变化聚敛的互联网环境</li>
</ul>
<h3 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h3><ul>
<li>出于管理和扩展的目的，因特网可以被分割成许多不同的自治系统（Autonomous System，AS）。换句话说，因特网是由自治系统汇集而成的。</li>
<li>现在的自治系统被扩展的定义为：共享同一路由选择策略的一组路由器。</li>
<li>IGP（Interior gateway protocols）——<strong>内部网关协议</strong>，定义为在一个自治系统内部使用的路由协议（包括动态路由协议和静态路由）。<ul>
<li>IGP的功能是完成数据包在AS内部的路由选择，或者说，是讲述数据包如何穿过本地AS的。</li>
<li>RIPv1&amp;v2，IGRP，EIGRP，OSPF，ISIS都是典型的IGP。使用最多的有：RIP和OSPF协议。</li>
</ul>
</li>
<li>EGP（Exterior gateway protocols）——<strong>外部网关协议</strong>，定义为在多个自治系统之间使用的路由协议。<ul>
<li>它主要完成数据包在AS间的路由选择，或者说，讲述数据包为了到达目的IP，需要通过哪些AS。</li>
<li>BGP4是最常用的一种EGP。</li>
</ul>
<p>	</p>
</li>
<li>采用分层路由后，每个路由器知道如何将分组路由到自己所在区域的目标地址，但对于其他区域内结构毫不知情。</li>
<li>有关IGP和EGP的内容，参考下一篇博客内容</li>
</ul>
<h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4的转发分组"><a href="#IPv4的转发分组" class="headerlink" title="IPv4的转发分组"></a>IPv4的转发分组</h3><ul>
<li>推荐阅读：<a href="https://www.cnblogs.com/songdechiu/p/5338063.html">IPv4数据报格式</a></li>
</ul>
<p><img src="/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-1/1.png" alt="ipv4"></p>
<p><img src="/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-1/2.png" alt="ipv4长度"></p>
<ul>
<li><p>首部长度、总长度、片偏移，分别以4B、1B、8B为基本单位。</p>
</li>
<li><p>重要字段含义：</p>
<ul>
<li>总长度：要结合数据链路层的MTU值来定（以太网的MTU为1500字节）；</li>
<li>标识：占16位，用以分片和组装，各片的标识都一样；</li>
<li>标志：两个参数MF和DF。MF&#x3D;1表示后面还有分片，MF&#x3D;0表示最后一个分片；DF&#x3D;0表示允许分片。</li>
<li>片偏移：13位字段，表示分片在整个数据报（原始位置）中的相对位置。</li>
<li>生存时间TTL：为了确保分组不会永远在网络中循环，经过一次转发分组，TTL减一，但TTL为0时，丢弃该分组。</li>
<li>协议，8位字段。</li>
<li>源地址和目的地址字段都是4字节。</li>
</ul>
</li>
<li><p>以某例题举例：</p>
</li>
</ul>
<blockquote>
<p>IP分组的前40字节内容（十六进制） <br><br>45   00 00 30  01 9b 40 00  80 06 1d e8  c0 a8 00 08  d3 44 47   50 <br><br>0b   d9 13 88  84 6b 41 c5  00 00 00 00  70 02 43 80  5d b0 00   00</p>
</blockquote>
<ul>
<li><p><code>45 00</code>指版本4，首部长度5（5*4B&#x3D;20B），服务0；</p>
</li>
<li><p><code>00 30</code>指总长度48（48*1B&#x3D;48B），</p>
</li>
<li><p><code>01 9b</code>指标识019b，可以唯一指代某一数据报（分拆后的分组具有相同标识）</p>
</li>
<li><p><code>40 00</code>，转化为二级制：<code>01000000 00000000</code>，前3位是标志（指中间一位DF&#x3D;1，最后一位MF&#x3D;0），后13位是片偏移（指0）</p>
</li>
<li><p><code>80 06</code>，指生存时间128，协议6（指TCP）</p>
</li>
<li><p><code>1d e8</code>，指首部检验和，略去不管</p>
</li>
<li><p><code>c0 a8 00 08</code>，指源地址192.168.0.8</p>
</li>
<li><p><code>d3 44 47 50</code>，指目的地址211.68.71.80</p>
</li>
<li><p>第二行是数据部分，不管</p>
</li>
<li><p>网络层转发分组的流程：</p>
<ul>
<li>此路由器设为A。从数据报中提取目的主机的IP地址Z，得出目的网络地址为Net；</li>
<li>①若A与Net直连，可以直接交付给Z；</li>
<li>②若以上不满足，且A的路由表中有个路由B，B是目的主机Z指定的路由，交付给B；</li>
<li>③若以上不满足，且A的路由表中有一个路由C，C可以到达网络Net，交付给C；</li>
<li>④若以上不满足，且A的路由表有一个默认路由D，交付给D；</li>
<li>⑤若以上不满足，则报告转发分组出错。</li>
</ul>
</li>
</ul>
<h3 id="IPv4地址与NAT"><a href="#IPv4地址与NAT" class="headerlink" title="IPv4地址与NAT"></a>IPv4地址与NAT</h3><h4 id="IPv4-1"><a href="#IPv4-1" class="headerlink" title="IPv4"></a>IPv4</h4><ul>
<li><p>IPv4地址分为A、B、C、D、E五类。</p>
</li>
<li><p>A类（1-126）0开头；</p>
</li>
<li><p>B类（128~191）10开头；</p>
</li>
<li><p>C类（192~223）110开头；</p>
</li>
<li><p>D类（224~239）1110开头；</p>
</li>
<li><p>E类（240~255）1111开头；</p>
</li>
<li><p>全32位</p>
<ul>
<li>全0，表示本网络上的本主机；</li>
<li>全1，，表示整个TCP&#x2F;IP网络的广播地址，但实际上因为路由器对广播域的隔离，此时等效于本网络的广播地址；</li>
</ul>
</li>
<li><p>主机号：</p>
<ul>
<li>全0的表示本网络本身，全1表示本网络的广播地址（如果目的地址是广播地址，会认为消息是发往本网段所有主机的消息）</li>
<li>127.0.0.0网络保留作为环路自检地址；</li>
</ul>
</li>
<li><p>IP地址是分等级的地址结构；</p>
<ul>
<li>IP地址管理机构在分配IP地址时只分配网络号，，主机号由得到网络的单位自行分配；</li>
<li>路由器仅根据网络号来转发分组（不考虑目标主机号）；</li>
</ul>
</li>
<li><p>当一个主机同时连接到两个网络时，该主机必须同时具有两个相应的IP地址。因此一个路由器至少有两个IP地址（实际上，路由器每个端口至少一个IP地址）</p>
</li>
<li><p>用转发器或网桥连接起来的若干个局域网仍然是同一个网络。</p>
</li>
</ul>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><ul>
<li>网络地址转换（NAT）：通过将专用网络地址转换为公用地址，从而对外隐藏了内部管理的IP地址。</li>
<li>私有IP地址只用于LAN，不用于WAN。私有IP网段有：<ul>
<li>A：10.0.0.0~10.255.255.255</li>
<li>B：172.16.0.0~172.31.255.255</li>
<li>C：192.168.0.0~192.168.255.255</li>
</ul>
</li>
<li>使用网关路由器，开启NAT功能，对照着NAT转换表，将本地地址转换成全球地址。只需一个全球地址，就可以让多台主机同时访问因特网。</li>
<li>NAT看到了端口，所以工作在传输层。</li>
</ul>
<h3 id="子网划分、子网掩码、CIDR"><a href="#子网划分、子网掩码、CIDR" class="headerlink" title="子网划分、子网掩码、CIDR"></a>子网划分、子网掩码、CIDR</h3><h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><ul>
<li>两级IP地址的空间利用率低；</li>
<li>采用划分子网的方式，使两段IP地址变成为三级IP地址。实现办法：从主机号借用若干个比特作为子网号:IP地址&#x3D;{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}；</li>
<li>流程：传来的IP数据报，根据网络号，找到连接在本单位网络上路由器，然后此路由器再按照目的网络号和子网号找到目的子网 ，最后交付给目的主机。</li>
</ul>
<h4 id="无分类编址CIDR"><a href="#无分类编址CIDR" class="headerlink" title="无分类编址CIDR"></a>无分类编址CIDR</h4><ul>
<li>CIDR,Classless Inter-Domain Routing</li>
<li>使用斜线记法，将网络前缀都相同的连续IP地址组成CIDR地址块，一个地址块能够表示很多地址，这种地址的聚合称为路由聚合，或构成超网。</li>
<li>CIDR的优点：网络前缀灵活</li>
<li>具体说明参考 ：<a href="https://blog.csdn.net/dan15188387481/article/details/49873923">CIDR地址块及其子网划分（内含原始IP地址分类及其子网划分的介绍）</a></li>
<li>最长前缀匹配（最佳匹配）。路由表中的 每个项目由“网络前缀 ”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果，应当从匹配结果中选择具有最长网络前缀的路由，因为网络前缀越长，其地址块就越小，因此路由就越具体。</li>
<li>CIDR常用二叉线索的方式查找最长前缀匹配。</li>
</ul>
<h2 id="ARP协议、DHCP协议与ICMP协议"><a href="#ARP协议、DHCP协议与ICMP协议" class="headerlink" title="ARP协议、DHCP协议与ICMP协议"></a>ARP协议、DHCP协议与ICMP协议</h2><h3 id="IP地址与硬件地址"><a href="#IP地址与硬件地址" class="headerlink" title="IP地址与硬件地址"></a>IP地址与硬件地址</h3><ul>
<li>IP地址放在IP数据报的首部，MAC地址放在MAC帧的首部，所以数据链路层无法看到IP地址。</li>
<li>由于路由器的隔离，IP网络无法通过广播方式依靠MAC地址完成跨网络的寻址（可以理解为：在局域网的链路层，能够通过广播MAC地址的方式寻址），所以IP网络只能使用IP地址完成寻址。</li>
<li>在IP网络转发分组时，IP分组在每个网络都被路由器解封装和重新封装，使用的MAC地址也是不断改变的。</li>
</ul>
<h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><ul>
<li>ARP用来进行<strong>局域网</strong>内，从IP地址到MAC地址的映射。</li>
<li>每个主机都设有一个ARP高速缓存，存放ARP表（本局域网上各主机和路由器的IP地址到MAC地址的映射表），并使用ARP协议动态维护。</li>
<li>ARP工作在网络层。是普通的单播。</li>
<li>工作原理：<ol>
<li>主机A打算向本局域网的主机B发送IP数据报；</li>
<li>先查找ARP表中是否有B的IP地址，如果有，就能查出MAC地址，完成传输；</li>
<li>如果ARP表中没有，主机A发送MAC地址为FF-FF-FF-FF-FF-FF的帧广播ARP请求分组；</li>
<li>主机B收到该ARP请求后，会想主机A发送响应ARP，分组中包含B的IP与MAC地址映射关系 ；</li>
<li>A收到该映射关系后，写入A的ARP表中，然后按照查到的MAC地址，发送MAC帧。</li>
</ol>
</li>
</ul>
<h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><ul>
<li>用于给主机动态地分配IP地址，提供即插即用联网的机制，是应用层协议，基于UDP；</li>
<li>原理：使用客户&#x2F;服务器方式。	<ul>
<li>需要IP的主机向局域网中的DHCP服务器（可能不止一个，挑最快回复的那个）广播发送<strong>发现报文</strong>，该主机称为DHCP客户；广播发送全部主机，但只有DHCP服务器才能回答；</li>
<li>DHCP服务器现在数据库中查找该计算机的配置信息，若找到则返回找到的信息；若没有找到，则从服务器的IP地址池中取一个地址分配给原主机。回答的报文叫<strong>提供报文</strong> ；</li>
<li>客户机如果接受该提供报文的参数，会通过广播消息到DHCP服务器 ，请求提供IP地址；</li>
<li>DHCP服务器收到请求后，将IP地址分配给DHCP客户机</li>
</ul>
</li>
<li>tips：<ul>
<li>被动态分配的IP地址是临时的，有一段“租用期”；</li>
<li>应用层协议有两种工作方式：客户&#x2F;服务器方式和p2p方式，本例属于前者；</li>
<li>本协议基于UDP，因为不需要建立连接，而TCP协议需要先建立连接 ，但如果不知道对方IP地址，根本不可能建立套接字连接。</li>
</ul>
</li>
</ul>
<h3 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><ul>
<li>为了提高IP数据报交付成功的机会，<strong>网络层</strong>使用了ICMP来允许主机或路由器报告差错和异常情况。</li>
<li>ICMP是IP层协议。</li>
<li>ICMP有两种类型，ICMP差错报告报文和ICMP询问报文：<ul>
<li>ICMP差错报告报文，用在目标主机或沿途上的路由器向源主机发送差错 报告的情况，有五种类型：<ul>
<li>终点不可达：不能交付时</li>
<li>源点抑制：发生网络拥塞时</li>
<li>时间超过：TTL减为零，或终点发现超时</li>
<li>参数问题：字段有误时</li>
<li>改变路由：重定向时</li>
</ul>
</li>
<li>ICMP询问报文，有四种类型<ul>
<li>回送请求和回答报文（例PING）</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul>
</li>
</ul>
</li>
<li>ICMP最常见两个应用：PING和Traceroute&#x2F;tracert（跟踪分组经过的路由）</li>
<li>PING工作在应用层，直接使用网络层的ICMP协议；Traceroute&#x2F;tracert工作在网络层。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络第四章（2）</title>
    <url>/2018/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="计算机网络——网络层（2）"><a href="#计算机网络——网络层（2）" class="headerlink" title="计算机网络——网络层（2）"></a>计算机网络——网络层（2）</h1><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><ul>
<li>从根源上解决了IPv4地址耗尽的问题。</li>
<li>特点：<ul>
<li>IPv4的32位增大到了128位，共16字节</li>
<li>IPv6不允许分片，只有在包的源结点才能分片，是端到端的</li>
<li>扩展阅读：<a href="https://blog.csdn.net/dog250/article/details/8169953">闲谈IPv6-尴尬的IPv4</a>。大意是解析IPv4的痛点，精华部分理解：<ul>
<li>原本的arp协议其实是没有使用IP协议进行封包，导致每一种链路层都需要一个arp协议。使用IPv6后，arp的功能由ICMPv6来替代，是使用IP承载的；</li>
<li>IPv6自动完成：电脑接入网络后，网口按照规则生成一个链路本地地址，使用此地址和本链路的其他节点通信；</li>
<li>IPv6不再需要NAT；</li>
<li>原来IPv4的分类地址使美国占据大量A类地址，IPv6使得地区分布更加均匀；</li>
</ul>
</li>
</ul>
</li>
</ul>
<span id="more"></span>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">IPv4</th>
<th align="center">IPv6</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一链路的通信</td>
<td align="center">必须使用DHCP或者手工指定同一网段的IP地址</td>
<td align="center">可以直接使用自动配置的链路本地地址</td>
</tr>
<tr>
<td align="center">同一机构内通信</td>
<td align="center">人工配置IP地址，如果使用全局的公网地址，时刻注意着不能有地址冲突。</td>
<td align="center">使用本地唯一地址</td>
</tr>
<tr>
<td align="center">互联网通信</td>
<td align="center">需要在出口路由器或者防火墙上配置多条策略，防止私有地址的外泄。</td>
<td align="center">私有的链路本地地址和机构地址跑不出出口路由器</td>
</tr>
<tr>
<td align="center">关于私有地址</td>
<td align="center">针对ABC类的每一类地址都有一个私有段，私有段不连续。私有段和地址分类有交集，必须显式进行区分</td>
<td align="center">直接针对限域来规定是否私有，私有段连续。可以直接解析地址本身得到地址的限域</td>
</tr>
</tbody></table>
<h3 id="IPv6的地址结构"><a href="#IPv6的地址结构" class="headerlink" title="IPv6的地址结构"></a>IPv6的地址结构</h3><ul>
<li>推荐阅读：<a href="https://blog.csdn.net/u011784495/article/details/71693296">IPv6数据报头部格式</a></li>
<li>目的地址：<ul>
<li>单播：</li>
<li>多播：一个交给多个</li>
<li>任播：一个交给多个中的某一个</li>
</ul>
</li>
<li>地址表示法：（紧凑型）每4位用一个十六进制数表示，并且用冒号分隔，例，4B5F:AA12:0216:FEBC:BA5F:039A:BE9A:2170（8部分×4个×进制代表的4位&#x3D;128位）；以及为0时的::省略办法。</li>
<li>首部40B，地址长度16B</li>
<li>分级概念：<ul>
<li>顶级：指明全球都知道的公共拓扑；</li>
<li>二级：指明单个场点；</li>
<li>三级：指明单个的网络接口。</li>
</ul>
</li>
<li>IPv6要能够向后兼容；</li>
<li>两种协议的选择问题上，可以采用双协议栈和隧道技术两种策略：<ul>
<li>双协议栈：一部分主机或路由器装有两个协议栈，来回切换；</li>
<li>隧道技术：将整个IPv6数据报封装到IPv4数据报的数据部分，这样使得IPV6的数据报能载IPv4网络的隧道中传输。</li>
</ul>
</li>
</ul>
<h2 id="IGP、EGP"><a href="#IGP、EGP" class="headerlink" title="IGP、EGP"></a>IGP、EGP</h2><ul>
<li>有关概念可以参考上一篇博客：<a href="http://likehui.fun/2018/09/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0-1/#more">计算机网络——网络层（1）</a>的层次路由段。简单来说，IGP是域内的内部使用路由协议，主要有RIP协议和OSPF协议；EGP是域间使用的外部网关协议，如BGP-4等。</li>
</ul>
<h3 id="RIP路由信息协议"><a href="#RIP路由信息协议" class="headerlink" title="RIP路由信息协议"></a>RIP路由信息协议</h3><ul>
<li>RIP：Routing Information Protocol，是根据最少跳数进行路径选择的协议。使用距离向量路由算法。</li>
<li>规定：<ul>
<li>每个路由器都要维护它自己到其他每一个目的网络的距离记录（即跳数）；</li>
<li>RIP允许一条路径最多只能包含15跳，距离等于16时被视为不可达；</li>
<li>默认在任意两个使用RIP协议的路由器之间每30秒（固定时间间隔）广播一次RIP路由更新信息，以便自动建立并维护路由表（动态维护，仅发生在相邻路由器，而且交换的是全部信息）；</li>
<li>不支持子网掩码的RIP广播，所以每个网络的子网掩码必须相同。但在新的RIP2中，支持变长子网掩码和CIDR。</li>
</ul>
</li>
<li>一般，第一次广播后，每一路由器知道自己相邻路由器的路由表信息；第二次广播后，就知道了距离自己2跳的路由表信息；若干次后，在一个小型互联网中，所有路由器就知道了整个IP网络的路由表，称为RIP协议最终是收敛的。收敛之后，每个路由器到每个目标网络的路由都是距离最短的。</li>
<li>优点：实现简单，开销小，收敛过程快；</li>
<li>缺点：<ul>
<li>RIP限制了网络的规模；</li>
<li>路由器之间交换的是完整的路由表，因此网络规模越大，开销也越大；</li>
<li>当出现网络故障时，会出现慢收敛现象（即需要较长时间才能将此消息传送到所有路由器），称为“好消息传得快，坏消息传的慢”，使更新过程的收敛时间长。</li>
</ul>
</li>
<li>RIP是应用层协议，它在传输层使用UDP传送数据。</li>
</ul>
<h3 id="OSPF开放最短路径优先协议"><a href="#OSPF开放最短路径优先协议" class="headerlink" title="OSPF开放最短路径优先协议"></a>OSPF开放最短路径优先协议</h3><ul>
<li>使用分布式链路状态路由算法。</li>
<li>与RIP对比的区别：<ol>
<li>向<strong>所有路由器</strong>发送<strong>部分</strong>信息（只有本路由相邻的所有路由器的链路状态而已，并非整个路由表）；</li>
<li>只有当链路状态发生变化时，才会使用洪泛法发送消息，而RIP是定期发送；</li>
<li>OSPF是网络层协议，不使用UDP或TCP而是直接IP数据报发送。</li>
</ol>
</li>
<li>更多特点：<ol>
<li>可对于不同类型的业务灵活计算出不同的路由（根据IP分组的不同服务类型将链路设置为不同的代价）；</li>
<li>如果同一个目的网络有多条相同代价的路径，可使用<strong>负载均衡</strong>分配给这几条路径；</li>
<li>路由器之间交换的分组具有鉴别功能，可以保证只在可信赖的路由器之间交换信息；</li>
<li>支持可变长度的子网划分和CIDR；</li>
<li>每一个链路状态都带上一个32位的序号，序号越大，状态就越新；</li>
<li>30分钟刷新一次数据库中的链路状态。</li>
</ol>
</li>
<li>OSPF原理：交换链路状态信息后，建立一个全网的拓扑结构图，使用Dijkstra最短路径算法计算自己到各网络最短路径，以及构建自己的路由表。（路由表不会存储完整路径，只会存储下一跳去哪）。</li>
<li>OSPF应用在规模很大的网络时，会将一个自治系统划分为若干个更小的范围（区域），使用洪泛法时，交换信息的范围局限在区域内，而不是整个网络拓扑。这些区域也有层次之分，上层的叫主干区域，负责连通下层的区域和其他自治域。 连接主干区域和其他下层区域的路由器称为区域边界路由器。主干区域中的路由器都叫主干路由器。</li>
<li>OSPF的五种分组类型<ul>
<li>问候分组：检测可达性，通常10秒一次；</li>
<li>数据库描述分组：向邻站发送自己的链路状态数据库中的摘要信息；</li>
<li>链路状态请求分组：向对方请求某些链路的信息；</li>
<li>链路状态更新分组，使用洪泛法对全网更新链路状态；</li>
<li>链路状态确认分组：对链路更新分组的确认。</li>
</ul>
</li>
</ul>
<h3 id="BGP边界网关协议"><a href="#BGP边界网关协议" class="headerlink" title="BGP边界网关协议"></a>BGP边界网关协议</h3><ul>
<li>BGP，Border Gateway Protocol。是一种外部网关协议。</li>
<li>扩展阅读：<a href="https://blog.csdn.net/pgl608/article/details/80260725">BGP协议基本原理</a></li>
<li>BGP是自治系统外部路由协议，用来在AS之间传递路由信息；</li>
<li>路径矢量路由协议，从设计上避免了环路的发生；</li>
<li>支持CIDR和路由聚合；</li>
<li>只发送增量路由更新。在建立邻居关系后，路由器会将自己的全部路由信息告知邻居，此后如果路由表发生了变化，只将增量&#x2F;更新部分发送给邻居。</li>
<li>路由表包括：	<ul>
<li>已知路由器的列表；</li>
<li>路由器能够达到的地址</li>
<li>每个路由器的路径的跳数</li>
</ul>
</li>
<li>BGP是应用层协议，基于TCP的。</li>
<li>BGP发言者（BGP Speaker）：发送BGP消息的路由器称为BGP发言者，它接收或者产生新的路由信息，并发布给其他BGP发言者。</li>
<li>使用四种报文：<ol>
<li>打开报文：与相邻的发言人建立关系</li>
<li>更新报文：发送更新信息</li>
<li>保活报文：确认打开报文、周期性确认邻站关系</li>
<li>通知报文：用来发送检测到的错误</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">协议</th>
<th align="center">RIP</th>
<th align="center">OSPF</th>
<th align="center">BGP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类型</td>
<td align="center">内部</td>
<td align="center">内部</td>
<td align="center">外部</td>
</tr>
<tr>
<td align="center">路由算法</td>
<td align="center">距离-向量</td>
<td align="center">链路状态</td>
<td align="center">路径-向量</td>
</tr>
<tr>
<td align="center">传递协议</td>
<td align="center">UDP</td>
<td align="center">IP</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">路径选择</td>
<td align="center">跳数最少</td>
<td align="center">代价最低</td>
<td align="center">较好，非最佳</td>
</tr>
<tr>
<td align="center">交换结点</td>
<td align="center">和本结点相邻的路由器</td>
<td align="center">网络中的所有路由器</td>
<td align="center">和本结点相邻的路由器</td>
</tr>
<tr>
<td align="center">交换内容</td>
<td align="center">当前本路由器知道的全部信息</td>
<td align="center">与本路由器相邻的所有路由器的链路状态</td>
<td align="center">首次发整个路由表，非首次发有变化的部分</td>
</tr>
</tbody></table>
<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><ul>
<li>组播机制：让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干台目标主机，并被它们正确接收。是应用于UDP的（因为TCP是一对一的）。</li>
<li>流程：源主机把单个分组发送给一个组播地址（标识一组地址），网络将分组给该组播地址内每一台主机投递一份拷贝。</li>
<li>在IP组播中，组播地址在D类地址空间进行分配（IPv6中也有一部分地址空间交给了组播组）。</li>
<li>主机可以选择加入或离开一个组，一台主机可以属于多个组。主机使用IGMP（因特网组管理协议）的协议加入组播组。它们使用该协议通知在本地网络上的路由器关于要接收发送给某个组播组的分组的愿望。</li>
<li>IP组播地址：使用D类地址格式作为目的地址（不可作为组播组的源地址），每一个D类IP地址标志一个组播组。范围是224.0.0.0~239.255.255.255（并不是所有D类地址）。</li>
<li>对组播数据报不产生ICMP差错报文，因此ping不通。</li>
<li>IP组播分为两类，只在本局域网上进行硬件组播，在因特网范围内进行组播：<ul>
<li>在因特网上进行组播的最后阶段，仍要把组播数据报放在局域网上用硬件组播交付给组播组的所有成员。</li>
<li>IANA拥有的以太网组播地址范围是：01-00-5E-00-00-00到01-00-5E-7F-FF-FF。只有23位可作为组播。D类IP地址可供分配的也只有23位。1110+空5位+23位&#x3D;32位IP地址。举例：224.215.145.231映射到组播MAC地址： 01-00-5E-57-91-E6（后23位是87.145.231，转化为16进制就是57-91-E6）。</li>
</ul>
</li>
</ul>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><ul>
<li>移动IP技术：移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能，并保证了基于网络IP的网络权限在漫游过程中不发生任何改变。是为了满足移动结点在移动时保持连接性而设计的。举例：出差到外地，也能使用公司内网或者共享的资料。</li>
<li>移动IP技术使漫游的主机可以用多种方式连接到因特网，移动IP的核心网络功能仍然是基于在固定互联网中一直在使用的各种路由选择协议。移动IP技术不同于移动自组网络（此处不做延伸）。</li>
<li>关键技术：代理搜索（判断自己是否处于漫游状态）；转交地址（移动节点来到外网时从外代理处得到的临时地址）；登录（移动节点到达外网时进行一系列认证、注册、建立隧道的过程）；隧道（家代理与外代理之间临时建立的双向数据通道）。</li>
<li>通信流程：<ol>
<li>移动结点在本地网时，按传统的TCP&#x2F;IP方式进行通信；</li>
<li>漫游到外地网络时，仍使用固定IP通信。为了能够收到通信端发给它的IP分组，移动结点需要向本地代理注册当前的位置地址（即转交地址）；</li>
<li>本地代理收到转交地址的注册后，会构建一条通向转交地址的隧道，将截获的发给移动结点的IP分组通过隧道送到转交地址处；</li>
<li>在转交地址处解除隧道封装，恢复原始的IP分组，最后送到移动结点，这样移动结点就收到了这些发给它的IP分组；</li>
<li>移动结点在外网通过外网的路由器或者外代理向通信对端发送IP数据包；</li>
<li>当移动结点来到另一个外网时，向本地代理更新注册的转交地址；</li>
<li>当移动结点回到本地网时，向本地代理注销转交地址，恢复TCP&#x2F;IP的方式进行通信。</li>
</ol>
</li>
</ul>
<h2 id="网络层设备——路由器"><a href="#网络层设备——路由器" class="headerlink" title="网络层设备——路由器"></a>网络层设备——路由器</h2><p><img src="/2018/09/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%882%EF%BC%89/1.png" alt="路由器"></p>
<ul>
<li>任务：连接不同的网络（连接异构网络）并完成路由转发（1.路由计算；2.分组转发）。在多个逻辑网络（即多个广播域）互联时必须使用路由器。</li>
<li>路由器具有两个部分：分组转发部分（输入端口、输出端口、交换开关）和控制部分（路由处理器，任务是选择出路由表，并定期更新维护路由表）。</li>
<li>路由器是面向协议的，能够完成不同线路、不同协议之间转换。网桥不行。</li>
<li>路由表具有四个项目：目的网络IP地址、子网掩码、下一跳IP地址、接口。</li>
<li>转发表由路由表得出：目的站、下一跳的MAC地址。</li>
<li>路由表总是由软件实现，转发表可以用软件，可以用特殊的硬件实现。</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡（1）</title>
    <url>/2018/11/28/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="1-负载均衡技术介绍"><a href="#1-负载均衡技术介绍" class="headerlink" title="1. 负载均衡技术介绍"></a>1. 负载均衡技术介绍</h1><ol>
<li>HTTP 重定向负载均衡</li>
<li>DNS 域名解析负载均衡</li>
<li>反向代理负载均衡</li>
<li>IP 负载均衡</li>
<li>数据链路层负载均衡</li>
</ol>
<span id="more"></span>

<h2 id="1-1-HTTP-重定向负载均衡"><a href="#1-1-HTTP-重定向负载均衡" class="headerlink" title="1.1 HTTP 重定向负载均衡"></a>1.1 HTTP 重定向负载均衡</h2><p>介绍：在网站机房有一台名为“HTTP 重定向负载均衡”的服务器 A。</p>
<p>步骤：</p>
<ol>
<li>浏览器请求 DNS 解析域名，拿到服务器 A 的IP地址并访问；</li>
<li>服务器 A 利用某种负载均衡算法获得一台实际物理服务器 B 的地址，重定向响应返回给浏览器；</li>
<li>浏览器自动重新请求该实际物理服务器的 IP 地址，完成访问。</li>
</ol>
<p>评价：</p>
<ol>
<li>简单、但需要浏览器两次访问服务器；</li>
<li>使用 HTTP302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。</li>
</ol>
<h2 id="1-2-DNS-域名解析负载均衡"><a href="#1-2-DNS-域名解析负载均衡" class="headerlink" title="1.2 DNS 域名解析负载均衡"></a>1.2 DNS 域名解析负载均衡</h2><p>介绍：DNS 服务器不仅进行域名解析，而且同时进行负载均衡。</p>
<p>步骤：</p>
<ol>
<li>在 DNS 服务器中配置多个 A 记录；</li>
<li>每次域名解析请求时会根据负载均衡算法计算一个不同的 IP 地址返回。</li>
</ol>
<p>评价：</p>
<ol>
<li>省去了网站维护负载均衡服务器的麻烦；</li>
<li>DNS 可以基于地理位置的域名解析（离用户较劲的服务器地址），可以加快用户访问速度；</li>
<li>DNS 服务器中的 A 记录修改较麻烦，生效慢；</li>
<li>控制器不在网站方，网站管理较麻烦。</li>
<li>大型网站中，会将 DNS 负载均衡放在第一级，域名解析得到的 IP 地址是下一级负载均衡服务器（非实际物理服务器），在下一级负载均衡服务器上会进行再次负载均衡。</li>
</ol>
<h2 id="1-3-反向代理负载均衡"><a href="#1-3-反向代理负载均衡" class="headerlink" title="1.3 反向代理负载均衡"></a>1.3 反向代理负载均衡</h2><p>介绍：在 Web 应用服务器前的反向代理服务器，不仅缓存 Web 响应资源，而且提供负载均衡的功能。</p>
<p>步骤：</p>
<ol>
<li>Web 服务器不直接对外提供访问，所以只需要内部 IP 地址即可；</li>
<li>反向代理服务器需要同时具有外部 IP 地址和内部 IP 地址两套 IP 地址；</li>
</ol>
<p>评价：</p>
<ol>
<li>反向代理服务器转发请求在 HTTP 协议层（在应用程序中分发），即<strong>应用层负载均衡</strong>；</li>
<li>优点是部署简单，缺点是反向代理服务器的重要性提升，需要关注其性能。</li>
</ol>
<h2 id="1-4-IP-负载均衡"><a href="#1-4-IP-负载均衡" class="headerlink" title="1.4 IP 负载均衡"></a>1.4 IP 负载均衡</h2><p>介绍：在网络层通过<strong>修改请求目标</strong>实现负载均衡。</p>
<p>方案一：</p>
<ol>
<li>用户请求数据包到达负载均衡服务器，负载均衡服务器在 OS 的<strong>内核进程</strong>获取网络数据包，计算出一台真实的 Web 服务器，然后将数据包的目的 IP 地址修改（同时修改源 IP 地址为负载均衡服务器的地址）；</li>
<li>Web 服务器响应时的数据包回到负载均衡服务器，服务器将数据包的源地址修改为自身的 IP 地址发送给浏览器。</li>
</ol>
<p>方案二：</p>
<ol>
<li>相比方案一，将<strong>负载均衡服务器同时当作网关服务器</strong>。那么不需要同时修改数据包的源 IP 地址，就可以让 Web 服务器将响应返还给负载均衡服务器了。</li>
</ol>
<p>评价：</p>
<ol>
<li>IP 负载均衡服务器是在内核进程完成数据分发，比在应用层的反向代理服务器性能更好；</li>
<li>但是所有的请求响应都必须经过负载均衡服务器，那么此负载均衡服务器的网卡带宽容易成为性能的瓶颈。</li>
</ol>
<h2 id="1-5-数据链路层负载均衡"><a href="#1-5-数据链路层负载均衡" class="headerlink" title="1.5 数据链路层负载均衡"></a>1.5 数据链路层负载均衡</h2><p>介绍：在通信协议的数据链路层修改 mac 地址进行负载均衡。</p>
<p>步骤：</p>
<ol>
<li>负载均衡服务器（实际 IP）与 Web 服务器集群（虚拟 IP）具有同一个 IP 地址；</li>
<li>负载均衡服务器拿到数据包后，不修改 IP 地址，而是修改目的 mac 地址，数据包就会传输到该 Web 服务器上；</li>
<li>Web 服务器的响应信息可以不经过负载均衡服务器，直接发送回用户浏览器。</li>
</ol>
<p>评价：</p>
<ol>
<li>以上负载均衡方式称为直接路由方式（DR），模式称为三角模式；</li>
<li>是目前大型网站应用最广的一种负载均衡手段；</li>
<li>Linux 平台上最好的链路层负载均衡开源产品是 LVS。</li>
</ol>
<h1 id="2-负载均衡算法"><a href="#2-负载均衡算法" class="headerlink" title="2. 负载均衡算法"></a>2. 负载均衡算法</h1><p>主要有：轮询、加权轮询、随机、最少连接、原地址散列：</p>
<ul>
<li>轮询：所有请求依次分发到每台服务器上，平均分配。</li>
<li>加权轮询：在轮询基础上，考虑不同服务器硬件性能的差异，按权重分发。</li>
<li>随机：请求被随机分配。</li>
<li>最少连接：将新进请求发给当前请求数最少的服务器。</li>
<li>源地址散列：将请求来源的 IP 地址进行 Hash，使得来自同一个 IP 地址的请求总在同一个服务器上处理，从而实现会话粘滞。</li>
</ul>
<p>推荐阅读：<a href="https://blog.csdn.net/u013870094/article/details/79580886">四层、七层负载均衡的比较</a></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>distributed system</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络练习题之一</title>
    <url>/2018/08/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<h1 id="计算机网络第一章——概述"><a href="#计算机网络第一章——概述" class="headerlink" title="计算机网络第一章——概述"></a>计算机网络第一章——概述</h1><h4 id="1-HTTPS采用（）实现安全网站访问？：SSL协议"><a href="#1-HTTPS采用（）实现安全网站访问？：SSL协议" class="headerlink" title="1. HTTPS采用（）实现安全网站访问？：SSL协议"></a>1. HTTPS采用（）实现安全网站访问？：SSL协议</h4><ul>
<li>另一种说法是SSL协议+TSL协议</li>
<li>SSL（Secure Sockets Layer安全套接层），</li>
<li>Https的作用：<ol>
<li>内容加密。建立信息安全通道来实现；</li>
<li>身份认证。确认网站的真实性；</li>
<li>数据完整性。防止内容被第三方冒充或篡改</li>
</ol>
</li>
<li>Https的劣势：<ol>
<li>需要进行非对称的加解密，且需要三次握手。首次连接比较慢</li>
</ol>
</li>
</ul>
<h4 id="2-假设一个主机的IP地址为192-168-5-121，而子网掩码为255-255-255-248-那么该主机的网络号部分（包括子网号部分）为：192-168-5-120"><a href="#2-假设一个主机的IP地址为192-168-5-121，而子网掩码为255-255-255-248-那么该主机的网络号部分（包括子网号部分）为：192-168-5-120" class="headerlink" title="2. 假设一个主机的IP地址为192.168.5.121，而子网掩码为255.255.255.248,那么该主机的网络号部分（包括子网号部分）为：192.168.5.120"></a>2. 假设一个主机的IP地址为192.168.5.121，而子网掩码为255.255.255.248,那么该主机的网络号部分（包括子网号部分）为：192.168.5.120</h4><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">IP：<span class="number">192.168.5.121</span></span><br><span class="line">掩码：<span class="number">255.255.255.248</span></span><br><span class="line">前者地址转化为二进制：<span class="number">11000000</span>.<span class="number">10101000</span>.<span class="number">00000101</span>.<span class="number">01111001</span></span><br><span class="line">子网掩码转化为二进制：<span class="number">11111111</span>.<span class="number">11111111</span>.<span class="number">11111111</span>.<span class="number">11111000</span></span><br><span class="line">IP地址的前<span class="number">24</span>位不变，后<span class="number">8</span>位将子网掩码中的后<span class="number">8</span>位复制过去,即以每个&quot;.&quot;符号为单位，如果第二个&quot;.&quot;和第三个&quot;.&quot;中的数字不全为<span class="number">1</span>，则子网掩码的后<span class="number">16</span>位复制到IP的后<span class="number">16</span>位，得到新&quot;IP&quot;地址则为网络号。</span><br><span class="line">按照上面的运算规则，运算后结果为<span class="number">11000000</span>.<span class="number">10101000</span>.<span class="number">00000101</span>.<span class="number">11111000</span>，转化为十进制则为<span class="number">192.168.5.120</span>。</span><br></pre></td></tr></table></figure>


<span id="more"></span>

<h4 id="3-顶级域名有：-com-gov-cn"><a href="#3-顶级域名有：-com-gov-cn" class="headerlink" title="3. 顶级域名有：.com .gov .cn"></a>3. 顶级域名有：.com .gov .cn</h4><ul>
<li>.mil是军用机构顶级域名。另外，.com是商业机构顶级域名，.gov是政府机构顶级域名。.cn是中国顶级域名。</li>
</ul>
<h4 id="4-网桥工作于（）用于将两个局域网连接在一起并按-MAC-地址转发帧：数据链路层"><a href="#4-网桥工作于（）用于将两个局域网连接在一起并按-MAC-地址转发帧：数据链路层" class="headerlink" title="4. 网桥工作于（）用于将两个局域网连接在一起并按 MAC 地址转发帧：数据链路层"></a>4. 网桥工作于（）用于将两个局域网连接在一起并按 MAC 地址转发帧：数据链路层</h4><ul>
<li>数据链路层两个重要设备名称：网桥和交换机</li>
<li><a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.htm">五层模型的介绍博客</a></li>
</ul>
<h4 id="5-下面哪一个IP地址可以分配给主机（-）-B"><a href="#5-下面哪一个IP地址可以分配给主机（-）-B" class="headerlink" title="5.下面哪一个IP地址可以分配给主机（ ）:B"></a>5.下面哪一个IP地址可以分配给主机（ ）:B</h4><blockquote>
<p>A. 202.280.130.45<br><br>B. 130.192.33.45<br><br>C. 192.168.255.255<br><br>D. 224.10.1.1</p>
</blockquote>
<ul>
<li>A：280大于255</li>
<li>B：可以</li>
<li>C：192.168.255.255，主机号不能全为1或0，不能是192.168.255.255（C类）</li>
<li>D：224超过了223，不属于A、B、C这三类网络</li>
</ul>
<h4 id="6-在FTP中，控制信息和传输的文件数据可以使用同一个套接字-错。"><a href="#6-在FTP中，控制信息和传输的文件数据可以使用同一个套接字-错。" class="headerlink" title="6. 在FTP中，控制信息和传输的文件数据可以使用同一个套接字:错。"></a>6. 在FTP中，控制信息和传输的文件数据可以使用同一个套接字:错。</h4><ul>
<li>控制连接端口21，数据连接端口20</li>
<li>进行FTP文件传输中，客户端首先连接到FTP服务器的21端口，进行用户的认证，认证成功后，要传输文件时，服务器会开一个端口为20来进行传输数据文件。</li>
</ul>
<h4 id="7-两个分布在不同区域的10BASET网络使用其集线器上的AUI口，AUI电缆、收发器。粗同轴电缆连接时，在互连后的网络中，两个相距最远的结点之间的布线距离为：200m"><a href="#7-两个分布在不同区域的10BASET网络使用其集线器上的AUI口，AUI电缆、收发器。粗同轴电缆连接时，在互连后的网络中，两个相距最远的结点之间的布线距离为：200m" class="headerlink" title="7. 两个分布在不同区域的10BASET网络使用其集线器上的AUI口，AUI电缆、收发器。粗同轴电缆连接时，在互连后的网络中，两个相距最远的结点之间的布线距离为：200m"></a>7. 两个分布在不同区域的10BASET网络使用其集线器上的AUI口，AUI电缆、收发器。粗同轴电缆连接时，在互连后的网络中，两个相距最远的结点之间的布线距离为：200m</h4><ul>
<li>问的是布线距离，不是问最大距离。所以布线距离＝最大距离 * 2 &#x3D; 100 * 2 &#x3D; 200米</li>
</ul>
<h4 id="8-TCP-x2F-IP-参考模型的网络层提供的是：无连接不可靠的数据包服务"><a href="#8-TCP-x2F-IP-参考模型的网络层提供的是：无连接不可靠的数据包服务" class="headerlink" title="8. TCP&#x2F;IP 参考模型的网络层提供的是：无连接不可靠的数据包服务"></a>8. TCP&#x2F;IP 参考模型的网络层提供的是：无连接不可靠的数据包服务</h4><ul>
<li>网络层提供的是一种无连接、不可靠但尽力而为的数据报传输服务，将数据报从原主机传送到目的主机。<br>从一台主机到另外一台主机的分组可能会通过不同的路由且分组有可能出现丢失、乱序等。<br>为了达到较高的分组传输效率，放弃了一些并非必需的可靠性操作。</li>
</ul>
<h4 id="9-Windows-NT为管理用户帐号提供的使用程序叫做：域用户管理器"><a href="#9-Windows-NT为管理用户帐号提供的使用程序叫做：域用户管理器" class="headerlink" title="9. Windows NT为管理用户帐号提供的使用程序叫做：域用户管理器"></a>9. Windows NT为管理用户帐号提供的使用程序叫做：域用户管理器</h4><ul>
<li>记忆性知识点，不解释</li>
</ul>
<h4 id="10-下面哪些项是TCP具有的能力：ABD"><a href="#10-下面哪些项是TCP具有的能力：ABD" class="headerlink" title="10. 下面哪些项是TCP具有的能力：ABD"></a>10. 下面哪些项是TCP具有的能力：ABD</h4><blockquote>
<p>有连接<br><br>数据可靠传输<br><br>数据按序到达<br><br>端到端流量控制</p>
</blockquote>
<ul>
<li>TCP发送的数据是有序的，接收端最后整成有序的，但接受的顺序不一定是有序的，会对其再次排序，从而保证结果的有序性。</li>
</ul>
<h4 id="11-评价计算机网络的时延分为哪几种？：发送时延、传播时延、处理时延、排队时延"><a href="#11-评价计算机网络的时延分为哪几种？：发送时延、传播时延、处理时延、排队时延" class="headerlink" title="11. 评价计算机网络的时延分为哪几种？：发送时延、传播时延、处理时延、排队时延"></a>11. 评价计算机网络的时延分为哪几种？：发送时延、传播时延、处理时延、排队时延</h4><ul>
<li>发送时延：搬货上车的耗时。比特数&#x2F;信道宽度：货量&#x2F;搬货的人手</li>
<li>传播时延：上路后高速上的耗时。信道长度&#x2F;电磁波在信道上的传播速率：680公里&#x2F;车速120</li>
<li>处理时延：出发时设置高德导航的耗时。</li>
<li>排队时延：排队上高速&#x2F;收费口排队的耗时。</li>
<li>计算时般以前两种为主，后两种通常忽略不计</li>
</ul>
<h4 id="12-网络五大功能是：数据通信、资源共享、分布式处理、提高可靠性、负载均衡"><a href="#12-网络五大功能是：数据通信、资源共享、分布式处理、提高可靠性、负载均衡" class="headerlink" title="12. 网络五大功能是：数据通信、资源共享、分布式处理、提高可靠性、负载均衡"></a>12. 网络五大功能是：数据通信、资源共享、分布式处理、提高可靠性、负载均衡</h4><h4 id="13-传输管道可以容纳的比特数量表示：时延带宽积"><a href="#13-传输管道可以容纳的比特数量表示：时延带宽积" class="headerlink" title="13. 传输管道可以容纳的比特数量表示：时延带宽积"></a>13. 传输管道可以容纳的比特数量表示：时延带宽积</h4><ul>
<li>发送端连续发送比特，第一个比特达到终点时，发送端发出的总比特数，计算方法为传播时延×信道带宽</li>
</ul>
<h4 id="14-吞吐量的定义：在单位时间内通过某个网络的数据量。受带宽或额定速率的限制"><a href="#14-吞吐量的定义：在单位时间内通过某个网络的数据量。受带宽或额定速率的限制" class="headerlink" title="14. 吞吐量的定义：在单位时间内通过某个网络的数据量。受带宽或额定速率的限制"></a>14. 吞吐量的定义：在单位时间内通过某个网络的数据量。受带宽或额定速率的限制</h4><h4 id="15-计算机网络系统的基本组成是：通信子网和资源子网。"><a href="#15-计算机网络系统的基本组成是：通信子网和资源子网。" class="headerlink" title="15. 计算机网络系统的基本组成是：通信子网和资源子网。"></a>15. 计算机网络系统的基本组成是：通信子网和资源子网。</h4><ul>
<li>从功能上看，计算机网络由通信子网和资源子网组成。从组成部分上看，计算机网络由硬件、软件、协议三部分组成。从工作方式上看，计算机网络由边缘部分和核心部分组成。</li>
<li>通信子网由各种传播介质、通信设备和相应的网络协议组成，它使网络具有数据传输、交换、控制、存储的能力。</li>
<li>资源子网是实现资源共享功能的设备及其软件的集合，向网络用户提供共享其他计算机上的硬件资源、软件资源和数据资源的服务。</li>
</ul>
<h4 id="16-局域网和广域网的差异不仅在于它们所覆盖的范围不同，还主要在于它们-所使用的协议和网络技术不同"><a href="#16-局域网和广域网的差异不仅在于它们所覆盖的范围不同，还主要在于它们-所使用的协议和网络技术不同" class="headerlink" title="16. 局域网和广域网的差异不仅在于它们所覆盖的范围不同，还主要在于它们:所使用的协议和网络技术不同"></a>16. 局域网和广域网的差异不仅在于它们所覆盖的范围不同，还主要在于它们:所使用的协议和网络技术不同</h4><ul>
<li>局域网跟广域网的区分关键在协议的不同 </li>
<li>广域网采用交换&#x2F;点对点技术</li>
<li>局域网采用广播技术</li>
<li>城域网可以理解为多个局域网相连，属于以太网的范畴（以太网是一种最盛行的局域网技术）</li>
</ul>
<h4 id="17-下列关于广播式网络的说法中错误的是：D"><a href="#17-下列关于广播式网络的说法中错误的是：D" class="headerlink" title="17. 下列关于广播式网络的说法中错误的是：D"></a>17. 下列关于广播式网络的说法中错误的是：D</h4><blockquote>
<p>A. 共享广播信道<br><br>B.不存在路由选择问题<br><br>C.可以不要网络层<br><br>D.不需要服务访问点</p>
</blockquote>
<ul>
<li>广播式网络共享总线，通常是局域网的一种通信方式，局域网工作在数据链路层，故不需要网络层，因此也不存在路由选择的问题。但数据链路层使用物理层的服务必须通过服务访问点来实现</li>
</ul>
<h4 id="18-下列哪一项是分组交换网络的缺点？B"><a href="#18-下列哪一项是分组交换网络的缺点？B" class="headerlink" title="18. 下列哪一项是分组交换网络的缺点？B"></a>18. 下列哪一项是分组交换网络的缺点？B</h4><blockquote>
<p>A. 信道利用率低<br><br>B.附加信息开销大<br><br>C.传播时延大<br><br>D.不同规格的终端很难相互通信</p>
</blockquote>
<ul>
<li>网络按照交换技术分类：电路交换网络、报文交换网络、分组交换网络。</li>
<li>电路交换网络。最典型的是传统电话网络，比特流连续的从源点直达终点。优点：直接传送、延迟小；缺点：线路利用率低、未充分利用线路容量、不便于进行差错控制。</li>
<li>报文交换网络。又叫存储-转发网络，整个报文先到达相邻结点，全部存储下来后查找转发表，转发到下一结点。优点：较充分利用线路容量、不同链路不同数据率的转换、格式转换、一对多多对一的访问、差错控制；缺点：增加了资源开销、增加缓冲延迟、需要额外的机制来保证多个报文的顺序、缓冲区难以管理。</li>
<li>分组交换网络。又叫包交换网络，讲数据分为较短的固定长度的数据块，在每个数据块中加上目的地址、源地址等辅助信息组成包，以存储转发的方式传输。除了存储-转发的优点外，还具有：缓冲易于管理、包的平均延迟小、网络中占得平均缓冲区更小、更易于标准化、更适合应用，所以应用得更广。</li>
<li>传播时延取决于传播介质和收发双方的距离。</li>
<li>对于各种交换方式，不同规格的终端都很难相互通信。</li>
</ul>
<h4 id="19-有两个网络，它们都提供可靠地面向连接的服务，一个提供可靠地字节流，另一个提供可靠的报文流，两者不同之处：报文流保持对报文边界的跟踪；而在字节流中网络不做这样的跟踪"><a href="#19-有两个网络，它们都提供可靠地面向连接的服务，一个提供可靠地字节流，另一个提供可靠的报文流，两者不同之处：报文流保持对报文边界的跟踪；而在字节流中网络不做这样的跟踪" class="headerlink" title="19. 有两个网络，它们都提供可靠地面向连接的服务，一个提供可靠地字节流，另一个提供可靠的报文流，两者不同之处：报文流保持对报文边界的跟踪；而在字节流中网络不做这样的跟踪"></a>19. 有两个网络，它们都提供可靠地面向连接的服务，一个提供可靠地字节流，另一个提供可靠的报文流，两者不同之处：报文流保持对报文边界的跟踪；而在字节流中网络不做这样的跟踪</h4><ul>
<li>对于两条1024B的数据，报文流讲收到两个报文各1024B；而字节流将全部的2048B当做一个整体，体现不出原先有的两个不同报文的事实。</li>
<li>字节流没边界，适合传输视频和音频；报文流有边界，适合传输普通文件</li>
<li>推荐阅读 ：<a href="https://blog.csdn.net/lianliange85/article/details/50194975">TCP 流协议和消息分帧的理解</a><ul>
<li>TCP是流协议，不区分流边界，如果不分帧，那么可能会发生你send了无数次，但是对方只接收一次的情况</li>
<li>在TCP通信过程中，我们不需要关心（也没法关心，但可以设置）数据包的大小，个数，我们只需要在客户端建立一个缓冲区不断发送，在服务端建立一个缓冲区不断接收就够了</li>
</ul>
</li>
</ul>
<h4 id="20-对网络模型进行分层的目的是：提供标准语言、定义标准界面、增加功能之间的独立性，并不定义功能执行的具体方法"><a href="#20-对网络模型进行分层的目的是：提供标准语言、定义标准界面、增加功能之间的独立性，并不定义功能执行的具体方法" class="headerlink" title="20. 对网络模型进行分层的目的是：提供标准语言、定义标准界面、增加功能之间的独立性，并不定义功能执行的具体方法"></a>20. 对网络模型进行分层的目的是：提供标准语言、定义标准界面、增加功能之间的独立性，并不定义功能执行的具体方法</h4><h4 id="21-拥塞控制是哪一层的功能：网络层和传输层"><a href="#21-拥塞控制是哪一层的功能：网络层和传输层" class="headerlink" title="21. 拥塞控制是哪一层的功能：网络层和传输层"></a>21. 拥塞控制是哪一层的功能：网络层和传输层</h4><ul>
<li>拥塞控制：如果某结点来不及接收分组，而要丢弃大量分组的情况时，网络就处于拥塞状态</li>
<li>推荐阅读：<a href="https://bbs.csdn.net/topics/330086059">理解数据链路层</a></li>
<li>数据链路层的某主要功能:链路连接的建、拆、分离，帧界定和帧同步，保证数据正确的顺序和完整性</li>
</ul>
<h4 id="22-会话层采取了什么机制，可以在通信失效时恢复通信，实现数据同步：校验点-x2F-同步点"><a href="#22-会话层采取了什么机制，可以在通信失效时恢复通信，实现数据同步：校验点-x2F-同步点" class="headerlink" title="22. 会话层采取了什么机制，可以在通信失效时恢复通信，实现数据同步：校验点&#x2F;同步点"></a>22. 会话层采取了什么机制，可以在通信失效时恢复通信，实现数据同步：校验点&#x2F;同步点</h4><ul>
<li>会话层的两个主要服务是会话管理和同步</li>
<li>另：会话层允许不同主机上的进程进行会话</li>
</ul>
<h4 id="23-表示层的作用-为异种机通信提供一种公共语言（翻译官），处理所有与数据表示与运输有关的问题。"><a href="#23-表示层的作用-为异种机通信提供一种公共语言（翻译官），处理所有与数据表示与运输有关的问题。" class="headerlink" title="23. 表示层的作用:为异种机通信提供一种公共语言（翻译官），处理所有与数据表示与运输有关的问题。"></a>23. 表示层的作用:为异种机通信提供一种公共语言（翻译官），处理所有与数据表示与运输有关的问题。</h4><ul>
<li>语法转换：设计代码转换和字符集的转换，数据格式修改、压缩解密等</li>
<li>语法选择：提供出事选择的一种语法和随后修改这种选择的手段</li>
<li>联结管理：利用会话层提供的服务建立联接，管理在这一联接之上的数据运输和同步控制，以及正常或非正常地终止联接</li>
<li>加密分为链路加密和端到端的加密。对于表示层，参与的加密属于端到端的加密，指信息由发送端自动加密，并进入TCP&#x2F;IP数据包封装，然后作为不可阅读和不可识别的数据进入互联网。到达目的地后，再自动充足解密，成为可读数据。端到端加密面向网络高层主体，不对下层协议进行信息加密，协议信息以明文进行传送，用户数据在中央节点不需解密</li>
</ul>
]]></content>
      <categories>
        <category>examination</category>
      </categories>
      <tags>
        <tag>computer network</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式一揽子</title>
    <url>/2019/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%8F%BD%E5%AD%90/</url>
    <content><![CDATA[<p>推荐阅读：<a href="http://www.runoob.com/design-pattern/design-pattern-tutorial.html">设计模式 菜鸟教程</a></p>
<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>场景：</p>
<blockquote>
<p>远程代理：为一个对象在不同的地址空间提供局部代表。<br>虚代理：根据需要创建开销很大的对象。<br>保护代理：控制对原始对象的访问。保护代理用于对象应该有不同访问权限的时候。<br>智能指引：取代了简单的指针，它在访问对象时执行了一些附加操作，如下：</p>
<ul>
<li>对指向实际对象的引用计数，这样当该对象没有引用的时候，可以自动释放它。</li>
</ul>
</blockquote>
<ul>
<li>当第一次引用一个持久对象时，将它装入内存。</li>
<li>在访问一个实际对象前，检查时候已经锁定了它，以确保其他对象不能改变它。</li>
</ul>
<span id="more"></span>

<h3 id="虚拟代理"><a href="#虚拟代理" class="headerlink" title="虚拟代理"></a>虚拟代理</h3><ul>
<li>未使用代理模式时：<ul>
<li>使用 JDBC 与 MySQL 交互时，需要创建<strong>数据库链接</strong>，开销大。</li>
</ul>
</li>
<li>使用代理模式的虚拟代理：<ul>
<li>让虚拟代理做“创建开销大的对象”的工作，把<strong>创建这类对象的工作推迟到使用它的时候</strong>。</li>
<li>每一张数据表，对应一个代理类。</li>
<li>当出现请求，想操作数据表时，这时代理类将创建对象，并完成对数据库的操作。<ul>
<li>操作数据表，相当于一个 AdminDAO 接口，对应实现 AdminDAOImpl。</li>
<li>代理类，即 AdminDaoProxy，同样 implements 了 AdminDAO 接口，而且。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="动态代理："><a href="#动态代理：" class="headerlink" title="动态代理："></a>动态代理：</h3><p><img src="/2019/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%8F%BD%E5%AD%90/%E4%BB%A3%E7%90%861.png" alt="代理1"> </p>
<ul>
<li>User 调用 Proxy，Proxy 实现 Subject 接口 plan 相关功能，某Invocation实际去 achieve  这些功能。<ul>
<li>此 InvocationHandler 实际上implements InvocationHandler 接口，并重写<code>invoke()</code>方法。</li>
</ul>
</li>
</ul>
<h3 id="代理模式的变体"><a href="#代理模式的变体" class="headerlink" title="代理模式的变体"></a>代理模式的变体</h3><p>防火墙代理、缓存代理、智能引用代理、同步代理（多线程）、写入时复制代理（copy-on-write）。</p>
<ul>
<li>copy-on-write：该优化根据需要创建的对象有关，用代理延迟拷贝的过程，因为它没有被修改的时候，没有必要因为拷贝而产生开销。只有用户请求修改实体的操作时，代理才会真正拷贝它</li>
</ul>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>参考：<a href="http://likehui.fun/2018/12/13/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%862/">面经整理2，第5题</a></p>
<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><ol>
<li>有一系列算法，一个算法称为一个策略，将每一个都封装起来，让它们可以相互替换。<ul>
<li>这些策略都 implements 了 Strategy 接口，拥有同名方法（例 operation）的不同实现。</li>
</ul>
</li>
<li>策略模式让算法独立于使用它的客户，然后根据环境或者条件的不同选择不同的策略来完成该项任务。<ul>
<li>环境 context 类中有一个指向 Strategy 接口的引用。</li>
<li>psvm 中会传入带有不同条件（通常指明了某实现类）的 context，然后让 context 执行 operation（由此自然定位到了预想的实现类中，执行预想的实现方法）。</li>
</ul>
</li>
<li>当算法被调用， Context 可以将该算法所需要的所有数据都传递给该 Strategy ，或者， Context 可以将自身作为一个参数传递给 Strategy 操作。这就让 Strategy 在需要的时候可以回调 Context。</li>
</ol>
<ul>
<li>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于<strong>行为型</strong>模式。</li>
<li>在策略模式中，我们创建<strong>表示各种策略的对象</strong>和一个行为随着策略对象改变而改变的 <strong>context 对象</strong>。策略对象改变 context 对象的执行算法。</li>
</ul>
<p>策略模式的缺点：</p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>对比策略模式：</p>
<ul>
<li>享元模式与策略模式极其类似，一般是在策略模式外包一层对象，但享元模式属于<strong>结构型</strong>模式，而策略模式属于<strong>行为型</strong>模式。</li>
</ul>
<p>建议直接看这篇博客：<a href="http://koon.cool/design-pattern/2018-08-23-flyweight/">初探享元模式</a>，清晰易懂。</p>
<p><img src="/2019/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%8F%BD%E5%AD%90/flyweight-pattern.jpg" alt="flyweight"></p>
<h1 id="外观模式（Facade-Pattern）"><a href="#外观模式（Facade-Pattern）" class="headerlink" title="外观模式（Facade Pattern）"></a>外观模式（Facade Pattern）</h1><ul>
<li>多个子系统，每一个都很细碎复杂，有时候客户并不需要知道太细节的东西。</li>
<li>给子系统们增加一个简单接口 Facade，Facade 可以提供一个简单的缺省视图，这一视图对大多数用户而言已经足够，而需要定制的用户则可以通过 Facade 层来使用子系统。</li>
</ul>
<p>此模式的参与者：</p>
<blockquote>
<p>Facade  : 知道哪些子系统负责处理请求，将用户的请求恰当发送。<br>Subsystem classes：实现子系统的功能，处理 Facade 指派。</p>
</blockquote>
<p><img src="/2019/01/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80%E6%8F%BD%E5%AD%90/facade.jpg" alt="facade"></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]多态的底层实现原理</title>
    <url>/2019/01/04/%E8%BD%AC-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[转载]原文地址：<a href="https://blog.csdn.net/SEU_Calvin/article/details/52191321">Java技术——多态的实现原理</a><br>1．Java多态概述</p>
<p><strong>Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但可具有不同的参数列表、返回值类型。调用方法时通过传递的参数类型来决定具体使用哪个方法，这就是多态性</strong>。</p>
<p><strong>Java的方法重写，是父类与子类之间的多态性，子类可继承父类中的方法，但有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写。重写的参数列表和返回类型均不可修改</strong>。</p>
<span id="more"></span>


<p>2．方法重写后的动态绑定</p>
<p><strong>多态允许具体访问时实现方法的动态绑定。Java对于动态绑定的实现主要依赖于方法表，通过继承和接口的多态实现有所不同。</strong></p>
<p><strong>继承</strong>：在执行某个方法时，在方法区中找到该类的方法表，再确认该方法在方法表中的偏移量，找到该方法后如果被重写则直接调用，否则认为没有重写父类该方法，这时会按照继承关系搜索父类的方法表中该偏移量对应的方法。 </p>
<p><strong>接口</strong>：Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同一个接口的的方法在不同类方法表中的位置就可能不一样了。所以不能通过偏移量的方法，而是通过搜索完整的方法表。</p>
<p>3．JVM的结构（拓展知识，不了解可以看看）</p>
<p><img src="/2019/01/04/%E8%BD%AC-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1.jpg" alt="1"></p>
<p>从上图可以看出，<strong>当程序运行需要某个类时，类加载器会将相应的class文件载入到JVM中，并在方法区建立该类的类型信息（包括方法代码，类变量、成员变量、以及本博文要重点讨论的方法表）</strong>。 <br>注意，这个方法区中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以方法区是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法区中类型信息。就像在java反射机制那样，通过class对象可以访问到该类的所有信息一样。</p>
<p>【重点】 </p>
<p><strong>方法表是实现动态调用的核心。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向记录该类方法的方法表，方法表中的每一个项都是对应方法的指针</strong>。这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。</p>
<blockquote>
<p>lee 的理解：一个类型信息，对应一个指向方法表的指针，然后方法表中有很多指针，各指向某一个方法。</p>
</blockquote>
<p>4．Java 的方法调用方式（拓展知识，可以不看）</p>
<p>Java 的方法调用有两类，<strong>动态方法</strong>调用与<strong>静态方法</strong>调用。</p>
<p>静态方法调用是指对于类的静态方法的调用方式，是静态绑定的；而动态方法调用需要有方法调用所作用的<strong>对象</strong>，是动态绑定的。</p>
<p><strong>类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。</strong></p>
<p><strong>实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。</strong></p>
<p>JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于<strong>JVM后两种调用</strong>实现的考察。</p>
<p>5．方法表与方法调用</p>
<p>如有类定义 Person, Girl, Boy</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>; </span><br><span class="line">	 &#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">eat</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">speak</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line">	</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a boy&quot;</span>; </span><br><span class="line">	 &#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">speak</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">fight</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a girl&quot;</span>; </span><br><span class="line">	 &#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">speak</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">sing</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当这三个类被载入到 Java 虚拟机之后，方法区中就包含了各自的类的信息。Girl 和 Boy 在方法区中的方法表可表示如下：</p>
<p><img src="/2019/01/04/%E8%BD%AC-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/2.jpg" alt="2"></p>
<p>可以看到，Girl 和 Boy 的方法表<strong>包含继承自 Object 的方法，继承自直接父类 Person 的方法及各自新定义的方法</strong>。注意方法表条目指向的具体的方法地址，如 Girl 继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。</p>
<p><strong>如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项.</strong><br>因此，方法表的偏移量总是固定的。<strong>所有继承父类的子类的方法表中</strong>，其父类所定义的方法的<strong>偏移量也总是一个定值</strong>。<br>Person 或 Object中的<strong>任意一个方法</strong>，在它们的方法表和其子类 Girl 和 Boy 的方法表中的<strong>位置 (index) 是一样的</strong>。这样 JVM 在<strong>调用实例方法其实只需要指定调用方法表中的第几个方法即可</strong>。</p>
<blockquote>
<p>[lee 的理解]因为是单继承，而且偏移量是从上往下数，那么对比 Girl 类和 Boy 类，两者继承自 Object 的部分完全一致，继承自 Person 的部分也完全一致，所以上述<code>偏移量是一个固定值的说法</code>成立。</p>
</blockquote>
<p>如调用如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Party</span>&#123; </span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">happyHour</span>()</span>&#123; </span><br><span class="line"> Person girl = <span class="keyword">new</span> Girl(); </span><br><span class="line"> girl.speak(); &#125; </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当编译 Party 类的时候，生成 girl.speak()的方法调用假设为：</p>
<p>Invokevirtual #12</p>
<p>设该调用代码对应着 girl.speak(); #12 是 Party 类的常量池的索引。JVM 执行该调用指令的过程如下所示：</p>
<p><img src="/2019/01/04/%E8%BD%AC-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/3.jpg" alt="3"></p>
<p>（1）在常量池（这里有个错误，上图为ClassReference常量池而非Party的常量池）中找到方法<strong>调用的符号引用</strong> 。<br>（2）查看Person的方法表，<strong>得到speak方法在该方法表的偏移量</strong>（假设为15），这样就得到该方法的直接引用。 <br>（3）根据this指针得到<strong>具体的对象</strong>（即 girl 所指向的位于堆中的对象）。<br>（4）<strong>根据对象得到该对象对应的方法表</strong>，根据偏移量15查看有无重写（override）该方法，如<strong>果重写，则可以直接调用（Girl的方法表的speak项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是Person类）的方法表，同样按照这个偏移量15查看有无该方法</strong>。</p>
<p>6．接口调用</p>
<p>因为 Java 类是可以同时实现多个接口的，而当用接口引用调用某个方法的时候，情况就有所不同了。</p>
<p>Java 允许一个类实现多个接口，从某种意义上来说相当于多继承，这样同样的方法在基类和派生类的方法表的位置就可能不一样了。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDance</span>&#123; </span><br><span class="line">   <span class="built_in">void</span> <span class="title function_">dance</span>(); </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a person.&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">eat</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">speak</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line">	</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Dancer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> <span class="keyword">implements</span> <span class="title class_">IDance</span> &#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;I&#x27;m a dancer.&quot;</span>; </span><br><span class="line">  &#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">dance</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Snake</span> <span class="keyword">implements</span> <span class="title class_">IDance</span>&#123; </span><br><span class="line"> <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">toString</span>(<span class="params"></span>)&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;A snake.&quot;</span>; &#125; </span><br><span class="line"> <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">dance</span>(<span class="params"></span>)&#123; </span><br><span class="line"> <span class="comment">//snake dance </span></span><br><span class="line">	 &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/01/04/%E8%BD%AC-%E5%A4%9A%E6%80%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/4.jpg" alt="4"></p>
<p>可以看到，由于接口的介入，<strong>继承自接口 IDance 的方法 dance()在类 Dancer 和 Snake 的方法表中的位置已经不一样了</strong>，显然我们无法仅根据偏移量来进行方法的调用。</p>
<p><strong>Java 对于接口方法的调用是采用搜索方法表的方式</strong>，如，要在Dancer的方法表中找到dance()方法，必须搜索Dancer的整个方法表。</p>
<p>因为每次接口调用都要<strong>搜索方法表</strong>，所以从效率上来说，<strong>接口方法的调用总是慢于类方法的调用的</strong>。</p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理2</title>
    <url>/2018/12/13/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%862/</url>
    <content><![CDATA[<p><a href="https://www.nowcoder.com/discuss/110274">美团一面</a></p>
<h4 id="1-判断回文"><a href="#1-判断回文" class="headerlink" title="1. 判断回文"></a>1. 判断回文</h4><ol>
<li>字符串转置，然后逐位比较；</li>
<li>字符串转置，直接 equals 比较；</li>
<li>for 循环 length&#x2F;2 次，首位和末尾逐次比较；</li>
</ol>
<h4 id="2-jvm，讲讲gc"><a href="#2-jvm，讲讲gc" class="headerlink" title="2. jvm，讲讲gc"></a>2. jvm，讲讲gc</h4><p>  jvm 将内存划分为：方法区、堆区、虚拟机栈、本地方法栈、程序计数器。</p>
  <span id="more"></span>
<p>方法区：</p>
<ul>
<li>要加载的类的信息、静态变量、构造函数、final 定义的信息，包含运行时常量池。</li>
<li>全局共享。</li>
<li>对应持久带，会被 GC，但很少发生。</li>
</ul>
<p>堆区：</p>
<ul>
<li>所有线程共享，主要存放对象实例和数组。</li>
</ul>
<p>虚拟机栈：</p>
<ul>
<li>每个方法被执行时，产生一个栈帧，用来存储局部变量表、动态链接、操作数和方法出口等信息。</li>
</ul>
<p>本地方法栈：</p>
<ul>
<li>执行 native 方法。</li>
</ul>
<p>程序计数器：</p>
<ul>
<li>存储当前线程执行的字节码行号。</li>
</ul>
<p>GC：对方法区和堆区进行垃圾回收，回收的对象多是那些不存在任何引用的对象。<br>GC 算法：标记-清除算法、复制算法、标记-整理算法、分代收集算法。<br>GC 收集器：串行收集器、ParNew GC、Parallel Scavenge GC、CMS 收集器、G1 收集器、Serial Old 收集器、Parallel Old 收集器、RTSJ 垃圾收集器。</p>
<h4 id="3-讲讲-osi-七层模型"><a href="#3-讲讲-osi-七层模型" class="headerlink" title="3. 讲讲 osi 七层模型"></a>3. 讲讲 osi 七层模型</h4><ol>
<li>应用层：文件传输、管理，邮件处理。协议：HTTP、FTP等。</li>
<li>表示层：编码转换、数据解析、管理数据的加解密。协议：Telnet、SNMP、Gopher等。</li>
<li>会话层：通信连接的建立、保持会话过程通信连接的畅通。协议：DNS、SMTP等。</li>
<li>传输层：定义一些传输数据的协议和端口。协议：TCP、UDP等。</li>
<li>网络层：控制子网的运行，如逻辑编址，分组传输，路由选择。协议：IP、ICMP、ARP等。</li>
<li>数据链路层：对物理层传输的比特流包装，物理寻址等。协议：PPP、SDLC、帧中继等。</li>
<li>物理层：定义物理设备的标准。协议：IEEE 802.1A、IEEE802.2等。</li>
</ol>
<p><img src="/2018/12/13/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%862/2.jpg" alt="2"></p>
<p>推荐阅读：<a href="https://blog.csdn.net/taotongning/article/details/81352985">OSI七层协议大白话解读</a><br><a href="https://my.oschina.net/LucasZhu/blog/1815402">OSI七层协议模型、TCP&#x2F;IP四层模型</a></p>
<h4 id="4-tcp-udp"><a href="#4-tcp-udp" class="headerlink" title="4. tcp udp"></a>4. tcp udp</h4><p><img src="/2018/12/13/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%862/3.jpg" alt="3"></p>
<p>区别：</p>
<ul>
<li>TCP 是面向连接的、UDP 是面向无连接的；</li>
<li>UDP 程序结构简单；</li>
<li>TCP 是面向字节流的，UDP 是基于数据报的；<ul>
<li>UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。（理解：不拆分，所以有原生的边界）。</li>
<li>TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。（理解：要拆分，所以没有边界，直接拼接上）。</li>
</ul>
</li>
<li>TCP 保证数据正确性、UDP 可能丢包；</li>
<li>TCP 保证数据顺序，UDP 不保证。</li>
<li>TCP 有流量控制（滑动窗口）、拥塞控制（拥塞窗口）机制。</li>
</ul>
<p>具体编程时，<br>socket()的参数不同：</p>
<ul>
<li>UDP Server 不需要调用 listen 和 accept；</li>
<li>UDP 收发数据用 sendto&#x2F;recvfrom 函数；</li>
<li>TCP：地址信息在 connect&#x2F;accept 时确定；</li>
<li>UDP：在 sendto&#x2F;recvfrom 函数中每次均需指定地址信息；</li>
<li>UDP：shutdown 函数无效。</li>
</ul>
<p>推荐阅读：<a href="https://blog.csdn.net/ce123_zhouwei/article/details/8976006">面向报文（UDP）和面向字节流（TCP）的区别</a></p>
<h3 id="5-设计模式-懒汉饿汉区别，抽象简单工厂区别"><a href="#5-设计模式-懒汉饿汉区别，抽象简单工厂区别" class="headerlink" title="5. 设计模式 懒汉饿汉区别，抽象简单工厂区别"></a>5. 设计模式 懒汉饿汉区别，抽象简单工厂区别</h3><p>饿汉和懒汉式设计模式中单例模式的两大种方式：</p>
<p><strong>饿汉式</strong>，在类创建的同时已经创建好了一个静态对象供使用，是线程安全的，但对内存有一定消耗。</p>
<p><strong>懒汉式</strong>，延时加载，线程不安全，为了实现线程安全有几种写法：</p>
<ul>
<li>加方法锁（有漏洞）</li>
<li>双锁（有漏洞）</li>
<li>双锁 + valatile等。（无漏洞、繁琐）</li>
<li><strong>静态内部类</strong>（也叫做 Holder 方法无漏洞）【常用】。</li>
<li><strong>枚举</strong>（无漏洞、简单）【常用】。有关枚举方式推荐阅读：<a href="https://www.hollischuang.com/archives/2498">为什么我墙裂建议大家使用枚举来实现单例</a>。枚举的分析如下：<ul>
<li>枚举类被加载时，会使用<code>ClassLoader</code>的<code>loadClass</code>方法（此方法使用同步代码块保证线程安全）。</li>
<li>枚举的序列化和反序列化是特殊定制的，可避免因反射引起的代码重排问题。</li>
<li>枚举单例的实例代码如下：</li>
</ul>
</li>
</ul>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Singleton&#123;</span><br><span class="line">	INSTANCE;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span>()</span>&#123; sysout ... &#125;</span><br><span class="line">	psvm&#123;</span><br><span class="line">		INSTANCE.check();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<pre><code>  + 枚举单例，再增加懒加载功能（配合静态内部类实现）如下：
</code></pre>
  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">enum</span> EnumHolder&#123;</span><br><span class="line">		INSTANCE;</span><br><span class="line">		<span class="keyword">private</span> Singleton instance;</span><br><span class="line">		EnumHolder()&#123;</span><br><span class="line">			<span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">private</span> Singleton <span class="title">getSingleton</span>()</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> instance;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span>()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> EnumHolder.INSTANCE.getSingleton();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p><strong>简单工厂：</strong>拥有一个工厂方法，接受一个参数，通过不同的参数实例化不同的产品类。<br>优点：简单、代码量少。<br>缺点：</p>
<ul>
<li>此工厂方法负责生产任何“东西”，负担太重；</li>
<li>在遵循开闭原则下，简单工厂无法增加新的产品。</li>
</ul>
<p><strong>工厂方法：</strong>针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例。<br>优点：可解决简单工厂的缺点，当需要增加某类“东西”时，不需要修改原工厂，只需要添加生产这类“东西”的工厂即可。<br>缺点：对于某些可以生成产品族的情况处理较复杂。比如可以将奔驰所有车看做一个产品族。</p>
<p><strong>抽象工厂：</strong>用于应对产品族概念的，与工厂方法类似，将工厂方法中的共同点抽象出来。<br>优点：便于增加产品族。</p>
<p>另一种总结：</p>
<ul>
<li>简单工厂：定义了一个类来负责创建其他产品类的实例。</li>
<li>工厂方法：工厂父类负责定义创建产品对象的公共接口，而工厂子类则决定生成具体的产品对象，这样类实例的创建就可以在子类中单独完成了。</li>
<li>抽象工厂：提供一个创建一系列相关或互相依赖对象的接口，而无须指定它们具体的类。</li>
</ul>
<p>推荐阅读：<a href="https://www.cnblogs.com/zhangchenliang/p/3700820.html">简单工厂、工厂方法、抽象工厂、策略模式、策略与工厂的区别</a></p>
<h4 id="6-linux-删除日志文件最后十行"><a href="#6-linux-删除日志文件最后十行" class="headerlink" title="6. linux 删除日志文件最后十行"></a>6. linux 删除日志文件最后十行</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">A=<span class="variable">$(</span>sed -n <span class="string">&#x27;$=&#x27;</span> a.txt) // 输出a.txt的行数赋给 A，取值时用<span class="variable">$</span></span><br><span class="line"><span class="variable"></span>sed <span class="variable">$(</span>(<span class="variable">$A</span> <span class="number">-10</span>+<span class="number">1</span>)),<span class="variable">$&#123;</span>A&#125;d a.txt</span><br></pre></td></tr></table></figure>

<p>注：如果将 10 改成 50，就成了删除最后 50 行了。a.txt 可以修改为题目中的日志文件。</p>
<p>推荐阅读：<a href="http://www.runoob.com/linux/linux-comm-sed.html">Linux sed命令</a><br><a href="http://blog.51cto.com/13466287/2066532">shell中sed命令的用法</a></p>
<h4 id="7-sql-注入"><a href="#7-sql-注入" class="headerlink" title="7. sql 注入"></a>7. sql 注入</h4><p>SQL 注入：SQL注入是比较常见的网络攻击方式之一，它不是利用操作系统的BUG来实现攻击，而是针对程序员编程时的疏忽，通过SQL语句，实现无帐号登录，甚至篡改数据库。</p>
<p>注入思路：</p>
<ol>
<li>寻找到SQL注入的位置</li>
<li>判断服务器类型和后台数据库类型</li>
<li>针对不同的服务器和数据库特点进行SQL注入攻击</li>
</ol>
<p>应对办法：</p>
<ol>
<li>采用预编译语句集 PreparedStatement；</li>
<li>使用正则表达式过滤；</li>
<li>字符串过滤；</li>
<li>jsp 中进行函数检查；</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/hkncd/archive/2012/03/31/2426274.html">SQL 注入</a><br><a href="https://blog.csdn.net/hxpjava1/article/details/81011334">如何防止sql注入</a></p>
<h4 id="8-快排时间复杂度，空间复杂度"><a href="#8-快排时间复杂度，空间复杂度" class="headerlink" title="8. 快排时间复杂度，空间复杂度"></a>8. 快排时间复杂度，空间复杂度</h4><p><img src="/2018/12/13/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%862/1.jpg" alt="1"></p>
<p>快排时间复杂度的三种证明办法：<a href="http://www.newhappy.com.cn/?p=875">为什么快速排序的时间复杂度是 O(nlogn)</a></p>
<p>Tips：</p>
<ul>
<li>快速排序排的是一个左右闭合区间； </li>
<li>快排每一趟只将一个数排好，放在正确的位置；</li>
<li>key 能选最左边也能选最右边，也可以随机选</li>
<li>当一组数为有序时使用快排对这组数排序，此时为快排的最坏情况；时间复杂度最高，为 O(N^2);</li>
</ul>
<p>顺口溜：</p>
<ul>
<li>不稳定：<strong>快些</strong>（希）<strong>选</strong>一<strong>堆</strong>小伙伴。</li>
<li>时间复杂度O(NlogN)：<strong>快归队</strong>（堆）。</li>
</ul>
<h4 id="9-数据库隔离级别"><a href="#9-数据库隔离级别" class="headerlink" title="9. 数据库隔离级别"></a>9. 数据库隔离级别</h4><p>数据库事务的隔离级别有 4 种，由低到高分别为<code>Read uncommitted 、Read committed 、Repeatable read 、Serializable</code> 。而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。</p>
<ol>
<li>Read uncommitted<br>读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。</li>
<li>Read committed<br>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</li>
<li>Repeatable read<br>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。（MySQL 默认）</li>
<li>Serializable 序列化<br>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。<ul>
<li>与重复读的区别，个人理解：序列化是读写必加锁，两个事务完全互斥，不可能发生干扰。而重复读的要求没有那么严格（要弱上很多），要求在 A 事务期间，B 事务不会修改 A 事务所涉及的资源。</li>
</ul>
</li>
</ol>
<h4 id="10-如何提高服务器性能"><a href="#10-如何提高服务器性能" class="headerlink" title="10. 如何提高服务器性能"></a>10. 如何提高服务器性能</h4><p>单服务器的优化办法有：</p>
<ol>
<li>使用内存数据库；</li>
<li>使用 RDD（Resilient Distributed Datasets）；</li>
<li>增加缓存；</li>
<li>使用 SSD；</li>
<li>优化数据库；</li>
<li>选择合适的 IO 模型；</li>
<li>使用多核处理策略；</li>
<li>分布式部署程序。</li>
</ol>
<p>分布式服务器的相关技术栈：</p>
<ol>
<li>负载均衡（反向代理）；</li>
<li>应用服务器集群；</li>
<li>数据库集群、读写分离；</li>
<li>动静分离；</li>
<li>缓存；</li>
<li>消息中间件；</li>
<li>NoSQL；</li>
<li>分布式文件系统；</li>
<li>并行计算；</li>
<li>实时分析；</li>
<li>高可用、虚拟化、云计算；</li>
<li>CDN</li>
</ol>
<p>推荐阅读：<br><a href="https://blog.csdn.net/fanyun_01/article/details/79942408">服务器性能优化的8种常用方法</a></p>
<p><a href="http://www.cnblogs.com/linuxprobe/p/5407347.html">20个Linux服务器性能调优技巧</a></p>
<h4 id="11-有关类加载器的几点思考"><a href="#11-有关类加载器的几点思考" class="headerlink" title="11. 有关类加载器的几点思考"></a>11. 有关类加载器的几点思考</h4><p>常见的类加载器有三种：</p>
<ol>
<li>BootStrap（引导）：加载的基础文件，用 C 语言编写的。</li>
<li>ExtclassLoader（扩展）：同样加载基础文件，范围略大于 bootStrap。</li>
<li>AppclassLoader（应用）：加载 ClassPath 指定的所有 jar 和目录等。</li>
</ol>
<p>如何获得类加载器？</p>
<ul>
<li>由“字节码对象”（即内存中的 class），可以调 API 拿到其类加载器。</li>
</ul>
<p>拿到类加载器能干什么？</p>
<ul>
<li>可以通过类加载器读出 src 目录下的其他各种文件，主要读出各种配置文件如 properties 等。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line">class clazz <span class="operator">=</span> class.forName(<span class="string">&quot;Mydemo&quot;</span>)<span class="comment">;</span></span><br><span class="line">ClassLoader loader <span class="operator">=</span> clazz.getClassLoader()<span class="comment">;</span></span><br><span class="line">loader.getResource(<span class="string">&quot;jdbc.properties&quot;</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理3</title>
    <url>/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%863/</url>
    <content><![CDATA[<p>部分题目来源：<a href="https://www.nowcoder.com/discuss/108195">美团 java 后台 哈尔滨现场面试面经</a></p>
<h4 id="1-数据库主从同步、读写分离"><a href="#1-数据库主从同步、读写分离" class="headerlink" title="1. 数据库主从同步、读写分离"></a>1. 数据库主从同步、读写分离</h4><p>主要用来提升数据库的并发负载能力。</p>
<ul>
<li>数据的热备；</li>
<li>架构的扩展；</li>
<li>支持更大的并发；</li>
</ul>
<p>主从复制的步骤：</p>
<ol>
<li>从库生成两个线程，一个 IO 线程，一个 SQL 线程；</li>
<li>IO 线程去请求主库的 binlog，并将得到的 binlog 日志写入 relay log 文件中。主库会生成一个 binlog dump 线程，用来给从库的 IO 线程传 binlog；<ul>
<li>binlog是一个二进制格式的文件，用于记录用户对数据库更新的SQL语句信息（查询不会有记录，只记录增删改）。在 my.cnf 中增加<code>log_bin</code>参数即可开启。</li>
</ul>
</li>
<li>SQL 线程，会读取 relay log 文件中的日志（从 Exec_Master_Log_Pos 位置开始执行），并解析成具体操作，来实现主从的操作一致，而最终数据一致。</li>
</ol>
<p>缺点：</p>
<ol>
<li>数据的实时性较差；</li>
<li>数据量大时，同步效率差；</li>
<li>同时连接多个数据库，容易引起混乱；</li>
<li>读具有高性能高可靠性和可伸缩。只读服务器因为没有写操作，大大减轻磁盘 IO 等性能问题；多个只读服务器可以采用负载均衡的方式实现可伸缩性。</li>
<li>写数据的分配一般采用哈希映射。</li>
</ol>
<span id="more"></span>

<p>推荐阅读：</p>
<p><a href="https://blog.csdn.net/DarkAngel1228/article/details/80004222">MySQL主从复制面试之作用和原理</a><br><a href="https://blog.csdn.net/u012170724/article/details/50976886">数据库（二）读写分离</a></p>
<h4 id="2-MySQL-上主从同步如何配置，工作原理"><a href="#2-MySQL-上主从同步如何配置，工作原理" class="headerlink" title="2. MySQL 上主从同步如何配置，工作原理"></a>2. MySQL 上主从同步如何配置，工作原理</h4><ol>
<li>设置多个数据库服务器。</li>
<li>打开 master 上的 binlog，设置 slave 上的 relay-log。</li>
<li>将 master 和 slave 服务器关联起来，在 master 中执行：</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">user</span> repl;</span><br><span class="line">mysql&gt; <span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> SLAVE <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;从xxx.xxx.xxx.xx&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line">mysql&gt; flush <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个数据库用户 repl，密码是 mysql，在 slave 中使用 repl 这个账号和 master 连接时，就赋予其 replication slave 的权限，<code>*.*</code>表示这个权限是针对 master 的所有表，其中<code>***</code>就是 slave 的 ip 地址。</li>
<li>进入 slave 数据库后执行以下代码：</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to master_host=<span class="string">&#x27;主xxx.xxx.xxx.xx&#x27;</span>,master_port=<span class="number">3306</span>,master_user=<span class="string">&#x27;repl&#x27;</span>,master_password=<span class="string">&#x27;mysql&#x27;</span>,master_log_file=<span class="string">&#x27;master-bin.000001&#x27;</span>,master_log_pos=<span class="number">0</span>;</span><br><span class="line">mysql&gt;start slave; <span class="regexp">//</span> 开启主从同步</span><br><span class="line">mysql&gt;stop slave; <span class="regexp">//</span> 关闭主从同步</span><br><span class="line">mysql&gt;show slave status \G; <span class="regexp">//</span> 查看状态命令</span><br></pre></td></tr></table></figure>

<p>Ps:上面的<code>master_log_file=&#39;master-bin.000001&#39;</code>是配置 binlog 和 relay-log 后，执行<code>SHOW MASTER STATUS</code>命令后查到的。</p>
<ol start="4">
<li>此时在 master 数据库进行的操作，都会在 slave 库中执行了。</li>
</ol>
<p><a href="https://blog.csdn.net/starlh35/article/details/78735510">数据库读写分离，主从同步实现方法</a></p>
<h4 id="3-线程的状态转换图"><a href="#3-线程的状态转换图" class="headerlink" title="3. 线程的状态转换图"></a>3. 线程的状态转换图</h4><p><img src="/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%863/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.jpeg" alt="线程状态图"></p>
<p>Java 线程具有六种基本状态：</p>
<ol>
<li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>运行(RUNNABLE)：Java线程中将<strong>就绪</strong>（ready）和<strong>运行中</strong>（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>阻塞(BLOCKED)：表示线程阻塞于锁。</li>
<li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>终止(TERMINATED)：表示该线程已经执行完毕。</li>
</ol>
<p>参考阅读：<a href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 6 种状态及切换(透彻讲解)</a></p>
<h4 id="4-wait-和sleep-的区别"><a href="#4-wait-和sleep-的区别" class="headerlink" title="4. wait()和sleep()的区别"></a>4. wait()和sleep()的区别</h4><ol>
<li>wait()：当前线程让出锁和同步资源，进入等待队列，等待调用 notify()&#x2F;notifyAll()唤醒指定线程或者所有线程，被唤醒的线程需要重新参与线程的调度，而不会直接获得 CPU。而且，wait()方法只能在同步方法&#x2F;块中使用。</li>
<li>sleep()：当前正在执行的线程休眠一段时间，主动让出 CPU，但是不让出锁和同步资源。到时间后，自动恢复，CPU 继续执行该线程。</li>
</ol>
<h4 id="5-手撕代码：给定大小为n的数组，找出第K小的元素"><a href="#5-手撕代码：给定大小为n的数组，找出第K小的元素" class="headerlink" title="5. 手撕代码：给定大小为n的数组，找出第K小的元素"></a>5. 手撕代码：给定大小为n的数组，找出第K小的元素</h4><p>首先看一个简单的：最坏情况下如何利用 n+logN-2 次比较找到n个元素中的第2小的元素？</p>
<p>采用 tournament method 算法：对数组a[1…n]中元素成对的做比较，每次比较后将较小的数拿出，形成的数组再继续这样处理，直到剩下最后的一个，就是数组中最小的那个。将这个过程以一个树的形式表现出来,如下图：</p>
<p><img src="/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%863/12.jpg" alt="12"></p>
<p>在这个过程中，非树叶节点就是比较的次数，一共进行了n-1次比较，树根即为最小的元素。而第二小的元素一定是在这个过程中与根节点进行过比较的元素。即上图中5，3和2。这样的节点最多有 logN 个，在这些节点中找到最小的元素需要进行-1次比较。因此总共所需的比较次数为n-1 +logN-1&#x3D;n+ logN -2次。</p>
<h5 id="长度为-n-的数组中，寻找第-K-小的元素"><a href="#长度为-n-的数组中，寻找第-K-小的元素" class="headerlink" title="长度为 n 的数组中，寻找第 K 小的元素"></a>长度为 n 的数组中，寻找第 K 小的元素</h5><p>建大根堆。建立一个包含K个元素的最大堆，将后续的N-K每个数与堆顶元素比较，如果小于堆顶元素，则将其替换堆顶元素并调整堆得结构维护最大堆的性质，最后堆中包含有最小的K个元素，从而堆顶元素就是第K小的数。建堆的时间为O(K)，每次调整最大堆结构时间为O(lgK)，从而总的时间复杂度为O(K + (N-K)lgK)。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*得到第K小的数*/</span></span><br><span class="line"><span class="built_in">int</span> min<span class="constructor">K(<span class="params">int</span> A[], <span class="params">int</span> N, <span class="params">int</span> K)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> heap<span class="literal">[K+<span class="number">1</span>]</span>;</span><br><span class="line">    build<span class="constructor">_max_heap(<span class="params">heap</span>, A, K)</span>; <span class="comment">//以数组A的前K个元素建立大小为K的最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=K+<span class="number">1</span>; i&lt;=N; i++) &#123; <span class="comment">//遍历A[K+1]到A[N]，如果有小于堆顶元素，则替换堆顶元素并保持堆的性质。</span></span><br><span class="line">        <span class="keyword">if</span> (A<span class="literal">[<span class="identifier">i</span>]</span> &lt; heap<span class="literal">[<span class="number">1</span>]</span>) &#123;</span><br><span class="line">            heap<span class="literal">[<span class="number">1</span>]</span> = A<span class="literal">[<span class="identifier">i</span>]</span>;</span><br><span class="line">            max<span class="constructor">_heapify(<span class="params">heap</span>, 1, K)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return heap<span class="literal">[<span class="number">1</span>]</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*采用插入方法建立堆*/</span></span><br><span class="line">void build<span class="constructor">_max_heap(<span class="params">int</span> <span class="params">heap</span>[], <span class="params">int</span> A[], <span class="params">int</span> K)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> heapsize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">1</span>; i&lt;=K; i++) &#123;</span><br><span class="line">        max<span class="constructor">_heap_insert(<span class="params">heap</span>, A[<span class="params">i</span>], <span class="params">heapsize</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*将key插入到堆中，并保证最大堆的性质*/</span></span><br><span class="line">void max<span class="constructor">_heap_insert(<span class="params">int</span> <span class="params">heap</span>[], <span class="params">int</span> <span class="params">key</span>, <span class="params">int</span> &amp;<span class="params">heapsize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    heapsize++;</span><br><span class="line">    heap<span class="literal">[<span class="identifier">heapsize</span>]</span> = INT_MIN;</span><br><span class="line">    heap<span class="constructor">_increase_key(<span class="params">heap</span>, <span class="params">heapsize</span>, <span class="params">key</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*将堆中heap[i]的关键字增大为key*/</span></span><br><span class="line">void heap<span class="constructor">_increase_key(<span class="params">int</span> <span class="params">heap</span>[], <span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">key</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">assert</span>(key &gt;= heap<span class="literal">[<span class="identifier">i</span>]</span>);</span><br><span class="line">    heap<span class="literal">[<span class="identifier">i</span>]</span> = key;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;<span class="number">1</span><span class="operator"> &amp;&amp; </span>heap<span class="literal">[<span class="identifier">parent</span>(<span class="identifier">i</span>)]</span>&lt;heap<span class="literal">[<span class="identifier">i</span>]</span>) &#123;</span><br><span class="line">        swap(heap, i, parent(i));</span><br><span class="line">        i = parent(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*保持堆的性质*/</span> </span><br><span class="line">void max<span class="constructor">_heapify(<span class="params">int</span> A[], <span class="params">int</span> <span class="params">i</span>, <span class="params">int</span> <span class="params">heapsize</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> l = left(i);</span><br><span class="line">    <span class="built_in">int</span> r = right(i);</span><br><span class="line">    <span class="built_in">int</span> largest = i;</span><br><span class="line">    <span class="keyword">if</span> (l&lt;=heapsize<span class="operator"> &amp;&amp; </span>A<span class="literal">[<span class="identifier">l</span>]</span>&gt;A<span class="literal">[<span class="identifier">i</span>]</span>)</span><br><span class="line">        largest = l;</span><br><span class="line">    <span class="keyword">if</span> (r&lt;=heapsize<span class="operator"> &amp;&amp; </span>A<span class="literal">[<span class="identifier">r</span>]</span>&gt;A<span class="literal">[<span class="identifier">largest</span>]</span>)</span><br><span class="line">        largest = r;</span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        swap(A, i, largest);</span><br><span class="line">        max<span class="constructor">_heapify(A, <span class="params">largest</span>, <span class="params">heapsize</span>)</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-线程同步的方法"><a href="#6-线程同步的方法" class="headerlink" title="6.  线程同步的方法"></a>6.  线程同步的方法</h4><p>推荐阅读：<a href="https://blog.csdn.net/u010842515/article/details/65443084">Synchronized 同步静态方法和非静态方法总结</a></p>
<ul>
<li><p>Synchronized 修饰非静态方法时，相当于对调用该方法的<strong>对象</strong>加锁。</p>
<ul>
<li>同一个对象，在两个线程中分别访问该对象的两个同步方法，会产生互斥。</li>
<li>不同对象在两个线程中调用同一个同步方法，不会产生互斥。</li>
</ul>
</li>
<li><p>Synchronized 修饰静态方法时，相当于对该<strong>类</strong>加锁。</p>
<ul>
<li>用类直接在两个线程中调用两个不同的同步方法，会产生互斥。</li>
<li>用一个类的静态成员对象在两个线程中调用静态方法和非静态方法，会产生互斥。</li>
<li>一个类的普通对象在两个线程中分别调用一个静态同步方法和一个非静态方法，不会产生互斥。</li>
</ul>
</li>
<li><p>同步方法：可以是静态和非静态方法，不可以是抽象和接口方法。</p>
<ul>
<li>当一个线程调用这个对象的同步方法，则这个对象的其他所有同步方法将被锁定，不能被调用，但非同步方法可以被另外的线程调用。</li>
</ul>
</li>
</ul>
<h4 id="7-spring-管理的controller是单例的，怎么实现的？"><a href="#7-spring-管理的controller是单例的，怎么实现的？" class="headerlink" title="7. spring 管理的controller是单例的，怎么实现的？"></a>7. spring 管理的controller是单例的，怎么实现的？</h4><p><a href="https://www.nowcoder.com/discuss/111444">问题来自海康一面</a></p>
<p>Spring 的 Controller 默认是 Singleton 的，这意味着每个 request  过来，系统都会用原有的 instance 去处理，这样导致了两个结果:</p>
<ol>
<li>一是我们不用每次创建 Controller；</li>
<li>二是减少了对象创建和垃圾收集的时间。</li>
</ol>
<ul>
<li>由于只有一个 Controller 的 instance，当多个线程调用它的时候，它里面的 instance 变量就不是线程安全的了，会发生窜数据的问题。当然大多数情况下，我们根本不需要考虑线程安全的问题，比如 dao,service 等，除非在 bean 中声明了实例变量。因此，我们在使用 spring mvc 的 controller 时，应避免在 controller 中定义实例变量。</li>
<li>如果一定要使用成员变量，可以采用以下方式：<ul>
<li>在 Controller 中声明 scope&#x3D;”prototype” ，即设置为多例模式。</li>
<li>在 Controller 中使用 ThreadLoader 变量。</li>
</ul>
</li>
</ul>
<p>实现：因为 spring 的 controller 默认就是单例，所以当 spring 创建 applicationContext 容器时，spring 会先初始化所有的该作用域实例，加上 lazy-init 就可以避免预处理。</p>
<h4 id="8-为什么使用JDBC-时需要反射"><a href="#8-为什么使用JDBC-时需要反射" class="headerlink" title="8. 为什么使用JDBC 时需要反射"></a>8. 为什么使用JDBC 时需要反射</h4><ol>
<li>通过反射获取<code>Class.forName(&quot;..Driver&quot;)</code>所在线程的上下文类加载器（通常是系统类加载器）。</li>
<li>利用类加载器，加载数据库驱动并初始化，其中有个 boolean 判断。</li>
<li>判断通过，则返回 Connection（即数据库厂商提供的实例）。</li>
</ol>
<p>主要原因：因为 JVM 双亲委托机制的限制，启动类加载器不可能加载得到第三方厂商提供的具体实验。有了线程上下文类加载器，启动类加载器（根加载器）反倒需要委托子类加载器去加载厂商提供的实现。<br>将父委托变成子委托的方式。</p>
<p>参考《Java 高并发编程详解》第11章 P178 详述<br>也可以参考<a href="http://likehui.fun/2019/01/11/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%865/">面经整理5</a>的第 2 题</p>
<h4 id="9-mysql-中-char-和-varchar-的区别"><a href="#9-mysql-中-char-和-varchar-的区别" class="headerlink" title="9. mysql 中 char 和 varchar 的区别"></a>9. mysql 中 char 和 varchar 的区别</h4><ol>
<li>char 和 varchar 在存储和检索方面有所不同。</li>
<li>char 长度为创建表时声明的长度（定长），长度值范围在 1 到 255。Varchar 存储可变长的字符数据。而且varchar 会用额外的字节来记录字符串的长度。</li>
</ol>
<p><a href="https://blog.csdn.net/Gane_Cheng/article/details/52316408">推荐阅读</a></p>
<h4 id="10-BLOB和TEXT有什么区别？"><a href="#10-BLOB和TEXT有什么区别？" class="headerlink" title="10. BLOB和TEXT有什么区别？"></a>10. BLOB和TEXT有什么区别？</h4><ol>
<li>BLOB是一个二进制对象，可以容纳可变数量的数据。TEXT是一个不区分大小写的BLOB。</li>
<li>BLOB和TEXT类型之间的唯一区别在于对BLOB值进行排序和比较时区分大小写（即有排序规则和字符集），对TEXT值不区分大小写（即没有排序规则和字符集）。</li>
<li>简单说，如果要存储中文，就选 TEXT。</li>
</ol>
<p><a href="https://blog.csdn.net/qq_35440678/article/details/51793658">推荐阅读</a></p>
<h4 id="11-什么情况下设置了索引但无法使用"><a href="#11-什么情况下设置了索引但无法使用" class="headerlink" title="11. 什么情况下设置了索引但无法使用"></a>11. 什么情况下设置了索引但无法使用</h4><ol>
<li>以“%”开头的LIKE语句，模糊匹配</li>
<li>OR语句前后没有同时使用索引</li>
<li>数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）</li>
</ol>
<h4 id="12-解释MySQL外连接、内连接与自连接的区别"><a href="#12-解释MySQL外连接、内连接与自连接的区别" class="headerlink" title="12. 解释MySQL外连接、内连接与自连接的区别"></a>12. 解释MySQL外连接、内连接与自连接的区别</h4><ul>
<li>先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。</li>
<li>内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。</li>
<li>外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。</li>
<li>左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL来填充。</li>
<li>右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。</li>
</ul>
<p><strong>左连接和右连接可以互换，MySQL目前还不支持全外连接。</strong></p>
<h4 id="13-悲观锁和乐观锁的-sql-实现"><a href="#13-悲观锁和乐观锁的-sql-实现" class="headerlink" title="13. 悲观锁和乐观锁的 sql 实现"></a>13. 悲观锁和乐观锁的 sql 实现</h4><p><strong>悲观锁：</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Begin Tran</span><br><span class="line">select top 1 @<span class="attribute">TrainNo</span>=T_NO</span><br><span class="line"><span class="keyword">from</span> Train_ticket with (UPDLOCK)  </span><br><span class="line">where <span class="attribute">S_Flag</span>=0  </span><br><span class="line">update Train_ticket  user,  <span class="attribute">T_Time</span>=getdate(),   <span class="attribute">S_Flag</span>=1  </span><br><span class="line">where <span class="attribute">T_NO</span>=@TrainNo </span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<p>查询的时候使用了with (UPDLOCK)选项,在查询记录的时候我们就对记录加上了更新锁,表示我们即将对此记录进行更新。其他用户还可以查询此表的内容，但其他更新用户就会阻塞。</p>
<p><strong>乐观锁：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 首先给表加一列 <span class="type">timestamp</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ttt <span class="keyword">ADD</span> timesFlag <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 然后更新时判断这个值是否被修改</span><br><span class="line"><span class="keyword">declare</span> <span class="variable">@count</span> <span class="keyword">as</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@flag</span> <span class="keyword">AS</span> <span class="type">TIMESTAMP</span></span><br><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@rowCount</span> <span class="keyword">AS</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">begin</span> tran</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@count</span><span class="operator">=</span>COUNT,<span class="variable">@flag</span><span class="operator">=</span>timesFlag<span class="operator">=</span><span class="variable">@flag</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@rowCount</span><span class="operator">=</span>@<span class="variable">@ROWCOUNT</span></span><br><span class="line"><span class="keyword">commit</span> tran</span><br><span class="line">IF <span class="variable">@rowCount</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line">PRINT ‘’更新成功”</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    PRINT”更新失败”</span><br></pre></td></tr></table></figure>

<p>　这便是乐观锁的解决方案，可以解决并发带来的数据错误问题，但不保证每一次调用更新都成功，可能会返回’更新失败’</p>
<p><a href="https://www.cnblogs.com/chenwolong/p/Lock.html">推荐阅读</a></p>
<h4 id="14-spring-MVC-和-Spring-boot-的区别"><a href="#14-spring-MVC-和-Spring-boot-的区别" class="headerlink" title="14. spring MVC 和 Spring boot 的区别"></a>14. spring MVC 和 Spring boot 的区别</h4><p><strong>SpringMVC：</strong></p>
<ol>
<li>   SpringMVC是Spring提供的一个强大而灵活的模块式web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。</li>
<li>   SpringMVC是一种基于Java的以请求为驱动类型的轻量级Web框架，其目的是将Web层进行解耦，即使用“请求-响应”模型，从工程结构上实现良好的分层，区分职责，简化Web开发。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。</li>
<li>   Spring框架最核心的就是所谓的依赖注射和控制反转。完全解耦类之间的依赖关系，一个类如果要依赖什么，那就是一个接口。至于如何实现这个接口，这都不重要了。只要拿到一个实现了这个接口的类，就可以轻松的通过xml配置文件把实现类注射到调用接口的那个类里。所有类之间的这种依赖关系就完全通过配置文件的方式替代了。</li>
</ol>
<p><strong>SpringBoot：</strong></p>
<ol>
<li>   Spring Boot引入自动配置的概念，让项目设置变得很容易。Spring Boot本身并不提供Spring框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于Spring框架的应用程序，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</li>
<li>   Spring Boot只是承载者，辅助开发者简化项目搭建过程的。如果承载的是WEB项目，使用Spring MVC作为MVC框架，那么工作流程和SpringMVC的是完全一样的，因为这部分工作是Spring MVC做的而不是Spring Boot。</li>
</ol>
<p><strong>联系：</strong></p>
<ul>
<li>Spring 最初利用“工厂模式”（ DI ）和“代理模式”（ AOP ）解耦应用组件。按照这种模式搞了一个 MVC 框架（一些用 Spring 解耦的组件），用开发 web 应用（ SpringMVC ）。</li>
<li>后来发现每次开发都要搞很多依赖，写很多样板代码，使代码臃肿而麻烦，于是聪明的前人整理了一些懒人整合包（ starter ），这套就是 Spring Boot 。</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>Spring MVC 是基于 Servlet 的一个 MVC框架 主要解决 WEB 开发的问题 但关于Spring 的配置比较 ；</li>
<li>而Spring boot 的原则是：约定优于配置 ，可以极大地简化了 spring 的配置流程。</li>
</ul>
<p><a href="https://www.cnblogs.com/piwefei/p/9149973.html">推荐阅读</a></p>
<h4 id="15-类加载机制中，什么时候进行静态变量的初始化"><a href="#15-类加载机制中，什么时候进行静态变量的初始化" class="headerlink" title="15. 类加载机制中，什么时候进行静态变量的初始化"></a>15. 类加载机制中，什么时候进行静态变量的初始化</h4><p>静态变量的初始化是在类被初始化时（类加载过程中的初始化阶段）进行的。而这个类，只有被首次主动使用时，才会被初始化。</p>
<p>主动使用的情况有六类：</p>
<ol>
<li>通过 new 关键词。</li>
<li>访问类的静态变量（但 final 修饰的静态变量实质上是静态常量，不属于此范畴，不会初始化类）。</li>
<li>访问类的静态方法。</li>
<li>对类进行反射操作。</li>
<li>初始化子类会导致父类的初始化。</li>
<li>启动类。也就是 main 函数所在的类会被初始化。</li>
</ol>
<p>参考本站另一篇博文：<a href="http://likehui.fun/2018/12/22/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E7%AC%94%E8%AE%B0/">类加载机制笔记</a></p>
<h4 id="16-线程池的拒绝策略"><a href="#16-线程池的拒绝策略" class="headerlink" title="16. 线程池的拒绝策略"></a>16. 线程池的拒绝策略</h4><ol>
<li>CallerRunsPolicy：线程调用运行该任务的 execute 本身。这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。</li>
<li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException。这种策略直接抛出异常，丢弃任务。</li>
<li>DiscardPolicy：不能执行的任务将被删除。这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。</li>
<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。</li>
</ol>
<h4 id="17-GC-Roots-有哪些？"><a href="#17-GC-Roots-有哪些？" class="headerlink" title="17. GC Roots 有哪些？"></a>17. GC Roots 有哪些？</h4><p>所谓“GC roots”，或者说tracing GC的“根集合”，就是<strong>一组必须活跃的引用</strong>（而不是对象）</p>
<p>这些引用可能包括：</p>
<ol>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数&#x2F;局部变量&#x2F;临时值。</li>
<li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles</li>
<li>（看情况）所有当前被加载的Java类</li>
<li>（看情况）Java类的引用类型静态变量</li>
<li>（看情况）Java类的运行时常量池里的引用类型常量（String或Class类型）</li>
<li>（看情况）String常量池（StringTable）里的引用</li>
</ol>
<p><a href="https://blog.csdn.net/leishenop/article/details/53728605">推荐阅读</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理4</title>
    <url>/2019/01/05/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%864/</url>
    <content><![CDATA[<h3 id="1-Spring是怎么避免循环依赖的"><a href="#1-Spring是怎么避免循环依赖的" class="headerlink" title="1. Spring是怎么避免循环依赖的"></a>1. Spring是怎么避免循环依赖的</h3><p><strong>循环依赖的问题</strong>：在DI时，如果有两个 class 类，都在 xml 文件中配置，但是如果 classA 是 classB 的属性，classB 同时也是 classA 的属性，那么该怎么处理呢？究竟先注入哪一个呢？</p>
<p>Spring是如何避免循环依赖的？</p>
<ul>
<li>答：Spring基于Java的引用传递，我们获取到对象的引用时，对象的field或者属性是可以延后设置的。但Spring避免循环依赖有一个前提：那就是循环依赖不能发生在构造器中。</li>
</ul>
<p>Spring 的单例对象的初始化主要分为三步：</p>
<ol>
<li>createBeanInstance实例化；</li>
<li>populateBean填充属性；</li>
<li>InitializeBean初始化。</li>
</ol>
<p>循环依赖就是两个对象（设为A，B）在①②步时发生冲突的。</p>
<p>Spring使用了一个叫<code>singletonFactories</code>的三级cache机制，让本该发生A-B-A循环依赖中的B走到第①步时，可以拿到A（虽然A此时并不完整，仅走了①②两步），但足以让B能够走完剩下的②③步。B完成后，A可以继续完成自己的第③步。</p>
<span id="more"></span>

<p>推荐阅读：</p>
<p><a href="https://my.oschina.net/yibuliushen/blog/737640">从spring源码角度分析循环依赖bean的组装</a></p>
<p><a href="https://my.oschina.net/jack19910921/blog/1802290">Spring是怎么解决循环依赖的</a></p>
<h3 id="2-说说数据库的三大范式"><a href="#2-说说数据库的三大范式" class="headerlink" title="2. 说说数据库的三大范式"></a>2. 说说数据库的三大范式</h3><p>第一范式：</p>
<ul>
<li>无重复的列，数据库每一列都是不可分割的基本数据项。下面这种情况违反1NF：</li>
</ul>
<p><img src="/2019/01/05/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%864/1.png"></p>
<p>第二范式：</p>
<ul>
<li>属性完全依赖于主键。每一列都与主键相关，而不能只与主键（联合主键）的某一部分相关。下面这种情况违反2NF：<ul>
<li>存在关系：选课（学号，课程名，姓名，成绩）。其中主键为（学号，课程名），但是姓名仅与学号相关。违反2NF。</li>
</ul>
</li>
</ul>
<p>第三范式：</p>
<ul>
<li>数据表中的每一列都和主键直接相关，而不是间接相关。下面这种情况违反3NF：<ul>
<li>存在关系：学生（姓名，院系，学院主任）。其中姓名是主键，但学院主任与姓名是间接相关，违反3NF。</li>
</ul>
</li>
</ul>
<h3 id="3-MyBatis中-和-区别"><a href="#3-MyBatis中-和-区别" class="headerlink" title="3. MyBatis中#{}和${}区别"></a>3. MyBatis中#{}和${}区别</h3><p><code>$&#123;&#125;</code>：sql拼接符号。<br><code>#&#123;&#125;</code>：占位符号，好处防止sql注入。</p>
<ul>
<li>sql 预编译指的是数据库驱动在发送 sql 语句和参数给 DBMS 之前对 sql 语句进行编译，这样 DBMS 执行 sql 时，就不需要重新编译。</li>
<li>${ } 变量的替换阶段是在动态 SQL 解析阶段，而 #{ }变量的替换是在 DBMS 中。</li>
<li>先发生<code>$&#123; &#125; </code>，后发生<code>#&#123; &#125;</code></li>
</ul>
<h4 id><a href="#" class="headerlink" title="${}"></a><code>$&#123;&#125;</code></h4><ul>
<li><p>仅为纯粹的String替换，在动态SQL解析阶段将进行变量替换（接受传参）<br>比如将Mapper.xml 下的：</p>
<p>  <code>select * from user where name = $&#123;name&#125;;</code></p>
</li>
<li><p>如果传参为“Tom”，那么SQL解析后：</p>
<p>  <code>select * from user where name = &quot;Tom&quot;;</code></p>
</li>
</ul>
<h4 id="-1"><a href="#-1" class="headerlink" title="#{}"></a><code>#&#123;&#125;</code></h4><ul>
<li><p>解析为一个 JDBC 预编译语句（prepared statement）的参数标记符。<br>比如将Mapper.xml 下的：</p>
<p>  <code>select * from user where name = #&#123;name&#125;;</code></p>
</li>
<li><p>动态解析为：</p>
<p>  <code>select * from user where name = ?;  // 一个#&#123;&#125;被解析为？</code></p>
</li>
</ul>
<p>用法：</p>
<ol>
<li>能使用 #{ } 的地方就用 #{ }</li>
<li>表名作为变量时，必须使用 ${}</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/sunny3096/p/8590901.html">MyBatis中#和$的区别</a></p>
<h3 id="4-建一个索引的SQL语句"><a href="#4-建一个索引的SQL语句" class="headerlink" title="4. 建一个索引的SQL语句"></a>4. 建一个索引的SQL语句</h3><p>方法一：ALTER TABLE，下面分别是创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<ol>
<li>   ALTER TABLE table_name ADD INDEX index_name (column_list)</li>
<li>   ALTER TABLE table_name ADD UNIQUE (column_list)</li>
<li>   ALTER TABLE table_name ADD PRIMARY KEY (column_list)</li>
</ol>
<p>方法二：CREATE INDEX，可对表增加普通索引或UNIQUE索引（不能增加主键索引）。</p>
<ol>
<li>   CREATE INDEX index_name ON table_name (column_list)</li>
<li>   CREATE UNIQUE INDEX index_name ON table_name (column_list)</li>
</ol>
<p>PS：column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<h4 id="两种方法的区别："><a href="#两种方法的区别：" class="headerlink" title="两种方法的区别："></a>两种方法的区别：</h4><ul>
<li>用方法1时，索引名index_name可选，缺省时，MySQL将根据第一个索引列赋一个名称。一个语句可以建立多个索引。</li>
<li>使用方法二时，必须提供index_name，不能缺省。而且，一个语句只能建立一个索引。</li>
</ul>
<p>推荐阅读：</p>
<p><a href="https://www.jianshu.com/p/e109aea6eb7c">MySQL索引的查看创建和删除</a></p>
<p><a href="https://www.cnblogs.com/timxgb/p/5844880.html">mysql 添加索引，ALTER TABLE和CREATE INDEX的区别</a></p>
<h3 id="5-面试中的红黑树"><a href="#5-面试中的红黑树" class="headerlink" title="5. 面试中的红黑树"></a>5. 面试中的红黑树</h3><p>推荐阅读：</p>
<p><a href="https://blog.csdn.net/qq_34173549/article/details/79636764">java面试-彻底搞懂红黑树</a></p>
<p><a href="https://www.cnblogs.com/wuchanming/p/4444961.html">面试题——轻松搞定面试中的红黑树问题</a></p>
<h3 id="6-JDBC-的预编译语句"><a href="#6-JDBC-的预编译语句" class="headerlink" title="6. JDBC 的预编译语句"></a>6. JDBC 的预编译语句</h3><ul>
<li>没有预编译时，直接执行 Statement的情况（数据库引擎对 SQL 语句进行编译）。<ul>
<li>Statement 的 execute 系列方法直接将 SQL 语句作为参数传入并提交给数据库。每提交一次，都需要先编译再执行。</li>
<li>问题出现了：如果有需要重复执行的 SQL 语句，每次都要经过编译这样效率太低。</li>
<li>存在 SQL 注入隐患。</li>
</ul>
</li>
<li>使用预编译语句的情况，使用 PreparedStatement 语句句柄，同时传入 SQL 语句。这里使用的预编译机制，如下：<ul>
<li>支持占位符<code>?</code>，可以等到后期再决定这些占位符具体的值（占位符只能站位普通值，不能站位表名、列名、SQL 关键字等）。</li>
<li>利用缓存机制（调用 getCachePreparedStatements()方法实现），将预编译语句语法与缓存中匹配，在有些时候可以不需再次编译即可直接执行。缓存的选择涉及到了使用频度等因素。</li>
<li>使用了预编译语句，传入的任何内容都不会和原来的语句发生任何匹配关系。</li>
</ul>
</li>
</ul>
<p>推荐阅读：</p>
<p><a href="https://blog.csdn.net/zhangw1236/article/details/59113941">jdbc中预编译语句PreparedStatement的深层分析</a><br><a href="https://blog.csdn.net/Lirx_Tech/article/details/51148853">JDBC：PreparedStatement预编译执行SQL语句</a></p>
<h3 id="7-Linux进程管理的相关命令"><a href="#7-Linux进程管理的相关命令" class="headerlink" title="7. Linux进程管理的相关命令"></a>7. Linux进程管理的相关命令</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##显示所有进程详细信息</span><br><span class="line">ps aux</span><br><span class="line"></span><br><span class="line">## -C 通过名字或者命令搜索进程</span><br><span class="line">ps -C apache2</span><br><span class="line"></span><br><span class="line">##显示一个进程的所有线程  -L 参数</span><br><span class="line">ps -p <span class="number">3150</span> -L</span><br><span class="line"></span><br><span class="line">##发送指定的信号到相应进程。不指定型号将发送SIGTERM（<span class="number">15</span>）终止指定进程。 关闭进程号<span class="number">12</span>的进程</span><br><span class="line">kill <span class="number">12</span></span><br><span class="line"></span><br><span class="line">##如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(<span class="number">9</span>) ，将强制结束进程  </span><br><span class="line">kill <span class="number">-9</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line">##pstree命令：列出当前的进程，以及它们的树状结构  格式：pstree [选项] [pid|user]</span><br><span class="line">pstree</span><br><span class="line"></span><br><span class="line">##nice命令：改变程序执行的优先权等级 应用程序优先权值的范围从<span class="number">-20</span>～<span class="number">19</span>，数字越小，优先权就越高。一般情况下，普通应用程序的优先权值（CPU使用权值）都是<span class="number">0</span>，如果让常用程序拥有较高的优先权等级，自然启动和运行速度都会快些。需要注意的是普通用户只能在<span class="number">0</span>～<span class="number">19</span>之间调整应用程序的优先权值，只有超级用户有权调整更高的优先权值（从<span class="number">-20</span>～<span class="number">19</span>）。</span><br><span class="line">nice [-n &lt;优先等级&gt;][--help][--version][命令]</span><br><span class="line">nice -n <span class="number">5</span> ls</span><br><span class="line"></span><br><span class="line">##top 动态查看进程的变化。</span><br><span class="line">top</span><br></pre></td></tr></table></figure>

<p>推荐阅读：<a href="https://blog.csdn.net/zhongweijian/article/details/46468627">linux 进程管理相关命令汇总</a></p>
<h3 id="8-多线程的使用场景"><a href="#8-多线程的使用场景" class="headerlink" title="8. 多线程的使用场景"></a>8. 多线程的使用场景</h3><ol>
<li>常见的浏览器应用。</li>
<li>Servlet多线程。（Servlet采用的是单实例多线程，参考：<a href="https://blog.csdn.net/hello5orld/article/details/19207053%EF%BC%89%E3%80%82">https://blog.csdn.net/hello5orld/article/details/19207053）。</a></li>
<li>FTP下载，多线程操作文件。</li>
<li>数据库用到的多线程。</li>
<li>分布式计算。</li>
<li>Tomcat 内部的多线程。</li>
<li>后台任务：比如后台批量发送邮件、监控任务等。</li>
<li>自动作业处理：比如定期备份日志，定期备份数据库。</li>
<li>异步处理：比如发微博、记录日志。</li>
<li>页面异步处理：比如大批量数据的核对工作（有10万个手机号码，核对哪些是已有用户）。</li>
<li>数据库的大量数据分析、数据迁移。</li>
<li>多步骤的任务处理，多任务分割。</li>
<li>Desktop应用开发，前台进度条显示。</li>
<li>Swing 编程。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/hll814/article/details/50816268">多线程的应用场景</a></p>
<h3 id="9-代码实现提取URL中传的参数和值，保存键值对"><a href="#9-代码实现提取URL中传的参数和值，保存键值对" class="headerlink" title="9. 代码实现提取URL中传的参数和值，保存键值对"></a>9. 代码实现提取URL中传的参数和值，保存键值对</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			url = <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://test.com?name=abcd&amp;id=1&amp;age=18&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(getParamByUrl(url, <span class="string">&quot;age&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;=========&quot;</span>);</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getParamByUrl</span><span class="params">(URL url,String name)</span>&#123;</span><br><span class="line">		String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// URL 类的 getQuery()方法可以获取 URL 中的参数</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">Query</span> <span class="operator">=</span> url.getQuery();</span><br><span class="line">		String[] queries = Query.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(String query : queries)&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> query.substring(<span class="number">0</span>,query.indexOf(<span class="string">&quot;=&quot;</span>));</span><br><span class="line">			<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> query.substring(query.indexOf(<span class="string">&quot;=&quot;</span>)+<span class="number">1</span>,query.length());</span><br><span class="line">			map.put(key,value);</span><br><span class="line">			<span class="keyword">if</span>(name.equals(key))&#123;</span><br><span class="line">				result = value;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="section">18</span></span><br><span class="line"><span class="section">=========</span></span><br><span class="line">&#123;name=abcd, id=1, age=18&#125;</span><br></pre></td></tr></table></figure>

<p>PS：本题有多种实现方式，此处借助了java.net.URL 类的方法。</p>
<h3 id="10-代码实现N的平方根，不考虑四舍五入取平方根"><a href="#10-代码实现N的平方根，不考虑四舍五入取平方根" class="headerlink" title="10. 代码实现N的平方根，不考虑四舍五入取平方根"></a>10. 代码实现N的平方根，不考虑四舍五入取平方根</h3><p>使用<a href="https://www.matongxue.com/madocs/205.html#/madoc">牛顿迭代法</a>获取 N 的平方根:<br>令f(x) &#x3D; x^2 - N。方程的零根，就是所求的平方根。<br>步骤：</p>
<ol>
<li>取一点<code>（Xn，f(Xn)）</code>，切线方程：<code>f(x) = 2Xn*x - Xn^2 - N</code>，切线与X轴交点<code>（(Xn + N/Xn)/2，0）</code>（设为(Xn+1，0)）。</li>
<li>根据牛顿迭代定理，Xn+1 是越来越接近目标值的，此处我们使用误差控制，来近似计算平方根。推荐阅读：<a href="https://blog.csdn.net/dawnbreak/article/details/3308413">牛顿迭代法计算平方根</a></li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> sqrtRoot(<span class="keyword">float</span> m ,<span class="keyword">float</span> precise)&#123;</span><br><span class="line">	<span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">float</span> err = precise != <span class="keyword">null</span> ? precise : <span class="number">1</span>e-<span class="number">7</span>;</span><br><span class="line">	<span class="keyword">float</span> i = <span class="number">0</span>,x;</span><br><span class="line">	<span class="keyword">while</span>((i*i) &lt;= m)&#123;</span><br><span class="line">		i+=<span class="number">0.1</span>;  <span class="comment">// 求出比平方根略大的一个数当作初始值</span></span><br><span class="line">	&#125;</span><br><span class="line">	x = i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">abs</span>(x1*x1-m)&gt;err)&#123;</span><br><span class="line">		x = (x+ m<span class="regexp">/x)/</span><span class="number">2</span>; <span class="comment">// 迭代出结果</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用牛顿迭代法的常见限制条件：</p>
<ol>
<li>函数在定义域最好是二阶可导的；</li>
<li>起始点对求根计算影响较大，可以增加一些别的判断手段先试错。</li>
</ol>
<h3 id="11-P2P-下载"><a href="#11-P2P-下载" class="headerlink" title="11. P2P 下载"></a>11. P2P 下载</h3><p>BT种子有什么信息？</p>
<ul>
<li>文件分块信息、分块哈希值（目的是下载时进行校验，防止恶意数据攻击）。此部分占空间大头。</li>
<li>中央服务器（问询服务器，tracker）的地址。<ul>
<li>中央服务器的作用：记录节点服务器。</li>
</ul>
</li>
<li>文件或者文件夹内每个文件的名字。</li>
<li>其他辅助信息。</li>
</ul>
<p>读取 BT 种子下载的流程：</p>
<ol>
<li>读取 BT 种子信息并载入内存。</li>
<li>告知问询服务器自己要下载，问询服务器会记录该客户端的公网IP。同时告知该客户端还有多少人也在下载这个文件（告知客户端有哪些 IP）。在下载过程中，需要 5 分钟跟 tracker 通信一次，如果太久不通信，tracker 会把这个客户端从节点列表中删除。</li>
<li>客户端拿到一堆 IP 后，会挨个尝试连接，连上了就开始互相通讯。<ul>
<li>通讯内容告诉对方，比如我有哪些块、缺哪些块。</li>
<li>然后你来我往开始了下载。</li>
</ul>
</li>
</ol>
<p>辅助技术：</p>
<ul>
<li>DHT技术。如果 tracker 服务器连不上了，可以通过分布式哈希表 DHT 技术，在 DHT 网络中慢慢寻找志同道合的邻居节点。</li>
<li>与运营商的相爱相杀。</li>
<li>BT 对磁盘的调度、缓存的机制、文件分块的调度算法、服务器对百万千万级别用户量的性能提升等。</li>
</ul>
<p>推荐阅读：<a href="https://www.zhihu.com/question/49829233">BT种子的原理是什么？</a></p>
<h3 id="12-MySQL中有哪几种日志"><a href="#12-MySQL中有哪几种日志" class="headerlink" title="12. MySQL中有哪几种日志"></a>12. MySQL中有哪几种日志</h3><p>MySQL中有以下几种日志文件：</p>
<ol>
<li>重做日志 redo log</li>
<li>回滚日志 undo log</li>
<li>二进制日志 binlog（用于主从同步）</li>
<li>错误日志 errorlog</li>
<li>慢查询日志 slow query log</li>
<li>一般查询日志 general log</li>
<li>中继日志 relay log</li>
</ol>
<p>推荐阅读：<a href="http://database.51cto.com/art/201806/576300.htm">MySQL到底有多少种日志类型</a></p>
<h3 id="13-LVS-的几种模型"><a href="#13-LVS-的几种模型" class="headerlink" title="13. LVS 的几种模型"></a>13. LVS 的几种模型</h3><p>&#x2F;&#x2F; todo</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理6</title>
    <url>/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/</url>
    <content><![CDATA[<p>SSM系列问题推荐阅读：<a href="https://blog.csdn.net/mrleeapple/article/details/78464723">SSM常见面试问题</a></p>
<p>汇总：趣链、蘑菇街、随手记、网易、招银、IBM、阿里</p>
<h1 id="趣链Java一面之lh篇"><a href="#趣链Java一面之lh篇" class="headerlink" title="趣链Java一面之lh篇"></a>趣链Java一面之lh篇</h1><p>自我介绍。<br>讲一下项目。</p>
<h3 id="1-类加载的过程。"><a href="#1-类加载的过程。" class="headerlink" title="1. 类加载的过程。"></a>1. 类加载的过程。</h3><p>三个阶段：加载、连接、初始化。</p>
<ul>
<li>加载：①class文件加载到内存中；②方法区生成运行时类文件；③堆区生成class对象，作为访问方法区中类文件的访问入口。</li>
<li>连接：①验证文件正确性；②为类的静态变量分配内存，并初始化默认值；③符号引用转换成直接引用。</li>
<li>初始化：为类变量赋予正确的初始值。</li>
</ul>
<span id="more"></span>

<p>详解 classLoader 的loadClass</p>
<h3 id="PriorityQueue-实现大根堆"><a href="#PriorityQueue-实现大根堆" class="headerlink" title="PriorityQueue 实现大根堆"></a>PriorityQueue 实现大根堆</h3><p>因为 PriorityQueue默认是小根堆，那么该怎么实现大根堆呢？</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line">Queue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(DEFAULT_INITIAL_CAPACITY, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> o2-o1; <span class="comment">// 关键：compare函数 return的结果如果小于0则保持原位置，大于 0 则交换。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>compartor 采用了策略模式，使用策略对象来改变它的行为。</p>
<p>comparator 用法扩展阅读 <a href="https://blog.csdn.net/u012250875/article/details/55126531">Comparator的用法</a></p>
<h3 id="2-用过哪些集合类。"><a href="#2-用过哪些集合类。" class="headerlink" title="2. 用过哪些集合类。"></a>2. 用过哪些集合类。</h3><p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/3.png"></p>
<p>Map、List、Set。<br>List：ArrayList、LinkedList、Vector；<br>Map：HashMap、HashTable、TreeMap、LinkedHashMap</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TreeMap 自定义Comparator，先按名字排序，名字相同者按年龄排序：</span></span><br><span class="line">TreeMap&lt;Student,String&gt; tmap = <span class="keyword">new</span> TreeMap&lt;Student,String&gt;(<span class="keyword">new</span> Comparator&lt;Student&gt;<span class="literal">()</span>&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public <span class="built_in">int</span> compare(Student s1,Student s2)&#123;</span><br><span class="line">		<span class="built_in">int</span> num = s1.get<span class="constructor">Name()</span>.compare<span class="constructor">To(<span class="params">s2</span>.<span class="params">getName</span>()</span>);</span><br><span class="line">		<span class="keyword">if</span>(num<span class="operator"> == </span><span class="number">0</span>)&#123;</span><br><span class="line">			return <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">s1</span>.<span class="params">getAge</span>()</span>).compare<span class="constructor">To(<span class="params">s2</span>.<span class="params">getAge</span>()</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		return num;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-HashMap和HashTable区别。"><a href="#3-HashMap和HashTable区别。" class="headerlink" title="3. HashMap和HashTable区别。"></a>3. HashMap和HashTable区别。</h3><ul>
<li>HashMap：①线程不安全；②key和value可为null；③扩容机制不同：初始默认16，两倍扩容。④链表长度大于8后，且桶的数量大于等于64 时，链表转为红黑树（桶数量低于64时会优先扩容）。</li>
<li>HashTable: ① 线程安全，Synchronized锁，效率低，目前已经用ConcurrentHashMap代替使用；②key不可为null；③初始默认11，2n+1扩容。④没有转红黑树的机制。</li>
</ul>
<h3 id="4-讲一下FutureTask，怎么获取返回值的，其他几种多线程的实现比较。"><a href="#4-讲一下FutureTask，怎么获取返回值的，其他几种多线程的实现比较。" class="headerlink" title="4. 讲一下FutureTask，怎么获取返回值的，其他几种多线程的实现比较。"></a>4. 讲一下FutureTask，怎么获取返回值的，其他几种多线程的实现比较。</h3><p>深度解析 futureTask：</p>
<ol>
<li>关键点一：RunnableFuture 接口，它同时继承了 Runnable、Future 两个接口，而 FutureTask 正是它的实现类。</li>
<li>关键点二：用户自己实现的 <code>**Callable</code> 实现类。</li>
<li>执行步骤：<ol>
<li>首先对线程池执行 <code>submit(**Callable)</code>方法，内部 <code>**Callable</code> 是作为参数放进 FutureTask 实例（<code>**FutureTask</code>）中的，所以其实是在执行<code>execute（**FutureTask）</code>，而带有业务逻辑的<code> call()</code>方法逻辑也就顺理成章的成了<code> run()</code>方法逻辑。</li>
<li><code>execute(**FutureTask)</code>方法会触发<code>**FutureTask</code>的<code>run()</code>方法，执行完成后，会封装成 <code>Future</code> 对象返回。</li>
<li>最后可以通过<code>**FutureTask.get()</code>方法拿到返回值（get 方法其实是线程阻塞的，所以 java 中的 Future 用法并不是真正意义上的异步操作）。</li>
<li>注：可以使用 <code>Thread.start()</code>方法代替线程池执行的<code> submit()</code>方法，两者后面的执行逻辑是相似的。</li>
</ol>
</li>
</ol>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ①FutureTask 单独使用</span></span><br><span class="line"><span class="comment">/** 1. Callable接口及发散的类，带着线程工作逻辑，被new出来。</span></span><br><span class="line"><span class="comment"> *  2. Future接口及发散类，new时传入Callable实例。</span></span><br><span class="line"><span class="comment"> *  3. Thread接口及发散类，new 时传入Future实例。</span></span><br><span class="line"><span class="comment"> *  4. 启动线程，可以get返回值（get方法会阻塞线程，）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstruceCallable</span>&lt;<span class="title">V</span>&gt; <span class="keyword"><span class="keyword">implements</span> <span class="type">Callable</span></span>&lt;<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> V call() throws Exception&#123;</span><br><span class="line">		<span class="comment">// todo 业务逻辑</span></span><br><span class="line">		<span class="keyword">return</span> V;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Callable&lt;V&gt; oneCallable = <span class="keyword">new</span> <span class="type">ConstruceCallable</span>&lt;V&gt;();</span><br><span class="line">FutureTask&lt;V&gt; task = <span class="keyword">new</span> <span class="type">FutureTask</span>&lt;V&gt;(oneCallable);</span><br><span class="line">Thread thread = <span class="keyword">new</span> <span class="type">Thread</span>(task);</span><br><span class="line">thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">task.<span class="keyword">get</span>(); <span class="comment">// 拿到返回值V </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ②FutureTask 结合线程池使用</span></span><br><span class="line"><span class="comment">/** 1. new 一个 ThreadPoolExecutor</span></span><br><span class="line"><span class="comment"> *  2. 在一个List&lt;FutureTask&gt; 中，逐个新增FutureTask实例</span></span><br><span class="line"><span class="comment"> *  3. 接收task列表，执行executor.submit 方法</span></span><br><span class="line"><span class="comment"> *  4. 遍历list获取返回值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> <span class="type">ThreadPoolExecutor</span>(<span class="number">5</span>,<span class="number">10</span>,<span class="number">10</span>L,</span><br><span class="line">		TimeUnit.SECONDS,<span class="keyword">new</span> <span class="type">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">10</span>));</span><br><span class="line">List&lt;FutureTask&gt; tasks = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(int i =<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">	FutureTask task = <span class="keyword">new</span> <span class="type">FutureTask</span>(<span class="keyword">new</span> <span class="type">SomeCallable</span>());</span><br><span class="line">	executor.submit(task);</span><br><span class="line">	tasks.add(task);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(FutureTask futureTask : <span class="type">tasks</span>)&#123;</span><br><span class="line">	System.out.println(futureTask.<span class="keyword">get</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比较：</p>
<blockquote>
<p>线程池七大参数的关系：其中比较容易让人误解的是：corePoolSize，maximumPoolSize，workQueue之间关系。<br>1.当线程数小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。<br>2.当线程数达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行<br>3.当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务<br>4.当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理<br>5.当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程<br>6.当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭 </p>
</blockquote>
<p>线程池的四种拒绝策略：</p>
<ol>
<li>CallerRunsPolicy：线程调用运行该任务的 execute 本身。这个策略显然不想放弃执行任务。但是由于池中已经没有任何资源了，那么就直接使用调用该execute的线程本身来执行。</li>
<li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException。这种策略直接抛出异常，丢弃任务。</li>
<li>DiscardPolicy：不能执行的任务将被删除。这种策略和AbortPolicy几乎一样，也是丢弃任务，只不过他不抛出异常。</li>
<li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序。该策略就稍微复杂一些，在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务，然后重新尝试运行该任务。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/duoduo18up/article/details/80245414">FutureTask的底层实现</a></p>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4><p>new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</strong></p>
<h3 id="5-MySQL怎么实现事务的，在SSM框架中你是怎么做的？"><a href="#5-MySQL怎么实现事务的，在SSM框架中你是怎么做的？" class="headerlink" title="5. MySQL怎么实现事务的，在SSM框架中你是怎么做的？"></a>5. MySQL怎么实现事务的，在SSM框架中你是怎么做的？</h3><h3 id="6-用过哪些设计模式，讲一个你最常用的，讲一下你对代理模式的理解。"><a href="#6-用过哪些设计模式，讲一个你最常用的，讲一下你对代理模式的理解。" class="headerlink" title="6. 用过哪些设计模式，讲一个你最常用的，讲一下你对代理模式的理解。"></a>6. 用过哪些设计模式，讲一个你最常用的，讲一下你对代理模式的理解。</h3><ol>
<li>代理模式就是通过代理来控制对象的访问。可以详细访问到对象的方法，并且在方法先后添加一些业务逻辑。</li>
<li>主要用在AOP、事务、日志打印、权限控制、远程调用、安全代理等。</li>
<li>代理模式通常有两种实现方式：静态代理和动态代理，后者又有两种实现，jdk和cglib。<ol>
<li>静态代理，一般就是加一层包装类的形式，原始类当作参数传入包装类，通过调用包装类间接调用目标对象。</li>
<li>jdk 方式，使用 implements 了InvocationHandler 的某类 handler，将原始接口target当作参数field传入构造方法，然后在代理类中invoke 方法中调用 method.invoke(target,args )。main方法首先获取这个某类 handler，然后通过 Proxy.newProxyInstance 拿到实例，之后随便调用 target 类的方法。</li>
</ol>
</li>
<li>jdk：面向接口生成代理，自带的Proxy和InvocationHandler。</li>
</ol>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/1.png"></p>
<ol start="4">
<li><p>cglib：没有接口这一硬性条件。基于ASM，是一种直接操作字节码的框架，推荐阅读：<a href="https://www.cnblogs.com/xrq730/p/6661692.html">Cglib及其基本使用</a></p>
</li>
<li><p>详细参考第 11 题。</p>
</li>
<li><p>ASM 阅读推荐：<a href="https://blog.csdn.net/zhuoxiuwu/article/details/78619645">ASM</a>，精华总结如下：</p>
<ol>
<li><p>ASM 是一种动态修改字节码数组的工具，跟一般的代理类有所区别，ASM 的最终目的是生成可以被装载的class 文件。</p>
</li>
<li><p>ASM技术对程序员隐藏了字节码偏移的细节，程序员只需要操作一个类似于树的数据结构，对字节码进行遍历即可。</p>
</li>
<li><p>具体做法是实现一个ClassVisitor 接口的类，重写相关的visit 方法，ASM 会自动调用这些 visit 方法</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下例子中重写了 visitField 方法，将修饰符修改为 Private</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccessClassAdapter</span> <span class="keyword">extends</span> <span class="title class_">ClassAdapter</span> &#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AccessClassAdapter</span><span class="params">(ClassVisitor cv)</span> &#123; </span><br><span class="line">    <span class="built_in">super</span>(cv); </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> FieldVisitor <span class="title function_">visitField</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> access, <span class="keyword">final</span> String name, </span></span><br><span class="line"><span class="params"><span class="keyword">final</span> String desc, <span class="keyword">final</span> String signature, <span class="keyword">final</span> Object value)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">privateAccess</span> <span class="operator">=</span> Opcodes.ACC_PRIVATE; </span><br><span class="line">    <span class="keyword">return</span> cv.visitField(privateAccess, name, desc, signature, value); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<h3 id="7-手写反转单链表。"><a href="#7-手写反转单链表。" class="headerlink" title="7. 手写反转单链表。"></a>7. 手写反转单链表。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">null</span> == head || <span class="literal">null</span> == head.next())&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode pre, cur, next;</span><br><span class="line">  pre = <span class="literal">null</span>; cur = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">null</span> != cur)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == cur.next())&#123;</span><br><span class="line">      <span class="comment">// cur 是原链最后一个结点</span></span><br><span class="line">      cur.next() = pre;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next = cur.next();  <span class="comment">// 核心思路：</span></span><br><span class="line">    cur.next() = pre;   <span class="comment">// 1. 让 cur 的后继指针指向它的 pre</span></span><br><span class="line">    pre = cur;          <span class="comment">// 2. 用 next 记住 cur 移动的下一位，保证不断链</span></span><br><span class="line">    cur = next;					<span class="comment">// 3. 再让 cur 来到 next 的位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  head.next() = cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按步骤 123 依此进行反转</p>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/reverse.jpg"></p>
<h3 id="8-项目中实现了哪些功能。有没有文字处理的功能。"><a href="#8-项目中实现了哪些功能。有没有文字处理的功能。" class="headerlink" title="8. 项目中实现了哪些功能。有没有文字处理的功能。"></a>8. 项目中实现了哪些功能。有没有文字处理的功能。</h3><p>个人项目流程：</p>
<ol>
<li>将java代码生成字节数组；<ul>
<li>1.1 热替换字节码数组；</li>
<li>1.2 自定义类加载器；</li>
</ul>
</li>
<li>然后将字节数组转换成Class类（类加载）；</li>
<li>反射调用的方式执行代码，获得执行结果；</li>
</ol>
<p>扩展：HotSpot 将字节码编译成机器码的两种方式：</p>
<ol>
<li>解释执行：需要时，将字节码逐条翻译成机器码并执行。<ul>
<li>优点：无需等待编译。</li>
<li>约占80%代码。</li>
</ul>
</li>
<li>编译执行：将部分字节码提前全部翻译好，然后执行，即 JIT。<ul>
<li>优点：实际运行速度更快。</li>
<li>采取了分层编译的方式，内置多个即时编译器，这些编译器有着不同的编译速度和各自特色，可以根据程序运行信息选取合适编译器，对编译后的执行效率进行优化。</li>
<li>约占20%代码。</li>
</ul>
</li>
<li>混合模式中，大部分打码采用解释执行，对于反复执行的热点代码，以方法为单位进行编译执行。</li>
</ol>
<h3 id="补充-：字节码中与方法调用相关的指令"><a href="#补充-：字节码中与方法调用相关的指令" class="headerlink" title="补充 ：字节码中与方法调用相关的指令"></a>补充 ：字节码中与方法调用相关的指令</h3><ol>
<li>invokestatic：用于调用静态方法；</li>
<li>invokespecial：用于调用私有实例方法、构造器，以及使用 super关键字调用父类的实例方法或构造器，和所实现接口的默认方法；</li>
<li>invokevirtual：用于调用非私有实例方法；</li>
<li>invokeinterface：用于调用接口方法；</li>
<li>invokedynamic：用于调用动态方法。</li>
</ol>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/6.png"></p>
<p>参考“《深入拆解 Java 虚拟机（极客时间）》04.JVM 是如何执行方法调用的（上）？”</p>
<h4 id="虚方法调用对性能影响很大"><a href="#虚方法调用对性能影响很大" class="headerlink" title="虚方法调用对性能影响很大"></a>虚方法调用对性能影响很大</h4><p>所以 JIT 采取了两种优化手段：内联缓存和方法内联，用来加速动态绑定。</p>
<ol>
<li>内联缓存：核心过程：利用缓存（快），避免基于方法表的动态绑定（慢）。<ul>
<li><p>缓存内容：虚方法中调用者的动态类型，以及该类型对应的目标方法。		- 所谓动态类型，就是运行时在程序内部动态生成的类或者类型。从多态的角度来看，理解为不同的子类这种情况。</p>
</li>
<li><p>分类：单态内联（JVM 中采用），多态内联，超多态内联。</p>
<ul>
<li>多态内联，缓存多种动态类型及其目标方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>参考“《深入拆解 Java 虚拟机（极客时间）》05.JVM 是如何执行方法调用的（下）？”</p>
<h3 id="9-知道JavaCompile的底层实现吗，具体怎么做的？不调api，你会怎么实现这个功能？"><a href="#9-知道JavaCompile的底层实现吗，具体怎么做的？不调api，你会怎么实现这个功能？" class="headerlink" title="9. 知道JavaCompile的底层实现吗，具体怎么做的？不调api，你会怎么实现这个功能？"></a>9. 知道JavaCompile的底层实现吗，具体怎么做的？不调api，你会怎么实现这个功能？</h3><h3 id="10-讲一下spring的ioc原理，怎么实现依赖注入的，具体是在哪一个环节注入属性的？"><a href="#10-讲一下spring的ioc原理，怎么实现依赖注入的，具体是在哪一个环节注入属性的？" class="headerlink" title="10. 讲一下spring的ioc原理，怎么实现依赖注入的，具体是在哪一个环节注入属性的？"></a>10. 讲一下spring的ioc原理，怎么实现依赖注入的，具体是在哪一个环节注入属性的？</h3><p>IOC实现：</p>
<ol>
<li>首先要有一个 Resource 接口及发散的几个类，用于解决IOC容器中内容从哪里来的问题。也就是配置文件从哪里读、怎么读的问题。</li>
<li>然后要有一个 BeanDefiniton 类及发散的几个类，用来解决Bean的具体定义问题（包括名字、类型、属性值或引用等），相当于把这些告诉IOC容器，让容器可以根据这个定义创建实例。</li>
<li>然后要有一个 BeanFactory 接口及发散的几个类，用于解决 IOC 容器在已获取到 Bean 的定义情况下，如何装配、获取Bean实例的问题。<ul>
<li>其中有一个<code>AutowireCapableBeanFactory </code>类，是一种具有<strong>自动装配功能</strong>的BeanFactory，实现了<code>doCreateBean</code>方法。具体有三步：①通过 BeanDefinition 中保存的类信息实例化一个对象；②把对象保存在 BeanDefinition 中，以备下次获取；③为其装配属性。装配属性时，通过 BeanDefinition 中维护的 PropertyValues 集合类，把 String - Value 键值对注入到 Bean 的属性中去。如果 Value 的类型是 BeanReference 则说明其是一个引用（对应于 XML 中的 ref），通过 getBean 对其进行获取，然后注入到属性中。</li>
</ul>
</li>
<li>最后要有一个 ApplicationContext 接口及发散的几个类，对前面三个进行功能的封装，解决根据地址获得IOC容器并使用的问题。</li>
</ol>
<p>依赖注入：	<strong>组件之间的依赖关系由容器在运行期间确定。</strong></p>
<ol>
<li>应用程序依赖于IOC容器，由IOC容器将对象需要的外部资源（比如其他对象、资源、常量数据等），注入到这个对象中。</li>
<li>BeanDefinition决定了依赖的具体关系的定义。</li>
<li>BeanFactory 进行注入的实施工作。</li>
</ol>
<p>墙裂推荐阅读：<a href="https://www.zybuluo.com/dugu9sword/note/382745">tiny-spring 分析</a><br>IOC与DI的区别讲的很好：<a href="https://blog.csdn.net/sinat_21843047/article/details/80297951">控制反转和依赖注入的理解(通俗易懂)</a></p>
<ul>
<li>bean的实例化前调用，也就是将AbsractBeanDefinition转换为BeanWrapper 前的处理。给子类一个修改BeanDefinition的机会，也就是说当程序经过这个方法（即<code>applyBeanPostProcessorsBeforeInstantiation()</code>）后，bean可能已经不是我们认为的bean了，而是或许成为了一个经过处理的代理bean，可能是通过 cglib 生成的，也可能是通过其它技术生成的。</li>
</ul>
<p>上一段参考：<a href="http://book.51cto.com/art/201311/419089.htm">实例化的前置处理</a></p>
<h3 id="11-aop的实现原理，你的项目中怎么做的？"><a href="#11-aop的实现原理，你的项目中怎么做的？" class="headerlink" title="11. aop的实现原理，你的项目中怎么做的？"></a>11. aop的实现原理，你的项目中怎么做的？</h3><p>JDK的方式：</p>
<ol>
<li>可以通过 Proxy 的 <code>newProxyInstance(obj.getClassLoader(), obj.getClass().getInterfaces(), handler)</code>，可以返回 obj 的代理对象 proxy。</li>
<li>InvocationHandler 接口有个invoke方法。当调用proxy.func(args)方法时，对象内部将委托给 handler.invoke(proxy, func, args) 函数实现。</li>
</ol>
<p>cglib的方式：</p>
<p>利用BeanPostProcessor接口和BeanFactoryAware接口，分别可以获取AOP在IOC容器中植入的位置，以及为哪些对象提供植入的清单。<br>切点通知器PointcutAdvisor类，用于提供对哪个对象的哪个方法进行什么样的拦截 的具体内容。动态代理的步骤：</p>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/2.png"></p>
<p>口述过程：首先是，在所有的Bean被实例化之前，“创造代理对象”的类即AutoProxyCreator先被实例化；普通bean在被实例化、初始化时，判断类是否是要被拦截的目标，如果是，则取出这个类的信息，并找到“欲拦截的方法”，“拦截的具体操作”，统统交给AopProxy生成代理。AopProxy生成一个InvocationHandler，在其中的invoke方法被执行。</p>
<p>代码实现及原理剖析：<a href="https://blog.csdn.net/wenbingoon/article/details/8988553">Spring AOP 实现原理</a></p>
<h3 id="12-HTTP请求涉及的协议，以及依次用到的协议的先后顺序。"><a href="#12-HTTP请求涉及的协议，以及依次用到的协议的先后顺序。" class="headerlink" title="12. HTTP请求涉及的协议，以及依次用到的协议的先后顺序。"></a>12. HTTP请求涉及的协议，以及依次用到的协议的先后顺序。</h3><p><a href="https://blog.csdn.net/myxyj/article/details/80027700">访问一个URL经历了哪些过程（最详尽版！）</a></p>
<h3 id="13-HTTPS请求的过程，这个过程是在TCP建立连接之前还是之后？"><a href="#13-HTTPS请求的过程，这个过程是在TCP建立连接之前还是之后？" class="headerlink" title="13. HTTPS请求的过程，这个过程是在TCP建立连接之前还是之后？"></a>13. HTTPS请求的过程，这个过程是在TCP建立连接之前还是之后？</h3><p>当然是之后了。</p>
<h3 id="14-安全证书和server公钥之间的关系。"><a href="#14-安全证书和server公钥之间的关系。" class="headerlink" title="14. 安全证书和server公钥之间的关系。"></a>14. 安全证书和server公钥之间的关系。</h3><blockquote>
<p>数字证书 &#x3D; 数字签名 + （server 的公钥 &amp; server 的个人信息）。</p>
</blockquote>
<blockquote>
<p>其中（server 的公钥 &amp; server 的个人信息）可以使用 Hash 算法得到消息摘要。<br>消息摘要使用 CA 的私钥可以得到数字签名。<br>client 验证证书的过程：</p>
</blockquote>
<blockquote>
<p>取出证书中的（server 的公钥 &amp; server 的个人信息），使用相同的 Hash 算法得到消息摘要1；<br>取出证书中的数字签名，使用 CA 的公钥解密，得到消息摘要2；<br>比较两份消息摘要，如果不同，说明可能遭到了篡改。</p>
</blockquote>
<h3 id="15-Redis的持久化机制。"><a href="#15-Redis的持久化机制。" class="headerlink" title="15. Redis的持久化机制。"></a>15. Redis的持久化机制。</h3><h3 id="16-有没有做过Redis集群？"><a href="#16-有没有做过Redis集群？" class="headerlink" title="16. 有没有做过Redis集群？"></a>16. 有没有做过Redis集群？</h3><h3 id="17-redis的主从复制是怎么一个过程？"><a href="#17-redis的主从复制是怎么一个过程？" class="headerlink" title="17. redis的主从复制是怎么一个过程？"></a>17. redis的主从复制是怎么一个过程？</h3><ol>
<li>单向的，只能从master到slave。</li>
<li>作用：数据热备、服务冗余（备机）、读写分离（负载均衡）、实现高可用的基础。</li>
<li>过程：<ol>
<li>slave 开启主从复制，slave存储有master的ip 和端口信息；slave每秒一次调用复制函数，一旦发现有可用主机，就根据ip和端口创建socket连接；slave发送ping命令进行首次请求；身份验证；将自身端口信息发给master。</li>
<li>数据同步：可分为全量复制和部分复制两种模式。</li>
<li>同步完后，master发送写命令给slave，slave执行写命令。此阶段master-slave之间还维持心跳机制。</li>
</ol>
</li>
<li>心跳机制：用于主从复制的超时判断、数据安全。心跳机制过程：master -&gt; slave 发送ping；slave -&gt; master 发送replconf ack。</li>
<li>主从复制可能出现的问题：延迟不一致（措施：监控延迟）；数据过期（定期删、惰性删）；故障切换（哨兵）；复制超时、复制中断（超时释放资源或者重新建立连接）。</li>
</ol>
<p>参考阅读：<a href="https://www.cnblogs.com/kismetv/p/9236731.html#t1">深入学习Redis（3）：主从复制</a></p>
<h3 id="18-知道zookeeper吗？讲一下"><a href="#18-知道zookeeper吗？讲一下" class="headerlink" title="18. 知道zookeeper吗？讲一下"></a>18. 知道zookeeper吗？讲一下</h3><h3 id="19-知道git-flow吗？讲一下"><a href="#19-知道git-flow吗？讲一下" class="headerlink" title="19. 知道git flow吗？讲一下"></a>19. 知道git flow吗？讲一下</h3><p>Gitflow 工作流程使用两个并行的、长期运行的分支来记录项目的历史记录，分别是 master 和 develop 分支。</p>
<ul>
<li>Master，随时准备发布线上版本的分支，其所有内容都是经过全面测试和核准的（生产就绪）。<ul>
<li>Hotfix，维护（maintenance）或修复（hotfix）分支是用于给快速给生产版本修复打补丁的。修复（hotfix）分支很像发布（release）分支和功能（feature）分支，除非它们是基于 master 而不是 develop 分支。</li>
</ul>
</li>
<li>Develop，是合并所有功能（feature）分支，并执行所有测试的分支。只有当所有内容都经过彻底检查和修复后，才能合并到 master 分支。<ul>
<li>Feature，每个功能都应留在自己的分支中开发，可以推送到 develop 分支作为功能（feature）分支的父分支。</li>
</ul>
</li>
</ul>
<h3 id="20-JVM中的堆最大量在32位，64位机器上的区别。"><a href="#20-JVM中的堆最大量在32位，64位机器上的区别。" class="headerlink" title="20. JVM中的堆最大量在32位，64位机器上的区别。"></a>20. JVM中的堆最大量在32位，64位机器上的区别。</h3><h3 id="21-redis怎么实现过期的？"><a href="#21-redis怎么实现过期的？" class="headerlink" title="21. redis怎么实现过期的？"></a>21. redis怎么实现过期的？</h3><h3 id="22-redis-的-lru？"><a href="#22-redis-的-lru？" class="headerlink" title="22. redis 的 lru？"></a>22. redis 的 lru？</h3><p>有很多种实现，这里提两种：链表法，链表&amp;HashMap 法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 链表法，伪代码</span></span><br><span class="line">List&lt;Integer&gt; lru = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Entry entry)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">this</span>.get(entry.key) != -<span class="number">1</span>)&#123;</span><br><span class="line">		lru.putHead(lru.get(entry));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		lru.putHead(entry);</span><br><span class="line">		<span class="keyword">if</span>(IsFull() == <span class="literal">true</span>)&#123;</span><br><span class="line">			lru.dropTail();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表&amp;HashMap 法 ，待补充</span></span><br></pre></td></tr></table></figure>



<h3 id="23-用过微服务吗？"><a href="#23-用过微服务吗？" class="headerlink" title="23. 用过微服务吗？"></a>23. 用过微服务吗？</h3><h3 id="24-linux操作熟悉吗？"><a href="#24-linux操作熟悉吗？" class="headerlink" title="24. linux操作熟悉吗？"></a>24. linux操作熟悉吗？</h3><h1 id="蘑菇街-Java-一面"><a href="#蘑菇街-Java-一面" class="headerlink" title="蘑菇街 Java 一面"></a>蘑菇街 Java 一面</h1><h3 id="1-项目中做词法、语法解析了吗？"><a href="#1-项目中做词法、语法解析了吗？" class="headerlink" title="1. 项目中做词法、语法解析了吗？"></a>1. 项目中做词法、语法解析了吗？</h3><h3 id="2-项目中旧的字节码有没有做卸载？"><a href="#2-项目中旧的字节码有没有做卸载？" class="headerlink" title="2. 项目中旧的字节码有没有做卸载？"></a>2. 项目中旧的字节码有没有做卸载？</h3><p><a href="https://www.cnblogs.com/pony1223/p/8654720.html"><a href="https://www.cnblogs.com/pony1223/p/8654720.html">JVM学习七：JVM之类加载器之类的卸载</a></a></p>
<p>精华：</p>
<pre><code>1. 加载时，方法区形成某类的二进制数据（运行时数据结构），对应堆中该类的 class 对象（类的实例对象，唯一存在，除非类被卸载了，也就是比如`**ServiceImpl.class`指代的东西），之后不管是 new 还是反射或者 newInstance 拿到的都是另一种实例对象，跟上面的 class 对象不一样。
2. 卸载就是对 class 对象、classLoader 对象的引用都删除的过程。怎么删除？让栈中对 classLoader 的引用、对 class 对象的引用，对实例对象的引用，以及实例对象都置 null 即可。
</code></pre>
<h3 id="3-写多线程一般用到哪些类？"><a href="#3-写多线程一般用到哪些类？" class="headerlink" title="3. 写多线程一般用到哪些类？"></a>3. 写多线程一般用到哪些类？</h3><h3 id="4-多线程的可见性问题，为什么会有这个问题？"><a href="#4-多线程的可见性问题，为什么会有这个问题？" class="headerlink" title="4. 多线程的可见性问题，为什么会有这个问题？"></a>4. 多线程的可见性问题，为什么会有这个问题？</h3><h3 id="5-G1-原理？"><a href="#5-G1-原理？" class="headerlink" title="5. G1 原理？"></a>5. G1 原理？</h3><h3 id="6-maven-使用的中央仓库，还是自己做了-maven-镜像？"><a href="#6-maven-使用的中央仓库，还是自己做了-maven-镜像？" class="headerlink" title="6. maven 使用的中央仓库，还是自己做了 maven 镜像？"></a>6. maven 使用的中央仓库，还是自己做了 maven 镜像？</h3><h3 id="7-MySQL-数据库的主从复制。"><a href="#7-MySQL-数据库的主从复制。" class="headerlink" title="7. MySQL 数据库的主从复制。"></a>7. MySQL 数据库的主从复制。</h3><h3 id="8-TCP-的拆包、粘包问题。"><a href="#8-TCP-的拆包、粘包问题。" class="headerlink" title="8. TCP 的拆包、粘包问题。"></a>8. TCP 的拆包、粘包问题。</h3><p>前置知识：</p>
<ul>
<li>UDP 是基于报文的，不会发生拆包、粘包现象。UDP 首部有一个参数会指出数据报文长度，因此在应用层可以很好地将不同的数据报文区分开。</li>
<li>TCP 是基于字节流的，在 TCP 的首部没有表示数据长度的字段，所以可能发生拆包、粘包的现象。</li>
</ul>
<h4 id="什么是拆包、粘包"><a href="#什么是拆包、粘包" class="headerlink" title="什么是拆包、粘包"></a>什么是拆包、粘包</h4><ol>
<li>接收端收到的一个包中，存在着发送端发来的两个包的数据，即出现了粘包，主要问题：接收端不知两个数据包边界。</li>
<li>接收端收到两个包，但这两个包要么是缺少一端，要么是多出一部分，主要问题：同时出现了拆包跟粘包。</li>
</ol>
<h4 id="发生的原因："><a href="#发生的原因：" class="headerlink" title="发生的原因："></a>发生的原因：</h4><p>拆包：一次发送数据大于缓存区大小、最大报文长度。</p>
<p>粘包：缓存区多个包的数据一次性发出去；接收端应用层没有及时读取缓存区数据包。</p>
<h4 id="TCP-采用的解决办法："><a href="#TCP-采用的解决办法：" class="headerlink" title="TCP 采用的解决办法："></a>TCP 采用的解决办法：</h4><p>解决原则：让每一个数据包知道自己的边界信息。具体：</p>
<ol>
<li>发送端可以将每一个包封装成固定的长度不足补0，接收端每次从缓冲区读取固定长度的数据。</li>
<li>在包之间设置边界，比如添加特殊标记等。</li>
<li>包首部增加包长度的字段。</li>
</ol>
<p>参考资料：<a href="https://blog.csdn.net/wxy941011/article/details/80428470">TCP粘包，拆包及解决方法</a></p>
<h3 id="9-一般-Web-开发会分为几层？"><a href="#9-一般-Web-开发会分为几层？" class="headerlink" title="9. 一般 Web 开发会分为几层？"></a>9. 一般 Web 开发会分为几层？</h3><h3 id="10-如果使用单例模式拿到的对象，在-JVM-中只能有一个吗？"><a href="#10-如果使用单例模式拿到的对象，在-JVM-中只能有一个吗？" class="headerlink" title="10. 如果使用单例模式拿到的对象，在 JVM 中只能有一个吗？"></a>10. 如果使用单例模式拿到的对象，在 JVM 中只能有一个吗？</h3><h3 id="11-一个Tomcat-可以部署多个项目吗？"><a href="#11-一个Tomcat-可以部署多个项目吗？" class="headerlink" title="11. 一个Tomcat 可以部署多个项目吗？"></a>11. 一个Tomcat 可以部署多个项目吗？</h3><h3 id="12-一个-Tomcat-是运行在一个-JVM-上的吗？（其实是问-Tomcat-跟-JVM-的关系）"><a href="#12-一个-Tomcat-是运行在一个-JVM-上的吗？（其实是问-Tomcat-跟-JVM-的关系）" class="headerlink" title="12. 一个 Tomcat 是运行在一个 JVM 上的吗？（其实是问 Tomcat 跟 JVM 的关系）"></a>12. 一个 Tomcat 是运行在一个 JVM 上的吗？（其实是问 Tomcat 跟 JVM 的关系）</h3><p>JVM ：Tomcat ：J2EE &#x3D; 1 : 1 : N。运行应用程序的 JVM 就是运行 Tomcat 的那个 JVM。</p>
<p>参考：<a href="http://likehui.fun/2019/01/11/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%865/">面经整理5</a>，进入页面搜索“Tomcat”即可。</p>
<h3 id="13-一个-JVM-上多个应用程序，他们有可能发生类冲突吗？jar-包冲突吗？"><a href="#13-一个-JVM-上多个应用程序，他们有可能发生类冲突吗？jar-包冲突吗？" class="headerlink" title="13. 一个 JVM 上多个应用程序，他们有可能发生类冲突吗？jar 包冲突吗？"></a>13. 一个 JVM 上多个应用程序，他们有可能发生类冲突吗？jar 包冲突吗？</h3><h3 id="14-Tomcat-的-classLoader-架构图？"><a href="#14-Tomcat-的-classLoader-架构图？" class="headerlink" title="14. Tomcat 的 classLoader 架构图？"></a>14. Tomcat 的 classLoader 架构图？</h3><h1 id="随手记-Java-一面"><a href="#随手记-Java-一面" class="headerlink" title="随手记 Java 一面"></a>随手记 Java 一面</h1><h3 id="1-Redis-缓存有个过期时间，过期了也就没了，或者有一种比较实时的，修改时马上修改这个缓存吗？"><a href="#1-Redis-缓存有个过期时间，过期了也就没了，或者有一种比较实时的，修改时马上修改这个缓存吗？" class="headerlink" title="1. Redis 缓存有个过期时间，过期了也就没了，或者有一种比较实时的，修改时马上修改这个缓存吗？"></a>1. Redis 缓存有个过期时间，过期了也就没了，或者有一种比较实时的，修改时马上修改这个缓存吗？</h3><ul>
<li>项目中采用的是高一致性的主动更新策略。拿到真实数据后，立即更新缓存数据。<ul>
<li>如果采用弱一致性的做法，可以只更新缓存，然后让缓存异步地批量更新数据库。</li>
</ul>
</li>
<li>对于交互时保存的缓存数据 ，设置过期时间。请求接口时，先请求Redis缓存，如果命中则返回命中数据，否则还是执行HTTP请求调用接口。</li>
</ul>
<h3 id="2-更新记录时，你是怎么让Redis知道自己的缓存失效的？"><a href="#2-更新记录时，你是怎么让Redis知道自己的缓存失效的？" class="headerlink" title="2. 更新记录时，你是怎么让Redis知道自己的缓存失效的？"></a>2. 更新记录时，你是怎么让Redis知道自己的缓存失效的？</h3><h3 id="3-JVM类加载的默认加载先后顺序。"><a href="#3-JVM类加载的默认加载先后顺序。" class="headerlink" title="3. JVM类加载的默认加载先后顺序。"></a>3. JVM类加载的默认加载先后顺序。</h3><p>检查类是否已被加载的检查顺序是自底而上，尝试加载顺序是自顶而下。<br>推荐阅读：<a href="https://blog.csdn.net/eff666/article/details/52203406">java中类的加载顺序介绍(ClassLoader)</a></p>
<h3 id="4-四种GC算法的细节，优缺点比较。"><a href="#4-四种GC算法的细节，优缺点比较。" class="headerlink" title="4. 四种GC算法的细节，优缺点比较。"></a>4. 四种GC算法的细节，优缺点比较。</h3><h3 id="5-分代收集算法中，新生代使用什么算法？"><a href="#5-分代收集算法中，新生代使用什么算法？" class="headerlink" title="5. 分代收集算法中，新生代使用什么算法？"></a>5. 分代收集算法中，新生代使用什么算法？</h3><h3 id="6-新生代、老年代各采用什么算法？为什么用？"><a href="#6-新生代、老年代各采用什么算法？为什么用？" class="headerlink" title="6. 新生代、老年代各采用什么算法？为什么用？"></a>6. 新生代、老年代各采用什么算法？为什么用？</h3><h3 id="7-什么情况下会从新生代升级成老年代？"><a href="#7-什么情况下会从新生代升级成老年代？" class="headerlink" title="7. 什么情况下会从新生代升级成老年代？"></a>7. 什么情况下会从新生代升级成老年代？</h3><ol>
<li>生命周期较长的对象进入老年代；</li>
<li>动态判定：相同年龄的对象的总内存超过了Survivor内存空间的一半的对象，进入老年代。</li>
<li>Minor GC触发内存分配担保时；</li>
<li>大对象直接进入老年代。</li>
</ol>
<h3 id="8-分配担保机制讲一下。"><a href="#8-分配担保机制讲一下。" class="headerlink" title="8. 分配担保机制讲一下。"></a>8. 分配担保机制讲一下。</h3><ol>
<li>在Minor GC之前，JVM检查老年代最大可用连续可用空间是否大于新生代所有对象总空间。</li>
<li>如果大于，Minor GC 可以保证是安全的。</li>
<li>如果不成立，JVM 会检查对HandlePromotionFailure的设置是否允许担保失败。</li>
<li>如果允许担保失败（冒风险），会继续检查老年代最大连续可用空间是否大于历次晋升到老年代对象的平均大小。<ol>
<li>如果大于，可以尝试进行一次有风险的GC；</li>
<li>如果小于，说明不愿意冒险，将进行一次Full GC。</li>
</ol>
</li>
</ol>
<h3 id="9-偏向锁是什么，什么情况下会取消偏向锁？"><a href="#9-偏向锁是什么，什么情况下会取消偏向锁？" class="headerlink" title="9. 偏向锁是什么，什么情况下会取消偏向锁？"></a>9. 偏向锁是什么，什么情况下会取消偏向锁？</h3><h3 id="10-锁的轻量级、重量级讲一下区分。"><a href="#10-锁的轻量级、重量级讲一下区分。" class="headerlink" title="10. 锁的轻量级、重量级讲一下区分。"></a>10. 锁的轻量级、重量级讲一下区分。</h3><h3 id="11-轻量锁和偏向锁会在哪里做什么标记吗？"><a href="#11-轻量锁和偏向锁会在哪里做什么标记吗？" class="headerlink" title="11. 轻量锁和偏向锁会在哪里做什么标记吗？"></a>11. 轻量锁和偏向锁会在哪里做什么标记吗？</h3><h3 id="12-Spring是怎么解决循环依赖的？详细一点。"><a href="#12-Spring是怎么解决循环依赖的？详细一点。" class="headerlink" title="12. Spring是怎么解决循环依赖的？详细一点。"></a>12. Spring是怎么解决循环依赖的？详细一点。</h3><p>首先Spring不支持原型bean的循环依赖，也无法解决构造器中的循环依赖问题，这里指的都是单例bean。</p>
<ul>
<li>涉及到三种缓存：<ol>
<li>① singletonObjects；② earlySingletonObjects；③ singletonFactories。</li>
<li>缓存①是完全初始化好的bean的缓存；</li>
<li>缓存②是存放原始bean的缓存；</li>
<li>缓存③是存放bean工厂的缓存。</li>
</ol>
</li>
</ul>
<p>创建bean 并顺便缓存的过程：</p>
<ol>
<li>从<code>doGetBean()</code>方法开始，会先尝试从缓存1中获取bean，此对象可能有三种状态（null、原始bean、完全态的bean）。</li>
<li>若状态为 null（即缓存中没取到 bean），就需要创建bean，首先调用<code>createBeanInstance()</code>创建一个原始bean，然后将单例的 beanFactory 添加到缓存3中（从这个工厂就可以获取原始对象的引用，也就是所谓的“早期引用”）。</li>
<li>之后向原始 bean 中注入属性并解析依赖（所谓循环依赖，通常就卡在2.5步上）。</li>
<li>执行完成后，返回完全实例化后的 bean，同时放入缓存1中。</li>
</ol>
<p>出现循环依赖时，取缓存的过程：</p>
<ol>
<li>先从 singletonObjects 即缓存1中取bean 实例。如果没取到，则去 earlySingletonObjects 即缓存2中取，如果没取到，则从singletonFactories即缓存3中取出 ObjectFactory 对象，然后从中获取原始 bean 实例的引用（即早期引用）。</li>
<li>获取成功后，将该原始bean实例放入 earlySingletonObjects 即缓存2中，同时将 ObjectFactory对象从 singletonFactories 中移除。</li>
<li>拿到原始 bean 的引用，就可以完成另一个被依赖的 bean 的初始化了，如此循环依赖被解决。</li>
</ol>
<p>推荐阅读：<a href="http://www.tianxiaobo.com/2018/06/08/Spring-IOC-%E5%AE%B9%E5%99%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">Spring-bean的循环依赖以及解决方式</a></p>
<h3 id="13-Spring-IOC-为解决循环依赖问题使用的缓存机制。"><a href="#13-Spring-IOC-为解决循环依赖问题使用的缓存机制。" class="headerlink" title="13. Spring IOC 为解决循环依赖问题使用的缓存机制。"></a>13. Spring IOC 为解决循环依赖问题使用的缓存机制。</h3><p>参考 上一题（T 12），此处不赘述。</p>
<h3 id="14-ConcurrentHashMap怎么保证在扩容操作时的线程安全？"><a href="#14-ConcurrentHashMap怎么保证在扩容操作时的线程安全？" class="headerlink" title="14 .ConcurrentHashMap怎么保证在扩容操作时的线程安全？"></a>14 .ConcurrentHashMap怎么保证在扩容操作时的线程安全？</h3><p>本题分两步来看：</p>
<ol>
<li>先看 <a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/">HashMap 本身的扩容操作</a></li>
<li>再看 <a href="https://www.cnblogs.com/zerotomax/p/8687425.html#go7">ConcurrentHashMap 的扩容 get put 操作</a></li>
</ol>
<h4 id="1-先看-HashMap-本身的扩容操作"><a href="#1-先看-HashMap-本身的扩容操作" class="headerlink" title="1. 先看 HashMap 本身的扩容操作"></a>1. 先看 HashMap 本身的扩容操作</h4><ul>
<li>HashMap 的扩容：</li>
<li>先涉及两个参数：newCap 和 newThreshold，newCap 通常是原来的2倍，阈值（Threshold）也变为原来的2倍。</li>
<li>扩容后要将键值对Hash的重新计算，然后移动到合适的位置上去，如下：<ol>
<li>在链表中，如果<code>e.hash &amp; oldCap == 0</code>，则保持在原本的位置上，并且相同计算结果的结点按原来的相对位置接在后面。</li>
<li>如果<code>e.hash &amp; oldCap == 1</code>，则这些结点都要放在原位置j + oldCap 的位置上，这些结点相对位置不变。</li>
<li>在红黑树中，如果需要扩容操作，红黑树也需要拆分后重新映射。研究拆分之前，建议先阅读下边的扩展内容——红黑树的树化步骤。现在说一下拆分过程：首先红黑树中保留了原链表结点的 next 指针，所以分组方式跟原链表完全相同，将分成两种不同的链表。</li>
<li>红黑树拆分后变成两个链表，长度自然会变短，如果长度小于等于 6 ，那么此半个红黑树将保持链表状态；如果长度超过 6 ，那么将继续树化，成为一颗红黑树。</li>
</ol>
</li>
</ul>
<p>推荐阅读：<a href="https://blog.csdn.net/jianghuxiaojin/article/details/52006118#commentBox">java-并发-ConcurrentHashMap高并发机制-jdk1.8</a></p>
<p>扩展：红黑树的树化步骤，如下：</p>
<ol>
<li>将链表普通结点改造成 TreeNode 树形节点链表；</li>
<li>将得到的链表转化成红黑树。<ol>
<li>形成红黑树时需要比较结点间的大小：① 首先比较 hash 的大小；② 如果相等，则检查键类是否实现了 Comparable 接口，若是则调用 compareTo 方法进行比较；③ 若仍无法比较大小，则调用<code>tieBreakOrder()</code>方法进行仲裁，仲裁后就有大小的区别了。</li>
<li>链表转红黑树后，原链表的连接顺序依旧被保留了下来（next 指针来实现）。</li>
</ol>
</li>
</ol>
<h4 id="2-再看-ConcurrentHashMap-的各种骚操作的线程安全："><a href="#2-再看-ConcurrentHashMap-的各种骚操作的线程安全：" class="headerlink" title="2. 再看 ConcurrentHashMap 的各种骚操作的线程安全："></a>2. 再看 ConcurrentHashMap 的各种骚操作的线程安全：</h4><p>以下内容来自：<a href="https://www.cnblogs.com/zerotomax/p/8687425.html">ConcurrentHashMap源码分析(1.8)</a></p>
<h4 id="0-使用-Unsafe-的方法执行的原子性操作"><a href="#0-使用-Unsafe-的方法执行的原子性操作" class="headerlink" title="0. 使用 Unsafe 的方法执行的原子性操作"></a>0. 使用 Unsafe 的方法执行的原子性操作</h4><p><code>tabAt()</code> 用来返回节点数组的指定位置的节点的原子操作。<br><code>casTabAt()</code> cas原子操作，在指定位置设定值<br><code>setTabAt()</code> 原子操作，在指定位置设定值</p>
<h4 id="0-1-关于sizeCtl-变量"><a href="#0-1-关于sizeCtl-变量" class="headerlink" title="0.1 关于sizeCtl 变量"></a>0.1 关于sizeCtl 变量</h4><p>-1 :代表table正在初始化,其他线程应该交出CPU时间片<br>-N: 表示正有N-1个线程执行扩容操作（高 16 位是 length 生成的标识符，低 16 位是扩容的线程数，最大 65535）<br>大于 0: 如果table已经初始化,代表table容量,默认为table大小的0.75,如果还未初始化,代表需要初始化的大小</p>
<h4 id="1-初始化操作："><a href="#1-初始化操作：" class="headerlink" title="1. 初始化操作："></a>1. 初始化操作：</h4><p>首先有一个执行“初始化操作”的线程，然后观察 sizectl 参数，如果小于 0 ，此线程自旋等待；如果大于等于 0 ，则利用 CAS 操作将其设为 -1，此 CAS 操作保证以下操作的线程安全：为数组开辟内存，将 sizeCtl 设为数组长度的 3&#x2F;4（即sc &#x3D; n - (n &gt;&gt;&gt; 2)）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化完整源码：</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-put-操作"><a href="#2-put-操作" class="headerlink" title="2. put 操作"></a>2. put 操作</h4><ol>
<li>先拿到欲添加的 key 的 hash（执行<code>(h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;</code>）。</li>
<li>若 table 还没有申请到内存，则先执行初始化操作，即本题上一节。</li>
<li>若将要放置的位置没有元素，会执行<code>casTabAt()</code>方法尝试添加。</li>
<li>若检测到当前元素的hash为moved状态（说明正在执行<code>transfer()</code>操作，此操作会调用<code>ForwardingNode()</code>方法，此方法会将元素的hash设置为moved）。说明正处于数组扩张的数据复制阶段，则此线程也会参与去复制即<a href="https://www.jianshu.com/p/39b747c99d32">helpTransfer</a>，通过允许多线程复制的功能，以此来减少数组的复制所带来的性能损失。</li>
<li>若当前位置有元素，则使用 Synchronized 的方式加锁，对以下操作进行线程安全控制：① 若是链表，遍历链表，若同hash同key，则替换该value；不然，新建node加到链表末尾???存疑，可详看下方链接② 若是红黑树，则添加到红黑树中。</li>
</ol>
<p>大神打架：<a href="https://bbs.csdn.net/topics/392302628?page=1">关于HashMap在put时Node插入方向的问题</a></p>
<h4 id="3-get操作"><a href="#3-get操作" class="headerlink" title="3. get操作"></a>3. get操作</h4><p>get 操作无锁，支持并发</p>
<h4 id="4-链表转树操作"><a href="#4-链表转树操作" class="headerlink" title="4. 链表转树操作"></a>4. 链表转树操作</h4><ol>
<li>在执行<code>treeifyBin()</code>转树方法时，若桶的数量小于 64 时，优先触发扩容操作，细节参考本题下一节：扩容操作。</li>
<li>若桶数量多于 64 时，使用Synchronized 方式加锁，对以下操作进行线程安全控制：① 将普通结点转换为 TreeNode 结点；② 将 TreeNode 组成的链表构造出 Treebin 对象，在 Treebin 对象的构造方法中，链表被转换成了红黑树。</li>
</ol>
<h4 id="5-扩容操作"><a href="#5-扩容操作" class="headerlink" title="5. 扩容操作"></a>5. 扩容操作</h4><p>首先调用<code>tryPresize()</code>方法（支持并发），确定扩容的目标值（决定扩容的次数），以及根据<code>sizeCtl</code>参数选择进入不同的分支。<br>最终来到<code>transfer</code>方法处。</p>
<ol>
<li>首先如果多线程一起进行扩容操作，那么每个线程最少处理 16 个长度的数组元素，以避免此方法占用过多的 CPU 使用。</li>
<li>第一个进入扩容的线程负责初始化一个新的table，长度是旧的两倍。</li>
<li>然后分配一个区间的桶（一般是16 个）给此线程，完成下标的控制。<ol>
<li>如果扩容结束，可以尝试领取新的区间；如果无法领取，那么 sizeCtl 减一，扩容的线程减少一个。</li>
<li>如果数组i处桶是空的，就尝试用 CAS 占位，将占位符 fwd 插入。</li>
<li>如果桶不是空，而且已经有了占位符，说明已有其他线程处理过此操作，那么当前线程将跳过这个桶。</li>
<li>如果以上都不是，而且扩容操作没有完成，那么将开始同步处理这个桶。</li>
</ol>
</li>
<li>处理每个桶的行为是同步的，使用Synchronized关键词修饰，剩下的操作与HashMap基本一致，不再赘述。</li>
</ol>
<h3 id="15-公平锁非公平锁讲一下。"><a href="#15-公平锁非公平锁讲一下。" class="headerlink" title="15. 公平锁非公平锁讲一下。"></a>15. 公平锁非公平锁讲一下。</h3><h3 id="16-CountDownLatch-和-CyclicBarrier。"><a href="#16-CountDownLatch-和-CyclicBarrier。" class="headerlink" title="16. CountDownLatch 和 CyclicBarrier。"></a>16. CountDownLatch 和 CyclicBarrier。</h3><p>countDownLatch是倒计时器，可以用于模拟多线程同时触发验证并行性的场景。一个或者多个线程，等待其他多个线程完成某件事情之后才能执行。</p>
<ol>
<li>主线程 new 一个 CountDownLatch（同时指定计数的个数），然后开启线程池，紧接着执行countdownlatch.wait()方法，主线程阻塞。</li>
<li>线程池的业务代码中执行 countDownLatch.countDown()将个数减一，等到个数减为零时，主线程从 await()处被唤醒。</li>
</ol>
<p>CyclicBarrier是循环栅栏，可以用于多线程计算数据，最后合并计算结果的应用场景。多个线程互相等待，直到到达同一个同步点，再继续一起执行。</p>
<ol>
<li>主线程 new 一个 CyclicBarrier（同时指定计数的个数），然后开启线程池。</li>
<li>线程池的业务代码中执行 cyclicBarrier.await()方法，线程被阻塞，等到有足够个数的线程被阻塞时，这些线程会被唤醒继续执行 await()后面的代码。</li>
</ol>
<p>参考链接：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/AQS.md">AQS</a>文末</p>
<h3 id="补充：将Redis配置为缓存，在Spring中是怎么做的？"><a href="#补充：将Redis配置为缓存，在Spring中是怎么做的？" class="headerlink" title="补充：将Redis配置为缓存，在Spring中是怎么做的？"></a>补充：将Redis配置为缓存，在Spring中是怎么做的？</h3><ol>
<li><p>配置三样东西：①Spring对缓存的支持也就是cacheManager（本次采用的实现类：RedisCacheManager）；②Redis对话使用的RedisTemplate，③连接工厂。</p>
</li>
<li><p>首先启动Spring 缓存支持，创建一个CacheManager的Bean，</p>
</li>
<li><p>使用的三个注解：Cacheable、CacheEvit、CachePut。</p>
<ol>
<li>Cacheable：当重复使用相同参数调用方法的时候，方法本身不会被调用执行，即方法本身被略过了，取而代之的是方法的结果直接从缓存中找到并返回了。</li>
<li>CacheEvit： 调用时会删除掉数据库和缓存里面的值。可以在@CacheEvict 里面添加condition 表达式，让其满足什么条件的时候才删除缓存。可以设置是否清除掉缓存中所有数据。</li>
<li>CachePut：使用@CachePut标注的方法在执行前不会去检查缓存中是否存在之前执行过的结果，而是每次都会执行该方法，并将执行结果以键值对的形式存入指定的缓存中。</li>
</ol>
<blockquote>
<p>使用 spring-cache 有三个步骤：</p>
<p>在启动类上加入 @EnableCaching 注解；</p>
<p>使用 CacheManager 初始化要使用的缓存框架，使用 @CacheConfig 注解注入要使用的资源；</p>
<p>使用 @Cacheable 等注解对资源进行缓存。<br>而针对缓存操作的注解有三个：</p>
<p>@Cacheable 表示如果缓存系统里没有这个数值，就将方法的返回值缓存起来；</p>
<p>@CachePut 表示每次执行该方法，都把返回值缓存起来；</p>
<p>@CacheEvict 表示执行方法的时候，清除某些缓存值。<br>非常简单，对缓存的操作也无非是 CRUD。</p>
<p>&lt;&lt;&lt;&lt;拉勾教育、八点一刻：Redis缓存一致性设计</p>
</blockquote>
</li>
</ol>
<h3 id="补充：Redis不支持事务回滚，那么事务中Redis崩溃怎么办？"><a href="#补充：Redis不支持事务回滚，那么事务中Redis崩溃怎么办？" class="headerlink" title="补充：Redis不支持事务回滚，那么事务中Redis崩溃怎么办？"></a>补充：Redis不支持事务回滚，那么事务中Redis崩溃怎么办？</h3><ol>
<li>使用Aof持久化方式时，Redis服务器如果宕机，可能只执行了事务中的一部分操作；</li>
<li>那么Redis服务器会在重启前检查上述状态，同时退出运行，并输出报错信息；</li>
<li>可以借助redis-check-aof工具修复上述的只增文件，会把执行不完全的事务删除。</li>
</ol>
<p>为什么不支持回滚？因为Redis认为回滚无法解决任何程序错误问题，而为了运行速度的考虑，所以不支持回滚。</p>
<h3 id="补充：Java中什么时候会出现内存泄漏，举个栗子？"><a href="#补充：Java中什么时候会出现内存泄漏，举个栗子？" class="headerlink" title="补充：Java中什么时候会出现内存泄漏，举个栗子？"></a>补充：Java中什么时候会出现内存泄漏，举个栗子？</h3><p><strong>【important】错误地保持了强引用（比如赋值给了static 变量），那么对象就可能没机会转变为类似弱引用的可达性状态了。判断内存泄漏的思路：检查弱引用指向的对象是否被垃圾收集。</strong></p>
<p>定义就是：不再被使用的对象的内存不会被回收。</p>
<ol>
<li>单例对象持有其他短生命周期对象的引用。</li>
<li>静态集合类中引用的对象，如果对象需要移除时，要把集合对象置null，整个集合 clear 掉。</li>
</ol>
<p>举例如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> New <span class="title function_">String</span><span class="params">(<span class="string">&quot;abc&quot;</span>)</span>;</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(num);</span><br><span class="line">num=<span class="literal">null</span>;</span><br><span class="line">list.clear();<span class="comment">//用完后需要及时 clear 掉</span></span><br></pre></td></tr></table></figure>

<p>“abc”字符串有两个强引用指向它，num 和 list 集合，使用完后，都需要进行处理。</p>
<h3 id="补充：静态内部类"><a href="#补充：静态内部类" class="headerlink" title="补充：静态内部类"></a>补充：静态内部类</h3><p>静态内部类不需要依赖外部类的实例，也无法访问外部类的非静态的变量和方法。</p>
<h3 id="补充：初始化顺序"><a href="#补充：初始化顺序" class="headerlink" title="补充：初始化顺序"></a>补充：初始化顺序</h3><p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h3 id="补充：Redis的禁忌操作有哪些，注意事项，优化策略？"><a href="#补充：Redis的禁忌操作有哪些，注意事项，优化策略？" class="headerlink" title="补充：Redis的禁忌操作有哪些，注意事项，优化策略？"></a>补充：Redis的禁忌操作有哪些，注意事项，优化策略？</h3><h4 id="1-键值设计"><a href="#1-键值设计" class="headerlink" title="1. 键值设计"></a>1. 键值设计</h4><ol>
<li>key名设计<ul>
<li>原则：无特殊字符。</li>
<li>建议：可读、可管理、简洁。</li>
</ul>
</li>
<li>value设计<ul>
<li>原则：拒绝大key，防止网卡流量、大查询。</li>
<li>建议：控制数据类型合适、控制key的生命周期；使用hash，set，zset，list等对存储量过多的元素进行优化（比如100个桶，先hash取模，找到某一个key）。</li>
</ul>
</li>
</ol>
<h4 id="2-命令设计"><a href="#2-命令设计" class="headerlink" title="2. 命令设计"></a>2. 命令设计</h4><ol>
<li>注意O(N)命令，尽量避免使用；</li>
<li>禁止线上使用keys、flushall、flushdb等命令；</li>
<li>合理使用select；</li>
<li>使用批量操作提高效率。</li>
<li>Redis事务较弱，建议不要过多使用</li>
<li>Redis集群版本在使用Lua上有特殊要求</li>
<li>monitor命令慎用。</li>
</ol>
<h4 id="3-配置优化"><a href="#3-配置优化" class="headerlink" title="3. 配置优化"></a>3. 配置优化</h4><ol>
<li>限制同时连接的客户数量。</li>
<li>设置客户端连接时的超时时间，单位为秒。</li>
<li>限制脚本的最长运行时间，默认为5秒钟。</li>
<li>内存淘汰策略的选择。</li>
</ol>
<h4 id="4-集群批量操作的优化"><a href="#4-集群批量操作的优化" class="headerlink" title="4. 集群批量操作的优化"></a>4. 集群批量操作的优化</h4><ol>
<li>IO优化的思路：<blockquote>
<p>(1) 命令本身的效率：例如sql优化，命令优化<br>(2) 网络次数：减少通信次数<br>(3) 降低接入成本:长连&#x2F;连接池,NIO等<br>(4) IO访问合并:O(n)到O(1)过程:批量接口(mget)</p>
</blockquote>
</li>
</ol>
<h4 id="5-其他优化"><a href="#5-其他优化" class="headerlink" title="5. 其他优化"></a>5. 其他优化</h4><ol>
<li>redis间数据同步可以使用：redis-port</li>
<li>热key寻找</li>
</ol>
<p>墙裂建议阅读：<a href="https://www.jianshu.com/p/829f16d1ca1f">Redis注意事项及常见优化</a></p>
<h3 id="补充：Redis中的Value值太大怎么办？"><a href="#补充：Redis中的Value值太大怎么办？" class="headerlink" title="补充：Redis中的Value值太大怎么办？"></a>补充：Redis中的Value值太大怎么办？</h3><p>Value最多可以容纳的数据长度是512M。<br>可以用阿里云的<a href="https://yq.aliyun.com/articles/117042">大key搜索工具</a>。</p>
<p>推荐阅读：<a href="https://blog.csdn.net/lu_wei_wei/article/details/50906101">Redis中String类型的Value最大可以容纳数据长度</a></p>
<h3 id="补充：高并发情况下，如何保证Redis缓存的一致性？"><a href="#补充：高并发情况下，如何保证Redis缓存的一致性？" class="headerlink" title="补充：高并发情况下，如何保证Redis缓存的一致性？"></a>补充：高并发情况下，如何保证Redis缓存的一致性？</h3><h3 id="补充：分布式锁的实现"><a href="#补充：分布式锁的实现" class="headerlink" title="补充：分布式锁的实现"></a>补充：分布式锁的实现</h3><p>参考这一节的内容 :<a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-lock-redis-vs-zookeeper.md">advanced-java 分布式锁</a></p>
<p>分布式锁主要从① 互斥②不能死锁③容错三个考点来陈述：</p>
<h4 id="1-Redis-实现的分布式锁"><a href="#1-Redis-实现的分布式锁" class="headerlink" title="1. Redis 实现的分布式锁"></a>1. Redis 实现的分布式锁</h4><p>Redis 使用 SETNX 命令来实现分布式锁，但有“原生 setnx”和“RedLock”两种方案</p>
<h5 id="1-1-原生-setnx-方案"><a href="#1-1-原生-setnx-方案" class="headerlink" title="1.1 原生 setnx 方案"></a>1.1 原生 setnx 方案</h5><p>setnx 全称 set is not exists 。</p>
<p>redis 2.6之前的方案： <code>SETNX key value</code></p>
<p>redis 2.6之后的方案：现在都以 SET + NX 参数的方案为主</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>NX</code>：表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li>
<li><code>PX 30000</code>：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。</li>
<li>返回 1，设置 key 成功；返回 0，设置 key 失败</li>
</ul>
</blockquote>
<p>使用以下 lua 脚本删除 key：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>缺陷：因为集群中数据使用异步保证数据的一致性，假设clientA 从 master 处拿到了锁，但 master 未完成数据的同步，此时 master 发生了 crash，系统将重新选举 master，clientB 可以从新 master 处拿到锁，于是 clientA 和 clientB 都获取到 key 的锁，集群中的缺陷就此暴露出了。（lee 理解：脑裂时不能保证互斥性）</p>
<p>改进办法：采用 RedLock 方案。</p>
<h5 id="1-2-RedLock-方案"><a href="#1-2-RedLock-方案" class="headerlink" title="1.2 RedLock 方案"></a>1.2 RedLock 方案</h5><blockquote>
<p>这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：</p>
<ol>
<li><p>获取当前时间戳，单位是毫秒；</p>
</li>
<li><p>跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；</p>
</li>
<li><p>如果尝试创建锁失败，无论什么原因，一旦失败就立即尝试下一个节点。</p>
</li>
<li><p>尝试在<strong>大多数节点</strong>上建立一个锁，比如 5 个节点就要求是 3 个节点 <code>n / 2 + 1</code>；</p>
</li>
<li><p>客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；</p>
</li>
<li><p>要是锁建立失败了，那么就依次之前建立过的锁删除；</p>
</li>
<li><p>只要别人建立了一把分布式锁，你就得<strong>不断轮询去尝试获取锁</strong>。</p>
</li>
</ol>
</blockquote>
<p>创建锁失败的原因可能是：当前 key 的锁已经被其他 client 占有、master 节点不可用</p>
<p>推荐阅读：<a href="http://ifeve.com/redis-lock/">《Redis官方文档》用Redis构建分布式锁</a></p>
<h4 id="2-zk-实现的分布式锁"><a href="#2-zk-实现的分布式锁" class="headerlink" title="2. zk 实现的分布式锁"></a>2. zk 实现的分布式锁</h4><h5 id="2-1-临时-znode-方案"><a href="#2-1-临时-znode-方案" class="headerlink" title="2.1 临时 znode 方案"></a>2.1 临时 znode 方案</h5><blockquote>
<p>zk 分布式锁，其实可以做的比较简单，就是某个节点尝试创建临时 znode，此时创建成功了就获取了这个锁；这个时候别的客户端来创建锁会失败，只能<strong>注册个监听器</strong>监听这个锁。释放锁就是删除这个 znode，一旦释放掉就会通知客户端，然后有一个等待着的客户端就可以再次重新加锁。</p>
</blockquote>
<h5 id="2-2-临时顺序节点方案"><a href="#2-2-临时顺序节点方案" class="headerlink" title="2.2 临时顺序节点方案"></a>2.2 临时顺序节点方案</h5><blockquote>
<p>如果有一把锁，被多个人竞争，此时需要排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听<strong>排在自己前面</strong>的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。</p>
</blockquote>
<p>基本步骤：</p>
<blockquote>
<p>1.建立一个节点，假如名为：lock 。节点类型为持久节点（PERSISTENT）<br>2.每当进程需要访问共享资源时，会调用分布式锁的lock()或tryLock()方法获得锁，这个时候会在第一步创建的lock节点下建立相应的顺序子节点，节点类型为临时顺序节点（EPHEMERAL_SEQUENTIAL），通过组成特定的名字name+<em>lock</em>+顺序号。<br>3.在建立子节点后，对lock下面的所有以name开头的子节点进行排序，判断刚刚建立的子节点顺序号是否是最小的节点，假如是最小节点，则获得该锁对资源进行访问。 （lee 理解：为什么是最小？因为拿到锁并释放锁的节点，会删除它的 znode，如果轮到当前节点，那么它所属的顺序号就应当是最小的）<br>4.假如不是该节点，就获得该节点的上一顺序节点，并给该节点是否存在注册监听事件。同时在这里阻塞。等待监听事件的发生，获得锁控制权。<br>5.当调用完共享资源后，调用unlock（）方法，关闭zk，进而可以引发监听事件，释放该锁。<br>实现的分布式锁是严格的按照顺序访问的并发锁。</p>
</blockquote>
<h4 id="3-etcd-实现的分布式锁"><a href="#3-etcd-实现的分布式锁" class="headerlink" title="3. etcd 实现的分布式锁"></a>3. etcd 实现的分布式锁</h4><p>[扩展]：有关 raft 协议大神级动画：<a href="http://thesecretlivesofdata.com/raft/">raft</a>，真不知道哪个神仙画的，太棒了！</p>
<p>对于每一个锁比如名字为 mylock，实际写入 key 时就叫做 <code>key1=mylock/uuid1</code>，如果两个 client 同时写 mylock 锁，写操作都会成功，但在 mylock 目录下会同时存在不同 uuid 的两个 key。UUID 可以保证全局的唯一性。使用每个 key 对应的一个自增的<code>Revision</code>号（进行一次事务，revision 自增 1），此 Revision 会返回给创建 key 的 client，由 client 记录下来。client 取 key 时，会把 <code>mylock/</code>下的所有 key-value 对都拿到，然后通过 revision 号来判断自己是否获得了锁。</p>
<p>租约：client 创建 key-value 时要设置租约期，租约到期时 key-value 会被删除，同时也可以被client续约。</p>
<p>避免死锁的方式：持有锁的 client 会创建一个定时任务作为心跳对 key 进行续约，一旦此 client 故障，那么租期到了就会自动释放锁，允许其他 client 来获取。</p>
<p>这里写的很详细（甚至有大量篇幅介绍etcd 以及 raft 协议），有兴趣可以了解：<a href="http://blogspring.cn/view/120">分布式锁的最佳实践之：基于 Etcd 的分布式锁</a></p>
<h4 id="三种实现分布式锁方式的区别"><a href="#三种实现分布式锁方式的区别" class="headerlink" title="三种实现分布式锁方式的区别"></a>三种实现分布式锁方式的区别</h4><ol>
<li>redis 方式，需要应用自己不断地去获取锁，比较消耗性能。而且如果请求锁的 app 挂掉了，需要等待超时时间后才能释放锁。</li>
<li>zk 方式，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。如果请求锁的 app 挂掉了，那么 znode 就会被删除，无需等待超时时间。通过一个自增序号判断 client 是否为获得锁的 client。</li>
<li>etcd 跟 zk 很接近，也是通过一个自增序号判断是否为获得锁的 client。</li>
</ol>
<p>另：这个链接里面，涉及到Redisson 方案，以及使用 setnx 时存在的缺陷，值得一看：<a href="https://yq.aliyun.com/articles/603575">阿里云专访Redisson作者Rui Gu：构建开源企业级Redis客户端之路</a></p>
<h3 id="补充：网络并发量突增时，该怎么处理"><a href="#补充：网络并发量突增时，该怎么处理" class="headerlink" title="补充：网络并发量突增时，该怎么处理?"></a>补充：网络并发量突增时，该怎么处理?</h3><ol>
<li>如果是几何型的递增，只能增加应用的集群节点、数据库集群节点或分布式模块管理。</li>
<li>如果是不规则的高峰模式，可以从应用和数据模型着手，减少服务器请求时间。<ol>
<li>必要的数据缓存；</li>
<li>合理的静态化页面；</li>
<li>多节点应用集群；</li>
</ol>
</li>
<li>如果高并发来自于恶意请求，不仅要改bug，还要限制IP访问。</li>
<li>请求放到消息队列里面；<ol>
<li>优点：异步处理请求，消峰、降低系统耦合</li>
<li>缺点：一致性问题、可用性问题、复杂性问题。</li>
</ol>
</li>
<li>图形验证码；</li>
<li>做服务降级。</li>
</ol>
<h3 id="补充：秒杀场景下保证库存数据的正确性"><a href="#补充：秒杀场景下保证库存数据的正确性" class="headerlink" title="补充：秒杀场景下保证库存数据的正确性"></a>补充：秒杀场景下保证库存数据的正确性</h3><blockquote>
<p>库存数据只需要达到最终一致，使用 MQ 做事件驱动加上 Redis 事务即可。增加&#x2F;扣减库存时用 Redis 事务做原子操作，每次扣减库存时生成一个唯一 ID，归还时带上该唯一 ID 用于做幂等操作。下单出错或者关单归还库存时可以通过 MQ 异步做最终的事务补偿。</p>
</blockquote>
<h3 id="补充：服务器负载历史记录怎么查看？"><a href="#补充：服务器负载历史记录怎么查看？" class="headerlink" title="补充：服务器负载历史记录怎么查看？"></a>补充：服务器负载历史记录怎么查看？</h3><p>shell 中的 uptime 命令，top 命令等都行</p>
<h3 id="补充：数据库死锁的例子"><a href="#补充：数据库死锁的例子" class="headerlink" title="补充：数据库死锁的例子"></a>补充：数据库死锁的例子</h3><p><a href="https://uule.iteye.com/blog/2422193">MYSQL数据库死锁的原因和解决方法</a></p>
<h1 id="网易-Lua-一面"><a href="#网易-Lua-一面" class="headerlink" title="网易 Lua 一面"></a>网易 Lua 一面</h1><h3 id="1-Mybatis-在-SSM-框架中充当什么角色？"><a href="#1-Mybatis-在-SSM-框架中充当什么角色？" class="headerlink" title="1. Mybatis 在 SSM 框架中充当什么角色？"></a>1. Mybatis 在 SSM 框架中充当什么角色？</h3><ol>
<li>主要完成对 JDBC 的封装，去掉了繁琐的 JDBC 代码和结果集的设置。</li>
<li>使用 XML 或注解，将接口和普通Java类映射成数据库中的数据，解除了 sql 跟代码的耦合。</li>
</ol>
<h3 id="2-JDBC-做了哪些事情呢、以及-JDBC-的设计模式？"><a href="#2-JDBC-做了哪些事情呢、以及-JDBC-的设计模式？" class="headerlink" title="2. JDBC 做了哪些事情呢、以及 JDBC 的设计模式？"></a>2. JDBC 做了哪些事情呢、以及 JDBC 的设计模式？</h3><ol>
<li><p>跟数据库建立连接，</p>
</li>
<li><p>使用 statement 执行 SQL 语句。（或者使用PreparedStatement，用？代替指定字符串，进行预编译，更加高效，还可防止SQL注入）。</p>
</li>
<li><p>执行查询，返回 ResultSet，循环调用next方法，获取每一行内容。</p>
</li>
<li><p>任何一个 jdbc 的 Driver 必须类似以下格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向 DriverManger 注册自己</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJDBCDriver</span> <span class="keyword">implements</span> <span class="title class_">Driver</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        DriverManager.registerDriver(<span class="keyword">new</span> <span class="title class_">MyJDBCDriver</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用 jdbc 时，使用<code>Class.forName(com.**.**.MyJDBCDriver)</code>，相当于加载这个driver，上边代码中的 static 代码块就会执行，完成了<code>MyJDBCDriver</code>的实例化。</p>
</li>
<li><p>补充：jdbc 主要使用了桥接模式</p>
<ol>
<li><p>桥接模式核心：一个抽象类使用了指向另一个接口的引用。抽象类可以有多种实现子类，接口也可以有多种实现，作用：使用桥接模式就是为了让抽象部分和实现部分都能够独立变化。抽象类设为 AC，接口设为 API，接口实现设为 Class1、Class2，AC 继承子类设为 ClassA、ClassB，真实使用代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassA</span> <span class="variable">classA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AC</span>(<span class="keyword">new</span> <span class="title class_">Class1</span>());</span><br><span class="line"><span class="type">ClassB</span> <span class="variable">classB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AC</span>(<span class="keyword">new</span> <span class="title class_">Class2</span>());</span><br></pre></td></tr></table></figure>



<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/bridge_pattern_uml_diagram.jpg"></p>
</li>
<li><p>至于 jdbc 的桥接模式，参考4&#x2F;5两项，不再做多余解释。</p>
</li>
</ol>
</li>
</ol>
<h3 id="3-IDE-项目中另外起一个JVM、进程来做，有什么思路吗？"><a href="#3-IDE-项目中另外起一个JVM、进程来做，有什么思路吗？" class="headerlink" title="3. IDE 项目中另外起一个JVM、进程来做，有什么思路吗？"></a>3. IDE 项目中另外起一个JVM、进程来做，有什么思路吗？</h3><h3 id="5-跳表的建立规则，它怎么决定一个数据要不要上升到上一层。"><a href="#5-跳表的建立规则，它怎么决定一个数据要不要上升到上一层。" class="headerlink" title="5. 跳表的建立规则，它怎么决定一个数据要不要上升到上一层。"></a>5. 跳表的建立规则，它怎么决定一个数据要不要上升到上一层。</h3><blockquote>
<p>一个链表内每一个结点可能包含多个指向后续元素的指针，后续节点个数是通过一个随机函数生成器得到</p>
</blockquote>
<p>跳表是通过随机函数来决定某个数据要不要去哪一层。</p>
<p>推荐阅读：<a href="https://blog.csdn.net/sunxianghuang/article/details/52221913">跳表（SkipList）</a></p>
<h3 id="6-CPU-缓存的更新和替换策略。"><a href="#6-CPU-缓存的更新和替换策略。" class="headerlink" title="6. CPU 缓存的更新和替换策略。"></a>6. CPU 缓存的更新和替换策略。</h3><p>CPU 采用了三级高速缓存，替换算法主要有三种：FIFO、LFU、LRU。其中LRU最常用。</p>
<h3 id="7-内存的值发生了变化后，cache要如何感知呢？"><a href="#7-内存的值发生了变化后，cache要如何感知呢？" class="headerlink" title="7. 内存的值发生了变化后，cache要如何感知呢？"></a>7. 内存的值发生了变化后，cache要如何感知呢？</h3><p>先看 cache 的写入策略：</p>
<ol>
<li><strong>写回法</strong>：当CPU写Cache命中时，只改变其缓存的内容，而不写入内存，直到替换策略把该块替换出来时才写入内存。这种方法减少了访问内存的次数，缩短了时间，也提高了内存带宽利用率，但在保持与内存内容的一致性上存在在隐患，并且使用写回法，必须为每个缓存块设置一个修改位，来反映此块是否被CPU修改过。</li>
<li><strong>全写法</strong>：当写Cache命中时，立即在所有的等级存储介质里更新，即同时写进Cache与内存，而当Cache未命中时，直接向内存写入，而Cache不用设置修改位或相应的判断器。这种方法的好处是，当Cache命中时，由于缓存和内存是同时写入的，所以可以很好的保持缓存和内存内容的一致性，但缺点也很明显，由于每次写入操作都要更新所有的存储体，如果一次有大量的数据要更新，就要占用大量的内存带宽，而现在PC系统中，内存带宽本来就不宽裕，而写操作占用太多带宽的话，那主要的读操作就会受到比较大的影响。</li>
<li><strong>写一次法</strong>：这是一种基于上面两种方法的写策略，它的特点是，除了第一次写Cache命中的时候要写入内存，其它时候都和写回法一样，只修改缓存。其实这也就是一种对缓存一致性的妥协，使得在缓存一致性和延迟中取的一个较好的平衡。</li>
</ol>
<blockquote>
<p>现在的CPU一般都有多个核，我们知道当某个核读取某个内存地址时，会把这个内存地址附近的64个字节放到当前核的cache line中，假设此时另外一个CPU核同时把这部分数据放到了对应的cache line中，这时候这64字节的数据实际上有三份，两份在CPU cache中，一份在主存中。自然而然就要考虑到数据一致性的问题，如何保证在某一个核中的数据做了改动时，其它的数据副本也能感知到变化呢？是由缓存一致性协议来保证的。缓存一致性协议也叫作MESI协议。<br>除了一致性协议外，还需要内存屏障的配合。</p>
</blockquote>
<p>这两部分就不展开了，可以参考下面两个链接。</p>
<p>内容参考：<a href="https://yq.aliyun.com/articles/8061">性能服务端系列 – 处理器篇</a><br>扩展阅读：<a href="http://cenalulu.github.io/linux/all-about-cpu-cache/">关于CPU Cache – 程序猿需要知道的那些事</a></p>
<h3 id="8-select、poll、epoll的区别？"><a href="#8-select、poll、epoll的区别？" class="headerlink" title="8. select、poll、epoll的区别？"></a>8. select、poll、epoll的区别？</h3><p>往下翻，参考：趣链 Java 一面之二 的第一题。</p>
<h3 id="9-实现一个数据结构，拥有栈的pop和push，同时提供一个min函数可以取最小值，怎么实现？"><a href="#9-实现一个数据结构，拥有栈的pop和push，同时提供一个min函数可以取最小值，怎么实现？" class="headerlink" title="9. 实现一个数据结构，拥有栈的pop和push，同时提供一个min函数可以取最小值，怎么实现？"></a>9. 实现一个数据结构，拥有栈的pop和push，同时提供一个min函数可以取最小值，怎么实现？</h3><p>提供两个栈，stack1 和 stack2，stack1进行栈的基本操作，stack2的栈顶作为min的记录，如果压栈的元素小于stack2的栈顶元素，则压入stack2，如果出栈的元素等于stack2的栈顶元素，说明min元素要出栈，此时stack2的栈顶元素pop出。</p>
<h3 id="10-接上一题，如果要你提供多个最小值，你要怎么做？"><a href="#10-接上一题，如果要你提供多个最小值，你要怎么做？" class="headerlink" title="10. 接上一题，如果要你提供多个最小值，你要怎么做？"></a>10. 接上一题，如果要你提供多个最小值，你要怎么做？</h3><p>接上题解法，stack2的后续几个元素就是多个最小值。</p>
<h3 id="11-大量数据的并行化处理思路"><a href="#11-大量数据的并行化处理思路" class="headerlink" title="11. 大量数据的并行化处理思路"></a>11. 大量数据的并行化处理思路</h3><p>背景：8G 甚至更多的数据，无法一次性放入内存中，所以需要分治的思想（甚至可以使用多线程并行处理），有两种策略：</p>
<ol>
<li>快速排序分治。先扫一遍数据，按大小分16 个区间（快排），并把数据放入。然后可以启动 16 个线程并行对这些数据进行排序，小区间排序完成后，整体数据就有序了。</li>
<li>归并排序分治。不提前扫数据，直接分成 16 个小数据集合，启动 16 个线程进行排序，排序完成后再将有序集合合并。</li>
</ol>
<h1 id="网易-Lua-二面"><a href="#网易-Lua-二面" class="headerlink" title="网易 Lua 二面"></a>网易 Lua 二面</h1><ol>
<li><p>如何避免外来Java代码任意创建多线程等其他危险操作？</p>
<p>只知道 redis 中可以嵌套 lua 脚本来实现自定义的逻辑。</p>
</li>
</ol>
<h1 id="招银网络-Java-一面"><a href="#招银网络-Java-一面" class="headerlink" title="招银网络 Java 一面"></a>招银网络 Java 一面</h1><h3 id="1-事务中用了try-catch捕获了异常，那么事务还会回滚吗？"><a href="#1-事务中用了try-catch捕获了异常，那么事务还会回滚吗？" class="headerlink" title="1. 事务中用了try-catch捕获了异常，那么事务还会回滚吗？"></a>1. 事务中用了try-catch捕获了异常，那么事务还会回滚吗？</h3><p>将异常捕获,并且在catch块中不对事务做显式提交(或其他应该做的操作如关闭资源等)&#x3D;生吞掉异常.<br>一般不用try-catch捕获异常。如果非要捕获，那就要在catch语句块中显式地抛异常&#x2F;显式地回滚。</p>
<p><a href="https://a-bin.iteye.com/blog/1056839">try catch异常抛出与spring事务回滚策略相关</a></p>
<h3 id="2-Servlet-的生命周期"><a href="#2-Servlet-的生命周期" class="headerlink" title="2. Servlet 的生命周期"></a>2. Servlet 的生命周期</h3><ol>
<li>加载</li>
<li>初始化</li>
<li>处理请求</li>
<li>服务终止<br><a href="https://www.cnblogs.com/lgk8023/p/6427977.html">Servlet生命周期</a></li>
</ol>
<h3 id="4-事务A，包含语句B，B异常时，事务A会回滚吗？"><a href="#4-事务A，包含语句B，B异常时，事务A会回滚吗？" class="headerlink" title="4. 事务A，包含语句B，B异常时，事务A会回滚吗？"></a>4. 事务A，包含语句B，B异常时，事务A会回滚吗？</h3><p>会。</p>
<h3 id="5-web-xml-能配置什么信息"><a href="#5-web-xml-能配置什么信息" class="headerlink" title="5. web.xml 能配置什么信息"></a>5. web.xml 能配置什么信息</h3><p>过滤器、监听器、applicationContext、Servlet等。</p>
<h3 id="6-String-跟-StringBuffer、StringBuilder的区别"><a href="#6-String-跟-StringBuffer、StringBuilder的区别" class="headerlink" title="6. String 跟 StringBuffer、StringBuilder的区别"></a>6. String 跟 StringBuffer、StringBuilder的区别</h3><p>String 是不可变类，StringBuffer 是可变类，线程安全。StringBuilder 是可变类，线程不安全。</p>
<p>从效率来讲，String -&gt; StringBuffer -&gt; StringBuilder, 先降后升。</p>
<p>String不可变的优点之一：String 的 hash 值也不可变，只需要计算一次，有利于作为 hashmap 的 key。</p>
<p>String 补充：</p>
<p>如果 new 一个 String，那么 String Object存在于堆里，如果 String str &#x3D; “abc”，将不在堆里，而在字符串常量池中有字面量“abc”和 String Object。</p>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/StringPool.jpg"></p>
<h3 id="7-wait-和-sleep-的区别"><a href="#7-wait-和-sleep-的区别" class="headerlink" title="7. wait 和 sleep 的区别"></a>7. wait 和 sleep 的区别</h3><ol>
<li>sleep，让CPU不让锁。</li>
<li>wait，放弃锁。</li>
</ol>
<h3 id="补充：用户级线程与内核级线程的区别："><a href="#补充：用户级线程与内核级线程的区别：" class="headerlink" title="补充：用户级线程与内核级线程的区别："></a>补充：用户级线程与内核级线程的区别：</h3><p>包括有没有陷入内核：<br>阅读：<a href="https://blog.csdn.net/weixin_42229896/article/details/80667187">用户线程与内核线程的区别</a></p>
<h1 id="IBM-Java-二面"><a href="#IBM-Java-二面" class="headerlink" title="IBM Java 二面"></a>IBM Java 二面</h1><h3 id="1-项目中-MySQL-数据表的设计有遵循范式吗？第二范式的要求？"><a href="#1-项目中-MySQL-数据表的设计有遵循范式吗？第二范式的要求？" class="headerlink" title="1. 项目中 MySQL 数据表的设计有遵循范式吗？第二范式的要求？"></a>1. 项目中 MySQL 数据表的设计有遵循范式吗？第二范式的要求？</h3><ul>
<li><p>第二范式：在第一范式要求的基础上（表是平表），要求每一个非主属性完全函数依赖于码。</p>
</li>
<li><p>3NF：首先属于2NF，然后每一个非主属性不传递依赖于码。任何非主属性不依赖于其他非主属性。</p>
</li>
<li><p>intent与Sentence的一对多关系。</p>
</li>
</ul>
<h3 id="2-查询过程中碰到性能方面的问题吗？"><a href="#2-查询过程中碰到性能方面的问题吗？" class="headerlink" title="2. 查询过程中碰到性能方面的问题吗？"></a>2. 查询过程中碰到性能方面的问题吗？</h3><p>虽然没有碰到，但还是尽量采用比较好的设计。比如：</p>
<ol>
<li><a href="https://blog.csdn.net/zly9923218/article/details/51007554">SQL优化</a>。<ol>
<li>列出查询字段，避免select *；</li>
<li>索引列不能含 null，建索引会失败</li>
<li>避免通配符%，出现在搜寻词首，该列索引将不生效</li>
<li>避免 orderby中的计算表达式或非索引项</li>
</ol>
</li>
<li>利用冗余设计，避免表连接。</li>
</ol>
<h3 id="3-分页是怎么实现的？这个工具是一个Jar包吗？Sql语句中怎么实现？"><a href="#3-分页是怎么实现的？这个工具是一个Jar包吗？Sql语句中怎么实现？" class="headerlink" title="3. 分页是怎么实现的？这个工具是一个Jar包吗？Sql语句中怎么实现？"></a>3. 分页是怎么实现的？这个工具是一个Jar包吗？Sql语句中怎么实现？</h3><p>用的PageHelper，引入PageHelper的依赖，<a href="https://blog.csdn.net/qq_21996541/article/details/79796117">PageHelper类实现了interceptor接口</a>，是mybatis的拦截器。</p>
<ol>
<li>传入当前页面、每页记录数，赋值到Page类中（，同时赋值到ThreadLocal中，成为线程私有）；</li>
<li>然后PageHelper实现了interceptor接口，通过拦截器获取到Page类的参数，然后在SQLparser中完成分页SQL语句的拼装，最终完成分页操作。</li>
</ol>
<p>不使用PageHelper，单纯sql实现：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// <span class="keyword">limit</span>可以接受一到两个参数：</span><br><span class="line">如果是一个参数，表示返回最大的记录行数目（<span class="keyword">LIMIT</span> n 等价于 <span class="keyword">LIMIT</span> <span class="number">0</span>,n）。</span><br><span class="line">如果是两个参数，第一个指定返回记录行的偏移量（起始位置），第二个指定返回记录行的最大数目（记录条数）。</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">10</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">95</span>,<span class="number">-1</span>； // <span class="number">-1</span> 表示到末尾</span><br><span class="line"></span><br><span class="line">// <span class="keyword">limit</span> <span class="keyword">offset</span>用法：</span><br><span class="line">返回四行、偏移量<span class="number">9</span>。</span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">LIMIT</span> <span class="number">4</span> <span class="keyword">OFFSET</span> <span class="number">9</span>;</span><br></pre></td></tr></table></figure>


<h3 id="4-你的Redis做缓存，key、value是怎么设计的？"><a href="#4-你的Redis做缓存，key、value是怎么设计的？" class="headerlink" title="4. 你的Redis做缓存，key、value是怎么设计的？"></a>4. 你的Redis做缓存，key、value是怎么设计的？</h3><h3 id="5-Spring-Schedule-的底层实现？执行频率？表达式？"><a href="#5-Spring-Schedule-的底层实现？执行频率？表达式？" class="headerlink" title="5. Spring Schedule 的底层实现？执行频率？表达式？"></a>5. Spring Schedule 的底层实现？执行频率？表达式？</h3><ol>
<li>实现 SchedulingConfigurer 接口，重写 configureTasks 方法。</li>
<li>创建一个 trigger触发，并增加一个runnable的task，放入业务逻辑。</li>
<li>从数据库中取出自定义的 cron 语句，然后得到 CronTrigger。</li>
<li><code>0 0 8 * * ？*</code>每天8点执行一次</li>
</ol>
<h3 id="6-批量数据的导入导出？有什么效果？easyExcel有什么突出的亮点？"><a href="#6-批量数据的导入导出？有什么效果？easyExcel有什么突出的亮点？" class="headerlink" title="6. 批量数据的导入导出？有什么效果？easyExcel有什么突出的亮点？"></a>6. 批量数据的导入导出？有什么效果？easyExcel有什么突出的亮点？</h3><p>使用EasyExcel进行批量数据的导入导出，具有映射到Java类的功能。</p>
<ul>
<li>导出时，可以自动生成表头。导入时，可以根据excel中的列号映射到java模型中。</li>
</ul>
<p>EasyExcel的使用步骤：</p>
<ol>
<li>添加maven依赖。</li>
<li>加上ExcelProperty的注解。</li>
</ol>
<h3 id="7-如果你的API出现性能问题，你会怎么考虑去调优它？"><a href="#7-如果你的API出现性能问题，你会怎么考虑去调优它？" class="headerlink" title="7. 如果你的API出现性能问题，你会怎么考虑去调优它？"></a>7. 如果你的API出现性能问题，你会怎么考虑去调优它？</h3><ol>
<li>架构设计上：<ol>
<li>应用服务器设置集群、增加反向代理和负载均衡。</li>
<li>业务层可以使用Dubbo等RPC框架实现分布式调用，达到多节点同时处理计算。</li>
<li>使用redis、es等nosql实现存储。</li>
</ol>
</li>
<li>代码角度上：<ol>
<li>将某些环节设置为异步处理，比如本项目中，分析意图和调取用户信息的任务可以异步进行。在Future模式下，先返回一个future给调用者，等需要结果时再调用future.get()获得结果。唯一需要注意的是要设置一个超时时间。</li>
<li>检查线程池、数据库连接池的配置是否合适。</li>
<li>sql 优化：减少聚合函数、增加必要索引等。</li>
</ol>
</li>
</ol>
<h3 id="8-你用JVM能做哪些方面的调优呢？"><a href="#8-你用JVM能做哪些方面的调优呢？" class="headerlink" title="8. 你用JVM能做哪些方面的调优呢？"></a>8. 你用JVM能做哪些方面的调优呢？</h3><p>【强推！】R 大推荐 JVM 书籍：<a href="https://rednaxelafx.iteye.com/blog/1886170">豆列：从表到里学习JVM实现</a></p>
<p>举个栗子，以高可用、低延迟为调优目标：</p>
<ol>
<li>需要量化GC时间和频率对响应时间和可用性的影响。</li>
</ol>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/4.png"></p>
<p>上图说明：降低单次GC时间和GC次数，可以有效减少GC对响应时间的影响。</p>
<ul>
<li>选用合适的GC 收集器、重新设置内存比例、调整JVM参数等。</li>
</ul>
<h4 id="1-Major-GC-和-Minor-GC-太频繁"><a href="#1-Major-GC-和-Minor-GC-太频繁" class="headerlink" title="1. Major GC 和 Minor GC 太频繁"></a>1. Major GC 和 Minor GC 太频繁</h4><p>背景：新生对象太多、存活太少。动态年龄低的时候就已经晋升老年代，引起频繁Major GC。<br>步骤：</p>
<ol>
<li>先尝试增加 Eden 空间，Minor GC频次降一半。<ul>
<li>虽然Eden区的扫描时间增加一倍，但是Minor GC 的间隔时间是以前的两倍，那么存活对象的数量将减小（短命对象就是优化点），这时对象的复制耗时会降低。</li>
<li>所以需要确定对象的生命周期分布情况。</li>
</ul>
</li>
<li>检查 new threshold 参数，也就是动态年龄判断（对象的晋升年龄阈值，很可能低于15）</li>
</ol>
<h4 id="2-请求高峰期发生GC-，导致服务可用性下降。"><a href="#2-请求高峰期发生GC-，导致服务可用性下降。" class="headerlink" title="2. 请求高峰期发生GC ，导致服务可用性下降。"></a>2. 请求高峰期发生GC ，导致服务可用性下降。</h4><p>背景：CMS 的重新标记阶段是STW的，所以需要降低此时间。</p>
<ul>
<li><p>跨代引用：重新标记阶段中，新生代持有指向老年代对象的引用，就是跨代引用。（虽然CMS是针对老年代的，但还是需要扫描）</p>
</li>
<li><p>所以CMS的重复标记阶段要全堆扫描，那么堆中对象的数目影响了Remark阶段耗时。降低Remark阶段耗时问题转换成如何减少新生代对象数量。</p>
</li>
<li><p>Remark 前又一次可中断的预清理阶段，等待Minor GC的发生（有时限，超时会等不到Minor GC） 。</p>
</li>
<li><p>优化 CMSScavengeBeforeRemark参数（增加此数值），用来保证Remark前强制进行一次Minor GC。	消除部分不可达对象，降低后期正式扫描时需要扫描的对象</p>
</li>
</ul>
<p>强推：CMS 过程分析：<a href="https://www.jianshu.com/p/2a1b2f17d3e4">图解CMS垃圾回收机制，你值得拥有</a><br>推荐阅读：<a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">美团GC实例</a></p>
<h3 id="3-比较-CMS、G1、ZGC"><a href="#3-比较-CMS、G1、ZGC" class="headerlink" title="3. 比较 CMS、G1、ZGC"></a>3. 比较 CMS、G1、ZGC</h3><ol>
<li>目标。CMS、G1：最短回收停顿时间；</li>
<li>共同特点：<ol>
<li>都是并发清除器，对 CPU 敏感，</li>
</ol>
</li>
<li>CMS 特点：<ol>
<li>标记清除算法，存在大量空间碎片，需要一次 Full GC 来处理(可以设置多次 CMS 触发一次 Full GC)。</li>
<li>CMS 使用<strong>空间列表</strong>用于对象分配内存。</li>
<li>只作用于老年代和永久带。</li>
</ol>
</li>
<li>G1特点：<ol>
<li>切分多个 Region，每次回收含垃圾最多的 Region（而不是全部），从而降低停顿。</li>
<li>可设置最大停顿时间。</li>
<li>使用写屏障。</li>
</ol>
</li>
<li>ZGC 特点：<ol>
<li>与 G1类似，都使用了Region（在 ZGC 中称为 Page），但 ZGC 分区不是为了减少停顿，。</li>
<li>不设最大停顿时间。</li>
<li>GC 的停顿时间，不随堆的规模和存活对象的规模变化而变化。</li>
<li>但使用读屏障，而且采用并发压缩的过程。</li>
<li>建议查看本站另一篇文章，梳理的很清晰：<a href="http://likehui.fun/2019/04/11/ZGC-%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/">ZGC 特性解读</a></li>
</ol>
</li>
</ol>
<h3 id="9-Git-的git-add-commit-和push-的区别？"><a href="#9-Git-的git-add-commit-和push-的区别？" class="headerlink" title="9. Git 的git add commit 和push 的区别？"></a>9. Git 的git add commit 和push 的区别？</h3><p>git add 是把文件添加到暂存区。<br>git commit 提交更改，把暂存区的所有内容提交到当前分支上。<br>git push 是将本地分支推送到远程分支。</p>
<h3 id="补充：git面试题汇总："><a href="#补充：git面试题汇总：" class="headerlink" title="补充：git面试题汇总："></a>补充：git面试题汇总：</h3><p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/git.jpeg"></p>
<ol>
<li>Git branch name     创建名字为name的branch</li>
<li>Git checkout xxx_dev    切换到名字为xxx_dev的分支</li>
<li>Git pull    从远程分支拉取代码到本地分支</li>
<li>Git checkout -b name   创建并切换到name</li>
<li>Git push origin name    执行推送的操作，完成本地分支向远程分支的同步</li>
<li>Git log filename 查看文件提交历史</li>
<li>Git log branch file 查看分支提交历史</li>
<li>我们在本地工程常会修改一些配置文件，这些文件不需要被提交，而我们又不想每次执行git status时都让这些文件显示出来，我们该如何操作？<ul>
<li>答：在Git工作区的跟目录下创建一个特殊的.gitignore文件，然后把忽略的文件名编辑进去，Git就会自动忽略这些文件。</li>
</ul>
</li>
<li>git提交代码时候写错commit信息后，如何重新设置commit信息？<ul>
<li>答：可以通过Git commit –amend 来对本次commit进行修改。</li>
</ul>
</li>
<li>什么时候应使用 “git stash”？<ul>
<li>git stash 命令把你未提交的修改（已暂存（staged）和未暂存的（unstaged））保存以供后续使用，以后就可以从工作副本中进行还原。</li>
</ul>
</li>
<li>如何从 git 中删除文件，而不将其从文件系统中删除？</li>
<li>如果你在 git add 过程中误操作，你最终会添加不想提交的文件。但是，git rm 则会把你的文件从你暂存区（索引）和文件系统（工作树）中删除，这可能不是你想要的。所以：换成 git reset 操作。</li>
<li>git 常规命令：<blockquote>
<p>git commit：是将本地修改过的文件提交到本地库中；<br>git push：是将本地库中的最新信息发送给远程库；<br>git pull：是从远程获取最新版本到本地，并自动merge；<br>git fetch：是从远程获取最新版本到本地，不会自动merge；<br>git merge：是用于从指定的commit(s)合并到当前分支，用来合并两个分支；</p>
<ol start="14">
<li>git clone <source repository> <destination repository>  本地</destination></li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="补充：Mybatis的逆向工程"><a href="#补充：Mybatis的逆向工程" class="headerlink" title="补充：Mybatis的逆向工程"></a>补充：Mybatis的逆向工程</h3><p>使用MybatisGenerator工具和mybatis-generator-gui界面工具，根据现有数据库表结构的基础上，自动生成bean、sql语句的xml、Mapper等文件<br>步骤：</p>
<ol>
<li>连接到数据库中。</li>
<li>指定各文件的存放位置。</li>
<li>生成代码。</li>
</ol>
<h3 id="补充：将Entity类实例Null-的属性字段过滤掉的最佳实践。通常用在-JPA-中"><a href="#补充：将Entity类实例Null-的属性字段过滤掉的最佳实践。通常用在-JPA-中" class="headerlink" title="补充：将Entity类实例Null 的属性字段过滤掉的最佳实践。通常用在 JPA 中"></a>补充：将Entity类实例Null 的属性字段过滤掉的最佳实践。通常用在 JPA 中</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lee 理解：通过 Wrapper修饰 src，然后取出所有的属性，过滤掉实例中属性为 null 的属性</span></span><br><span class="line"><span class="comment">// lee 认为，这种设计模式也很值得学习</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpaUtil</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyNotNullProperties</span><span class="params">(Object src, Object target)</span>&#123;</span><br><span class="line">    BeanUtils.copyProperties(src, target, getNullPropertyNames(src));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String[] getNullPropertyNames(Object object)&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BeanWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanWrapperImpl</span>(object);</span><br><span class="line">    <span class="keyword">return</span> Stream.of(wrapper.getPropertyDescriptors())</span><br><span class="line">      .map(PropertyDescriptor::getName)</span><br><span class="line">      .filter(propertyName -&gt; wrapper.getPropertyValue(propertyName) == <span class="literal">null</span>)</span><br><span class="line">      .toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="补充：配置Spring的方式："><a href="#补充：配置Spring的方式：" class="headerlink" title="补充：配置Spring的方式："></a>补充：配置Spring的方式：</h3><ol>
<li>XML 文件；</li>
<li>注解；</li>
<li>Java配置：</li>
</ol>
<blockquote>
<p>Spring对Java配置的支持是由@Configuration注解和@Bean注解来实现的。由@Bean注解的方法将会实例化、配置和初始化一个新对象，这个对象将由Spring的IoC容器来管理。**@Bean声明所起到的作用与<code>&lt;bean/&gt; </code>元素类似**。被@Configuration所注解的类则表示这个类的主要目的是作为bean定义的资源。被@Configuration声明的类可以通过在同一个类的内部调用@bean方法来设置嵌入bean的依赖关系。</p>
</blockquote>
<p>推荐阅读：<a href="https://blog.csdn.net/mrleeapple/article/details/78464723">请搜关键词：Spring配置</a></p>
<h3 id="补充：Restful-说一下："><a href="#补充：Restful-说一下：" class="headerlink" title="补充：Restful 说一下："></a>补充：Restful 说一下：</h3><ol>
<li>网络上的信息定义为一种资源</li>
<li>使用 HTTP 协议中的 get、post、put、delete等操作方式代表资源的增删改查操作。</li>
<li>个人理解：比较理想化、不太适合复杂业务逻辑的项目。</li>
</ol>
<h3 id="补充：反射执行Java代码的优缺点？"><a href="#补充：反射执行Java代码的优缺点？" class="headerlink" title="补充：反射执行Java代码的优缺点？"></a>补充：反射执行Java代码的优缺点？</h3><p>优点：</p>
<ol>
<li>能够动态获取类的实例，提高系统的灵活性和扩展性；</li>
<li>与Java动态编译相结合，可以实现更多功能。</li>
</ol>
<p>缺点：</p>
<ol>
<li>性能较低；</li>
<li>反射相对不太安全；</li>
<li>破坏了类的封装性， 可以获取这个类的私有方法和属性。</li>
</ol>
<h4 id="反射之本地实现"><a href="#反射之本地实现" class="headerlink" title="反射之本地实现"></a>反射之本地实现</h4><ol>
<li>方法调用时，也就是将传入的参数准备好，执行 <code>Method.invoke()</code>方法，然后调用进入目标方法。</li>
<li>此方法会调用<code>MethodAccessor</code>接口的<code>invoke()</code>方法，然后进入委派实现<code>DelegatingMethodAccessorImpl()</code>，再然后进入本地实现<code>NativeMethodAccessorImpl</code>最终达到目标方法。</li>
<li>就是说会通过 Java 调用 C++，然后再转到 Java，比较耗时，适合只执行一次的目标方法，如果想多次执行，就会切换到动态实现了（调用次数超过15次，就由委派实现切换到动态实现）。</li>
</ol>
<h4 id="反射之动态实现"><a href="#反射之动态实现" class="headerlink" title="反射之动态实现"></a>反射之动态实现</h4><ol>
<li>动态实现是一种将方法动态生成字节码的实现方式，先经过十分耗时的“生成字节码”的操作，然后通过字节码进行反射却不怎么耗时（比本地实现效率高上20倍）。</li>
<li>对比两种方式，如果是仅执行一次的方法，那么本地实现比较划算，如果是要多次执行的热点代码，将会切换到动态实现，通过字节码来执行反射更加合理。这种情况十分类似于 Java 代码中的解释执行跟编译执行的区别，如下：<ul>
<li>热点代码（编译执行 – 动态实现）</li>
<li>冷门代码（解释执行 – 本地实现）</li>
</ul>
</li>
</ol>
<h4 id="反射为什么效率低"><a href="#反射为什么效率低" class="headerlink" title="反射为什么效率低"></a>反射为什么效率低</h4><ol>
<li>变长参数方法导致的 Object 数组。</li>
<li>基本类型的自动装箱、拆箱。</li>
<li>某些场合的方法内联失效。</li>
</ol>
<p>目前的优化方向：</p>
<ol>
<li>方法内联。</li>
<li>关闭反射调用的 Inflation 机制，取消本地实现，全部使用动态实现。</li>
<li>取消每次反射调用前的检查。也就是<code>method.setAccessible(true);</code></li>
</ol>
<p>参考“《深入拆解 Java 虚拟机（极客时间）》07.JVM 是如何实现反射的？”</p>
<h4 id="反射的运用领域？"><a href="#反射的运用领域？" class="headerlink" title="反射的运用领域？"></a>反射的运用领域？</h4><ol>
<li>反射可以拿到类的实例；</li>
<li>反射可以用来判断某类是不是另一个类的实例；</li>
<li>可以用<code>Array.newInstance(Class,int)</code>来构造该类型的数组；</li>
<li>自定义注解：在自定义注解时，需要三步①<strong>定义注解——相当于定义标记</strong>；②<strong>配置注解——把标记打在需要用到的程序代码中；</strong>③<strong>解析注解——在编译期或运行时检测到标记，并进行特殊操作。</strong>其中第三步，就是通过反射来实现。参考：<a href="https://www.jianshu.com/p/a7bedc771204">自定义注解-简书</a>，<a href="https://blog.csdn.net/xsp_happyboy/article/details/80987484">自定义注解-csdn</a>。</li>
<li>可以访问到类的成员（注：<code>getDeclaredMethods()</code>方法不会返回父类成员，但能够返回私有成员；<code>getMethods()</code>方法刚好相反），拿到成员后，可以：</li>
<li>使用<code>Methods.setAccessible()</code>方法可以绕过Java 的语言限制；</li>
<li>使用<code>Constructor.newInstance()</code>获得类的实例；</li>
<li>使用<code>Method.invoke()</code>来调用方法。</li>
</ol>
<p>有关反射的内容：这里有篇文章看到热泪：<a href="https://mp.weixin.qq.com/s/5H6UHcP6kvR2X5hTj_SBjA">假笨说-从一起GC血案谈到反射原理</a>，有脑无脑强推！！！</p>
<h1 id="阿里-Java-一面"><a href="#阿里-Java-一面" class="headerlink" title="阿里 Java 一面"></a>阿里 Java 一面</h1><h3 id="1-Spring-怎么对-bean-进行增强或者修改。"><a href="#1-Spring-怎么对-bean-进行增强或者修改。" class="headerlink" title="1. Spring 怎么对 bean 进行增强或者修改。"></a>1. Spring 怎么对 bean 进行增强或者修改。</h3><p>可以通过bean的后处理器。</p>
<ol>
<li>bean 的后处理器中的BeforInitialization 和 AfterInitialization 方法。</li>
<li>init-method 、destroy-method 方法；</li>
<li>实现*Aware 接口，在bean 中Spring框架的某些对象，比如ApplicationContext、beanFactory、beanName等。</li>
</ol>
<h3 id="2-CountDownLatch-细节"><a href="#2-CountDownLatch-细节" class="headerlink" title="2. CountDownLatch 细节"></a>2. CountDownLatch 细节</h3><h3 id="3-new-一个很大的对象，对象是怎么分配的"><a href="#3-new-一个很大的对象，对象是怎么分配的" class="headerlink" title="3. new 一个很大的对象，对象是怎么分配的"></a>3. new 一个很大的对象，对象是怎么分配的</h3><h3 id="4-最新的垃圾回收机制有了解过吗？"><a href="#4-最新的垃圾回收机制有了解过吗？" class="headerlink" title="4. 最新的垃圾回收机制有了解过吗？"></a>4. 最新的垃圾回收机制有了解过吗？</h3><p>ZGC</p>
<h3 id="5-项目访问量对项目的影响？"><a href="#5-项目访问量对项目的影响？" class="headerlink" title="5. 项目访问量对项目的影响？"></a>5. 项目访问量对项目的影响？</h3><h3 id="6-Redis-的key、value能装类吗？"><a href="#6-Redis-的key、value能装类吗？" class="headerlink" title="6. Redis 的key、value能装类吗？"></a>6. Redis 的key、value能装类吗？</h3><h3 id="7-怎么序列化类的？"><a href="#7-怎么序列化类的？" class="headerlink" title="7. 怎么序列化类的？"></a>7. 怎么序列化类的？</h3><p>一般通过ObjectOutputStream 和 ObjectInputStream 进行序列化和反序列化的。</p>
<ol>
<li>类首先实现 Serializable 接口。<ol>
<li>在不想被序列化的属性前加上 transient 关键字；</li>
<li>也可以在类中自定义 WriteObject 、ReadObject 方法，让某些 transient 修饰的属性按照自定义的方式完成序列化。</li>
<li>静态属性不会被序列化。</li>
</ol>
</li>
<li>如果打算序列化父类的某些行为，那么父类也需要实现 Serializable 接口。所有引用对象也必须是可序列化的。</li>
<li>序列化是深拷贝的过程。</li>
<li>指定序列化ID，让相互传输数据的两个客户端之间类的序列化ID保持一致，这样才能正确地反序列化拿到数据。<ul>
<li>序列化ID 一般可以通过：类名，接口名，方法和属性等来生成的。</li>
</ul>
</li>
<li>对象转为二进制举例：新建一个 ObjectOutputStream 对象，同时传入一个 OutputStream 作为存储二进制数据的位置。再调用<code>writeObject()</code>将对象写入。</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 核心代码</span></span><br><span class="line"><span class="comment">// 一个名为 A 并实现 Serializable 接口的类此处未展示</span></span><br><span class="line"><span class="comment">// 类 A 不能是内部类，因为内部类的序列化要依赖于外部类</span></span><br><span class="line">@Test</span><br><span class="line">public void test<span class="literal">()</span> &#123;</span><br><span class="line">	A a = <span class="keyword">new</span> <span class="constructor">A()</span>;</span><br><span class="line">	a.value = <span class="number">1</span>;</span><br><span class="line">	a.name = <span class="string">&quot;xiaoming&quot;</span>;</span><br><span class="line"></span><br><span class="line">	FileOutputStream fos = null;</span><br><span class="line">	FileInputStream fis = null;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		fos = <span class="keyword">new</span> <span class="constructor">FileOutputStream(<span class="string">&quot;temp&quot;</span>)</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> <span class="constructor">ObjectOutputStream(<span class="params">fos</span>)</span>;</span><br><span class="line">		oos.write<span class="constructor">Object(<span class="params">a</span>)</span>;</span><br><span class="line">		fos.close<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">		fis = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">&quot;temp&quot;</span>)</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> <span class="constructor">ObjectInputStream(<span class="params">fis</span>)</span>;</span><br><span class="line">		A a2 = (A) ois.read<span class="constructor">Object()</span>;</span><br><span class="line">		fis.close<span class="literal">()</span>;</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a2.value);</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(a2.name);</span><br><span class="line"></span><br><span class="line">	&#125;catch (IOException e)&#123;</span><br><span class="line">		e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">	&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">		e.print<span class="constructor">StackTrace()</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>参考阅读：<a href="https://blog.csdn.net/a724888/article/details/80210095">Java基础18：Java序列化与反序列化</a></p>
<p>深拷贝扩展：</p>
<ol>
<li>简短解说： 浅拷贝：拷贝对象与原始对象的引用类型引用同一个对象；深拷贝：拷贝对象与原始对象的引用类型引用不同对象。</li>
<li>欲实现引用属性的拷贝，就需要实现 cloneable 接口，并重写 clone 方法来实现。比如想拷贝类 A，就让类A按上面的做法。</li>
</ol>
<ul>
<li>不重写 clone 方法，默认就是浅拷贝，重写了才是深拷贝。</li>
</ul>
<ol start="3">
<li>欲实现引用对象的<strong>深拷贝</strong>，就需要让被引用的类也同样实现 cloneable 接口，并重写其 clone 方法来实现。也就是说类 A 携带有指向类 B 的引用，那么 A、B 都要实现 cloneable 接口并重写 clone 方法。但是此做法不利于后期的维护。</li>
<li>以上两种做法要么不全面，要么太难，所以可以采用序列化的方式来实现，参考：<a href="https://www.cnblogs.com/NaLanZiYi-LinEr/p/9192734.html">Java深拷贝与序列化</a></li>
</ol>
<h3 id="8-Redis-数据的序列化机制？"><a href="#8-Redis-数据的序列化机制？" class="headerlink" title="8. Redis 数据的序列化机制？"></a>8. Redis 数据的序列化机制？</h3><ol>
<li>使用 RedisTemplate 中的一个序列化工具：<code>GenericJackson2JsonRedisSerializer</code>。</li>
</ol>
<p>推荐阅读:<a href="https://blog.csdn.net/asdfsadfasdfsa/article/details/79962056">RedisTemplate序列化工具</a></p>
<h3 id="9-序列化成字符串然后存到Redis的value-中，这部分工作能否让Redis-完成？效率如何？"><a href="#9-序列化成字符串然后存到Redis的value-中，这部分工作能否让Redis-完成？效率如何？" class="headerlink" title="9. 序列化成字符串然后存到Redis的value 中，这部分工作能否让Redis 完成？效率如何？"></a>9. 序列化成字符串然后存到Redis的value 中，这部分工作能否让Redis 完成？效率如何？</h3><h3 id="10-ConcurrentHashMap-的-put-方法"><a href="#10-ConcurrentHashMap-的-put-方法" class="headerlink" title="10. ConcurrentHashMap 的 put 方法"></a>10. ConcurrentHashMap 的 put 方法</h3><p>参考随手记第 14 题，往上翻。</p>
<h3 id="11-MySQL-索引的优先原则"><a href="#11-MySQL-索引的优先原则" class="headerlink" title="11. MySQL 索引的优先原则"></a>11. MySQL 索引的优先原则</h3><p>最左前缀原则。</p>
<h3 id="12-我的项目中动态编译、类加载的全部过程"><a href="#12-我的项目中动态编译、类加载的全部过程" class="headerlink" title="12. 我的项目中动态编译、类加载的全部过程"></a>12. 我的项目中动态编译、类加载的全部过程</h3><p>类加载参考其他题目，这里说一下编译过程：</p>
<ol>
<li>首先要涉及 JavaCompiler 这个类，它是 JDK 提供的动态编译的 api；</li>
<li>然后涉及 JavaFileObject 接口及发散类，它是封装源码和字节码的对象；</li>
<li>然后涉及 JavaFileManager 接口及发散类，编译器通过这个类来管理JavaFileObject对象；</li>
<li>然后调用<code>getTask()</code>方法生成编译任务并执行。获取到输出流，最终将输出流转换成字节数组。</li>
</ol>
<h3 id="补充：-MySQL-的行溢出"><a href="#补充：-MySQL-的行溢出" class="headerlink" title="补充： MySQL 的行溢出"></a>补充： MySQL 的行溢出</h3><p>行溢出：如果某条记录太大，即使叶子结点中还剩余一多半的空间但仍然存不下怎么办？这种情况称之为<strong>行溢出</strong>。<br>简单的解决方式就是把记录存储在溢出页（磁盘的其它空闲地方）中，然后叶子结点中存储的是这个记录的指针。</p>
<p>参考资料：<a href="https://www.cnblogs.com/nullzx/p/8978177.html">B+树在磁盘存储中的应用</a>，包括了对 4KB 大小的解释。</p>
<h3 id="补充：锁的-JVM-相关命令："><a href="#补充：锁的-JVM-相关命令：" class="headerlink" title="补充：锁的 JVM 相关命令："></a>补充：锁的 JVM 相关命令：</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">-XX:PreBlockSpin <span class="regexp">//</span> 更改自旋等待的次数</span><br><span class="line">-XX:+UseSpinning <span class="regexp">//</span> 开启或关闭自旋锁</span><br><span class="line">-XX:-UseBiasedLocking=false <span class="regexp">//</span> 命令关闭偏向锁（default 开启）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="补充：对象头细节："><a href="#补充：对象头细节：" class="headerlink" title="补充：对象头细节："></a>补充：对象头细节：</h3><p>对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。</p>
<ul>
<li>Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。	- 锁标志位：无锁 01、偏向锁 01、轻量级锁 00、重量级锁 10。</li>
<li>Klass Pointer：对象指向它的类元数据（亦称Klass、类类型，即类信息存储的地方，在方法区）的指针。</li>
</ul>
<h3 id="补充：Atomic-源码细节："><a href="#补充：Atomic-源码细节：" class="headerlink" title="补充：Atomic 源码细节："></a>补充：Atomic 源码细节：</h3><p>比如 AtomicInteger 的<code>getAndIncrement()</code>调用的就是 Unsafe 类的 <code>getAndAddInt()</code>方法。此方法使用 do-while 配合 CAS 进行自旋：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 来自 Unsafe类</span></span><br><span class="line">public final <span class="built_in">int</span> get<span class="constructor">AndAddInt(Object <span class="params">var1</span>, <span class="params">long</span> <span class="params">var2</span>, <span class="params">int</span> <span class="params">var4</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 取出内存中的值 var5</span></span><br><span class="line">        var5 = this.get<span class="constructor">IntVolatile(<span class="params">var1</span>, <span class="params">var2</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(!this.compare<span class="constructor">AndSwapInt(<span class="params">var1</span>, <span class="params">var2</span>, <span class="params">var5</span>, <span class="params">var5</span> + <span class="params">var4</span>)</span>); <span class="comment">// CAS 实现 var5 + var4</span></span><br><span class="line"></span><br><span class="line">    return var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="补充：Unsafe-类学习总结："><a href="#补充：Unsafe-类学习总结：" class="headerlink" title="补充：Unsafe 类学习总结："></a>补充：Unsafe 类学习总结：</h3><p>本小节知识点参考博客：<a href="https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html">Java魔法类：Unsafe应用解析</a></p>
<ol>
<li>Unsafe 的调用方必须是被Bootstrap CL 加载的类，否则会抛出安全异常，解决办法是：<ol>
<li>方法一：将欲调用 Unsafe 的类的 jar 包添加到默认的 bootstrap 路径中。</li>
<li>方法二：使用反射获取单例对象 Unsafe。</li>
</ol>
</li>
</ol>
<p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/5.png"></p>
<ol>
<li><strong>内存的操作</strong>。以下主要讲解<strong>直接内存</strong>：通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收。</li>
<li><strong>CAS 操作</strong>。代码可参考上一题——Atomic 源码细节。其中调用的 <code>compareAndSwap*</code>才是真正的原子操作，<code>CAS#getAndAddInt()</code>是在原子操作的基础上增加了自旋的逻辑。</li>
<li><strong>线程调度</strong>。</li>
</ol>
<blockquote>
<p>Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。<br>4. <strong>内存屏障</strong>。其实是 CPU 或者 IDE 对内存随机访问的一个安全点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。体现在 Unsafe类中的<code>*Fence()</code>系列方法<br>5. Class 操作。不展开，直接看原博客。<br>6. 对象操作。主要应用场景是：非常规的对象实例化方式（比如绕过类构造器，绕过安全检查等）。<br>7. 数组相关。主要跟 AtomicIntegerArray中的数组操作中的元素定位有关。<br>8. 系统相关。系统指针大小（32位指针大小是4B，64位是8B）；内存页大小（作者主机上内存页大小是4096B）。</p>
</blockquote>
<h3 id="补充：ReentrantLock-源码细节："><a href="#补充：ReentrantLock-源码细节：" class="headerlink" title="补充：ReentrantLock 源码细节："></a>补充：ReentrantLock 源码细节：</h3><h1 id="趣链-Java-一面之二"><a href="#趣链-Java-一面之二" class="headerlink" title="趣链 Java 一面之二"></a>趣链 Java 一面之二</h1><h3 id="redis-高效的原因，IO-多路复用讲一下"><a href="#redis-高效的原因，IO-多路复用讲一下" class="headerlink" title="redis 高效的原因，IO 多路复用讲一下"></a>redis 高效的原因，IO 多路复用讲一下</h3><ol>
<li>redis 是纯内存访问；</li>
<li>redis 使用单线程，避免了线程的切换和竞争；</li>
<li>redis 实现了 I&#x2F;O 多路复用技术，IO效率很高。</li>
</ol>
<p>IO 多路复用：用select、poll、epoll监听多个io对象，一旦某个io对象数据准备好了，就可以通知用户进程，完成业务。好处是单个进程可以处理多个socket连接。</p>
<ul>
<li>select：当用户进程调用select，此用户进程被阻塞，然后select会轮询它负责的socket流，当任意一个socket中的数据准备好了，select就会返回，此时用户进程会调用read操作拷贝数据。</li>
<li>poll：基于链表来存储，没有最大连接数的限制（也就是说可扩展长度）。</li>
<li>epoll：基于事件驱动：<ul>
<li>epoll 对象存放着“添加进来的事件”，这些事件挂载在红黑树中（能避免重复事件）</li>
<li>上面的这些事件会跟设备驱动建立回调关系，当事件发生时，会调用这个回调函数。此时发生的事件也会被添加到一个双链表中。</li>
</ul>
</li>
</ul>
<p>对比 select、poll、epoll：</p>
<ol>
<li>select 和 poll 的时间复杂度都是O(n)，都是无差别轮询所有流。两者本质没有差别，只是 poll 会把用户传入的数组拷到内核空间，然后逐个查询状态，而且 poll 是基于链表实现的。</li>
<li>epoll 的时间复杂度是O(1)，epoll 会把哪个流发生的什么 IO 事件发给我们，涉及到一些函数回调。</li>
</ol>
<h3 id="从-Java-内存模型角度讲一下-i-执行步骤"><a href="#从-Java-内存模型角度讲一下-i-执行步骤" class="headerlink" title="从 Java 内存模型角度讲一下 i++ 执行步骤"></a>从 Java 内存模型角度讲一下 i++ 执行步骤</h3><ol>
<li>从主内存中取出变量i到工作内存；</li>
<li>工作内存完成+1操作；</li>
<li>写回主内存。</li>
</ol>
<h3 id="a-x3D-a-b-与-a-x3D-b-的区别"><a href="#a-x3D-a-b-与-a-x3D-b-的区别" class="headerlink" title="a&#x3D;a+b 与 a+&#x3D;b 的区别"></a>a&#x3D;a+b 与 a+&#x3D;b 的区别</h3><ol>
<li>前者，计算a+b，然后赋给a引用。</li>
<li>后者，先用一个temp对象存储a，然后和b相加，相加结果赋给a引用。</li>
<li>+&#x3D; 涉及到自动类型转换的问题。</li>
</ol>
<h3 id="int-在32位和64位机子占的内存大小"><a href="#int-在32位和64位机子占的内存大小" class="headerlink" title="int 在32位和64位机子占的内存大小"></a>int 在32位和64位机子占的内存大小</h3><p>都是4个字节。</p>
<p>补充姿势：</p>
<p>1字节 8 位：byte&#x2F;8</p>
<p>2字节 CS（char 和 short）</p>
<p>4 字节 IF（int 和 float）</p>
<p>8 字节 LD（long 和 double）</p>
<h3 id="32位和64位，java-内存的分配大小"><a href="#32位和64位，java-内存的分配大小" class="headerlink" title="32位和64位，java 内存的分配大小"></a>32位和64位，java 内存的分配大小</h3><p>堆内存大小受：32位&#x2F;64位限制，可用虚拟内存限制，可用物理内存限制。<br>32位下，堆最大在1.5G~2G之间。64位要高30%左右。</p>
<h3 id="git-工作流、revert、fix-bugs"><a href="#git-工作流、revert、fix-bugs" class="headerlink" title="git 工作流、revert、fix bugs"></a>git 工作流、revert、fix bugs</h3><p>git revert 跟 git reset区别：</p>
<ol>
<li>git reset 恢复到之前提交的某个版本，之后提交的版本不要了。</li>
<li>git revert 反向创建一个新版本，这个版本跟我们要回退的版本一致。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/yxlshk/article/details/79944535">Git恢复之前版本的两种方法reset、revert（图文详解）</a></p>
<p>fixBugs：</p>
<ul>
<li>先在bug分支修改，</li>
<li>然后branch验证通过后，才被允许合并到master中。</li>
</ul>
<p><a href="http://blog.jobbole.com/76867/">git flow 简介</a></p>
<ol>
<li>历史分支：master 和 develop；</li>
<li>功能分支：feature；</li>
<li>发布分支：release；</li>
<li>维护分支：hotfix；</li>
</ol>
<h3 id="多线程传输的场景下，设计一个系统"><a href="#多线程传输的场景下，设计一个系统" class="headerlink" title="多线程传输的场景下，设计一个系统"></a>多线程传输的场景下，设计一个系统</h3><h3 id="分析多线程可能出现的问题，针对这些问题提出解决方案"><a href="#分析多线程可能出现的问题，针对这些问题提出解决方案" class="headerlink" title="分析多线程可能出现的问题，针对这些问题提出解决方案"></a>分析多线程可能出现的问题，针对这些问题提出解决方案</h3><ol>
<li>原子性问题；使用Synchronized关键字；</li>
<li>可见性问题；使用volatile关键字；</li>
<li>指令重排问题；使用volatile禁止指令重排。</li>
</ol>
<p><a href="https://blog.csdn.net/qq_31997407/article/details/79705767">原子性、内存可见性、重排序、顺序一致性、volatile、锁、final</a></p>
<h3 id="ringbuffer"><a href="#ringbuffer" class="headerlink" title="ringbuffer"></a>ringbuffer</h3><h3 id="多线程竞争、原子性等"><a href="#多线程竞争、原子性等" class="headerlink" title="多线程竞争、原子性等"></a>多线程竞争、原子性等</h3><h3 id="算法实现：rand-产生1到7，怎么实现1到10？"><a href="#算法实现：rand-产生1到7，怎么实现1到10？" class="headerlink" title="算法实现：rand 产生1到7，怎么实现1到10？"></a>算法实现：rand 产生1到7，怎么实现1到10？</h3><p>个人思路（乱来）：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rand</span>-<span class="number">1</span> 是<span class="number">0</span>到<span class="number">6</span>，</span><br><span class="line">（<span class="built_in">rand</span>-<span class="number">1</span>）*<span class="number">9</span>/<span class="number">6</span> 是<span class="number">0</span>到<span class="number">9</span></span><br><span class="line"><span class="number">1</span>+（<span class="built_in">rand</span> - <span class="number">1</span>）*<span class="number">9</span>/<span class="number">6</span> 就是<span class="number">1</span>到<span class="number">10</span>了吧</span><br></pre></td></tr></table></figure>

<p>官方解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rand10</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> rand7();</span><br><span class="line">    <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> rand7();</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> col + (row - <span class="number">1</span>)*<span class="number">7</span>;</span><br><span class="line">  &#125;<span class="keyword">while</span>(index &gt; <span class="number">40</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + (index - <span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="java-util-concurrent-中-CountDownLatch、CyclicaBarrier、Semaphore"><a href="#java-util-concurrent-中-CountDownLatch、CyclicaBarrier、Semaphore" class="headerlink" title="java.util.concurrent 中 CountDownLatch、CyclicaBarrier、Semaphore"></a>java.util.concurrent 中 CountDownLatch、CyclicaBarrier、Semaphore</h3><h3 id="Http-协议-与-Https-协议的区别，增加的-s-层细节"><a href="#Http-协议-与-Https-协议的区别，增加的-s-层细节" class="headerlink" title="Http 协议 与 Https 协议的区别，增加的 s 层细节"></a>Http 协议 与 Https 协议的区别，增加的 s 层细节</h3><ol>
<li>接收client访问时，server 返回数字证书，包括server的公钥；client使用预置的 CA 列表验证证书。</li>
<li>client再生成一个随机的对称密钥，用server的公钥加密后发给server。server用自己的私钥解密，得到此对称密钥。</li>
<li>之后可以相互访问。</li>
</ol>
<p>推荐阅读：<a href="http://likehui.fun/2018/12/19/HTTP-1-1/">HTTP-1-1</a></p>
<h3 id="有了-HTTP协议，为什么还需要-RPC-协议呢？"><a href="#有了-HTTP协议，为什么还需要-RPC-协议呢？" class="headerlink" title="有了 HTTP协议，为什么还需要 RPC 协议呢？"></a>有了 HTTP协议，为什么还需要 RPC 协议呢？</h3><p><img src="/2019/02/23/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%866/7.jpg" alt="RPC&amp;Http"></p>
<p>Http跟 RPC 不是同一级别的概念，但它们都是解决应用调用另一个应用的备选方案。</p>
<p>Http：可读性好、跨语言性、有防火墙支持等优势。最佳实践—— Restful 。</p>
<p>RPC：不是网络七层、头部信息少，相比 HTTP 能携带更多信息，效率高。可基于私有协议传输。最佳实践——Dubbo、gRpc、thrift。</p>
<h1 id="趣链-Java-一面之三"><a href="#趣链-Java-一面之三" class="headerlink" title="趣链 Java 一面之三"></a>趣链 Java 一面之三</h1><p>1）介绍下自己的项目</p>
<p>2）JVM 垃圾回收算法</p>
<ol>
<li>标记清除；先标记阶段然后清除阶段。<ul>
<li>适合老年代；</li>
</ul>
</li>
<li>标记整理；先标记，然后存活对象向一端移动。<ul>
<li>适合老年代；</li>
</ul>
</li>
<li>复制；一半使用，一半备用。将活着的对象复制到备用块上，然后将原内存块一次性清理掉。<ul>
<li>适合新生代。</li>
</ul>
</li>
<li>分代回收。</li>
</ol>
<p>收集器：（记忆：3对+1）<br>左边新生代都是复制算法，右边老年代。ParNew 是 serial 的多线程版本。ParNew 跟 Parallel Scavenge 几乎一样。</p>
<ul>
<li><p>serial &amp; serial Old（整）</p>
</li>
<li><p>ParNew &amp; CMS（清）绝配。</p>
</li>
<li><p>Parallel Scavenge &amp; Paralled Old（整）</p>
</li>
<li><p>G1 </p>
</li>
<li><p>G1收集器的特点：用在服务器，在满足GC停顿时间要求的同时，还具备高吞吐量性能特征。</p>
<ol>
<li>通过并发的方式，让GC线程与Java程序同时运行。</li>
<li>可以独立管理新生代和老年代。</li>
<li>可预测的停顿，建立一个可预测的停顿时间模型，让使用者明确指明一个长度为M毫秒的时间片段内。</li>
<li>具有一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的部分进行回收。</li>
</ol>
</li>
</ul>
<p>3）synchronized 与ReentrantLock 区别</p>
<ol>
<li>都是可重入锁；</li>
<li>前者依赖于JVM，程序员看不到，后者依赖于API，可以查看JDK中它的源码；</li>
<li>后者有新功能：<ol>
<li>等待可中断；</li>
<li>可实现公平锁；</li>
<li>ReentrantLock 结合 Condition 可以选择性地通知某些线程（这些线程在Condition对象中注册），而不是使用 notify&#x2F;notifyAll（效率低）。</li>
</ol>
</li>
</ol>
<p>4）java.util.concurrent 中 CountDownLatch、CyclicaBarrier、Semaphore</p>
<p>5）创建线程的 3 中方法：Thread、Callable、Runnable，区别，你的使用习惯</p>
<p>6）线程池</p>
<p>10）Http 协议 与 TCP 的区别</p>
<p>11）进程间通信：管程、Socket…</p>
<p>12）进程与线程的区别，有没有做过多进程的项目</p>
<p>13）MySql 索引</p>
<ul>
<li>聚簇索引：每张表主键构成B+树（存储顺序与索引顺序一致），叶子节点存放真实的数据行。<ul>
<li>主要用在InnoDB引擎上。</li>
</ul>
</li>
<li>非聚簇索引：数据行存储顺序与索引存储顺序不一致，叶子节点没有存放数据，存的是“键-指针对”，根据此指针再去其他索引树去查找。<ul>
<li>主要用在MyISAM引擎上。</li>
</ul>
</li>
</ul>
<p>InnoDB 跟 MyISAM 的区别：</p>
<p>14）注入攻击</p>
<p>15）跨域请求</p>
<p>16）项目中的拦截机制、Session</p>
<p>17）项目中考虑到的安全问题</p>
<p>18）Redis 缓存使用中当数据库中数据更新了，怎么实现缓存中的更新</p>
<p>19）Redis 的用处啥的</p>
<p>24）有没有使用过 git</p>
<p>25）git 的基本操作</p>
<p>26）git clone 与 git fork 的区别</p>
<p>27）合作项目中 git 的使用，主要是 master 和分支啥的</p>
<p>29）有没有使用过 rpc</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理5</title>
    <url>/2019/01/11/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%865/</url>
    <content><![CDATA[<h3 id="1-spring事务写在哪一部分，为什么不写在DAO-Controller层"><a href="#1-spring事务写在哪一部分，为什么不写在DAO-Controller层" class="headerlink" title="1. spring事务写在哪一部分，为什么不写在DAO,Controller层"></a>1. spring事务写在哪一部分，为什么不写在DAO,Controller层</h3><p><strong>事务写在Service层</strong>。</p>
<ol>
<li><p>为什么不在DAO层？</p>
<ul>
<li>在数据库中,所谓事务是指一组逻辑操作单元即一组sql语句。当这个单元中的一部分操作失败,整个事务回滚，只有全部正确才完成提交。</li>
<li>如果放在了DAO层，每一次增删改查都将提交一次事务，那么事务的一致性就会被破坏。</li>
<li>一般在Service的一处可以调用DAO层的多处，所以只要添加一处事务注解@Transactional，这样才能体现事务的特性。</li>
</ul>
</li>
<li><p>为什么不在Controller层？</p>
<ul>
<li>不推荐，但是事实上可以实现把事务放在Controller层。</li>
<li>一般不会将事务放在Controller层，而且直接放是会报404错误的（因为SpringMVC和Spring是两个不同的容器）。application.xml中应该负责扫描除@Controller的注解如@Service，而SpringMVC的配置文件应该只负责扫描@Controller，否则会产生重复扫描导致Spring容器中配置的事务失效。</li>
</ul>
</li>
</ol>
<span id="more"></span>

<p>推荐阅读：<br><a href="https://blog.csdn.net/PanYangxu/article/details/77431873">事务为什么加在service层而不加在dao层</a></p>
<p><a href="https://ask.csdn.net/questions/670086">@transactional可以注解到controller上吗？</a></p>
<p><a href="https://blog.csdn.net/mmm333zzz/article/details/45288061">在Spring MVC中，事务可以加在Controller层</a></p>
<p>【严重推荐！】<a href="http://www.importnew.com/28465.html">Transaction 在 Controller 层的探索</a></p>
<h3 id="2-数据库驱动为什么使用反射调用不直接new"><a href="#2-数据库驱动为什么使用反射调用不直接new" class="headerlink" title="2. 数据库驱动为什么使用反射调用不直接new"></a>2. 数据库驱动为什么使用反射调用不直接new</h3><p>使用<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 去加载驱动的目的：</p>
<ol>
<li>   用反射检查JDBC驱动的主类<code>com.mysql.jdbc.Driver</code>是否存在，若不存在则表示运行环境中没有这个驱动，并进入catch段。用反射来加载的好处是，当驱动jar包不存在时，我们可以做更多的操作。</li>
<li>   实现解耦。JDBC其实是JDK的一系列接口，对于不同数据库软件有不同的实现。使用反射后，代码中就不存在任何与实现相关的东西。如果直接用new，那么可能会引入<code>com.mysql.*</code>或者<code>com.oracle.*</code>等，与代码耦合性高。</li>
</ol>
<p>推荐阅读：<a href="https://www.jianshu.com/p/bed585ae1b34">JDBC为什么使用反射加载驱动</a></p>
<h3 id="3-观察者模式讲一下"><a href="#3-观察者模式讲一下" class="headerlink" title="3. 观察者模式讲一下"></a>3. 观察者模式讲一下</h3><ol>
<li>是一对多关系的体现。</li>
<li>每个观察者Observer需要被保存到被观察者的集合中，并且被观察者提供添加和删除的方式。</li>
<li>被观察者把自己传给观察者（使用Observer自身的构造方法），当状态改变后，通过遍历和循环的方式逐个通知列表中的观察者。</li>
<li>虽然解耦了观察者和被观察者的依赖，让各自的变化不大影响另一方的变化，但是这种解耦并不是很彻底，没有完全解除两者之间的耦合。</li>
</ol>
<p>推荐阅读：<a href="http://blog.jobbole.com/109845/">观察者模式</a></p>
<h3 id="4-多线程之Monitor"><a href="#4-多线程之Monitor" class="headerlink" title="4. 多线程之Monitor"></a>4. 多线程之Monitor</h3><ul>
<li><p>Synchronized关键字包括monitor enter和monitor exit两个JVM指令。</p>
</li>
<li><p>Monitor是一种同步机制。使用synchronized关键字时，同一时刻只能有一个线程访问同步资源，视为“加锁”。但实际上，是该线程获取了与mutex（互斥对象，即monitor object）相关联的monitor锁。</p>
</li>
<li><p>在JVM中，每一个对象都与一个monitor相关联，一个monitor的lock锁只能被一个线程在同一时间获得，在一个线程尝试获得与对象关联monitor的所有权时会发生如下的情况：</p>
<ol>
<li>如果monitor的计数器为0，意味着该monitor的lock还没有被获得，某个线程获得之后将立即对该计数器加一，从此该线程就是这个monitor的所有者了。</li>
<li>如果一个已经拥有该monitor所有权的线程重入，则monitor计数器再次累加。</li>
<li>如果monitor已经被其他线程所拥有，那么某个线程尝试获取该monitor的所有权时，会被陷入阻塞状态知道monitor计数器变为0，才能再次尝试获取对monitor的所有权。</li>
</ol>
</li>
<li><p>Wait()&#x2F;notify()&#x2F;notifyAll()方法构成监视条件（Monitor Condition）。</p>
</li>
<li><p>拥有monitor锁的线程可以调用wait()进入等待队列（Wait Set），同时释放监视锁，进入等待状态。</p>
</li>
<li><p>其他线程（有monitor锁的线程才有资格）调用notify()&#x2F;notifyAll()方法唤醒等待队列中的线程，被唤醒的线程需要重新争取monitor锁。</p>
</li>
</ul>
<p>推荐阅读：《Java高并发编程详解》P69 - P70<br>    以及：<a href="https://www.jianshu.com/p/6fe4bc3374a2">Java 多线程（二）－Monitor</a></p>
<h3 id="5-如何使浏览器加载请求可以稳定到达后台而不使用浏览器缓存"><a href="#5-如何使浏览器加载请求可以稳定到达后台而不使用浏览器缓存" class="headerlink" title="5. 如何使浏览器加载请求可以稳定到达后台而不使用浏览器缓存"></a>5. 如何使浏览器加载请求可以稳定到达后台而不使用浏览器缓存</h3><ol>
<li><p><code>Cache-Control/Pragma</code>这个HTTP Head字段中进行缓存禁用：</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Cache-Control:</span> <span class="literal">no</span><span class="string">-store</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="literal">no</span><span class="string">-cache,</span> <span class="literal">no</span><span class="string">-store,</span> <span class="string">must-revalidate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Expires</code>字段，后面设置过期的日期和时间。</p>
</li>
<li><p><code>Last-Modified/EtagLast-Modified</code>字段，一般服务端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如Last-Modified:Sat,25Feb201212:55:04GMT，浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25Feb 201212:55:04GMT字段，询问当前缓存的页面是否是最新的，如果是最新的就返回304状态码，告诉浏览器是最新的，服务器也不会传输新的数据。</p>
</li>
<li><p><code>Etag</code>字段，与Last-Modified字段类似。这个字段的作用是让服务端给每个页面分配一个唯一的编号，然后通过这个编号来区分当前这个页面是否是最新的。这种方式比使用Last-Modified更加灵活，但是在后端的Web服务器有多台时比较难处理，因为每个Web服务器都要记住网站的所有资源，否则浏览器返回这个编号就没有意义了。</p>
</li>
</ol>
<p>推荐阅读：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ">HTTP 缓存</a></p>
<p><a href="https://blog.csdn.net/u014034854/article/details/50374709">防止浏览器缓存的几种方法</a></p>
<h3 id="6-eclipse、IJ开发快捷键及使用技巧讲几个"><a href="#6-eclipse、IJ开发快捷键及使用技巧讲几个" class="headerlink" title="6. eclipse、IJ开发快捷键及使用技巧讲几个"></a>6. eclipse、IJ开发快捷键及使用技巧讲几个</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Eclipse</th>
<th align="center">Idea</th>
</tr>
</thead>
<tbody><tr>
<td align="center">格式化当前代码</td>
<td align="center">Ctrl+Shift+F</td>
<td align="center">Ctrl+Alt+L</td>
</tr>
<tr>
<td align="center">注释当前行，再按取消注释</td>
<td align="center">Ctrl+&#x2F;</td>
<td align="center">Ctrl+&#x2F;</td>
</tr>
<tr>
<td align="center">删除当前行</td>
<td align="center">Ctrl+D</td>
<td align="center">Ctrl+X</td>
</tr>
<tr>
<td align="center">自动补全代码或者提示代码</td>
<td align="center">Alt+&#x2F;</td>
<td align="center">Ctrl+空格</td>
</tr>
<tr>
<td align="center">组织类的import导入</td>
<td align="center">Ctrl+Shift+O</td>
<td align="center">Alt+空格</td>
</tr>
</tbody></table>
<p>Eclipse使用技巧：</p>
<ol>
<li>   在Eclipse里文档生成是件简单的事情，只要键入“&#x2F;**”，在一个声明上按enter键。</li>
<li>   查看某个类的继承关系：选中该类，ctrl+t。</li>
<li>   快捷键添加set、get方法，重写或实现接口的某个方法：shift+alt+s</li>
</ol>
<p>Idea使用技巧：</p>
<ol>
<li>   Ctrl+H 查看类的继承层次。</li>
<li>   Ctrl+Alt+B 可以跳转到抽象方法的实现。</li>
<li>   Ctrl-Shift-Backspace 让你调转到代码中所做改变的最后一个地方，多按几次 Ctrl-Shift-Backspace 查看更深的修改历史。</li>
<li>   使用 Ctrl-Shift-V 快捷键可以将最近使用的剪贴板内容选择插入到文本。使用时系统会弹出一个含有剪贴内容的对话框，从中你可以选择你要粘贴的部分。</li>
<li>   Ctrl-D 可以复制选择的块或者没有所选块是的当前行。</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/childhooders/article/details/4319679">IntelliJ Idea 常用快捷键列表</a></p>
<p><a href="http://www.imooc.com/article/1009">eclipse使用技巧心得分享</a></p>
<h3 id="7-classPath-与path的区别"><a href="#7-classPath-与path的区别" class="headerlink" title="7. classPath 与path的区别"></a>7. classPath 与path的区别</h3><ol>
<li>Path环境变量，作用是指定<strong>命令搜索路径</strong>。<ul>
<li>比如，在命令行下 javac  helloWorld.java，那么将从Path路径下找这个java文件。</li>
<li>如何来做：把jdk安装目录下的bin目录增加到现有的PATH变量中（bin目录下有常用的javac&#x2F;java&#x2F;javadoc等命令）。</li>
</ul>
</li>
<li>ClassPath环境变量，作用是指定<strong>类搜索路径</strong>。<ul>
<li>JVM就是通过CLASSPTH来寻找类的。</li>
<li>如何来做：需要把jdk安装目录下的lib子目录中的dt.jar和tools.jar，以及当前目录“.”一并设置到CLASSPATH中。</li>
</ul>
</li>
<li>JAVA_HOME环境变量，指向<strong>jdk的安装目录</strong>。<ul>
<li>Eclipse&#x2F;NetBeans&#x2F;Tomcat等软件就是通过搜索JAVA_HOME变量来找到并使用安装好的jdk。</li>
</ul>
</li>
</ol>
<p>推荐阅读：<a href="https://blog.csdn.net/fb281906011/article/details/8057672">环境变量path和classpath的作用是什么?</a></p>
<h3 id="8-Linux-的软链接、硬连接"><a href="#8-Linux-的软链接、硬连接" class="headerlink" title="8. Linux 的软链接、硬连接"></a>8. Linux 的软链接、硬连接</h3><p>先看三个概念，文件数据块、元数据、inode号，解释如下：</p>
<ol>
<li>文件数据块（data block），也称为用户数据（user data），是记录文件真实内容的地方。</li>
<li>元数据（metadata），属于文件的附加属性，记录着“文件大小、创建时间、所有者”等信息。也包括了inode号。</li>
<li>inode号，是文件的唯一标识（文件名不是唯一标识），使用inode号来查找正确的文件数据块。（流程：filename -&gt; inode -&gt; data blocks）。<ul>
<li>在 linux 中，可以使用命令 <code>ls -i</code>查看 inode。</li>
<li>移动命令<code>mv</code>和重命名，并不会改变文件的“文件数据块”和 inode 号。</li>
</ul>
</li>
</ol>
<p>重点来了，硬链接与软链接，如下：</p>
<ol>
<li>硬链接 hard link：同一个文件使用的多个别名。此时的多个 link 有着共同的 inode 及 data block，<strong>仅文件名不相同</strong>。<ul>
<li>可以用命令<code>link</code>或<code>ln</code>创建，后跟<code>-d</code>。</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统创建硬链接；</li>
<li>只能对文件创建，不能对目录进行创建；</li>
<li>删除硬链时，不会影响其他有相同 inode 号的文件。</li>
</ul>
</li>
<li>软链接 soft link 或者 symbolic link：若文件的文件数据块中存放的内容是另一个文件的路径名的指向时，这个文件就是软链接。软链接就是一个普通文件，只是数据块内容有点特殊，它有自己独有的 inode 号以及文件数据块。<ul>
<li>可以用命令<code>ln -s</code>来创建；</li>
<li>有自己的文件属性及权限；</li>
<li>可对不存在的文件或目录创建软链；</li>
<li>可交叉文件系统；</li>
<li>创建软链时，链接计数<code>i_nlink</code>不会增加；<ul>
<li>简单来说，<code>i_nlink</code>是一个inode中统计 hard link 数量的计数器</li>
</ul>
</li>
<li>删除软链不会影响被指向的文件，但如果被指向的原文件被删，则相关软链被称为死链。</li>
</ul>
</li>
</ol>
<p>软链接举例：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"># ln -s 目标地址 快捷方式地址（放在 <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span> 目录下可以直接启动）</span><br><span class="line">ln -s <span class="regexp">/usr/</span>redis-<span class="number">5.0</span>.<span class="number">3</span><span class="regexp">/src/</span>redis-cli <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>redis-cli</span><br></pre></td></tr></table></figure>


<p>推荐阅读：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html">理解 Linux 的硬链接与软链接</a></p>
<h3 id="9-Spring-中-bean-的生命周期"><a href="#9-Spring-中-bean-的生命周期" class="headerlink" title="9. Spring 中 bean 的生命周期"></a>9. Spring 中 bean 的生命周期</h3><p>在 Spring 中，bean 的生命周期完全由<strong>容器</strong>控制。</p>
<p><img src="/2019/01/11/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%865/bean2.jpg"></p>
<p><img src="/2019/01/11/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%865/bean.png"></p>
<p>最简理解（阉割版）：</p>
<ol>
<li>实例化bean；</li>
<li>DI；</li>
<li>前置、后置处理；</li>
<li>使用；</li>
<li>销毁。</li>
</ol>
<p>推荐阅读：<a href="https://www.zhihu.com/question/38597960">Spring中Bean的生命周期是怎样的？</a></p>
<h3 id="10-Mybatis批量查询手写sql"><a href="#10-Mybatis批量查询手写sql" class="headerlink" title="10.Mybatis批量查询手写sql"></a>10.Mybatis批量查询手写sql</h3><ol>
<li>情况1，传入是一个集合时（如一个装着 id 的 List ）如下：</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// Mapper.java</span><br><span class="line"> 	<span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; findUserListById(@Param(&quot;Ids&quot;) List&lt;<span class="type">Integer</span>&gt; Ids);</span><br><span class="line">	</span><br><span class="line">// mapper.xml</span><br><span class="line">	&lt;<span class="keyword">select</span> id = &quot;findUserListById&quot; resultType=&quot;com.glory.api.jog.pojo.User&quot;&gt;</span><br><span class="line">		<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users</span><br><span class="line">		<span class="keyword">WHERE</span> id <span class="keyword">IN</span></span><br><span class="line">		&lt;<span class="keyword">foreach</span> collection = &quot;Ids&quot; item = &quot;id&quot; <span class="keyword">open</span> = &quot;(&quot; <span class="keyword">close</span> = &quot;)&quot; separator = &quot;,&quot;&gt;</span><br><span class="line">			#&#123;id&#125;</span><br><span class="line">		&lt;/<span class="keyword">foreach</span>&gt;</span><br><span class="line">	&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>情况2，传入的是一个 Map时（Map 有一个&lt;String,List&gt;的键值对）如下：</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// Service</span><br><span class="line">	HashMap&lt;String,<span class="keyword">Object</span>&gt;params = <span class="built_in">new</span> HashMap&lt;&gt;();</span><br><span class="line">	params.put(&quot;mapList&quot;,list); // list中装着id</span><br><span class="line">	TestDao.findUserListByList(params);</span><br><span class="line"></span><br><span class="line">// Mapper.java</span><br><span class="line">	<span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; findUserListByList(HashMap&lt;String,<span class="keyword">Object</span>&gt; params);</span><br><span class="line"></span><br><span class="line">// mapper.xml</span><br><span class="line">	&lt;<span class="keyword">select</span> id=&quot;findUserListByList&quot; resultType = &quot;User&quot;&gt;</span><br><span class="line">		<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users</span><br><span class="line">		<span class="keyword">WHERE</span> id <span class="keyword">IN</span></span><br><span class="line">		&lt;<span class="keyword">foreach</span> item = &quot;item&quot; <span class="keyword">index</span> = &quot;index&quot; collection=&quot;mapList&quot;</span><br><span class="line">					<span class="keyword">open</span> = &quot;(&quot; <span class="keyword">close</span> = &quot;)&quot; separator = &quot;,&quot;&gt;</span><br><span class="line">				#&#123;item&#125;</span><br><span class="line">		&lt;/<span class="keyword">foreach</span>&gt;</span><br><span class="line">	&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line">&lt;!<span class="comment">--重点关注 collection 中的内容，传的是 map 中的一个 key--&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>情况3，传入的是一个对象时（比如对象中有一个 list 集合及 getter、setter 方法）如下：</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// Service</span><br><span class="line">	<span class="built_in">public</span> <span class="keyword">class</span> TestModel&#123;</span><br><span class="line">		private List&lt;<span class="type">Integer</span>&gt; listDemo;</span><br><span class="line">		// getter setter 方法略</span><br><span class="line">	&#125;</span><br><span class="line">	TestModel tm = <span class="built_in">new</span> TestModel();</span><br><span class="line">	tm.setter(listDemo); // listDemo 中装着id</span><br><span class="line">	TestDao.getListByObject(tm);</span><br><span class="line"></span><br><span class="line">// Mapper.java</span><br><span class="line">	<span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; getListByObject(TestModel tm);</span><br><span class="line">	</span><br><span class="line">// mapper.xml</span><br><span class="line">	&lt;<span class="keyword">select</span> id = &quot;getListByObject&quot; resultType = &quot;User&quot;&gt;</span><br><span class="line">		<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users</span><br><span class="line">		<span class="keyword">WHERE</span> id <span class="keyword">IN</span></span><br><span class="line">		&lt;<span class="keyword">foreach</span> item = &quot;item&quot; <span class="keyword">index</span> = &quot;index&quot; collection = &quot;listDemo&quot;</span><br><span class="line">				<span class="keyword">open</span> = &quot;(&quot; <span class="keyword">close</span> = &quot;)&quot; separator = &quot;,&quot;&gt;</span><br><span class="line">			#&#123;item&#125;</span><br><span class="line">		&lt;/<span class="keyword">foreach</span>&gt;</span><br><span class="line">	&lt;/<span class="keyword">select</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!<span class="comment">--重点关注 collection 中的内容，传的是对象中的一个属性--&gt;</span></span><br></pre></td></tr></table></figure>


<p>ps ：Mybatis 中的 resultType 与 resultMap的区分：</p>
<ol>
<li><p>resultType 是直接表示<strong>返回类型</strong>的 ，resultMap 则是对外部 ResultMap 的引用（旁边一定有个 ResultMap 的元素）。resultType 与resultMap 不能共存。</p>
</li>
<li><p>当提供的返回类型属性是<code>resultType</code>时，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，只是当提供的返回类型属性是resultType的时候，MyBatis对自动的给把对应的值赋给resultType所指定对象的属性。</p>
</li>
<li><p>当提供的返回类型是<code>resultMap</code>时，因为Map不能很好表示领域模型，就需要自己再进一步的把它转化为对应的对象，这常常在复杂查询中很有作用。使用 resultMap 的简单查询与复杂查询：</p>
 <figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--简单查询--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--通过“BlogResult”进行映射--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">id</span>=<span class="string">&quot;BlogResult&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;title&quot;</span> <span class="attr">property</span>=<span class="string">&quot;title&quot;</span>/&gt;</span> <span class="comment">&lt;!--如果不写这些映射，Mybatis也会自动帮封装--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;content&quot;</span> <span class="attr">property</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;owner&quot;</span> <span class="attr">property</span>=<span class="string">&quot;owner&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BlogResult&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">select * from t_blog where id = #</span><span class="template-variable">&#123;id&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>复杂查询就不写代码了，可能涉及到子节点、关联查询等，太复杂，建议直接看下面的链接。</li>
</ul>
<p>推荐阅读：<a href="https://blog.csdn.net/canot/article/details/50988550">Mybatis中的resultType和resultMap</a></p>
<h3 id="11-JVM、Tomcat与进程之间你需要知道的事情"><a href="#11-JVM、Tomcat与进程之间你需要知道的事情" class="headerlink" title="11. JVM、Tomcat与进程之间你需要知道的事情"></a>11. JVM、Tomcat与进程之间你需要知道的事情</h3><ol>
<li>一个 JVM 就相当于一个操作系统（实质是一个进程）。<ul>
<li>JVM 的生命周期：一个 Java 程序开始执行时，JVM 才运行；程序结束时它停止执行。</li>
</ul>
</li>
<li>一个 Java 应用程序会开启一个 JVM 进程，如果运行了三个程序，那么会有三个运行中的 JVM 进程。</li>
<li>JVM 运行 Java 程序有两种方式：jar 包和 Class：<ol>
<li>运行 jar 时，先拿 JNIEnv 实例，然后拿 Manifest 对象，最后拿 jar 中的文件（拿主类），然后装载该主类。</li>
<li>运行 Class 时，main 函数直接调用 Java.c 中的 LoadClass 方法装载该类。</li>
</ol>
</li>
<li>Tomcat 是一个 Java  程序，是一个用 Java 语言开发的免费开源的 Web 服务器。<ul>
<li>Tomcat 与 Java 应用程序（webapps 目录下的 war 包）是运行在同一个 JVM 中，但是分工不同，Tomcat 相当于调度员，Java 程序相当于工人。Tomcat 处理请求的步骤如下：<ol>
<li>Tomcat 监听8080端口（假设），一个 http 请求从主机的 8080 端口发送过来，Tomcat 最先获悉；</li>
<li>Tomcat 将该请求放入一个队列中，JVM 中有若干工作者线程会从此队列中获取任务；</li>
<li>假设线程 A 取得此任务，A 会分析请求的 url，并检查已加载的 Web.xml 配置，来判断要将此请求交给应用的哪个 servlet 来处理（假设应用由 servlet 来实现的）；</li>
<li>此时应用开始干活，解析请求参数，处理业务流程，生成响应；</li>
<li>线程 A 把 response 回送给请求的发送端。</li>
</ol>
</li>
</ul>
</li>
</ol>
<p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/25713880">Java JVM 运行机制及基本原理</a><br><a href="https://blog.csdn.net/cuisha_/article/details/83016518">tomcat 和 jvm 的关系</a></p>
<h3 id="12-通过-Class-对象获取方法集合的三种方法的区分"><a href="#12-通过-Class-对象获取方法集合的三种方法的区分" class="headerlink" title="12. 通过 Class 对象获取方法集合的三种方法的区分"></a>12. 通过 Class 对象获取方法集合的三种方法的区分</h3><ol>
<li>getDeclaredMethods： 获得声明的所有方法（protected、private、default、public，但不包含继承的方法）。</li>
<li>getMethods：获得所有 public 方法，包括继承类的 public 方法（即父类的 public 方法）。</li>
<li>getMethod：传入方法名（以及参数表对应的多个 class，比如 int.class），获取该方法</li>
</ol>
<p>推荐阅读：<a href="https://www.sczyh30.com/posts/Java/java-reflection-1/">深入解析Java反射（1） - 基础</a></p>
<h3 id="13-如果排序-10G-的元素"><a href="#13-如果排序-10G-的元素" class="headerlink" title="13. 如果排序 10G 的元素"></a>13. 如果排序 10G 的元素</h3><p>问题：不能一次性放入内存中，所以需要引入外部排序。</p>
<ol>
<li>数据源读一批数据到缓冲区；</li>
<li>缓冲区中读取一批数据到内存； </li>
<li>内存进行堆排序（或使用Priority Queue）。</li>
</ol>
<p>Iterable <T> merge(List&lt;Iterable<T>&gt; sortedData);</T></T></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>面经整理（好友投稿）</title>
    <url>/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%88%E5%A5%BD%E5%8F%8B%E6%8A%95%E7%A8%BF%EF%BC%89/</url>
    <content><![CDATA[<h1 id="天猫Java一面"><a href="#天猫Java一面" class="headerlink" title="天猫Java一面"></a>天猫Java一面</h1><h3 id="1-常见集合类的区别和适用场景"><a href="#1-常见集合类的区别和适用场景" class="headerlink" title="1. 常见集合类的区别和适用场景"></a>1. 常见集合类的区别和适用场景</h3><h4 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h4><p>ArrayList：</p>
<ul>
<li>基于数组来实现集合的功能，内部维护了一个可变长的对象数组，集合扩容时会创建更大的数组空间，把原有数据复制到新的数组中。随机访问快，插入和删除的效率低。</li>
</ul>
<p>LinkedList：</p>
<ul>
<li>基于链表实现，数据的删除和插入快，随机访问的速度很慢。</li>
</ul>
<p>####Map集合</p>
<p>HashMap：</p>
<ul>
<li>线程不安全，存储键值对，允许 key 和 value 为 null</li>
</ul>
<p>ConcurrentHashMap：</p>
<ul>
<li>线程安全，不允许 key 和 value 为 null，使用的锁机制实现线程安全</li>
</ul>
<p>TreeMap：</p>
<ul>
<li>线程不安全，依靠comparator或comparable实现key的去重，TreaMap是有序的</li>
</ul>
<span id="more"></span>

<h3 id="2-并发容器、同步容器"><a href="#2-并发容器、同步容器" class="headerlink" title="2. 并发容器、同步容器"></a>2. 并发容器、同步容器</h3><p><strong>同步容器</strong>：同步容器将所有对容器状态的访问都串行化，以实现线程安全性。同步容器包括 Vector、HashTable。同步容器实现线程安全的方式是对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。由于两个同步方法的操作顺序不一致，会引起数组越界，不安全。</p>
<p><strong>并发容器</strong>：ConcurrentHashMap、CopyOnWriteArrayList、Queue、BlockingQueue、ConcurrentSkipListMap、ConcurrentSkipListSet。</p>
<h3 id="3-ConcurrentHashMap、CopyOnWriteArrayList"><a href="#3-ConcurrentHashMap、CopyOnWriteArrayList" class="headerlink" title="3. ConcurrentHashMap、CopyOnWriteArrayList"></a>3. ConcurrentHashMap、CopyOnWriteArrayList</h3><p><strong>ConcurrentHashMap</strong>：锁分段技术：容器中有多把锁，每把锁锁住容器的一部分数据，那么当多线程访问容器中的不同数据时就不存在锁竞争。</p>
<ul>
<li>concurrentHashMap 的结构是由 segment、hashEntry 组成。</li>
</ul>
<p><strong>CopyOnWriteArrayList</strong>：CopyOnWrite 容器即写时复制的容器。</p>
<ul>
<li>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以 CopyOnWrite 容器也是一种读写分离的思想，读和写不同的容器。写的时候需要加锁，不然多个线程同时写会有多个副本。CopyOnWrite 并发容器用于读多写少的并发场景。</li>
</ul>
<h3 id="4-判断一个列表是否有环"><a href="#4-判断一个列表是否有环" class="headerlink" title="4. 判断一个列表是否有环"></a>4. 判断一个列表是否有环</h3><p>两个指针，一个走的快，一个走的慢，最终经过若干步，走的快的指针总会超过慢的指针一圈而相遇。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line">bool hasCycle(ListNode* head) &#123;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    <span class="function"><span class="title">while</span>(fast &amp;&amp; fast-&gt;</span>next) &#123;</span><br><span class="line">        <span class="function"><span class="title">fast</span> = fast-&gt;</span><span class="function"><span class="title">next</span>-&gt;</span>next;</span><br><span class="line">        <span class="function"><span class="title">slow</span> = slow-&gt;</span>next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-多台服务器之间session共享方案"><a href="#5-多台服务器之间session共享方案" class="headerlink" title="5. 多台服务器之间session共享方案"></a>5. 多台服务器之间session共享方案</h3><p>方案：</p>
<ol>
<li>session集中处理，建立一个数据库存放session，不同的应用从这个数据库中取session；</li>
<li>应用间session同步（缺点：网络间复制信息效率低）；</li>
<li>将请求固定到对应的服务器，保证下次请求还是到达上次访问的服务器（即 session sticky 技术）；</li>
<li>通过cookie中夹带的session，将session放在客户端。</li>
</ol>
<h3 id="6-BIO、NIO、AIO"><a href="#6-BIO、NIO、AIO" class="headerlink" title="6. BIO、NIO、AIO"></a>6. BIO、NIO、AIO</h3><p><strong>BIO</strong>：阻塞IO，一个Socket套接字需要一个线程处理。<br><strong>NIO</strong>：基于事件驱动思想，采用Reactor模式，统一通过Reactor对所有客户端的Socket套接字的事件做处理，然后派发到不同的线程。（线程与Socket是多对多的关系）。<br><strong>AIO</strong>：异步IO，NIO在有通知是可以进行相关操作，AIO在有通知时表示相关操作已经完成</p>
<p>其实还有 IO 复用，信号驱动IO两种方式，具体参考：<a href="http://likehui.fun/2018/12/07/interview%EF%BC%881%EF%BC%89/">面经整理1</a></p>
<h3 id="7-JVM内存模型"><a href="#7-JVM内存模型" class="headerlink" title="7. JVM内存模型"></a>7. JVM内存模型</h3><p>堆：主要存放对象实例，分为新生代、老年代，线程共享。<br>栈：主要存放局部变量，线程私有，方法调用的过程就是入栈到出栈的过程<br>方法区：线程共享，用于存放已被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。<br>GC：引用计数法、可达性分析法。GC Roots：栈中引用的对象；方法区中类静态属性引用的对象，常量引用的对象；</p>
<h3 id="8-Java的垃圾回收——标记算法和复制算法"><a href="#8-Java的垃圾回收——标记算法和复制算法" class="headerlink" title="8. Java的垃圾回收——标记算法和复制算法"></a>8. Java的垃圾回收——标记算法和复制算法</h3><p>标记算法：分为两个阶段：标记和清除。首先标记出所有需要回收的对象，在标记完成后统一回收。问题：效率不高；会产生内存碎片</p>
<p>复制算法：将内存按容量分成大小相等的两块，每次只用其中的一块，当一块内存用完了，就将还存活的对象复制到另一块上，清空已使用过的内存空间。内存的利用率变高，只有百分之十的空间被浪费。</p>
<h3 id="9-http和https的区别，http1-x和http2-0的区别，SSL和TSL之间的区别"><a href="#9-http和https的区别，http1-x和http2-0的区别，SSL和TSL之间的区别" class="headerlink" title="9. http和https的区别，http1.x和http2.0的区别，SSL和TSL之间的区别"></a>9. http和https的区别，http1.x和http2.0的区别，SSL和TSL之间的区别</h3><p>https在http的基础上加了ssl协议，ssl协议工作于传输层和应用层之间，为应用层提供数据的加密能力。</p>
<p>TSL：传输层安全协议，TLS可以理解成SSL协议3.0版本的升级，对于大的协议栈而言，SSL和TSL区别不大。</p>
<p>Http2.0实现多路复用、请求优先级、首部压缩、服务端推送</p>
<h3 id="10-GC、G1、ZGC的区别"><a href="#10-GC、G1、ZGC的区别" class="headerlink" title="10. GC、G1、ZGC的区别"></a>10. GC、G1、ZGC的区别</h3><p>G1收集器：G1是一款面向服务端应用的垃圾收集器，特点：并行与并发（Stop The World）、分代收集、空间整合、可预测的停顿。G1收集器运作：初始标记、并发标记、最终回收、筛选回收。</p>
<p>ZGC：java11发布的新的GC收集器，缩短GC停顿，新技术：着色指针和读屏障<br>GC时方法论，G1、ZGC等收集器是具体实现。</p>
<h3 id="11-B树、B-树、红黑树"><a href="#11-B树、B-树、红黑树" class="headerlink" title="11. B树、B+树、红黑树"></a>11. B树、B+树、红黑树</h3><p><a href="https://www.cnblogs.com/vincently/p/4526560.html">【经典数据结构】B树与B+树</a></p>
<p><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html">浅谈算法和数据结构: 九 平衡查找树之红黑树</a></p>
<h3 id="12-内存泄漏和内存溢出的区别"><a href="#12-内存泄漏和内存溢出的区别" class="headerlink" title="12. 内存泄漏和内存溢出的区别"></a>12. 内存泄漏和内存溢出的区别</h3><p>内存泄漏：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积的后果就是内存溢出</p>
<p>内存溢出（OOM）：是指程序申请内存空间时，没有足够的内存空间供申请者使用</p>
<p>栈溢出：如果线程请求的栈深度大于JVM 允许的最大深度，抛出异常</p>
<p>内存溢出解决方案：修改JVM启动参数，直接增加内存；找出可能发生内存溢出的位置。</p>
<h3 id="13-session的生命周期"><a href="#13-session的生命周期" class="headerlink" title="13. session的生命周期"></a>13. session的生命周期</h3><ul>
<li>session存放在服务器端，一般放在服务器的内存，session放在sessions容器中由Manager类管理，长时间不用的session将被回收，Tomcat中的默认失效时间是20分。</li>
<li>调用session的invalidate方法也会让session失效。</li>
</ul>
<h1 id="天猫Java二面"><a href="#天猫Java二面" class="headerlink" title="天猫Java二面"></a>天猫Java二面</h1><h3 id="1-java-cas原理"><a href="#1-java-cas原理" class="headerlink" title="1. java cas原理"></a>1. java cas原理</h3><p>CAS包含三个操作数——需要读写的内存位置V，进行比较的值A和拟写入的新值B。</p>
<ul>
<li>当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。属于乐观锁。</li>
</ul>
<h3 id="2-Java线程池参数"><a href="#2-Java线程池参数" class="headerlink" title="2. Java线程池参数"></a>2. Java线程池参数</h3><p>7个参数</p>
<ol>
<li>corePoolSize表示常驻核心线程数；</li>
<li>maximumPoolSize表示线程池能够容纳同时执行的最大线程数；</li>
<li>keepAliveTime表示线程池中线程空闲时间，当空闲时间达到keepAliveTime时，线程会被销毁，直到剩下corePoolSize个线程为止；</li>
<li>TimeUnit表示时间单位；</li>
<li>workQueue表示缓存队列，当请求的线程数大于maximumPoolSize时，线程进入BlockingQueue阻塞队列；</li>
<li>threadFactory表示线程工厂，用来生产一组相同任务的线程；</li>
<li>handler表示执行拒绝策略的对象，当超过workQueue的任务缓存区上限的时候，就可以通过该策略处理器供求。</li>
</ol>
<h3 id="3-Java的lock的底层实现"><a href="#3-Java的lock的底层实现" class="headerlink" title="3. Java的lock的底层实现"></a>3. Java的lock的底层实现</h3><ul>
<li>继承AQS，AbstractQueuedSynchronizer会把所有的请求线程构成一个CLH队列，线程请求获取锁，如果获取失败会将线程信息封装成node加入Sync queue队列，循环请求获取锁。锁释放之后会唤醒队列中的第一个线程<ul>
<li>当一个线程执行完毕（unlock）后，会激活队列中的后续结点。</li>
<li>原生 CLH 队列是自旋锁，但Doug Lea把其改造为阻塞锁。</li>
</ul>
</li>
</ul>
<p>lee补充：</p>
<p>####（0）调用顺序</p>
<p><img src="/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%88%E5%A5%BD%E5%8F%8B%E6%8A%95%E7%A8%BF%EF%BC%89/lock.gif" alt="lock"></p>
<ul>
<li><p>各种  Lock 的实现，都继承于<code>java.util.concurrent.*</code>包下的<code>AbstractQueuedSynchronizer</code>类。</p>
</li>
<li><p>以 <code>ReentrantLock</code>为例：</p>
  <figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReentrantLock 的所有 Lock 接口的操作都委派到 Sync 上</span></span><br><span class="line">static <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个子类，公平和非公平锁</span></span><br><span class="line"><span class="keyword">final</span> static <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Snyc</span></span></span><br><span class="line"><span class="keyword">final</span> static <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Snyc</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>AQS 抽象了绝大部分 Lock 的功能，只把<code>tryAcquire()</code>方法延迟到子类中实现。</p>
<ul>
<li><code>tryAcquire()</code>方法在于用子类来判断，请求线程是否可以获得锁。</li>
<li>参考博文：<a href="http://likehui.fun/2018/12/07/interview%EF%BC%881%EF%BC%89/">interview（1）</a>的第八题</li>
</ul>
</li>
</ul>
<h4 id="（1）加锁："><a href="#（1）加锁：" class="headerlink" title="（1）加锁："></a>（1）加锁：</h4><ul>
<li><p>每次请求锁都会调用<code>nonfairTryAcquire()</code>方法：</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">final boolean nonfair<span class="constructor">TryAcquire(<span class="params">int</span> <span class="params">acquires</span>)</span>&#123;  <span class="comment">// acquires 初始为1</span></span><br><span class="line">	final Thread current = <span class="module-access"><span class="module"><span class="identifier">Thread</span>.</span></span>current<span class="constructor">Thread()</span>;</span><br><span class="line">	<span class="built_in">int</span> c = get<span class="constructor">State()</span>;</span><br><span class="line">	<span class="keyword">if</span>(c<span class="operator"> == </span><span class="number">0</span>)&#123;  <span class="comment">// 说明当前没有锁竞争此资源 </span></span><br><span class="line">		<span class="keyword">if</span>(compare<span class="constructor">AndSetState(0,<span class="params">acquires</span>)</span>)&#123;  <span class="comment">// CAS 的方式设置</span></span><br><span class="line">			set<span class="constructor">ExclusiveOwnerThread(<span class="params">current</span>)</span>;</span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(current<span class="operator"> == </span>get<span class="constructor">ExclusiveOwnerThread()</span>)&#123; </span><br><span class="line">		<span class="comment">// 说明当前线程已经拥有此锁</span></span><br><span class="line">		<span class="built_in">int</span> nextc = c + acquires; <span class="comment">// 线程重入锁+1</span></span><br><span class="line">		<span class="keyword">if</span>(nextc &lt; <span class="number">0</span>)</span><br><span class="line">			throw <span class="keyword">new</span> <span class="constructor">Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>)</span>;</span><br><span class="line">		set<span class="constructor">State(<span class="params">nextc</span>)</span>; <span class="comment">// 实现了偏向锁的功能</span></span><br><span class="line">		return <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果请求锁失败，那么新的竞争线程会被追加到队尾，具体采用 CAS 的 Lock-free 算法，因为线程并发对 tail 调用 CAS 可能会导致其他线程 CAS 失败，解决办法是循环 CAS 直至成功。</p>
</li>
<li><p>入队出队都是用CAS方式设置的，addWaiter 方法负责把当前拿锁失败的线程包装成一个 Node 添加到队尾，如下：</p>
  <figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">Node</span> <span class="title">addWaiter</span>(<span class="keyword">Node</span> <span class="title">mode</span>)&#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">node</span> = new <span class="keyword">Node</span><span class="title">(Thread</span>.currentThread(),mode);</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">pred</span> = tail;</span><br><span class="line">	if(pred)&#123; // 如果 tail 非空，将新的 <span class="keyword">node</span> <span class="title">置于 tail</span> 处</span><br><span class="line">		node.prev = pred;</span><br><span class="line">		if(compareAndSetTail(pred,<span class="keyword">node</span><span class="title">)&#123; // 追加队尾操作</span></span><br><span class="line"><span class="title">			pred</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">			return</span> <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">		&#125;</span></span><br><span class="line"><span class="title">	&#125;</span></span><br><span class="line"><span class="title">	enq</span>(<span class="keyword">node</span><span class="title">); // 如果 tail</span> 是空的，或者上一步的 CAS 失败，则执行 enq 方法</span><br><span class="line">	return <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">&#125;</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">private</span> <span class="keyword">Node</span> <span class="title">enq</span>(final <span class="keyword">Node</span> <span class="title">node</span>)&#123;</span><br><span class="line">	for(;;)&#123;  // 无限循环进行 CAS，知道把当前线程追加到队尾（或队头）</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">t</span> = tail;</span><br><span class="line">		if(t == null)&#123;</span><br><span class="line">			<span class="keyword">Node</span> <span class="title">h</span> = new <span class="keyword">Node</span><span class="title">();</span></span><br><span class="line"><span class="title">			h</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">			node</span>.prev = h;</span><br><span class="line">			if(compareAndSetHead(h))&#123;</span><br><span class="line">				tail = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">				return</span> h;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			node.prev = t;</span><br><span class="line">			if(compareAndSetTail(t,<span class="keyword">node</span><span class="title">))&#123;</span></span><br><span class="line"><span class="title">				t</span>.next = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">				return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>acquireQueued()</code>方法，将刚追加到队列中的线程节点进行阻塞，但阻塞前再一次通过<code>tryAccquire()</code>重试是否能获得锁，如果重试成功则无需阻塞，直接返回，如下：</p>
  <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 false 表示可获得锁，无需入队</span></span><br><span class="line">final boolean acquire<span class="constructor">Queued(<span class="params">final</span> Node <span class="params">node</span>,<span class="params">int</span> <span class="params">arg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		boolean interrupted = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">			final Node p = node.predecessor<span class="literal">()</span>;</span><br><span class="line">			<span class="keyword">if</span>(p<span class="operator"> == </span>head<span class="operator"> &amp;&amp; </span><span class="keyword">try</span><span class="constructor">Acquire(<span class="params">arg</span>)</span>)&#123;</span><br><span class="line">				set<span class="constructor">Head(<span class="params">node</span>)</span>;</span><br><span class="line">				p.next = null;</span><br><span class="line">				return interrupted;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(should<span class="constructor">ParkAfterFailedAcquire(<span class="params">p</span>,<span class="params">node</span>)</span><span class="operator"> &amp;&amp;</span></span><br><span class="line"><span class="operator">				</span>park<span class="constructor">AndCheckInterrupt()</span>) </span><br><span class="line">				<span class="comment">/* parkAndCheckInterrupt会调用 LockSupport.park() 显式阻塞，</span></span><br><span class="line"><span class="comment">				*  此时进入系统内核中，检查线程状态（should...方法检查）</span></span><br><span class="line"><span class="comment">				*/</span>  然后阻塞（park...方法阻塞）</span><br><span class="line">				</span><br><span class="line">				 <span class="comment">// 被阻塞的线程经解锁后来到此步，将 interrupted 置为 true</span></span><br><span class="line">				 <span class="comment">// 解除阻塞状态的线程不一定能获得锁，仍需要参与竞争tryAccquire</span></span><br><span class="line">				 interrupted = <span class="literal">true</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;catch (RuntimeException ex)&#123;</span><br><span class="line">		cancel<span class="constructor">Acquire(<span class="params">node</span>)</span>;</span><br><span class="line">		throw ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）解锁："><a href="#（2）解锁：" class="headerlink" title="（2）解锁："></a>（2）解锁：</h4><ul>
<li><p><code>AbstractQueuedSynchronizer.release</code>和<code>Sync.tryRelease</code>方法:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(tryRealse(arg))&#123;  <span class="comment">// 如果可以释放锁，进入此判断</span></span><br><span class="line">		<span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">		<span class="keyword">if</span>(h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">			unparkSuccessor(h);  <span class="comment">// 唤醒 head 线程（即队列第一个）</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">	<span class="keyword">if</span>(Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(c == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">// 如果多次锁定，就多次释放，直到 c 为0才真正释放锁</span></span><br><span class="line">		free = <span class="literal">true</span>;</span><br><span class="line">		setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	setState(c); <span class="comment">// 因为没竞争，所以用不着 CAS</span></span><br><span class="line">	<span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">	<span class="keyword">if</span>(ws &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		compareAndSetWaitStatus(node,ws,<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next; <span class="comment">// 一般 s 就是 head</span></span><br><span class="line">	<span class="comment">// 如果head 是空（几率小），队列从后往前回溯，找到第一个可用线程</span></span><br><span class="line">	<span class="keyword">if</span>(s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		s = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t!= <span class="literal">null</span> &amp;&amp; t != node; t= t.prev)</span><br><span class="line">			<span class="keyword">if</span>(t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">				s = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(s != <span class="literal">null</span>)</span><br><span class="line">		LockSupport.unpark(s.thread); <span class="comment">// 通知系统内核唤醒该线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）Lock-跟-Synchronized-底层比较"><a href="#（3）Lock-跟-Synchronized-底层比较" class="headerlink" title="（3）Lock 跟 Synchronized 底层比较"></a>（3）Lock 跟 Synchronized 底层比较</h4><ul>
<li>两者底层都是基于 CAS 操作的，从数据结构来说两者设计上没有本质区别。</li>
<li>synchronized 实现了自旋锁，并针对不同的系统和硬件体系进行了优化；</li>
<li>Lock 完全依靠系统阻塞挂起等待线程。</li>
<li>Lock 比 synchronized 更适合在应用层扩展，可以既传承 AQS 定义各种实现，比如实现读写锁、公平、非公平锁等；Lock 比 wait&#x2F;notify要方便的多、灵活地多。</li>
</ul>
<p>Ps：Lock 的使用方法（四种锁法）可以参考这篇博文：<a href="https://segmentfault.com/q/1010000005602326">Lock 的使用</a></p>
<p>【墙裂推荐阅读！】Lock 底层：<a href="https://blog.csdn.net/endlu/article/details/51249156">Java锁—-Lock实现原理</a></p>
<h3 id="4-mysql的数据库默认存储引擎"><a href="#4-mysql的数据库默认存储引擎" class="headerlink" title="4. mysql的数据库默认存储引擎"></a>4. mysql的数据库默认存储引擎</h3><p><strong>InnoDB</strong>：在使用MYSQL的时候，你所面对的每一个挑战几乎都源于ISAM和MyISAM数据库引擎<strong>不支持事务处理</strong>（transaction process）也不支持<strong>外键</strong>。尽管要比ISAM和 MyISAM引擎慢很多，但是InnoDB包括了对事务处理和外来键的支持，这两点都是前两个引擎所没有的。</p>
<p><strong>MyISAM</strong>：除了提供ISAM里所没有的索引和字段管理的大量功能，MyISAM还使用一种表格锁定的机制，来优化多个并发的读写操作，其代价是你需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，MYISAM强调了快速读取操作，MyISAM格式的一个重要缺陷就是不能在表损坏后恢复数据。</p>
<p><strong>ISAM</strong>：因此，ISAM执行读取操作的速度很快，而且不占用大量的内存和存储资源。ISAM的两个主要不足之处在于，它不支持事务处理，也不能够容错。</p>
<p>MyISAM引擎的索引结构为B+Tree，其中B+Tree的数据域存储的内容为实际数据的<strong>地址</strong>，也就是说它的索引和实际的数据是分开的，只不过是用索引指向了实际的数据，这种索引就是所谓的<strong>非聚集索引</strong>。</p>
<p>InnoDB引擎的索引结构同样也是B+Tree，但是Innodb的<strong>索引文件本身就是数据文件</strong>，即B+Tree的数据域存储的就是实际的数据，这种索引就是<strong>聚集索引</strong>。这个索引的key就是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<h3 id="5-Mysql的事务隔离级别"><a href="#5-Mysql的事务隔离级别" class="headerlink" title="5. Mysql的事务隔离级别"></a>5. Mysql的事务隔离级别</h3><table>
<thead>
<tr>
<th align="center">事务隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">读未提交</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">读提交</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">重复读</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center">串行化</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p>脏读：</p>
<ul>
<li>事务A读取了事务B更新的数据，然后B回滚操作，那么A读到的数据就是脏数据。</li>
</ul>
<p>不可重复读：</p>
<ul>
<li>事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
</ul>
<p>幻读：</p>
<ul>
<li>系统管理员A将学生成绩分数改为ABCDE等级，这是系统管理员B插入一条学生成绩分数的记录，当系统管理员改结束后发现有一条记录没有更改，好像产生幻觉。</li>
</ul>
<p><strong>小结</strong>：不可重复读和幻读很容易混淆，<strong>不可重复读侧重于修改，幻读侧重于新增或删除</strong>。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p>
<h3 id="6-四个表-记录成绩，每个大约十万条记录，如何找到成绩最好的同学"><a href="#6-四个表-记录成绩，每个大约十万条记录，如何找到成绩最好的同学" class="headerlink" title="6.  四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学"></a>6.  四个表 记录成绩，每个大约十万条记录，如何找到成绩最好的同学</h3><p>创建索引，多线程查询，优化sql语句，提高查询效率</p>
<h3 id="7-常用的负载均衡算法"><a href="#7-常用的负载均衡算法" class="headerlink" title="7. 常用的负载均衡算法"></a>7. 常用的负载均衡算法</h3><p>轮询、随机、源地址哈希、加权轮询、加权随机、最小连接数法</p>
<h3 id="8-Redis持久化、keys命令"><a href="#8-Redis持久化、keys命令" class="headerlink" title="8. Redis持久化、keys命令"></a>8. Redis持久化、keys命令</h3><p>如果Redis有一亿个key，使用keys命令会影响性能，改为使用set（smemebers key）<br>redis持久化：<a href="http://redisdoc.zixuebook.cn/topic/persistence.html#redis">http://redisdoc.zixuebook.cn/topic/persistence.html#redis</a></p>
<h1 id="天猫Java三面"><a href="#天猫Java三面" class="headerlink" title="天猫Java三面"></a>天猫Java三面</h1><h3 id="1-大型网站的分布式服务器集群部署"><a href="#1-大型网站的分布式服务器集群部署" class="headerlink" title="1. 大型网站的分布式服务器集群部署"></a>1. 大型网站的分布式服务器集群部署</h3><p><img src="/2018/12/14/%E9%9D%A2%E7%BB%8F%E6%95%B4%E7%90%86%EF%BC%88%E5%A5%BD%E5%8F%8B%E6%8A%95%E7%A8%BF%EF%BC%89/1.jpg" alt="1"></p>
<h3 id="2-多个RPC请求进来，服务器怎么处理并发"><a href="#2-多个RPC请求进来，服务器怎么处理并发" class="headerlink" title="2. 多个RPC请求进来，服务器怎么处理并发"></a>2. 多个RPC请求进来，服务器怎么处理并发</h3><p>通过负载均衡策略，将请求分流；采用异步IO、非阻塞IO</p>
<h3 id="3-Redis的哨兵机制（是一个分布式系统）"><a href="#3-Redis的哨兵机制（是一个分布式系统）" class="headerlink" title="3. Redis的哨兵机制（是一个分布式系统）"></a>3. Redis的哨兵机制（是一个分布式系统）</h3><p>Redis的哨兵系统用于管理多个Redis服务器，该系统执行一下三个任务：<br>监控：Sentinel会不断地检查你的主服务器和从服务器是否正常运行<br>提醒：当被监控地某个Redis服务器出现问题时，Sentinel可以通过API向管理员或者其他应用程序发哦是那个通知<br>自动故障迁移：当一个主服务器不能正常工作时，Sentinel会开始一次自动故障迁移操作，他会将失效主服务器地其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主的服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。<br>其他：<br>主观下线：指的是单个Sentinel实例对服务器做出的下线判断<br>客观下线：指的是多个Sentinel实例对服务器做出主观下线判断，并且通过SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断。</p>
<p>（lee 总结：对主从服务器进行①运行监控 ②故障定位 ③故障转移 ④下线判断）</p>
<p>故障转移：</p>
<ol>
<li>发现主服务器已经进入客观下线状态</li>
<li>对我们当前纪元进行自增，并尝试再这个纪元中当选</li>
<li>如果当选失败，那么在设定的故障迁移超时时间的两倍之后，重新尝试当选 ，如果当选成功执行以下步骤</li>
<li>选出一个从服务器，并将它升级为主服务器</li>
<li>向被选中的从服务器发送SALVE NO ONE命令，让他转变为主服务器</li>
<li>通过发布与订阅功能，将更新后的配置传播给所有其他Sentinel，其他Sentinel对它们自己的配置进行更新</li>
<li>向已下线主服务器的从服务器发送SLAVEOF命令，让它们去复制新的主服务器</li>
<li>当所有从服务器都已经开始复制新的主服务器时，领头Sentinel终止这次故障迁移操作</li>
</ol>
<h3 id="3-数据库分库分表一般多大数据量才需要"><a href="#3-数据库分库分表一般多大数据量才需要" class="headerlink" title="3. 数据库分库分表一般多大数据量才需要"></a>3. 数据库分库分表一般多大数据量才需要</h3><p>一般来说，Mysql单库超过5000万条记录，Oracle单库超过1亿条记录，DB压力就很大，当数据量达到数据库所能承载的数据量后就需要分库、分表。单个库数据量（1T-2T）。</p>
<p>切库思路：读写分离，第一种自定义注解完成数据库切库，第二种项目中配置多个库的数据源（这几个数据库是完全不同的）。</p>
<p>数据库分表：横向分表、纵向分表（根据数据活跃度分离）mybatis分表插件shardbatis2.0</p>
<h3 id="4-如何保证数据库与redis缓存数据一致"><a href="#4-如何保证数据库与redis缓存数据一致" class="headerlink" title="4. 如何保证数据库与redis缓存数据一致"></a>4. 如何保证数据库与redis缓存数据一致</h3><p>首先尝试从缓存中读数据，命中则直接返回，如果读不到则到数据库读数据，并将数据写入缓存；更新数据时，先更新数据库，然后把缓存里对应的数据失效掉。</p>
<p>解决方案：定期全量更新，定期把缓存全部清掉，然后再全量加载；给所有的缓存一个失效期。</p>
<h3 id="5-消息队列的使用、应用场景"><a href="#5-消息队列的使用、应用场景" class="headerlink" title="5. 消息队列的使用、应用场景"></a>5. 消息队列的使用、应用场景</h3><p>消息队列：解耦、异步、削峰。应用场景：解决应用解耦、异步消息、流量削峰<br>缺点：系统可用性降低、系统复杂度增加</p>
<h3 id="6-JVM相关分析工具、具体的性能调优步骤"><a href="#6-JVM相关分析工具、具体的性能调优步骤" class="headerlink" title="6. JVM相关分析工具、具体的性能调优步骤"></a>6. JVM相关分析工具、具体的性能调优步骤</h3><p>jstat、jinfo、jps、jstack、jmap</p>
<h3 id="7-MySQL的慢sql优化"><a href="#7-MySQL的慢sql优化" class="headerlink" title="7. MySQL的慢sql优化"></a>7. MySQL的慢sql优化</h3><p>慢sql的原因：sql编写问题；锁；业务实例相互干扰；服务器硬件；MYSQL BUG</p>
<ul>
<li>优化sql语句：通过慢查询日志，抓取慢sql，通过explain对慢sql分析。</li>
<li>字段类型转换导致不用索引，如字符串类型的不用引号，数字类型的用引号等，这有可能会用不到索引导致全表扫描；</li>
<li>mysql 不支持函数转换，所以字段前面不能加函数，否则这将用不到索引；</li>
<li>不要在字段前面加减运算；</li>
<li>字符串比较长的可以考虑索引一部份减少索引文件大小，提高写入效率；</li>
<li>like % 在前面用不到索引；</li>
<li>根据联合索引的第二个及以后的字段单独查询用不到索引；</li>
<li>不要使用 <code>select *</code>；</li>
<li>排序请尽量使用升序 ;</li>
<li>or 的查询尽量用 union 代替 （Innodb）；</li>
<li>复合索引高选择性的字段排在前面；</li>
<li>order by &#x2F; group by 字段包括在索引当中减少排序，效率会更高。</li>
<li>除了上述索引使用规则外，SQL 编写时还需要特别注意以下几点：<ul>
<li>尽量规避大事务的 SQL，大事务的 SQL 会影响数据库的并发性能及主从同步；</li>
<li>分页语句 limit 的问题；</li>
<li>删除表所有记录请用 truncate，不要用 delete；</li>
<li>不让 mysql 干多余的事情，如计算；</li>
<li>输写 SQL 带字段，以防止后面表变更带来的问题，性能也是比较优的 ( 涉及到数据字典解析，请自行查询资料)；</li>
<li>在 Innodb上用 select count(*)，因为 Innodb 会存储统计信息；</li>
<li>慎用 Oder by rand()。</li>
</ul>
</li>
<li>最后，服务器的参数优化。</li>
</ul>
<h3 id="8-秒杀场景的设计"><a href="#8-秒杀场景的设计" class="headerlink" title="8. 秒杀场景的设计"></a>8. 秒杀场景的设计</h3><p><strong>特点</strong>：秒杀时网站的访问量大增；秒杀时购买的请求数量远小于库存，只有部分用户能够成功；业务流程简单，根据先后顺序，下订单减库存</p>
<p><strong>前端</strong>：加验证码可以在单位时间内有效的控制住合法用户；将活动页面上的元素全部静态化，通过CDN抗峰值；禁止重复提交</p>
<p><strong>后端</strong>：加缓存、限制uid、采用消息队列缓存请求、利用缓存应对读写请求</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发笔记（1）</title>
    <url>/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>多线程还是多看多理解，就不做笔记了吧，以下是重点的截图。</p>
<span id="more"></span>


<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/1.png" alt="1"></p>
<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/2.png" alt="2"></p>
<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/3.png" alt="3"></p>
<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/4.png" alt="4"></p>
<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="序列化"></p>
<p><img src="/2018/12/10/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.png" alt="线程池拒绝策略"></p>
]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发项目指南书</title>
    <url>/2021/01/14/%E9%AB%98%E5%B9%B6%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%8C%87%E5%8D%97%E4%B9%A6/</url>
    <content><![CDATA[<p>本文主要学习参考自“拉勾教育”《打造千万级流量秒杀系统》，作者易乐天，<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=547#/content">链接点此.</a></p>
<p>对于秒杀系统来说，它的核心非功能需求主要有：<strong>高可用指标、高性能指标、高并发指标</strong>，比如可用性方面要高于 99.99%，高性能方面要求请求延迟小于 100ms，高并发方面要求QPS 大于 10万。这三个指标俗称“三高”要求，公司不同，指标大小要求也会有所不同。</p>
<span id="more"></span>

<h4 id="1-高可用指标"><a href="#1-高可用指标" class="headerlink" title="1. 高可用指标"></a>1. 高可用指标</h4><p>高可用指标是指用来衡量一个系统可用性有多高。这里有几个需要了解的概念：</p>
<ol>
<li><p><strong>MTBF</strong>（Mean Time Between Failure，平均可用时长），系统正常、稳定运行的平均时长，比如三天内系统出现了3次故障，每次持续1小时，那么平均可用时长是23小时。</p>
</li>
<li><p><strong>MTTR</strong>（Mean Time To Repair，平均修复时长），系统从失效后到恢复正常所耗费的平均时间，比如前面提到的每次故障持续1小时。</p>
</li>
<li><p><strong>SLA</strong>（Service-Level Agreement，服务等级协议），用于评估服务可用性等级，计算公式是MTBF&#x2F;(MTBF+MTTR)，一般我们所说的可用性高于 99.99%，是指 SLA 高于 99.99%。</p>
</li>
<li><blockquote>
<p>那么，在实际项目中SLA应该如何计算呢？SLA的计算规则如下。</p>
<ol>
<li>如果一个系统的正常运行还依赖多个子系统，比如系统中有 a、b、c、d 四个子系统（系统依赖于 a，a 依赖于b 和 c，b 依赖于 d），只要其中一个子系统不正常，整个系统就无法正常工作，那么整个系统的 SLA &#x3D; SLA(a) × SLA(b) × SLA(c) × SLA(d)。</li>
</ol>
<p>假如四个子系统的SLA分别为 99.99%、99.995%、99.995%、99.999%，那么最终的 SLA 为 99.979%，整体SLA小于每一个子系统的SLA。</p>
<ol start="2">
<li>如果两个子系统作为主备关系提供服务时，只有两个子系统都出问题了才会影响整个系统，那么SLA&#x3D;1-(1-SLA(a1)) × (1-SLA(a2))。</li>
</ol>
<p>如果 a1 系统的 SLA 为 99.99%，a2 系统的 SLA 为 99.995%，那么系统最终的 SLA 为 99.9999995%。当然这是理想情况，主备切换也是需要耗费时间的，实际计算的时候需要将主备切换耗时考虑在内。</p>
</blockquote>
</li>
</ol>
<h4 id="2-高并发指标"><a href="#2-高并发指标" class="headerlink" title="2. 高并发指标"></a>2. 高并发指标</h4><p>QPS（Queries Per Second，每秒查询率）。</p>
<p>范例：</p>
<p>某电商通过观察数据统计得知，自己的日活大概有 600 万。活动期间，运营团队在社交媒体上推广，预计可拉新 50 万，那么活动当天日活大概就有 650 万。根据经验，活动期间活跃用户占日活用户 70%，那么参加这场活动的活跃用户大概有 455 万。</p>
<p>假如有一爆款商品，库存只有 1000 件，预计会有 30% 的活跃用户参加秒杀，那么参与抢购的人大概是 136.5万人。假如每个用户每秒触发 2 次请求，那么业务服务承载的 QPS 最高可能达到 273 万。另外，我们还知道它的底层 Redis 承载能力为 1 万 QPS。</p>
<p><strong>根据业务服务承载最高值达 270 万 QPS 以及底层 Redis 承载能力 1 万 QPS，我们预留 10% ～ 20% 的余量，可以初步制定出并发指标：业务服务300万QPS，底层资源 8000QPS。</strong></p>
<p>这里你可能会问了：为何业务服务的 QPS 要比实际的高，而底层资源 QPS 却比实际承载能力低呢？</p>
<p>其实这是一种保护措施：业务系统设计上保留余量，要比计算出来的 QPS 高一些，以防实际突发流量高于估算值导致系统不稳定；底层资源一般比较固定，不容易扩容，需要限制QPS不能超过其承载能力。总的来说，系统资源在设计上要留有 10% ～ 20% 的余量，以便应对突发流量。</p>
<h4 id="3-高性能指标"><a href="#3-高性能指标" class="headerlink" title="3. 高性能指标"></a>3. 高性能指标</h4><p>不同并发压力下，<strong>请求延迟</strong>可能不同。通常来说，并发压力越大，平均请求延迟也越大。这好比排队买东西，排队的人越多，最后一个人买东西耗时越长。所以，我们在评估性能的时候，通常需要跟并发指标关联起来。例如，并发低于100万时，平均请求延迟不高于200ms。</p>
<h3 id="五视图"><a href="#五视图" class="headerlink" title="五视图"></a>五视图</h3><ol>
<li>逻辑视图：对应逻辑架构，主要关注功能需求，以及系统职责和行为的划分。逻辑视图不仅包括用户可见的功能，还包括相应的辅助功能。比如秒杀系统中的活动场次切换、商品列表、用户登录、活动管理、后台权限等功能，其中后台权限属于辅助功能。</li>
<li>开发视图：对应开发架构，主要关注系统开发过程中的质量属性。它包括软件源码的组织方式、配置方式、编译打包方式以及与第三方包的依赖关系等。</li>
<li>运行视图：对应运行架构，主要关注软件运行过程中的质量属性，它包括进程、线程、协程、对象之间的并发、同步、通信的问题等。</li>
<li>物理视图：对应物理架构，主要关注安装和部署需求。它包括软件运行时的系统、网络、服务器等基础设施和相关配置，以及如何利用基础设施来实现应用程序的高可用、可伸缩等。</li>
<li>数据视图：对应数据架构，主要关注数据需求，它包括数据的格式、属性、关系等。</li>
</ol>
<p>秒杀场景的物理架构内容：</p>
<ol>
<li>动静分离，CDN缓存，秒杀系统静态页面和静态数据。</li>
<li>多个可用区、多台机器同时提供后端服务。作为一个整体对外提供服务，需要部署路由器、防火墙、交换机、SLB（Server Load Balancer，负载均衡器）。路由器是负责接收外网请求并转发到内网；防火墙负责过滤掉有风险的数据，比如过滤掉黑客发起的网络攻击；交换机负责将请求转发到具体的可用区内；SLB 是负载均衡器，它可以将可用区内多个节点作为一个整体对外提供访问，并将请求均衡地转发到后端各节点。</li>
<li>域名解析，将域名解析到 SLB 外网 IP 上。</li>
</ol>
]]></content>
      <categories>
        <category>Java+</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>（转载）在linux下创建自定义服务</title>
    <url>/2020/02/20/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E5%9C%A8linux%E4%B8%8B%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>原文链接：<a href="https://www.jianshu.com/p/92208194d700">在linux下创建自定义服务</a></p>
<h2 id="利用systemctl创建服务"><a href="#利用systemctl创建服务" class="headerlink" title="利用systemctl创建服务"></a>利用systemctl创建服务</h2><p>历史版本中的linux对服务的操作是通过service来完成的。若创建用户自定义的服务，则需要较为复杂的操作。目前linux新的发行版已经内置了systemctl来操作服务。</p>
<h2 id="服务脚本编写"><a href="#服务脚本编写" class="headerlink" title="服务脚本编写"></a>服务脚本编写</h2><p>新的自定义服务脚本以service为后缀，这些service文件存放于&#x2F;lib&#x2F;systemd&#x2F;system中。我们只需要编写符合标准规范的service脚本文件，放在这个文件夹下面即可。这个标准的服务文件格式如下：</p>
<span id="more"></span>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/halo.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Halo Service</span><br><span class="line">Documentation=https://halo.run</span><br><span class="line">After=network-online.target</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/java -server -Xms256m -Xmx256m -jar YOUR_JAR_PATH</span><br><span class="line">ExecStop=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line">Restart=always</span><br><span class="line">StandOutput=syslog</span><br><span class="line"></span><br><span class="line">StandError=inherit</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<h2 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h2><p>这个脚本分为3个部分：[Unit] [Service] [Install]。</p>
<h3 id="Unit"><a href="#Unit" class="headerlink" title="Unit"></a>Unit</h3><p>Unit表明该服务的描述，类型描述。我们称之为一个单元。比较典型的情况是单元A要求在单元B启动之后再启动。这种设置是通过Unit下面的<code>Requires、After、Before、Wants</code>来调整的。比如上述场景的编写可以这样（在A中编写）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Requires=B</span><br><span class="line">After=B</span><br></pre></td></tr></table></figure>

<p>这段设置表明了A的启动依赖于B，同时有要求在B启动之后启动自己。设置十分简介。需要注意的是，依赖关系通常用在服务（Service）而不是目标（Target）上。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service是脚本的关键部分，这一部分用于设置一些关键参数：</p>
<ul>
<li><code>Type=forking</code> : 后台运行模式</li>
<li><code>PIDFile=/xxx/xxx.xxx</code> : 存放PID文件的位置</li>
<li><code>ExecStart=/bin/echo xxx</code> : 这是服务运行的具体执行命令</li>
<li><code>ExecReload=/bin/echo xxx</code> ： 这是服务重启的执行命令</li>
<li><code>EexcStop=/bin/echo xxx</code> : 这是服务停止的执行命令</li>
</ul>
<p>Service的启动方式，在Service段中，启动方式使用Type指定。具体可以参考<code>man systemd.service</code>。</p>
<p>值得注意的是，在脚本中关于服务启动、重启、关闭的指令需要使用绝对路径，否则会出现无法识别的情况。</p>
<p>当完成一个服务脚本后，我们就可以使用systemctl start|stop|restart xxx.service等指令了。若要开机启动这个服务我们使用如下的指令：</p>
<ul>
<li><code>systemctl enable xxx.service</code></li>
</ul>
<p>若要关闭开机启动:</p>
<ul>
<li><code>systemctl disable xxx.service</code></li>
</ul>
<p>当我们需要查看服务信息的使用可以使用如下指令：</p>
<ul>
<li><code>systemctl list-units --type=service</code> ： 列出正在运行的服务</li>
</ul>
<p>在service片段中有几个概念很重要，这直接影响到实践中创建自定义服务的最终结果。以下内容根据linux系统<br> 中<code>man systemd.service</code>用户手册说明经过翻译和整理而得。</p>
<h3 id="service配置之Type"><a href="#service配置之Type" class="headerlink" title="service配置之Type"></a>service配置之Type</h3><p>首先是Type配置，在service片段中有Type的配置，这个配置给当前的服务单元用于设置进程的启动类型。<br> Type有如下几种可选项：</p>
<ul>
<li><code>simple</code></li>
<li><code>forking</code></li>
<li><code>oneshot</code></li>
<li><code>dbus</code></li>
<li><code>notify</code></li>
<li><code>idel</code></li>
</ul>
<p><strong>simple</strong>，这是默认的Type，当Type和BusName配置都没有设置，指定了ExecStart设置后，simple就是默认的Type设置。simple使用ExecStart创建的进程作为服务的主进程。在此设置下systemd会立即启动服务，如果该服务要启动其他服务（simple不会forking），它们的通讯渠道应当在守护进程启动之前被安装好（e.g. sockets,通过sockets激活）。</p>
<p><strong>forking</strong>，如果使用了这个Type，则ExecStart的脚本启动后会调用fork()函数创建一个进程作为其启动的一部分。当一切初始化完毕后，父进程会退出。子进程会继续作为主进程执行。这是传统UNIX主进程的行为。如果这个设置被指定，建议同时设置PIDFile选项来指定pid文件的路径，以便systemd能够识别主进程。</p>
<p><strong>oneshot</strong>，onesh的行为十分类似simple，但是，在systemd启动之前，进程就会退出。这是一次性的行为。可能还需要设置RemainAfterExit&#x3D;yes，以便systemd认为j进程退出后仍然处于激活状态。</p>
<p><strong>dbus</strong>，这个设置也和simple很相似，该配置期待或设置一个name值，通过设置BusName&#x3D;设置name即可。</p>
<p><strong>notify</strong>，同样地，与simple相似的配置。顾名思义，该设置会在守护进程启动的时候发送推送消息(通过sd_notify(3))给systemd。</p>
<h3 id="Service其他配置节点"><a href="#Service其他配置节点" class="headerlink" title="Service其他配置节点"></a>Service其他配置节点</h3><ul>
<li><code>RemainAfterExit</code>：默认值no</li>
</ul>
<p>默认值为no，这个设置采用booleean值，可以是0、no、off、1、yes、on等值。它表明服务是否应当被视为激活的，即便当它所有的进程都退出了。简言之，这个设置用于告诉systemd服务是否应当是被视为激活状态，而不管进程是否退出。当为true时，即便服务退出，systemd依然将这个服务视为激活状态，反之则服务停止。</p>
<ul>
<li><code>GuessMainPID</code></li>
</ul>
<p>采用boolean值指定systemd在无法确切的查明服务的时候是否需要猜测服务的main pid。除非<code>Type=forking</code>被采用并且PIDFile没有被设置，否则这个选项会被忽略。因为当设置为Type的其他选项，或者显示的指定了PID文件后，systemd总是能够知道main pid。</p>
<ul>
<li><code>PIDFile</code></li>
</ul>
<p>采用一个绝对路径的文件名指定守护进程的PID文件。当Type&#x3D;forking被设置的时候，建议采取这个设置。当服务启动后，systemd会读取守护进程的主进程id。systemd不会对该文件写入数据。</p>
<ul>
<li><code>BusName</code></li>
</ul>
<p>使用一个D-Bus的总线名称,作为该服务的可访问名称。当<code>Type=dbus</code>的时候，该设置被强制使用。</p>
<ul>
<li><code>BusPolicy</code></li>
</ul>
<p>如果该选项被指定，一个自定义的kdbus终结点将会被创建，并且会被指定为默认的dbus节点安装到服务上。这样的自定义终结点自身持有一个策略规则集合。这些规则将会在总线范围内被强制指定。该选项只有在kdbus被激活时有效。</p>
<ul>
<li><code>ExecStart</code></li>
</ul>
<p>当服务启动的时候（<code>systemctl start youservice.service</code>），会执行这个选项的值，这个值一般是<code>“ExecStart=指令 参数”</code>的形式。当<code>Type=oneshot</code>的时候，只有一个指令可以并且必须给出。原因是oneshot只会被执行一次。</p>
<ul>
<li><code>ExecStartPre</code>、<code>ExecStartPost</code></li>
</ul>
<p>顾名思义，这两个设置的意义在于<code>ExecStart</code>被执行之前和之后被执行。</p>
<ul>
<li><code>ExecReload</code></li>
</ul>
<p>服务重启时执行。</p>
<ul>
<li><code>ExecStop</code></li>
</ul>
<p>服务停止时执行。</p>
<ul>
<li><code>ExecStopPost</code></li>
</ul>
<p>服务停止后执行。</p>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>（转载）项目心得_ 一周爆肝上线百万高并发系统</title>
    <url>/2020/02/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%B8%80%E5%91%A8%E7%88%86%E8%82%9D%E4%B8%8A%E7%BA%BF%E7%99%BE%E4%B8%87%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>原文链接：<a href="%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%B8%80%E5%91%A8%E7%88%86%E8%82%9D%E4%B8%8A%E7%BA%BF%E7%99%BE%E4%B8%87%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F.md"><a href="https://www.nowcoder.com/discuss/368998?type=0&amp;order=0&amp;pos=7&amp;page=1">https://www.nowcoder.com/discuss/368998?type=0&amp;order=0&amp;pos=7&amp;page=1</a></a></p>
<p>作者<a href="https://www.nowcoder.com/profile/5077378">木子鱼皮</a>，是（腾讯广告全栈毕业生）从零开始一周紧急上线百万高并发系统的相关经验、思路及感悟，在此记录分享。</p>
<p><strong>写的比较复杂，今天修改一下~欢迎大家先🐴后看</strong></p>
<p><strong>花5分钟阅读本文，你将收获：</strong></p>
<ol>
<li>加深对实际工作环境、工作状态的了解 </li>
<li>学习高并发系统的设计思路、技术选型及理解 </li>
<li>学习工作中对接多方的沟通技巧 </li>
<li>学会与测试打配合的技巧 </li>
<li>学习紧急事故的处理方式 </li>
<li>事后如何进行归纳总结 </li>
<li>感受笔者爆肝工作的痛苦与挣扎</li>
</ol>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从年前开始和导师二人接手了一个加紧项目，年前加班做完一期后效果显著，于是开工后加急开发二期，目标是7天上线（后来延长至9天）。由于项目难度大、工期紧、人手缺、对接方多，极具挑战性，因此和导师二人开始了007的爆肝工作。</p>
<blockquote>
<p>PS：007本意指一周七天随时灵活oncall。此处的007特指朝9晚0点后、无午休以及夜里做梦的时间都在工作的爆肝工作制。</p>
</blockquote>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>首先要介绍下负责的项目及系统。项目背景、业务等信息自然不能透露，这里剥离业务，介绍一下抽象出的关键系统模型，如下图：</p>
<p><img src="/2020/02/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%B8%80%E5%91%A8%E7%88%86%E8%82%9D%E4%B8%8A%E7%BA%BF%E7%99%BE%E4%B8%87%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/1.png" alt="架构"></p>
<p>如图，我负责的是一个状态流转系统和查询系统，以及它们依赖的DB服务。</p>
<p>状态流转系统的作用主要是按照逻辑修改DB中的状态值，并在修改成功时依据状态向其他业务侧发送通知。</p>
<p>查询系统，顾名思义就是查询我们负责的DB的值，包括最基础的鉴权、查询等功能。</p>
<p><strong>先分析一下系统中一些难点：</strong></p>
<ol>
<li><p>明显，查询系统是一个<strong>高扇入服务</strong>，被各其他业务侧调用，必然会存在三个问题：</p>
<ul>
<li>高并发：各业务侧流量聚集，经评估，会产生百万量级的高并发流量</li>
</ul>
</li>
</ol>
<ul>
<li>兼容性：如何设计一套API，兼容各业务侧的同时易被理解 <ul>
<li>对接复杂：要同时与4个业务侧的同学沟通，想想就是一件很复杂的事情</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p>状态流转系统逻辑相当复杂（最后光逻辑就300多行代码） </p>
</li>
<li><p>状态流转系统与查询系统、其他业务侧存在交互（比如互相发送通知），对时延、一致性要求很高</p>
</li>
</ol>
<p>分析出难点后，下面开始编写技术方案。</p>
<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>在实际工作中，编写好的、详细的技术方案是非常有必要的。优秀的工程师会在技术方案中考虑到各种场景、评估各种风险、工作量估时、记录各种问题等，不仅帮助自己梳理思路、归纳总结，同时也给其他人提供了参照以及说服力（比如你预期7天上线，没有方案谁信你？）。</p>
<p>根据二八定理，复杂的系统中，可能编写技术方案、梳理设计思路的时间和实际敲代码开发的时间比例为8 : 2。</p>
<p><strong>设计遵循的原则是”贴合业务“，没有最好的架构，只有最适合业务的架构。切忌过度设计！</strong></p>
<p><strong>此外，还要考虑项目的紧急程度和人力成本，先保证可用，再追求极致。</strong></p>
<p>一些简单的设计这里就略过了，下面针对系统难点和业务需求，列举几个重点设计及技术选型：</p>
<h3 id="1-高并发"><a href="#1-高并发" class="headerlink" title="1. 高并发"></a>1. 高并发</h3><p>提到高并发，大家首先想到的是缓存和负载均衡，缺一不可。</p>
<p>负载均衡说白了就是“砸钱，加机器！”，但是<strong>为公司省机器、省成本</strong>应该是每位后端工程师的基本理念，就要靠技术选型和架构设计来实现了，<strong>目标是保证每台机器能抗住最大的并发流量</strong>。</p>
<p><strong>选型如下：</strong></p>
<ol>
<li>编程框架：选择轻量级的Restful框架Jersey，搭配轻量级依赖注入Guice（不用Spring，可以私信我问原因） </li>
<li>Web服务器：选择性能最高的轻量级NIO服务器Grizzly（<a href="https://blog.csdn.net/antony1776/article/details/78962535">各服务器性能对比</a>） </li>
<li>缓存：CKV+ 腾讯自研海量分布式存储系统（支持Redis协议，已开源） </li>
<li>DB分库分表：公司自研基础设施，不多说 </li>
<li>负载均衡：轻量级反向代理服务器 Nginx，百万并发需要增加十余台机器 </li>
<li>CDN及预热：保证高效的下载服务</li>
</ol>
<p>其中，缓存是抗住高并发流量的关键，须重点设计。</p>
<h4 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h4><h5 id="1-数据结构设计"><a href="#1-数据结构设计" class="headerlink" title="1. 数据结构设计"></a>1. 数据结构设计</h5><p>用过缓存的同学都了解，关于缓存Key的设计是很重要的，根据业务来，保证隔离和易查找（便于缓存更新）就好，这里我选择请求参数+接口唯一id来拼接key。并且分页接口可复用全量list接口。</p>
<p><strong>2. 缓存降级</strong></p>
<p>找不到对应key&#x2F;redis连接失败时直接查库。</p>
<p><strong>3. 缓存更新</strong></p>
<p>当DB修改时，对缓存进行删除。由于存在非必填的请求参数，因此key可能是一个模糊值（比如有a、b两个请求参数，key可能为“a”，也可能为“ab”）。</p>
<p>针对请求字段固定（均必填）的接口，更新缓存时，直接拼接出唯一的key进行删除即可。</p>
<p>而针对请求字段不固定（存在非必填字段）的接口，可使用redis的scan命令范围扫描<strong>（千万别用keys命令！用了等着被优化吧）</strong></p>
<p>要更新的接口、对应key及匹配规则可能如下表：</p>
<table>
<thead>
<tr>
<th align="center">接口</th>
<th align="center">key</th>
<th align="center">匹配规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Int1</td>
<td align="center">[a:xx;]b:xxx;%s;</td>
<td align="center">scan正则1：a:xxx;* scan正则2：<em>b:xxx;</em></td>
</tr>
<tr>
<td align="center">Int2</td>
<td align="center">a:xx;%s;</td>
<td align="center">拼唯一键</td>
</tr>
</tbody></table>
<p><strong>4. 缓存穿透</strong></p>
<p>无论查询出的列表是否为空，都写入缓存。但在业务会返回多种错误码时，不建议采用这种方式，复杂度高，成本太大。</p>
<h3 id="2-兼容性"><a href="#2-兼容性" class="headerlink" title="2. 兼容性"></a>2. 兼容性</h3><p>兼容性主要考察接口的设计，为兼容多个业务侧，需要将请求参数以及响应参数设置的尽可能灵活。在设计接口时，切忌一定要和所有的业务侧对齐，否则可能导致满盘皆输！</p>
<p><strong>这里有三个技巧：</strong></p>
<ol>
<li>提供可访问链接的文档（一般公司都有知识库）。 </li>
<li>请求参数不能过多，且要易于理解，不能为了强制兼容而设置过于复杂的参数，必要时可针对某一业务侧定制接口。 </li>
<li>响应参数尽量多（多不是滥），要知道每次增加返回字段都要修改代码，而适当冗余的字段避免了此问题。</li>
</ol>
<h3 id="3-消息通知"><a href="#3-消息通知" class="headerlink" title="3. 消息通知"></a>3. 消息通知</h3><p>上面难点中提到：状态流转系统与查询系统、其他业务侧存在互相发送通知的交互，在查询系统收到通知后，要对缓存进行即时更新，因此对消息的<strong>实时性要求很高</strong>。</p>
<p><strong>这里最初有两种方案：</strong></p>
<ol>
<li>各系统提供回调接口，用于接收通知。能保证实时性，但是各系统间紧耦合，不利于扩展。 </li>
<li>使用消息队列，实现应用解耦及异步消息。</li>
</ol>
<p><strong>最后还是果断采取了第二种方案</strong>，并选用公司自研 <a href="https://tubemq.apache.org/en-us/">TubeMQ 万亿级分布式消息中间件</a>（已开源Apache孵化），原因如下：</p>
<ol>
<li>状态流转系统的通知数据之后可能存在其他消费方，使用消息队列利于扩展，对代码侵入性也少 </li>
<li>消息队队列可持久化消息 </li>
<li>TubeMQ支持消费方负载均衡，性能高 </li>
<li>TubeMQ容量大，可存放万亿数量级消息 </li>
<li>支持公司自研组件，便于形成统一规范（类似现在的全业务上云）</li>
</ol>
<blockquote>
<p>在技术选型和确定方案时，不仅要关注当前的业务需求，也要有一定的前沿视角。</p>
</blockquote>
<h3 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h3><p><strong>切忌，在使用中间件&#x2F;框架前，要尽可能多的进行了解可能带来的风险，一般公司内都有KM（知识库），可利用好内部资源或者google！</strong></p>
<p>这里我主要评估了TubeMQ带来的风险，做一些分享，非技术的同学建议直接跳过！</p>
<h4 id="TubeMQ风险"><a href="#TubeMQ风险" class="headerlink" title="TubeMQ风险"></a>TubeMQ风险</h4><h5 id="1-消息可靠性"><a href="#1-消息可靠性" class="headerlink" title="1. 消息可靠性"></a>1. 消息可靠性</h5><p>Tube性能高，但是<strong>不保证消息的绝对可靠</strong>！</p>
<p>Tube系统主要在两个地方可能会有数据丢失：</p>
<ol>
<li>第一是Tube采取了Consumer信任模型，即数据一旦被Consumer拉取到本地，就默认会消费成功，如果Consumer在实际消费的过程中出现错误，则Tube并不负责恢复。 </li>
<li>由于操作系统pagecache的利用，服务器断电或宕机而可能带来的数据丢失。</li>
</ol>
<p><strong>经评估，本业务需同时保障发送方及消费方的消息可靠性。</strong></p>
<h5 id="2-消息顺序性"><a href="#2-消息顺序性" class="headerlink" title="2. 消息顺序性"></a>2. 消息顺序性</h5><p>Tube沿用了Kafka的分区设计思想，而分区的数据消费之间是没有先后顺序关系的，而且Tube支持消息的异步方式发送；在这种方式下，网络并不能保证先发送的消息就一定会先到达服务端，所以Tube一般<strong>不提供顺序性的保证</strong>。</p>
<p><strong>经评估，本业务消息消费方允许消息非顺序。</strong></p>
<h4 id="3-消息重复"><a href="#3-消息重复" class="headerlink" title="3. 消息重复"></a>3. 消息重复</h4><p>Tube集群中，Consumer的消费位置信息由Broker端进行管理，所以在某些异常情况下，Broker可能无准确获得Consumer的实际消费情况而<strong>导致数据重复</strong>；另外就是出于性能考虑， Consumer的消费位置信息在每次变化时，并不会实时更新到持久化存储中，而是暂存于内存，周期性更新，如果此时broker宕机即会导致<strong>少量的数据重复</strong>。</p>
<p><strong>经评估，本业务消息消费方是相对幂等操作，可允许消息重复。</strong></p>
<h4 id="4-监控告警"><a href="#4-监控告警" class="headerlink" title="4. 监控告警"></a>4. 监控告警</h4><ol>
<li>公司内部提供监控平台，<strong>但数据有五分钟延迟，非实时监控</strong></li>
<li>提供了对消费方单分区滞后的告警，可在公司内部平台直接修改消费配置</li>
</ol>
<p>那么，如何规避风险呢？设计了针对消息可靠性和数据一致性的解决方案。</p>
<h4 id="消息可靠性方案"><a href="#消息可靠性方案" class="headerlink" title="消息可靠性方案"></a>消息可靠性方案</h4><h5 id="1-生产方消息可靠性"><a href="#1-生产方消息可靠性" class="headerlink" title="1. 生产方消息可靠性"></a>1. 生产方消息可靠性</h5><ol>
<li>Tube可保证消息一定送达，发送失败时会自动重发。 </li>
<li>发送消息结束时会触发回调，回调里可判断ACK状态，将发送失败的消息放入队列，下次发送优先从队列里取。</li>
</ol>
<h5 id="2-消费方消息可靠性"><a href="#2-消费方消息可靠性" class="headerlink" title="2. 消费方消息可靠性"></a>2. 消费方消息可靠性</h5><ol>
<li>消费失败时记录日志，确保消息不丢失</li>
</ol>
<h4 id="数据一致性方案"><a href="#数据一致性方案" class="headerlink" title="数据一致性方案"></a>数据一致性方案</h4><h5 id="1-设计消息补偿接口"><a href="#1-设计消息补偿接口" class="headerlink" title="1. 设计消息补偿接口"></a>1. 设计消息补偿接口</h5><p>消息消费失败时，会记录日志，人工排查日志，调用补偿接口再次消费消息。（其实也可以存db消息表，写任务去轮询消费，成本太高）</p>
<h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><p>其实开发过程没什么好说的，记住Git一定要给每个项目一个独立分支，合并的时候分批合并，否则别人CR你代码的时候可能你就要打喷嚏了！</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>问题主要在测试及线上被发现，问题解决的过程就像坐过山车，经常的状态是：测试 &#x3D;&gt; 开发 &#x3D;&gt; 测试 &#x3D;&gt; 上线 &#x3D;&gt; 开发 &#x3D;&gt; 测试，循环往复。。。</p>
<p><strong>两个温馨小贴士：</strong></p>
<ol>
<li>遇到问题时，千万不要慌，可以先深呼吸几口气，因为问题一定是可以解决的，解决不了那么你可能要被解决了！ </li>
<li>解决问题后，千万别激动，可以先深呼吸几口气，因为你还会产生新的问题，而且往往新问题更严重！</li>
</ol>
<p>这里分享一些印象深刻的问题。</p>
<h3 id="1-事务提交时报错？"><a href="#1-事务提交时报错？" class="headerlink" title="1. 事务提交时报错？"></a>1. 事务提交时报错？</h3><p>原因：事务依赖的服务里也有事务，因此事务里套了事务，破坏了隔离性。</p>
<p>解决：修改代码，保证事务隔离性。</p>
<h3 id="2-依赖包存在，项目启动却报错？"><a href="#2-依赖包存在，项目启动却报错？" class="headerlink" title="2. 依赖包存在，项目启动却报错？"></a>2. 依赖包存在，项目启动却报错？</h3><p>原因：存在多版本jar包，导致Java代码使用反射机制动态生成类是不知道使用哪个版本的依赖的类。</p>
<p>解决：删掉多余版本jar包。</p>
<h3 id="3-缓存未即时更新"><a href="#3-缓存未即时更新" class="headerlink" title="3. 缓存未即时更新"></a>3. 缓存未即时更新</h3><p>原因：经排查，是由于实际的key数量可达千万级，导致更新缓存前对要删除的keys的scan扫描效率过低，长达20多秒！</p>
<p>解决：修改更新缓存方案，不再使用scan扫描，而是拼凑出所有可能的keys，直接delete。</p>
<p>以为这个问题这样就结束了？不要忘记上面的小贴士：</p>
<p>“解决问题后，千万别激动，可以先深呼吸几口气，因为你还会产生新的问题，而且往往新问题更严重！”</p>
<p>↓↓↓</p>
<h3 id="4-缓存仍未即时更新？"><a href="#4-缓存仍未即时更新？" class="headerlink" title="4. 缓存仍未即时更新？"></a>4. 缓存仍未即时更新？</h3><p>原因：某业务侧要求数据强一致性，而缓存虽然是毫秒级更新，但无法做到真正的实时一致。</p>
<p>解决：为其定制一个接口，该接口不查询缓存，直接查DB，保证查到的数据一定是最新值。</p>
<h3 id="5-请求卡死"><a href="#5-请求卡死" class="headerlink" title="5. 请求卡死"></a>5. 请求卡死</h3><p>服务运行一段时间后，发现所有的请求都被阻塞了！心脏受不了。</p>
<p>原因：jstack打印线程信息后分析thread_dump文件，发现是由于jedis未手动释放连接使资源耗尽，导致新的请求中会不断等待jedis连接资源释放，从而卡死。</p>
<p>解决：补充释放资源代码即可。</p>
<h3 id="6-线上环境分析日志时突然告警磁盘IO占用超过99-！？"><a href="#6-线上环境分析日志时突然告警磁盘IO占用超过99-！？" class="headerlink" title="6. 线上环境分析日志时突然告警磁盘IO占用超过99%！？"></a>6. 线上环境分析日志时突然告警磁盘IO占用超过99%！？</h3><p>原因：误用cat命令查看未分割的原始日志文件（31G！！！），导致磁盘IO直接刷爆！</p>
<p>解决：使用less、tail、head等命令替换cat，并移除已备份的大日志文件</p>
<h3 id="7-进程闪退"><a href="#7-进程闪退" class="headerlink" title="7. 进程闪退"></a>7. 进程闪退</h3><p>排查：通常jvm进程闪退是有错误日志的，但是并没有找到，排查陷入绝境。没办法，只能祈祷问题不再复现。后来问题真的没出现过了，谢谢谢谢！</p>
<p>原因：最后，经询问，是有人手动kill掉了这个进程。。。好的，开启问候模式</p>
<h3 id="8-线上环境的消息通知发送成功了，怎么没有预期的数据更新效果？"><a href="#8-线上环境的消息通知发送成功了，怎么没有预期的数据更新效果？" class="headerlink" title="8. 线上环境的消息通知发送成功了，怎么没有预期的数据更新效果？"></a>8. 线上环境的消息通知发送成功了，怎么没有预期的数据更新效果？</h3><p>定位思路：先看消息是否被消费，再看对消息的处理是否正确</p>
<p>排查：查看线上日志，发现消息并未被消费；但是查看监控界面，发现消息被测试环境的机器消费了！！！</p>
<p>原因：由于测试环境和线上环境属于同一个消费组，当消息到达时，同一个消费组只有一个消费者能够成功消费该消息，被测试环境消费掉了，导致线上环境数据没更新。</p>
<p>发现这个问题的时候，已经是上线前一天的深夜。。。再申请一个消费组已经来不及了，情急之下，只能先下掉测试环境的服务。第二天申请好消费组后，根据环境去区分使用哪个消费组就可以了，这样每个消费组都会消费消息，成功避免了消息竞争。</p>
<blockquote>
<p>方法笨了点，有用就行！</p>
</blockquote>
<h3 id="9-报告！流量太大，撑不住啊！"><a href="#9-报告！流量太大，撑不住啊！" class="headerlink" title="9. 报告！流量太大，撑不住啊！"></a>9. 报告！流量太大，撑不住啊！</h3><p>原因：现有4台机器无法支撑百万并发，需进行紧急扩容</p>
<p>解决：紧急新申请了10台机器，部署之后修改负载均衡服务配置，成功增大了并发度。</p>
<h3 id="10-上线前一天你跟我说接口设计有问题？"><a href="#10-上线前一天你跟我说接口设计有问题？" class="headerlink" title="10. 上线前一天你跟我说接口设计有问题？"></a>10. 上线前一天你跟我说接口设计有问题？</h3><p>原因：沟通出现严重问题！</p>
<p>其实工作中，很多同事因为自身业务繁忙，可能在核对接口设计方案的时候不说话，周知的消息不看，给文档也不看。等他们忙完了，会反复@你、私聊你询问。<strong>我们一定不要这样！</strong></p>
<p>解决：紧急电话会议，拉群核对方案</p>
<blockquote>
<p>有时4个人能拉4个群。。。</p>
</blockquote>
<h3 id="11-线上出bug了！！！"><a href="#11-线上出bug了！！！" class="headerlink" title="11. 线上出bug了！！！"></a>11. 线上出bug了！！！</h3><p>线上出bug，是一件很大的事，必须紧急响应。在梦里也得给我爬起来！</p>
<p>原因：测试环境和线上环境未必完全一致，且测试环境未必能测出所有问题。因此验证时通常需要预发布环境，数据使用线上数据，但却是独立的服务器，保证不影响线上。</p>
<p>解决：紧急排查定位问题，三分钟成功修复！</p>
<p>修复bug有一定的技巧，分享下个人的排错路径：</p>
<p><strong>截图&#x2F;问题 &#x3D;&gt; 请求 &#x3D;&gt; bug是否可复现，和测试紧密配合 &#x3D;&gt; 数据 &#x3D;&gt; 数据源（真实数据与接口数据是否一致） &#x3D;&gt; 数据处理</strong></p>
<p><strong>解释一下：</strong></p>
<p>通常发现问题的是运维、用户或者测试，他们会抛出一个问题或者问题的相关的截图，这时，我们要快速想到这个问题对应的功能（即对应的请求&#x2F;接口），然后让问题描述者尽可能多的提供信息（比如请求参数、问题时间等）。</p>
<p>如果问题时间较久，看日志及监控不易排查，可以询问是否可以造一个复现该问题的case，这样只需观察最新的日志即可，方便排错。</p>
<p>定位到请求后，我们要分析请求及响应的哪些数据是异常的，即定位关键数据，然后定位数据来源（是从数据库查的，还是从缓存查的），并观察响应数据与真实数据源是否一致。如果不一致，可能是业务逻辑中对数据的处理出现了问题，再进一步去做分析。</p>
<blockquote>
<p>高效沟通建议：描述问题，尽量用数据说话，别光截图，要提供完整的数据信息，有助他人分析</p>
</blockquote>
<h2 id="血泪教训"><a href="#血泪教训" class="headerlink" title="血泪教训"></a>血泪教训</h2><ol>
<li>有问题一定尽可能在测试环境去解决，否则线上出问题对心脏很不友好 </li>
<li>不要盲目乐观，以为上线就没问题，要多验证，保持警惕。</li>
</ol>
<p>PS：上线后如果发现问题，会经历如下的流程，我称它为happy流程：</p>
<p><strong>上线后的变更流程：</strong></p>
<p><img src="/2020/02/21/%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%E9%A1%B9%E7%9B%AE%E5%BF%83%E5%BE%97-%E4%B8%80%E5%91%A8%E7%88%86%E8%82%9D%E4%B8%8A%E7%BA%BF%E7%99%BE%E4%B8%87%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/2.png" alt="上线后的变更流程"></p>
<p>当发现DB服务的bug后，<del>你只需要改DB服务的一行代码</del>。你需要重复如下流程：</p>
<ol>
<li>修改DB服务的一行代码 </li>
<li>跑单元测试 </li>
<li>DB服务打成依赖包 </li>
<li>修改“状态流转系统”、“查询系统”对DB服务的依赖包（改动版本号&#x2F;更新本地缓存拉取最新包） </li>
<li>重新发布“状态流转系统”、“查询系统”至测试环境 </li>
<li>可能还要重新交给测试的同学进行回归测试 </li>
<li>测试通过，再次提交“状态流转系统”、“查询系统”的代码，发起CR（代码审查） </li>
<li>找同事&#x2F;Leader读代码，通过CR </li>
<li>合并分支 </li>
<li>发布“状态流转系统”、“查询系统”至线上环境，每发一台机器，都要进行一次验证（滚动部署） </li>
<li><strong>再次发现新的bug</strong></li>
</ol>
<p>这是一件恶心到爆炸的事情，但是在这个过程中我们发现，2、6、8状态时，是存在空余时间的，这个时候我们可以<del>做做其他工作，记录一下工作内容、问题等</del> 刷刷抖音，看看牛客。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>首先总结一下这个项目各阶段的耗时：</strong></p>
<ul>
<li>理解需求：5% </li>
<li>开发：15% </li>
<li>沟通确认问题：30% </li>
<li>测试及验证：30% </li>
<li>上线及验证：20%</li>
</ul>
<p><strong>项目过程存在的问题：</strong></p>
<ol>
<li>前期未参与需求评审，了解的信息较少。 </li>
<li>上线前一天晚上，竟然还在临时对齐接口？这是在沟通方案阶段应该确认好的。 </li>
<li>大约80%的时间花在沟通、查询数据、提供数据及验证。 </li>
<li>自己没测试完，就开始串测，导致同一个bug被多方发现，反复@，导致改bug效率低下。 </li>
<li>对自研中间件的不熟悉，导致花费的时间成本较高。</li>
</ol>
<p><strong>自我感觉良好的地方：</strong></p>
<ol>
<li>和测试同学配合紧密，互相体谅，测试效率较高 </li>
<li>最快3分钟紧急修复线上bug </li>
<li>最快30分钟从接受需求到上线 </li>
<li>在发现中间件问题时，即时和对接方沟通，设计出了对其无任何影响的低成本解决方案 </li>
<li>积极帮助其他同学查询数据，排查问题 </li>
<li>编写脚本高效解决部分错误数据</li>
</ol>
<p><strong>成长与收获：</strong></p>
<ol>
<li>抗压熬夜能力 ↑ </li>
<li>设计思维能力 ↑ </li>
<li>沟通能力 ↑ </li>
<li>解决问题能力 ↑ </li>
<li>高级命令熟悉度 ↑ </li>
<li>中间件熟悉度 ↑ </li>
<li>集群管理能力 ↑ </li>
<li>拒绝需求能力 ↑ </li>
<li>吐槽能力 ↑ </li>
<li>吹🐂能力 ↑</li>
</ol>
<p><strong>工作简单而不简单，做着有意义的事就好~</strong></p>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>项目上线后，通过总结复盘，发现了项目中值得优化的地方，也思考到了一些更健全的机制，将逐渐去实现。</p>
<p>如下：</p>
<h3 id="1-两个系统中有部分相同的配置，目前采用复制粘贴的方式去同步"><a href="#1-两个系统中有部分相同的配置，目前采用复制粘贴的方式去同步" class="headerlink" title="1. 两个系统中有部分相同的配置，目前采用复制粘贴的方式去同步"></a>1. 两个系统中有部分相同的配置，目前采用复制粘贴的方式去同步</h3><p>这种方式的优点是比较简单，无需额外的操作。但缺点也很明显，如果一个系统的配置改了，而忘了修改另一个系统的配置，就会出现错误。</p>
<p>事实上，可以引入一个<strong>配置中心</strong>，集中管理配置文件，并且支持手动修改、多环境、灰度等功能。</p>
<p>公司内部做了调研，发现了一个不错的开源协同项目。当然也可以采用阿里的Nacos或携程的Apollo。</p>
<h3 id="2-曾经的进程闪退问题，必须重视！"><a href="#2-曾经的进程闪退问题，必须重视！" class="headerlink" title="2. 曾经的进程闪退问题，必须重视！"></a>2. 曾经的进程闪退问题，必须重视！</h3><p>无法保证进程不闪退，但是可以采取对进程实时监控，并自动对闪退进程进行重启的策略。</p>
<p>实现方式有两种：</p>
<ol>
<li>使用工具，例如supervisor或monit，可以对进程进行管理和闪退重启 </li>
<li>编写shell脚本，再通过定时任务，实现周期性观察进程状态及重启。推荐将定时任务接入<strong>分布式任务调度平台</strong>，尤其当定时任务很多时，进行可视化的管理和方便的控制调度是必要的！</li>
</ol>
<p>由于公司内部的平台比较完善，我选择第二种方式。</p>
<blockquote>
<p>原来自己写过一个<a href="https://www.bilibili.com/video/av47442014">分布式邮件调度平台</a>，参考了分布式任务调度平台的实现方式，大家有兴趣可以了解下原理，感觉对拓宽后端思路很有帮助。</p>
</blockquote>
<p><strong>工作简单而不简单，做着有意义的事就好~</strong></p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>此处回答一些牛友们的问题，欢迎牛友们抛出疑问、指出不足、积极讨论。</p>
<h2 id="问题讨论"><a href="#问题讨论" class="headerlink" title="问题讨论"></a>问题讨论</h2><p><strong>1. 事务依赖的服务也有事务，怎么处理？</strong></p>
<p>答：同一个数据访问对象（dao）开启多个事务才会出现此问题，处理方式是不使用依赖服务中有事务的方法。比如可以用for循环单条删除来代替批量删除。</p>
<p><strong>2. 为什么不用主流的Spring + SpringMVC，而是用Jersey + Guice框架？</strong></p>
<p>的确，Spring是主流，生态好，一般大家都会选择SpringBoot + Tomcat。但主流不代表适用于所有的业务场景，还是要<strong>贴合业务去做技术选型</strong>。其实这里应该拿SpringMVC去对标Jersey、Spring对标Guice，但实际上SpringMVC也依赖Spring（一家人）。</p>
<p>这里不用Spring有如下几个原因：</p>
<ol>
<li>系统较小型。Spring和SpringMVC功能虽大而全，但是相对于Jersey，显得有些重量级，需要做更多的工作（比如编写配置文件等等）。 </li>
<li>系统仅提供查询服务。而Jersey框架专门提供Restful风格接口，完全可以满足需求。 </li>
<li>由于Jersey轻量的特性，支持手动注册接口，相对Spring更为灵活，与其他框架搭配使用也很方便（比如Guice、Grizzly），不易出现版本冲突。 </li>
<li>Guice可以在一个文件中手动注入管理所有依赖，便于查找。而用Spring的时候我们通常是在每个类上加注解扫包或者编写配置文件，虽然写起来爽的飞起，但非常不利于代码阅读（import *和lombok也是同理，最好不要用）！</li>
</ol>
<p><strong>这里也提一下用Grizzly服务器来替代Tomcat的好处，主要是：</strong></p>
<ol>
<li>性能更高，高并发场景表现更稳定。 </li>
<li>操作管理方便，在代码中启动即可（虽然Tomcat也提供了embed版本）。</li>
</ol>
<p><strong>3. 负载均衡怎么实现？</strong></p>
<p>企业负载均衡一般都是软硬结合（例如l5、Nginx）、四七层结合（例如lvs+keepalived、Nginx）。</p>
<p>要提高负载，首先增加机器或扩容（以设置更大的jvm内存），给每个机器部署相同的服务，然后配置负载均衡器，增加到新机器的路由即可。当然完成上述操作后要去做验证，看是否有请求路由到了新机器。</p>
<p>缓存和DB都是集群的，提供统一接口供查询服务调用，不用担心各机器的查询结果不一致。</p>
]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>python模拟MQTTproducer</title>
    <url>/2023/09/15/python%E6%A8%A1%E6%8B%9FMQTTproducer/</url>
    <content><![CDATA[<p>以下模拟100个客户端、订阅100个topic<br>需要1. locust，2.paho</p>
<span id="more"></span>
<p>以下是python代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> locust <span class="keyword">import</span> User, TaskSet, events, task, between</span><br><span class="line"><span class="keyword">import</span> paho.mqtt.client <span class="keyword">as</span> mqtt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">broker_address=<span class="string">&quot;127.0.0.1&quot;</span>  <span class="comment">#服务器ip地址，实际压测要根据mqtt的实际ip进行修改</span></span><br><span class="line">REQUEST_TYPE = <span class="string">&#x27;MQTT&#x27;</span></span><br><span class="line">PUBLISH_TIMEOUT = <span class="number">10000</span> <span class="comment">#超时时间</span></span><br><span class="line">TOPIC_NUM = <span class="number">100</span>  <span class="comment"># 每个客户端订阅的topic数量</span></span><br><span class="line">MESSAGE_NUM = <span class="number">15</span>  <span class="comment"># 每个topic每5秒发送的消息数量</span></span><br><span class="line">CLIENT_NUM = <span class="number">100</span>  <span class="comment"># 模拟的客户端数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fire_locust_success</span>(<span class="params">**kwargs</span>):</span><br><span class="line">    events.request.fire(</span><br><span class="line">        request_type=kwargs.get(<span class="string">&#x27;request_type&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>),</span><br><span class="line">        name=kwargs.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;unknown&#x27;</span>),</span><br><span class="line">        response_time=kwargs.get(<span class="string">&#x27;response_time&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">        response_length=kwargs.get(<span class="string">&#x27;response_length&#x27;</span>, <span class="number">0</span>),</span><br><span class="line">        exception=<span class="literal">None</span>,</span><br><span class="line">        context=<span class="literal">None</span>,</span><br><span class="line">        request_meta=&#123;&#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">time_delta</span>(<span class="params">t1, t2</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>((t2 - t1)*<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublishTask</span>(<span class="title class_ inherited__">TaskSet</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_start</span>(<span class="params">self</span>):</span><br><span class="line">        self.start_time = time.time()</span><br><span class="line">        username = <span class="string">&quot;****&quot;</span></span><br><span class="line">        password = <span class="string">&quot;****&quot;</span></span><br><span class="line">        self.client.username_pw_set(username, password)</span><br><span class="line">        self.client.connect(host=broker_address, port=<span class="number">61613</span>, keepalive=<span class="number">60</span>)</span><br><span class="line">        self.client.loop_start()</span><br><span class="line">        self.topics = [<span class="string">f&quot;/yace/device<span class="subst">&#123;random_string(<span class="number">4</span>)&#125;</span>&quot;</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(TOPIC_NUM)]</span><br><span class="line">        <span class="keyword">for</span> topic <span class="keyword">in</span> self.topics:</span><br><span class="line">            self.client.subscribe(topic)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Connected and subscribed to <span class="subst">&#123;TOPIC_NUM&#125;</span> topics.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_stop</span>(<span class="params">self</span>):</span><br><span class="line">        self.client.loop_stop()</span><br><span class="line">        self.client.disconnect()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Disconnected.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @task(<span class="params"><span class="number">1</span></span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">task_pub</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> topic <span class="keyword">in</span> self.topics:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(MESSAGE_NUM):</span><br><span class="line">                payload = <span class="string">&quot;Message - &quot;</span> + <span class="built_in">str</span>(self.client._client_id)</span><br><span class="line">                infot = self.client.publish(topic, payload, qos=<span class="number">0</span>)</span><br><span class="line">                infot.wait_for_publish()</span><br><span class="line"></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        total_time = time_delta(self.start_time, end_time)</span><br><span class="line">        fire_locust_success(</span><br><span class="line">            request_type=REQUEST_TYPE,</span><br><span class="line">            name=<span class="built_in">str</span>(self.client._client_id),</span><br><span class="line">            response_time=total_time,</span><br><span class="line">            response_length=<span class="built_in">len</span>(payload) * MESSAGE_NUM * TOPIC_NUM</span><br><span class="line">        )</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    wait_time = between(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MQTTLocust</span>(<span class="title class_ inherited__">User</span>):</span><br><span class="line">    tasks = [PublishTask]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        MQTTLocust.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> MQTTLocust.count &gt; CLIENT_NUM:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 超过100个客户端后不再创建</span></span><br><span class="line">        client_name = <span class="string">&quot;Device - &quot;</span> + <span class="built_in">str</span>(MQTTLocust.count)</span><br><span class="line">        self.client = mqtt.Client(client_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">on_disconnect</span>(<span class="params">self, client, userdata, rc</span>):</span><br><span class="line">        <span class="keyword">if</span> rc != <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Unexpected disconnection.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_string</span>(<span class="params">length</span>):</span><br><span class="line">    digits = string.digits  <span class="comment"># 包含所有数字字符的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(random.choice(digits) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    os.system(<span class="string">&quot;locust -f yace_4.py -u 100 -r 1 --headless  --host=127.0.0.1&quot;</span>)  <span class="comment"># Start 100 Locust users</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>edge</category>
      </categories>
      <tags>
        <tag>mqtt</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot常见面试题</title>
    <url>/2024/10/09/springboot%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>链接：<a href="https://juejin.cn/post/6844904125709156359">Spring Boot面试题</a></p>
<p>什么是 Spring Boot？</p>
<p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</p>
<p>为什么要用SpringBoot</p>
<p>快速开发，快速整合，配置简化、内嵌服务containers</p>
<p>SpringBoot与SpringCloud 区别</p>
<p>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</p>
<span id="more"></span>

<p>以下是50道关于Spring Boot的面试题目及其标准答案：</p>
<ol>
<li><p><strong>什么是Spring Boot？</strong></p>
<ul>
<li>Spring Boot是一个基于Spring框架的项目初始化工具，旨在简化Spring应用程序的创建和部署。它通过自动配置、内嵌服务器、生产就绪特性等，减少了开发和配置的复杂性。</li>
</ul>
</li>
<li><p><strong>为什么要用Spring Boot？</strong></p>
<ul>
<li>Spring Boot提供自动配置、内嵌服务器、简化的项目结构和生产级别的监控和管理功能，显著减少了开发时间和配置复杂度。</li>
</ul>
</li>
<li><p><strong>Spring Boot的核心注解是哪个？</strong></p>
<ul>
<li><code>@SpringBootApplication</code>，它是一个组合注解，包含 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code> 和 <code>@ComponentScan</code>。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中定义多套不同环境配置？</strong></p>
<ul>
<li>使用配置文件如 <code>application-&#123;profile&#125;.properties</code> 或 <code>application-&#123;profile&#125;.yaml</code>，并通过 <code>spring.profiles.active</code> 属性激活特定环境的配置。</li>
</ul>
</li>
<li><p><strong>Spring Boot支持哪些外部配置？</strong></p>
<ul>
<li>支持properties文件、YAML文件、环境变量、系统属性和命令行参数等。</li>
</ul>
</li>
<li><p><strong>Spring Boot的配置文件加载顺序是怎样的？</strong></p>
<ul>
<li>默认加载顺序为：命令行参数 &gt; <code>application.properties</code> &gt; <code>application-&#123;profile&#125;.properties</code> &gt; <code>application.yaml</code> &gt; <code>application-&#123;profile&#125;.yaml</code>。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot启动时运行一些特定的代码？</strong></p>
<ul>
<li>实现 <code>CommandLineRunner</code> 或 <code>ApplicationRunner</code> 接口，并在 <code>run</code> 方法中编写启动时执行的代码。</li>
</ul>
</li>
<li><p><strong>如何实现Spring Boot应用程序的安全性？</strong></p>
<ul>
<li>使用Spring Security进行身份验证和授权，通过配置类或注解如 <code>@EnableWebSecurity</code> 和 <code>@Configuration</code> 来实现安全配置。</li>
</ul>
</li>
<li><p><strong>Spring Boot中的监视器是什么？</strong></p>
<ul>
<li>Spring Boot Actuator提供了一组生产级别的监控和管理功能，包括健康检查、指标监控、审计和应用程序信息等。</li>
</ul>
</li>
<li><p><strong>如何使用Spring Boot实现分页和排序？</strong></p>
<ul>
<li>使用Spring Data JPA提供的 <code>Pageable</code> 和 <code>Sort</code> 接口，通过方法签名中的参数实现分页和排序功能。</li>
</ul>
</li>
<li><p><strong>什么是Spring Boot Starter？</strong></p>
<ul>
<li>Starter是一组方便的依赖描述符，帮助快速搭建项目。例如，<code>spring-boot-starter-web</code> 包含了构建web应用所需的所有依赖。</li>
</ul>
</li>
<li><p><strong>Spring Boot如何实现热部署？</strong></p>
<ul>
<li>可以使用 <code>spring-boot-devtools</code> 依赖来实现热部署。</li>
</ul>
</li>
<li><p><strong>Spring Boot的自动配置原理是什么？</strong></p>
<ul>
<li>Spring Boot的自动配置基于 <code>@EnableAutoConfiguration</code> 注解，通过扫描 <code>META-INF/spring.factories</code> 文件，加载相应的自动配置类。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中设置支持跨域请求？</strong></p>
<ul>
<li>可以在配置类中使用 <code>@CrossOrigin</code> 注解，或者通过配置 <code>CorsRegistry</code>：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>).allowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中禁用默认Web服务器？</strong></p>
<ul>
<li>在 <code>application.properties</code> 文件中设置以下属性：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.web-application-type</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中替换或覆盖嵌入式Tomcat服务器？</strong></p>
<ul>
<li>排除默认的Tomcat依赖，并添加新的服务器依赖（如Jetty或Undertow）：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中启用HTTP&#x2F;2支持？</strong></p>
<ul>
<li>在 <code>application.properties</code> 文件中添加以下配置：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.http2.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中定义属性？</strong></p>
<ul>
<li>可以在 <code>application.properties</code> 或 <code>application.yml</code> 文件中定义属性。例如：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">数据库.主机</span>=<span class="string">本地主机</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中访问应用程序中定义的值？</strong></p>
<ul>
<li>使用 <code>@Value</code> 注解来访问在 <code>application.properties</code> 文件中定义的属性。例如：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;custom.value&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String customVal;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>什么是Spring Boot Actuator？</strong></p>
<ul>
<li>Spring Boot Actuator是一个子项目，提供了一系列生产级的监控和管理功能，如健康检查、度量收集、环境信息、日志级别管理等。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现异常处理？</strong></p>
<ul>
<li>使用 <code>@ControllerAdvice</code> 注解创建一个全局异常处理类，并使用 <code>@ExceptionHandler</code> 注解处理特定异常。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中集成Swagger2？</strong></p>
<ul>
<li>添加Swagger2依赖，并配置Swagger：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.example.package&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中配置数据源？</strong></p>
<ul>
<li>在 <code>application.properties</code> 文件中配置数据库连接信息：<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/yourdatabase</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">yourusername</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">yourpassword</span></span><br><span class="line"><span class="attr">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update</span></span><br><span class="line"><span class="attr">spring.jpa.show-sql</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中使用JPA进行数据库操作？</strong></p>
<ul>
<li>创建实体类并使用JPA注解标注，创建Repository接口并继承 <code>JpaRepository</code>，在服务层或控制器中注入Repository并使用其方法进行数据库操作。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现文件上传和下载？</strong></p>
<ul>
<li>使用 <code>MultipartFile</code> 接口处理文件上传，使用 <code>ResponseEntity</code> 返回文件下载响应。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现定时任务？</strong></p>
<ul>
<li>使用 <code>@EnableScheduling</code> 注解启用定时任务支持，并使用 <code>@Scheduled</code> 注解定义定时任务方法。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现缓存？</strong></p>
<ul>
<li>使用 <code>@EnableCaching</code> 注解启用缓存支持，并使用 <code>@Cacheable</code>、<code>@CachePut</code> 和 <code>@CacheEvict</code> 注解管理缓存。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现国际化（i18n）？</strong></p>
<ul>
<li>在 <code>src/main/resources</code> 目录下创建国际化资源文件（如 <code>messages.properties</code>、<code>messages_en.properties</code>），并在配置类中配置 <code>LocaleResolver</code>。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现异步处理？</strong></p>
<ul>
<li>使用 <code>@EnableAsync</code> 注解启用异步支持，并使用 <code>@Async</code> 注解标注异步方法。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现WebSocket通信？</strong></p>
<ul>
<li>使用 <code>@EnableWebSocket</code> 注解启用WebSocket支持，并配置 <code>WebSocketConfigurer</code> 实现类。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现分布式事务管理？</strong></p>
<ul>
<li>使用Spring Cloud中的消息中间件（如RabbitMQ或Kafka）实现Saga模式，或使用Atomikos、Bitronix等分布式事务管理器实现两阶段提交（2PC）。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现API版本控制？</strong></p>
<ul>
<li>在控制器类或方法上使用 <code>@RequestMapping</code> 注解中的 <code>value</code> 属性指定版本号（如 <code>/api/v1/resource</code>）。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现日志管理？</strong></p>
<ul>
<li>使用Spring Boot默认的Logback日志框架，并在 <code>application.properties</code> 文件中配置日志级别和输出格式。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现邮件发送功能？</strong></p>
<ul>
<li>添加 <code>spring-boot-starter-mail</code> 依赖，并配置邮件服务器设置。使用 <code>JavaMailSender</code> 发送邮件。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现数据验证？</strong></p>
<ul>
<li>使用JSR-303&#x2F;JSR-380注解（如 <code>@NotNull</code>、<code>@Size</code>）标注实体类属性，并在控制器方法中使用 <code>MethodArgumentNotValidException</code> 处理验证错误。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现自定义异常处理？</strong></p>
<ul>
<li>使用 <code>@ControllerAdvice</code> 注解创建全局异常处理类，并使用 <code>@ExceptionHandler</code> 注解处理特定异常。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现单元测试？</strong></p>
<ul>
<li>使用 <code>@SpringBootTest</code> 注解启动Spring Boot测试环境，并使用 <code>@Test</code>、<code>@MockBean</code> 等注解进行单元测试。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现集成测试？</strong></p>
<ul>
<li>使用 <code>@SpringBootTest</code> 注解启动Spring Boot测试环境，并使用 <code>@Test</code>、<code>@AutoConfigureMockMvc</code> 等注解进行集成测试。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现性能测试？</strong></p>
<ul>
<li>使用JMeter、Gatling等性能测试工具进行性能测试。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现安全性测试？</strong></p>
<ul>
<li>使用OWASP ZAP、Fortify等安全扫描工具进行安全性测试。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现端到端测试？</strong></p>
<ul>
<li>使用Selenium、Cypress等自动化测试工具进行端到端测试。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现API文档管理？</strong></p>
<ul>
<li>使用Swagger、Redoc等工具生成API文档。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现微服务架构？</strong></p>
<ul>
<li>使用Spring Cloud、Docker、Kubernetes等技术构建微服务架构。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现服务注册与发现？</strong></p>
<ul>
<li>使用Eureka、Consul等服务注册中心进行服务注册与发现。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现API网关？</strong></p>
<ul>
<li>使用Zuul、Gateway等API网关进行请求路由、过滤和聚合。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现配置中心？</strong></p>
<ul>
<li>使用Spring Cloud Config、Apollo等配置中心进行集中配置管理。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现分布式链路追踪？</strong></p>
<ul>
<li>使用Spring Cloud Sleuth、Zipkin等工具进行分布式链路追踪。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现服务熔断？</strong></p>
<ul>
<li>使用Hystrix、Resilience4j等熔断器实现服务熔断。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现服务降级？</strong></p>
<ul>
<li>使用Hystrix、Resilience4j等熔断器实现服务降级。</li>
</ul>
</li>
<li><p><strong>如何在Spring Boot中实现容器化部署？</strong></p>
<ul>
<li>使用Docker、Kubernetes等容器化技术进行部署。</li>
</ul>
</li>
</ol>
<p>Spring Boot 有哪些优点？</p>
<p>Spring Boot 主要有如下优点：</p>
<p>容易上手，提升开发efficiency，为 Spring 开发提供一个更快、更简单的开发framework。<br>开箱即用，远离繁琐的配置。<br>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、security管理、运行数据监控、运行状况检查和外部化配置等。<br>SpringBootsummarizes就是使编码变简单、配置变简单、部署变简单、监控变简单等等</p>
<p>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</p>
<p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p>
<p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p>
<p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，<br>例如：java 如关闭数据源自动配置功能： @SpringBootApplication(exclude &#x3D; { DataSourceAutoConfiguration.class })。</p>
<p>@ComponentScan：Spring组件扫描。</p>
<p>Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</p>
<p>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</p>
<p>SpringBoot Starter的工作原理</p>
<p>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</p>
<p>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 &#x2F;&#x2F;（SpringContext是Spring的配置文件）</p>
<p>Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</p>
<p>配置变更<br>JDK 版本升级<br>第三方类库升级<br>响应式 Spring 编程支持<br>HTTP&#x2F;2 支持<br>配置属性绑定<br>更多改进与加强</p>
<p>SpringBoot支持什么前端模板，</p>
<p>thymeleaf，freemarker，jsp，官方不推荐JSP会有限制</p>
<p>SpringBoot的缺点</p>
<p>我觉得是为难人，SpringBoot在目前我觉得没有什么缺点，非要找一个出来我觉得就是</p>
<p>由于不用自己做的配置，报错时很难定位。</p>
<p>运行 Spring Boot 有哪几种方式？</p>
<p>打包用command或者放到容器中运行</p>
<p>用 Maven&#x2F; Gradle 插件运行</p>
<p>直接执行 main 方法运行</p>
<p>Spring Boot 需要独立的容器运行吗？</p>
<p>可以不需要，内置了 Tomcat&#x2F; Jetty 等容器。</p>
<p>开启 Spring Boot 特性有哪几种方式？</p>
<p>继承spring-boot-starter-parent项目</p>
<p>导入spring-boot-dependencies项目依赖</p>
<p>SpringBoot 实现热部署有哪几种方式？</p>
<p>热部署就是可以不用重新运行SpringBoot项目可以realize操作后台代码自动更新到以运行的项目中<br>主要有两种方式：</p>
<p>Spring Loaded<br>Spring-boot-devtools</p>
<p>SpringBoot事物的使用</p>
<p>SpringBoot的事物很简单，首先使用注解EnableTransactionManagement开启事物之后，然后在Service方法上添加注解Transactional便可。</p>
<p>Async异步调用方法</p>
<p>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步调用。<br>注意：需要在启动类加入@EnableAsync使异步调用@Async注解生效。</p>
<p>如何在 Spring Boot 启动的时候运行一些特定的代码？</p>
<p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</p>
<p>Spring Boot 有哪几种读取配置的方式？</p>
<p>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</p>
<p>什么是 JavaConfig？</p>
<p>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他，它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p>
<p>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以inherit另一个，重写它的@Bean 方法等。</p>
<p>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</p>
<p>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p>
<p>常用的Java config：</p>
<p>@Configuration：在类上打上写下此注解，表示这个类是配置类<br>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。<br>@Bean：bean的注入：相当于以前的&lt; bean id&#x3D;”objectMapper” class&#x3D;”org.codehaus.jackson.map.ObjectMapper” &#x2F;&gt;<br>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;<br>@ImportResource： 相当于xml的 &lt; import resource&#x3D;”applicationContext-cache.xml”&gt;</p>
<p>SpringBoot的自动配置原理是什么</p>
<p>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</p>
<p>有了这个EnableAutoConfiguration的话就会：</p>
<p>从配置文件META_INF&#x2F;Spring.factories加载可能用到的自动配置类<br>去重，并将exclude和excludeName属性携带的类排除<br>过滤，将满足条件（@Conditional）的自动配置类返回</p>
<p>你如何理解 Spring Boot 配置加载顺序？</p>
<p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<p>1.properties文件；</p>
<p>2.YAML文件；</p>
<p>3.系统环境变量；</p>
<p>4.命令行参数；</p>
<p>等等……</p>
<p>什么是 YAML？</p>
<p>YAML 是一种人类可读的data序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少confusion。可以看出 YAML 具有分层配置data。</p>
<p>YAML 配置的优势在哪里 ?</p>
<p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p>
<p>配置有序，在一些特殊的场景下，配置有序很关键</p>
<p>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</p>
<p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p>
<p>Spring Boot 是否可以使用 XML 配置 ?</p>
<p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p>
<p>spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</p>
<p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p>
<p>spring boot 核心的两个配置文件：</p>
<p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；<br>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p>
<p>什么是 Spring Profiles？</p>
<p>在项目的开发中，有些配置文件在开发、测试或者production等不同环境中可能是不同的，例如数据库connection、redis的配置等等。那我们如何在不同环境中automate实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能<br>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p>
<p>SpringBoot多数据源拆分的思路</p>
<p>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中</p>
<p>SpringBoot多数据源事务如何管理</p>
<p>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</p>
<p>第二种是使用jta-atomikos实现分布式事务管理</p>
<p>保护 Spring Boot 应用有哪些方法？</p>
<p>在生产中使用HTTPS<br>使用Snyk检查你的依赖关系<br>升级到最新版本<br>启用CSRF保护<br>使用内容安全策略防止XSSattacks</p>
<p>如何实现 Spring Boot 应用程序的安全性？</p>
<p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</p>
<p>比较一下 Spring Security 和 Shiro 各自的优缺点 ?</p>
<p>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：</p>
<p>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</p>
<p>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</p>
<p>Spring Security 功能强大；Shiro 功能简单</p>
<p>Spring Boot 中如何解决跨域问题 ?</p>
<p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p>
<p> 代码解读复制代码  @Configuration<br>  public class CorsConfig implements WebMvcConfigurer {</p>
<pre><code>  @Override
  public void addCorsMappings(CorsRegistry registry) &#123;
      registry.addMapping(&quot;/**&quot;)
              .allowedOrigins(&quot;*&quot;)
              .allowCredentials(true)
              .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
              .maxAge(3600);
  &#125;
</code></pre>
<p>  }<br>Spring Boot 中的监视器是什么？</p>
<p>Spring boot actuator 是 spring 启动framework中的重要功能之一。Spring boot 监视器可帮助您访问production环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
<p>如何使用 Spring Boot 实现全局异常处理？</p>
<p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p>
<p>我们如何监视所有 Spring Boot 微服务？</p>
<p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的components（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p>
<p>SpringBoot性能如何优化</p>
<p>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围</p>
<p>在项目启动时设置JVM初始内存和最大内存相同</p>
<p>将springboot内置服务器由tomcat设置为undertow</p>
<p>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</p>
<p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要challenge是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将eliminate每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员most需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在production环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</p>
<p> 代码解读复制代码<dependency><br>      <groupId>org.springframework.boot</groupId><br>      <artifactId>spring-boot-devtools</artifactId><br></dependency><br>SpringBoot微服务中如何实现 session 共享 ?</p>
<p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p>
<p>您使用了哪些 starter maven 依赖项？</p>
<p>使用了下面的一些依赖项</p>
<p>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持<br>spring-boot-starter-data-jpa 数据库支持<br>spring-boot-starter-data-redis redis数据库支持<br>spring-boot-starter-data-solr solr支持<br>mybatis-spring-boot-starter 第三方的mybatis集成starter<br>自定义的starter(如果自己开发过就可以说出来)</p>
<p>Spring Boot 中的 starter 到底是什么 ?</p>
<p>首先，这个 Starter 并非什么新的技术点，basically还是基于 Spring 已有功能来实现的。首先它提供了一个automated配置类，一般命名为 XXXAutoConfiguration ，在这个配置类中通过条件注解来determine一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)injection将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</p>
<p>Spring Boot 中如何实现定时任务 ?</p>
<p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一-个则是使用第三方框架 Quartz。</p>
<p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p>
<p>spring-boot-starter-parent 有什么用 ?</p>
<p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<p>定义了 Java 编译版本为 1.8 。<br>使用 UTF-8 格式编码。<br>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。<br>执行打包操作的配置。<br>自动化的资源filtering。<br>自动化的插件配置。<br>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p>
<p>总结就是打包用的</p>
<p>SpringBoot如何实现打包</p>
<p>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包<br>或者点击左边选项栏中的Mavne，先点击clean在点击package</p>
<p>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</p>
<p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar command来运行，这种 jar 不可以作为普通的 jar 被其他项目relied，即使依赖了也无法使用其中的类。</p>
<p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>javaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PyQt5,pyinstaller开发跨平台小工具</title>
    <url>/2025/03/03/%E4%BD%BF%E7%94%A8PyQt5-pyinstaller%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>使用 <strong>PyQt5</strong> 进行 GUI 开发，并通过 <strong>PyInstaller</strong> 打包为可执行文件</p>
<span id="more"></span>

<h2 id="一、PyQt5-GUI-开发示例"><a href="#一、PyQt5-GUI-开发示例" class="headerlink" title="一、PyQt5 GUI 开发示例"></a><strong>一、PyQt5 GUI 开发示例</strong></h2><h3 id="1-安装-PyQt5"><a href="#1-安装-PyQt5" class="headerlink" title="1. 安装 PyQt5"></a><strong>1. 安装 PyQt5</strong></h3><p>首先，安装 PyQt5 ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pip install pyqt5</span><br></pre></td></tr></table></figure>

<h3 id="2-创建简单的-PyQt5-界面-这一部分建议chatgpt来写"><a href="#2-创建简单的-PyQt5-界面-这一部分建议chatgpt来写" class="headerlink" title="2. 创建简单的 PyQt5 界面(这一部分建议chatgpt来写)"></a><strong>2. 创建简单的 PyQt5 界面</strong>(这一部分建议chatgpt来写)</h3><p>假设我们开发一个简单的<strong>工资计算器</strong>，用户输入基本工资、绩效奖金后，点击按钮计算总工资。</p>
<h4 id="（1）使用-Qt-Designer-设计-UI"><a href="#（1）使用-Qt-Designer-设计-UI" class="headerlink" title="（1）使用 Qt Designer 设计 UI"></a><strong>（1）使用 Qt Designer 设计 UI</strong></h4><p>PyQt5 提供了一个可视化 UI 设计工具 <strong>Qt Designer</strong>，可以使用以下命令打开它（Windows）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pyqt5-tools designer</span><br></pre></td></tr></table></figure>

<p>在 Qt Designer 里：</p>
<ol>
<li>创建一个 <code>QWidget</code> 窗口。</li>
<li>添加 <code>QLineEdit</code> 用于输入基本工资和绩效奖金。</li>
<li>添加 <code>QPushButton</code> 按钮用于计算工资。</li>
<li>添加 <code>QLabel</code> 显示计算结果。</li>
<li>保存 UI 文件，如 <code>salary_calculator.ui</code>。</li>
</ol>
<h4 id="（2）转换-ui-文件为-Python-代码"><a href="#（2）转换-ui-文件为-Python-代码" class="headerlink" title="（2）转换 .ui 文件为 Python 代码"></a><strong>（2）转换 <code>.ui</code> 文件为 Python 代码</strong></h4><p>使用 <code>pyuic5</code> 将 UI 文件转换为 Python 代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pyuic5 -o ui_salary.py salary_calculator.ui</span><br></pre></td></tr></table></figure>

<h4 id="（3）编写主逻辑代码"><a href="#（3）编写主逻辑代码" class="headerlink" title="（3）编写主逻辑代码"></a><strong>（3）编写主逻辑代码</strong></h4><p>创建 <code>main.py</code>，并编写工资计算逻辑：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="keyword">from</span> ui_salary <span class="keyword">import</span> Ui_MainWindow  <span class="comment"># 导入转换后的 UI 代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalaryCalculator</span>(QMainWindow, Ui_MainWindow):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setupUi(self)</span><br><span class="line">        self.calculate_button.clicked.connect(self.calculate_salary)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_salary</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            base_salary = <span class="built_in">float</span>(self.base_salary_input.text())</span><br><span class="line">            bonus = <span class="built_in">float</span>(self.bonus_input.text())</span><br><span class="line">            total_salary = base_salary + bonus</span><br><span class="line">            self.result_label.setText(<span class="string">f&quot;总工资: <span class="subst">&#123;total_salary:<span class="number">.2</span>f&#125;</span> 元&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            self.result_label.setText(<span class="string">&quot;请输入有效数字！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv)</span><br><span class="line">    window = SalaryCalculator()</span><br><span class="line">    window.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>



<h2 id="二、使用-PyInstaller-进行打包"><a href="#二、使用-PyInstaller-进行打包" class="headerlink" title="二、使用 PyInstaller 进行打包"></a><strong>二、使用 PyInstaller 进行打包</strong></h2><h3 id="1-安装-PyInstaller"><a href="#1-安装-PyInstaller" class="headerlink" title="1. 安装 PyInstaller"></a><strong>1. 安装 PyInstaller</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line">复制编辑</span><br><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure>

<h3 id="2-生成可执行文件"><a href="#2-生成可执行文件" class="headerlink" title="2. 生成可执行文件"></a><strong>2. 生成可执行文件</strong></h3><p>在终端运行以下命令，将 <code>main.py</code> 打包成 Windows 可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash</span><br><span class="line"><span class="comment"># 指定配置文件settings.json</span></span><br><span class="line"><span class="comment"># win上打包：</span></span><br><span class="line">pyinstaller --onefile --add-data=settings.json;. -w main.py</span><br><span class="line"><span class="comment"># mac上打包：</span></span><br><span class="line">pyinstaller --onefile --add-data=settings.json:. -w main.py</span><br></pre></td></tr></table></figure>

<p><strong>打包成功后</strong>，Windows 用户会在 <code>dist</code> 目录下找到 <code>main.exe</code>，macOS 用户会得到 <code>.app</code> 应用包。</p>
<p>注意：<strong>打包要在目标平台进行</strong>：Windows 上打包 Windows 应用，macOS 上打包 macOS 应用。</p>
<h2 id="三、在win7上运行"><a href="#三、在win7上运行" class="headerlink" title="三、在win7上运行"></a><strong>三、在win7上运行</strong></h2><p>如果在win10上打包，因为pyinstaller默认会打包win10的api，故在win7上运行时会报错：计算机丢失 api-ms-win-core-path-l1-1-0.dll等。<br>所以必须使用pyinstaller在win7上打包，打包后的exe才能在win7上运行。<br>win10机器安装win7虚拟机并完成pyinstaller打包步骤：</p>
<ol>
<li>安装vmware（17.0.2之后版本个人使用免费）,假如win10在1909版本之前的本系统，安装vmware前需要同时处理<a href="blog.csdn.net/dling8/article/details/106809555">Hyper-V</a>和Virtualization-Based Security的兼容性问题（可使用下文脚本）。</li>
<li>安装win7（MSDN，i tell you）</li>
<li>安装python3.8.10（最后支持win7的python）<br> + 可能报错缺少service pack，安装<a href="https://catalog.update.microsoft.com/Search.aspx?q=KB976932">KB976932</a> 和 <a href="(down.kkxxiazai.com/small/KB2533623.zip)">KB2533623</a> 补丁<br> + 参考：<a href="https://www.cnblogs.com/ryuma/p/14863346.html">教程</a></li>
<li>假如要用cryptography，请使用38.0.4版本</li>
</ol>
<h2 id="三、解决单一实例限制"><a href="#三、解决单一实例限制" class="headerlink" title="三、解决单一实例限制"></a><strong>三、解决单一实例限制</strong></h2><p>用户多次点击 PyInstaller 打包生成的 .exe 文件时，程序会启动多个实例（多开），而你希望无论点击多少次，都只运行一个应用界面（单一实例）。这在 GUI 应用程序中是常见需求，称为单一实例限制。</p>
<blockquote>
<p>问题分析<br>PyInstaller 打包的 .exe 行为：每次点击 .exe 文件，PyInstaller 默认会启动一个新的进程，导致多个独立的应用实例运行。<br>PyQt5 的特点：PyQt5 本身不会自动限制单一实例，需要手动实现进程间通信（IPC）或锁机制来确保只有一个实例运行。<br>你的代码：当前的 main.py 没有实现单一实例检查，因此每次点击 .exe 都会启动新的进程和窗口。</p>
</blockquote>
<h3 id="解决办法：使用本地-socket-进行-IPC（更灵活）"><a href="#解决办法：使用本地-socket-进行-IPC（更灵活）" class="headerlink" title="解决办法：使用本地 socket 进行 IPC（更灵活）"></a>解决办法：使用本地 socket 进行 IPC（更灵活）</h3><p>通过本地 socket 实现进程间通信（IPC）。当新实例启动时，它会尝试连接到一个已知的 socket 端口。如果连接成功，说明已有实例运行，新实例可以发送消息激活已有窗口并退出</p>
<p>以下是一个基于 QLocalSocket 和 QLocalServer 的实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow, QMessageBox</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtNetwork <span class="keyword">import</span> QLocalServer, QLocalSocket</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QMainWindow</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;Single Instance App&quot;</span>)</span><br><span class="line">        self.setGeometry(<span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">        self.server = <span class="literal">None</span></span><br><span class="line">        self.start_server()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start_server</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Start local server to enforce single instance.&quot;&quot;&quot;</span></span><br><span class="line">        self.server = QLocalServer()</span><br><span class="line">        server_name = <span class="string">&quot;SingleInstanceApp&quot;</span></span><br><span class="line">        QLocalServer.removeServer(server_name)  <span class="comment"># Remove stale server</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.server.listen(server_name):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Server failed to start: <span class="subst">&#123;self.server.errorString()&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.server.newConnection.connect(self.handle_new_connection)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_new_connection</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Handle new client connection and activate window.&quot;&quot;&quot;</span></span><br><span class="line">        socket = self.server.nextPendingConnection()</span><br><span class="line">        <span class="keyword">if</span> socket:</span><br><span class="line">            socket.readyRead.connect(<span class="keyword">lambda</span>: self.activate_window(socket))</span><br><span class="line">            socket.disconnected.connect(socket.deleteLater)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">activate_window</span>(<span class="params">self, socket</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Activate the current window.&quot;&quot;&quot;</span></span><br><span class="line">        self.raise_()</span><br><span class="line">        self.activateWindow()</span><br><span class="line">        socket.disconnectFromServer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">closeEvent</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Clean up server on window close.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.server:</span><br><span class="line">            self.server.close()</span><br><span class="line">        event.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server_name = <span class="string">&quot;SingleInstanceApp&quot;</span></span><br><span class="line">    socket = QLocalSocket()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Try to connect to existing server</span></span><br><span class="line">    socket.connectToServer(server_name)</span><br><span class="line">    <span class="keyword">if</span> socket.waitForConnected(<span class="number">500</span>):</span><br><span class="line">        <span class="comment"># Existing instance found, activate it and exit</span></span><br><span class="line">        socket.write(<span class="string">b&quot;activate&quot;</span>)</span><br><span class="line">        socket.waitForBytesWritten(<span class="number">500</span>)</span><br><span class="line">        socket.disconnectFromServer()</span><br><span class="line">        QMessageBox.warning(<span class="literal">None</span>, <span class="string">&quot;Application Running&quot;</span>, <span class="string">&quot;The application is already running!&quot;</span>)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># No existing instance, start new one</span></span><br><span class="line">    app = QApplication.instance()</span><br><span class="line">    <span class="keyword">if</span> app <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        app = QApplication(sys.argv)</span><br><span class="line">    </span><br><span class="line">    window = MainWindow()</span><br><span class="line">    window.show()</span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure>
<p>说明</p>
<ul>
<li>QLocalServer 和 QLocalSocket：PyQt5 提供的跨平台 IPC 机制，用于进程间通信。</li>
<li>工作原理：<ul>
<li>第一个实例启动时，创建并监听一个本地 socket（PensionAppInstance）。</li>
<li>新实例启动时，尝试连接到该 socket。如果连接成功，说明已有实例运行，新实例发送“activate”消息并退出。</li>
<li>已有实例收到消息后，通过 raise_() 和 activateWindow() 将窗口置顶并激活。</li>
</ul>
</li>
<li>优势：不仅防止多开，还能激活已有窗口，提升用户体验。</li>
<li>清理：在窗口关闭时通过 closeEvent 清理服务器，确保下次启动时不会冲突。</li>
<li>PyInstaller 兼容性：此方法适用于 PyInstaller 打包的程序，无需额外依赖。</li>
</ul>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h5 id="关闭-Virtualization-Based-Security：以下代码写成bat文件，管理员权限运行即可"><a href="#关闭-Virtualization-Based-Security：以下代码写成bat文件，管理员权限运行即可" class="headerlink" title="关闭 Virtualization-Based Security：以下代码写成bat文件，管理员权限运行即可"></a>关闭 Virtualization-Based Security：以下代码写成bat文件，管理员权限运行即可</h5><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">echo</span> off</span><br><span class="line"></span><br><span class="line">dism <span class="string">/Online</span> <span class="string">/Disable-Feature</span><span class="function">:microsoft-hyper-v-all</span> <span class="string">/NoRestart</span></span><br><span class="line">dism <span class="string">/Online</span> <span class="string">/Disable-Feature</span><span class="function">:IsolatedUserMode</span> <span class="string">/NoRestart</span></span><br><span class="line">dism <span class="string">/Online</span> <span class="string">/Disable-Feature</span><span class="function">:Microsoft-Hyper-V-Hypervisor</span> <span class="string">/NoRestart</span></span><br><span class="line">dism <span class="string">/Online</span> <span class="string">/Disable-Feature</span><span class="function">:Microsoft-Hyper-V-Online</span> <span class="string">/NoRestart</span></span><br><span class="line">dism <span class="string">/Online</span> <span class="string">/Disable-Feature</span><span class="function">:HypervisorPlatform</span> <span class="string">/NoRestart</span></span><br><span class="line"></span><br><span class="line">REM ===========================================</span><br><span class="line"></span><br><span class="line">mountvol X: <span class="string">/s</span></span><br><span class="line">copy %WINDIR%\System32\SecConfig.efi X:\EFI\Microsoft\Boot\SecConfig.efi <span class="string">/Y</span></span><br><span class="line">bcdedit <span class="string">/create</span> &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; <span class="string">/d</span> <span class="string">&quot;DebugTool&quot;</span> <span class="string">/application</span> osloader</span><br><span class="line">bcdedit <span class="string">/set</span> &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; path <span class="string">&quot;\EFI\Microsoft\Boot\SecConfig.efi&quot;</span></span><br><span class="line">bcdedit <span class="string">/set</span> &#123;bootmgr&#125; bootsequence &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125;</span><br><span class="line">bcdedit <span class="string">/set</span> &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; loadoptions DISABLE-LSA-ISO,DISABLE-VBS</span><br><span class="line">bcdedit <span class="string">/set</span> &#123;0cb3b571-2f2e-4343-a879-d86a476d7215&#125; device partition=X:</span><br><span class="line">mountvol X: <span class="string">/d</span></span><br><span class="line">bcdedit <span class="string">/set</span> hypervisorlaunchtype off</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span>.</span><br><span class="line"><span class="keyword">echo</span>.</span><br><span class="line"><span class="keyword">echo</span> =======================================================</span><br><span class="line"><span class="keyword">echo</span> 当前操作已完成，接下来请关闭此窗口并重启电脑，然后根据屏幕提示完成剩下操作。</span><br><span class="line">pause &gt; nul</span><br><span class="line"><span class="keyword">echo</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Operation</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>初接触金数报送知识点</title>
    <url>/2025/03/28/%E5%88%9D%E6%8E%A5%E8%A7%A6%E9%87%91%E6%95%B0%E6%8A%A5%E9%80%81%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="金数报送"><a href="#金数报送" class="headerlink" title="金数报送"></a>金数报送</h1><h2 id="一、初接触金融数据报送十条最关键的知识点"><a href="#一、初接触金融数据报送十条最关键的知识点" class="headerlink" title="一、初接触金融数据报送十条最关键的知识点"></a>一、初接触金融数据报送十条最关键的知识点</h2><hr>
<h3 id="1-报送方式"><a href="#1-报送方式" class="headerlink" title="1. 报送方式"></a>1. <strong>报送方式</strong></h3><p>金融数据报送通常<strong>通过客户端方式</strong>进行，涵盖逐笔明细数据和报表数据的采集。流程包括：</p>
<ul>
<li><strong>任务获取</strong>：从服务端同步待处理任务列表。</li>
<li><strong>文件关联</strong>：将本地打包好的文件与任务关联。</li>
<li><strong>校验</strong>：对文件进行格式和业务校验。</li>
<li><strong>提交</strong>：校验通过后提交数据。 熟悉客户端操作是顺利完成报送的基础。</li>
</ul>
<hr>
<span id="more"></span>



<h3 id="2-文件格式"><a href="#2-文件格式" class="headerlink" title="2. 文件格式"></a>2. <strong>文件格式</strong></h3><p>报送文件采用长文件名，分为：</p>
<ul>
<li><strong>头文件（I文件）</strong>：包含关键字代码等元信息。</li>
<li><strong>数据文件（J文件）</strong>：记录具体业务数据。 文件需压缩为.zip格式，文件名包含机构代码（如统一社会信用代码）、日期、报表编号等，确保唯一性和可追溯性。例如：BI91100000100003962T2020033120201.zip。</li>
</ul>
<hr>
<h3 id="3-数据类型与格式"><a href="#3-数据类型与格式" class="headerlink" title="3. 数据类型与格式"></a>3. <strong>数据类型与格式</strong></h3><p>数据项分为多种类型，每种类型有严格的格式要求：</p>
<ul>
<li><strong>字符型（C）</strong>：如机构名称，长度固定。</li>
<li><strong>日期型（D）</strong>：采用YYYY-MM-DD格式，如2023-12-29。</li>
<li><strong>数值型（N）</strong>：如金额，需注意小数位数（如保留两位小数）和单位。 填写时必须严格遵循格式规范，避免校验失败。</li>
</ul>
<hr>
<h3 id="4-业务范围（详见第三章）"><a href="#4-业务范围（详见第三章）" class="headerlink" title="4. 业务范围（详见第三章）"></a>4. <strong>业务范围</strong>（详见第三章）</h3><p>报送数据覆盖广泛的金融业务领域，包括：</p>
<ul>
<li>同业业务</li>
<li>表内贷款</li>
<li>担保</li>
<li>委托贷款</li>
<li>存款</li>
<li>债券投资与发行</li>
<li>股权及特定目的载体投资</li>
<li>票据业务</li>
<li>收款业务<br>了解各业务的基本概念和报送要求是准确填报的前提。</li>
</ul>
<hr>
<h3 id="5-参考主体信息"><a href="#5-参考主体信息" class="headerlink" title="5. 参考主体信息"></a>5. <strong>参考主体信息</strong></h3><p>报送时需提供机构和客户的基本信息，例如：</p>
<ul>
<li><strong>统一社会信用代码</strong>：18位，用于标识报送机构。</li>
<li><strong>机构名称</strong>、<strong>客户类型</strong>等。<br>这些信息确保数据的准确性和完整性，是校验的重要依据。</li>
</ul>
<hr>
<h3 id="6-报送频率"><a href="#6-报送频率" class="headerlink" title="6. 报送频率"></a>6. <strong>报送频率</strong></h3><p>不同数据和报表的报送周期不同：</p>
<ul>
<li><strong>月报</strong>：月末提交。</li>
<li><strong>季报</strong>：季末提交，如XXXX0331表示3月31日。 掌握报送时间节点，避免延误提交。</li>
</ul>
<hr>
<h3 id="7-数据校验"><a href="#7-数据校验" class="headerlink" title="7. 数据校验"></a>7. <strong>数据校验</strong></h3><p>提交前需进行两类校验：</p>
<ul>
<li><strong>格式校验</strong>：检查文件格式、命名规范等。</li>
<li><strong>基础业务校验</strong>：验证数据逻辑合理性。<br>若校验不通过，可修改数据后重新提交，或附上说明文件强制提交。</li>
</ul>
<hr>
<h3 id="8-报表结构"><a href="#8-报表结构" class="headerlink" title="8. 报表结构"></a>8. <strong>报表结构</strong></h3><p>报表采用固定表样，例如：</p>
<ul>
<li><strong>金融机构基本情况统计表（20201）</strong>：记录机构名称、注册地等。</li>
<li><strong>资产负债及损益表（20202）</strong>：记录存款、贷款等金额。</li>
<li><strong>利润及资本表（20203）</strong>：记录收入、支出等。<br>每张表有独特的指标代码和名称，需准确对应填写。</li>
</ul>
<hr>
<h3 id="9-金额单位"><a href="#9-金额单位" class="headerlink" title="9. 金额单位"></a>9. <strong>金额单位</strong></h3><p>金额数据通常以人民币元为单位：</p>
<ul>
<li><strong>保留两位小数</strong>：如123.45。</li>
<li><strong>例外情况</strong>：从业人员数等数量指标以人为单位，填写整数。<br>注意单位一致性，避免填写错误。</li>
</ul>
<hr>
<h3 id="10-异常情况处理"><a href="#10-异常情况处理" class="headerlink" title="10. 异常情况处理"></a>10. <strong>异常情况处理</strong></h3><p>报送中可能遇到异常，处理方法包括：</p>
<ul>
<li><strong>上传中断</strong>：重新选择文件继续上传。</li>
<li><strong>任务被打回</strong>：根据打回原因修改文件，或填写强制提交理由并附说明文件。</li>
<li><strong>强制提交</strong>：需经审核人员同意。<br>熟悉异常处理流程能确保报送工作不中断。</li>
</ul>
<hr>
<p>掌握这十条知识点，你将能够快速熟悉金融数据报送的基本流程和要求，提高工作效率，确保数据的准确性和及时性。建议在实际操作中结合客户端系统的具体指引，逐步熟练掌握每一步骤。</p>
<h2 id="二、开发人员做金融数据报送十条最关键的知识点"><a href="#二、开发人员做金融数据报送十条最关键的知识点" class="headerlink" title="二、开发人员做金融数据报送十条最关键的知识点"></a>二、开发人员做金融数据报送十条最关键的知识点</h2><p>作为一个刚接触金融数据报送的开发技术人员，你需要快速掌握金融基础数据报送系统的核心技术知识，以理解系统的运作方式并有效参与开发与维护工作。以下是针对你的角色总结的十条最关键的知识点，帮助你快速上手：</p>
<hr>
<h3 id="1-系统架构的基本构成"><a href="#1-系统架构的基本构成" class="headerlink" title="1. 系统架构的基本构成"></a>1. <strong>系统架构的基本构成</strong></h3><ul>
<li>系统采用<strong>客户端-服务器模式</strong>：客户端负责数据准备、校验和提交，服务器端负责接收、校验和存储数据。</li>
<li><strong>任务管理流程</strong>：客户端会从服务器同步任务列表，你需要将本地文件与任务关联后进行校验和提交。</li>
<li><strong>数据传输方式</strong>：数据以压缩文件（<code>.zip</code>）形式传输，包含头文件（<code>.idx</code>）和数据文件（<code>.dat</code>）。</li>
</ul>
<hr>
<h3 id="2-文件格式与命名规则"><a href="#2-文件格式与命名规则" class="headerlink" title="2. 文件格式与命名规则"></a>2. <strong>文件格式与命名规则</strong></h3><ul>
<li><strong>文件名构成</strong>：文件名通常包括机构代码、日期、报表编号等，例如<code>BI91100000100003962T2020033120201.zip</code>。</li>
<li><strong>文件类型</strong>：<ul>
<li><strong>头文件（I文件）</strong>：记录元信息，如<strong>关键字代码、表单代码</strong>等。</li>
<li><strong>数据文件（J文件）</strong>：<strong>存储业务数据，字段间用“|”分隔</strong>。</li>
</ul>
</li>
<li><strong>压缩要求</strong>：所有文件需压缩为<code>.zip</code>格式。</li>
</ul>
<hr>
<h3 id="3-数据校验的核心机制"><a href="#3-数据校验的核心机制" class="headerlink" title="3. 数据校验的核心机制"></a>3. <strong>数据校验的核心机制</strong></h3><ul>
<li><strong>客户端校验</strong>：包括文件格式检查和单表单条记录的业务逻辑校验。</li>
<li><strong>服务器端校验</strong>：除了格式和基础业务校验外，还包括跨表或跨记录的综合业务校验。</li>
<li><strong>异常处理</strong>：支持强制提交（需附说明文件），并能处理上传中断等问题。</li>
</ul>
<hr>
<h3 id="4-数据类型与格式规范"><a href="#4-数据类型与格式规范" class="headerlink" title="4. 数据类型与格式规范"></a>4. <strong>数据类型与格式规范</strong></h3><ul>
<li><strong>字符型（C）</strong>：如机构名称，通常为固定长度。</li>
<li><strong>日期型（D）</strong>：格式为<code>YYYY-MM-DD</code>，如<code>2023-12-31</code>。</li>
<li><strong>数值型（N）</strong>：如金额，需正确处理小数位和负数。</li>
<li>你需要确保系统中每个数据项的类型和长度符合规范。</li>
</ul>
<hr>
<h3 id="5-支持的业务数据范围（详见第三章）"><a href="#5-支持的业务数据范围（详见第三章）" class="headerlink" title="5. 支持的业务数据范围（详见第三章）"></a>5. <strong>支持的业务数据范围（详见第三章）</strong></h3><ul>
<li>系统需处理多种金融业务数据，包括：<ul>
<li>同业业务</li>
<li>表内贷款</li>
<li>存款</li>
<li>债券投资与发行</li>
<li>票据业务等</li>
</ul>
</li>
<li>开发时需确保每种业务对应的数据表和字段准确无误。</li>
</ul>
<hr>
<h3 id="6-参考主体信息的重要性"><a href="#6-参考主体信息的重要性" class="headerlink" title="6. 参考主体信息的重要性"></a>6. <strong>参考主体信息的重要性</strong></h3><ul>
<li><strong>机构信息</strong>：如统一社会信用代码、机构名称。</li>
<li><strong>客户信息</strong>：如客户类型、证件号码。</li>
<li>这些信息在多个表中作为关联字段，需保持一致性和完整性。</li>
</ul>
<hr>
<h3 id="7-报表结构与编码规则"><a href="#7-报表结构与编码规则" class="headerlink" title="7. 报表结构与编码规则"></a>7. <strong>报表结构与编码规则</strong></h3><ul>
<li><strong>报表编码</strong>：如<code>20201</code>表示金融机构基本情况统计表。</li>
<li><strong>指标编码</strong>：如<code>20201001</code>表示金融机构名称。</li>
<li><strong>数据存储格式</strong>：在J文件中以<code>关键字代码|报表代码|数据值</code>的方式组织。</li>
</ul>
<hr>
<h3 id="8-数据报送的频率与周期"><a href="#8-数据报送的频率与周期" class="headerlink" title="8. 数据报送的频率与周期"></a>8. <strong>数据报送的频率与周期</strong></h3><ul>
<li><strong>报送周期</strong>：包括月报（月末数据）、季报（季末数据）等，日期格式为<code>YYYYMMDD</code>。</li>
<li>你需要在系统中处理不同周期的任务逻辑，确保按时完成数据报送。</li>
</ul>
<hr>
<h3 id="9-数据安全与权限管理"><a href="#9-数据安全与权限管理" class="headerlink" title="9. 数据安全与权限管理"></a>9. <strong>数据安全与权限管理</strong></h3><ul>
<li><strong>数据加密</strong>：传输过程中可能需要加密保护数据。</li>
<li><strong>权限控制</strong>：不同用户（报送人员、审核人员）有不同权限，需实现角色管理功能。</li>
<li><strong>审计日志</strong>：记录提交、校验等操作，便于问题追溯。</li>
</ul>
<hr>
<h3 id="10-系统集成与扩展性要求"><a href="#10-系统集成与扩展性要求" class="headerlink" title="10. 系统集成与扩展性要求"></a>10. <strong>系统集成与扩展性要求</strong></h3><ul>
<li><strong>接口开发</strong>：系统可能需要与金融机构内部系统对接以获取数据。</li>
<li><strong>扩展性设计</strong>：支持新增业务类型或报表，数据表结构需灵活调整。</li>
<li><strong>性能优化</strong>：面对大量数据报送，需优化处理和存储效率。</li>
</ul>
<hr>
<h3 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h3><p>以上十条知识点涵盖了金融数据报送系统的技术架构、数据处理流程和业务需求的关键内容。作为新手，建议你从<strong>系统架构</strong>和<strong>文件格式</strong>入手，逐步理解<strong>数据校验</strong>和<strong>业务数据范围</strong>，最后关注<strong>安全性和扩展性</strong>。在实际开发中，结合具体需求和团队指导，逐步熟悉系统功能，确保开发出的系统高效、稳定且符合金融业务要求。</p>
<h2 id="三、金融数据报送的业务范围解释"><a href="#三、金融数据报送的业务范围解释" class="headerlink" title="三、金融数据报送的业务范围解释"></a>三、金融数据报送的业务范围解释</h2><p>以下是对金融数据报送中业务范围的详细解释，包括每个业务的基本概念和报送要求。这些业务领域是金融机构日常运营的核心部分，报送数据时需确保准确性和及时性，以满足监管要求和风险管理需求。</p>
<hr>
<h3 id="1-同业业务"><a href="#1-同业业务" class="headerlink" title="1. 同业业务"></a>1. 同业业务</h3><ul>
<li><strong>基本概念</strong>：<br>同业业务是指金融机构之间进行的资金融通和业务合作，主要包括：<ul>
<li>同业拆借：短期资金借贷。  </li>
<li>同业存款：金融机构在其他金融机构存放的资金。  </li>
<li>同业借款：金融机构向其他金融机构借入的资金。</li>
</ul>
</li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>交易对手（金融机构名称或代码）  </li>
<li>交易金额  </li>
<li>交易日期  </li>
<li>利率  </li>
<li>交易类型（拆借、存款、借款等）<br>这些数据用于监控金融机构之间的资金流动和风险暴露。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-表内贷款"><a href="#2-表内贷款" class="headerlink" title="2. 表内贷款"></a>2. 表内贷款</h3><ul>
<li><p><strong>基本概念</strong>：<br>表内贷款是金融机构在资产负债表中记录的贷款业务，包括：  </p>
<ul>
<li>企业贷款：向企业提供的信贷。</li>
<li>个人贷款：如房贷、消费贷等。</li>
</ul>
</li>
<li><p><strong>报送要求</strong>：<br>报送时需提供：  </p>
<ul>
<li>贷款金额  </li>
<li>贷款期限  </li>
<li>利率  </li>
<li>借款人信息（企业或个人）  </li>
<li>贷款类型（流动资金贷款、固定资产贷款等）<br>这些数据反映金融机构的信贷规模、资产质量和风险管理水平。</li>
</ul>
</li>
<li><p>相对应的有<strong>表外贷款</strong>（不直接计入资产负债表，但仍涉及信贷风险），常见的表外贷款形式包括：</p>
<ol>
<li>贷款承诺（Loan Commitments）<br>这是银行承诺未来向客户提供贷款的协议，例如授信额度（credit lines）或备用信用证（standby letters of credit）。只有当客户真正使用贷款额度时，贷款才会转入表内资产。</li>
<li>信贷资产证券化（Loan Securitization）<br>银行可能会将贷款打包，出售给特殊目的实体（SPE&#x2F;SPV），并转换为资产支持证券（ABS），如住房按揭贷款支持证券（MBS）。由于贷款已被出售，不再出现在银行的资产负债表上，但银行仍可能保留部分风险，如担保或回购义务。</li>
<li>银团贷款（Syndicated Loans）<br>银行与其他金融机构共同提供大额贷款，部分贷款可能计入表外。</li>
<li>信用担保（Credit Guarantees）和贷款承兑<br>银行为企业或个人提供担保（如银行承兑汇票、信用证担保），但只有在客户违约时，银行才需承担支付责任并计入表内。</li>
<li>表外理财产品<br>例如银行通过理财子公司或信托计划发行的理财产品，其中部分资金投向贷款资产，但不计入银行表内。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-担保"><a href="#3-担保" class="headerlink" title="3. 担保"></a>3. 担保</h3><ul>
<li><strong>基本概念</strong>：<br>担保是为债务人提供信用支持的行为，确保债务履约。常见担保方式包括：  <ul>
<li>抵押：以不动产等资产作为担保。  </li>
<li>质押：以动产或权利作为担保。  </li>
<li>保证：由第三方承担连带责任。</li>
</ul>
</li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>担保方式（抵押、质押、保证等）  </li>
<li>担保金额  </li>
<li>担保物信息（抵押物、质押物等）  </li>
<li>被担保债务信息<br>这些数据用于评估金融机构的风险缓释措施和信用风险。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-委托贷款"><a href="#4-委托贷款" class="headerlink" title="4. 委托贷款"></a>4. 委托贷款</h3><ul>
<li><strong>基本概念</strong>：<br>委托贷款是金融机构接受委托人的委托，向指定借款人发放的贷款。金融机构仅作为中介，不承担信用风险。  </li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>委托人信息  </li>
<li>借款人信息  </li>
<li>贷款金额  </li>
<li>利率  </li>
<li>贷款期限<br>这些数据反映金融机构的委托贷款业务规模和潜在风险。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-存款"><a href="#5-存款" class="headerlink" title="5. 存款"></a>5. 存款</h3><ul>
<li><strong>基本概念</strong>：<br>存款是客户将资金存入金融机构的行为，主要包括：  <ul>
<li>活期存款：可随时支取。  </li>
<li>定期存款：有固定存期。</li>
</ul>
</li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>存款金额  </li>
<li>存款类型（活期、定期等）  </li>
<li>存款人信息（个人或企业）  </li>
<li>存款期限（定期存款）<br>这些数据反映金融机构的资金来源和流动性状况。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-债券投资与发行"><a href="#6-债券投资与发行" class="headerlink" title="6. 债券投资与发行"></a>6. 债券投资与发行</h3><ul>
<li><strong>基本概念</strong>：  <ul>
<li>债券投资：金融机构购买其他机构发行的债券。  </li>
<li>债券发行：金融机构发行债券以筹集资金。</li>
</ul>
</li>
<li><strong>报送要求</strong>：  <ul>
<li><strong>债券投资</strong>：  <ul>
<li>债券类型（国债、金融债等）  </li>
<li>发行人  </li>
<li>投资金额  </li>
<li>利率</li>
</ul>
</li>
<li><strong>债券发行</strong>：  <ul>
<li>债券类型  </li>
<li>发行金额  </li>
<li>利率  </li>
<li>发行日期<br>这些数据反映金融机构在债券市场的投资和融资活动。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-股权及特定目的载体投资"><a href="#7-股权及特定目的载体投资" class="headerlink" title="7. 股权及特定目的载体投资"></a>7. 股权及特定目的载体投资</h3><ul>
<li><strong>基本概念</strong>：  <ul>
<li>股权投资：金融机构购买其他企业的股权，成为股东。  </li>
<li>特定目的载体（SPE）投资：投资于为特定目的（如资产证券化）设立的实体。</li>
</ul>
</li>
<li><strong>报送要求</strong>：  <ul>
<li><strong>股权投资</strong>：  <ul>
<li>被投资企业信息  </li>
<li>投资金额  </li>
<li>持股比例</li>
</ul>
</li>
<li><strong>SPE投资</strong>：  <ul>
<li>SPE信息  </li>
<li>投资金额  </li>
<li>投资目的<br>这些数据反映金融机构的股权投资和资产证券化活动。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-票据业务"><a href="#8-票据业务" class="headerlink" title="8. 票据业务"></a>8. 票据业务</h3><ul>
<li><strong>基本概念</strong>：<br>票据业务涉及票据的承兑、贴现和转贴现等，主要包括：  <ul>
<li>票据承兑：金融机构承诺在票据到期时支付款项。  </li>
<li>票据贴现：金融机构购买未到期票据，提供资金。  </li>
<li>票据转贴现：金融机构将持有的票据卖给其他金融机构。</li>
</ul>
</li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>票据类型（商业汇票、银行承兑汇票等）  </li>
<li>票据金额  </li>
<li>承兑人  </li>
<li>贴现率  </li>
<li>交易日期<br>这些数据反映金融机构的票据市场活动和流动性管理。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-收款业务"><a href="#9-收款业务" class="headerlink" title="9. 收款业务"></a>9. 收款业务</h3><ul>
<li><strong>基本概念</strong>：<br>收款业务是金融机构为客户提供的收款服务，包括：  <ul>
<li>代收款项：如水电费代收。  </li>
<li>结算服务：如跨行转账、清算等。</li>
</ul>
</li>
<li><strong>报送要求</strong>：<br>报送时需提供：  <ul>
<li>收款金额  </li>
<li>收款方式（代收、结算等）  </li>
<li>客户信息  </li>
<li>交易日期<br>这些数据反映金融机构的支付结算业务规模和客户服务水平。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上业务领域的报送数据是金融机构日常运营和风险管理的重要组成部分。报送时，需确保数据的准确性、完整性和及时性，以满足监管要求和内部管理需求。每个业务的数据报送要求略有不同，但都围绕业务的核心要素展开，开发人员在设计系统时应充分考虑这些要求，确保系统能够高效、准确地处理和报送相关数据。</p>
<h2 id="四、报送数据示例"><a href="#四、报送数据示例" class="headerlink" title="四、报送数据示例"></a>四、报送数据示例</h2><p>以下是一个简短的报送数据示例，基于表内贷款业务，包含头文件和数据文件的内容，符合常见的金融数据报送格式要求。</p>
<hr>
<h3 id="1-头文件（-idx）内容"><a href="#1-头文件（-idx）内容" class="headerlink" title="1. 头文件（.idx）内容"></a>1. <strong>头文件（.idx）内容</strong></h3><p>头文件记录了数据项的元信息，每个字段用“|”分隔，包含关键字代码、表单代码、数据类型、数据长度、单位等。</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line"><span class="number">000001</span>|<span class="type">20203</span>|<span class="type">N</span>|<span class="type">10</span>|<span class="type">1</span>|<span class="type">1</span>|<span class="type">1</span>|<span class="type">91100000100003962T</span></span><br><span class="line"><span class="number">000002</span>|<span class="type">20203</span>|<span class="type">N</span>|<span class="type">2</span>|<span class="type">2</span>|<span class="type">1</span>|<span class="type">1</span>|<span class="type">91100000100003962T</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字段说明</strong>：<ul>
<li><code>000001|20203|N|10|1|1|1|91100000100003962T</code>：表示贷款金额，数值型（N），长度10，单位为元（1），统一社会信用代码为“91100000100003962T”。</li>
<li><code>000002|20203|N|2|2|1|1|91100000100003962T</code>：表示贷款期限，数值型（N），长度2，单位为月（2）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-数据文件（-dat）内容"><a href="#2-数据文件（-dat）内容" class="headerlink" title="2. 数据文件（.dat）内容"></a>2. <strong>数据文件（.dat）内容</strong></h3><p>数据文件记录了具体的业务数据，字段同样用“|”分隔。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">000001</span>|<span class="number">20203</span>|<span class="number">100000</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">000002</span>|<span class="number">20203</span>|<span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>字段说明</strong>：<ul>
<li><code>000001|20203|100000.00</code>：贷款金额为100000.00元。</li>
<li><code>000002|20203|12</code>：贷款期限为12个月。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-文件命名"><a href="#3-文件命名" class="headerlink" title="3. 文件命名"></a>3. <strong>文件命名</strong></h3><ul>
<li><strong>头文件</strong>：<code>BI91100000100003962T2023123120203.idx</code></li>
<li><strong>数据文件</strong>：<code>BJ91100000100003962T2023123120203.dat</code></li>
<li><strong>压缩文件</strong>：将上述文件压缩为<code>BI91100000100003962T2023123120203.zip</code><ul>
<li>文件名中，“91100000100003962T”为统一社会信用代码，“20231231”为报送日期，“20203”为表单代码。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>此示例展示了表内贷款业务的报送数据，包括贷款金额和期限两项指标。头文件定义了数据的元信息，数据文件提供了具体数值，格式简洁且符合规范要求。</p>
]]></content>
      <categories>
        <category>Regulatory Compliance</category>
      </categories>
      <tags>
        <tag>finance</tag>
      </tags>
  </entry>
  <entry>
    <title>nocobase部署笔记</title>
    <url>/2025/04/17/nocobase%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>我用docker运行了nocobase，并配置了系统，现在我想将该修改后的系统通过docker部署到云服务器上，是否需要打镜像？该如何操作？</p>
<span id="more"></span>

<p><strong>以下是ChatGPT的回答，其中方法二我已经验证可行。</strong></p>
<p>你已经在本地通过 Docker 运行并配置了 NocoBase，现在希望将<strong>当前的系统状态（包括配置、插件、数据等）迁移并部署到云服务器上</strong>，这可以通过以下两种方式实现：</p>
<hr>
<h2 id="✅-方法一：打包为镜像，部署到云服务器（适合可复制部署）"><a href="#✅-方法一：打包为镜像，部署到云服务器（适合可复制部署）" class="headerlink" title="✅ 方法一：打包为镜像，部署到云服务器（适合可复制部署）"></a>✅ 方法一：打包为镜像，部署到云服务器（适合可复制部署）</h2><h3 id="🧠-适合场景"><a href="#🧠-适合场景" class="headerlink" title="🧠 适合场景"></a>🧠 适合场景</h3><p>你希望将本地环境“打包”成一个镜像，在其他服务器上直接部署成一样的系统，且不会频繁变动。</p>
<h3 id="📦-步骤如下："><a href="#📦-步骤如下：" class="headerlink" title="📦 步骤如下："></a>📦 步骤如下：</h3><h4 id="1-找到你当前容器运行的数据挂载方式"><a href="#1-找到你当前容器运行的数据挂载方式" class="headerlink" title="1. 找到你当前容器运行的数据挂载方式"></a>1. 找到你当前容器运行的数据挂载方式</h4><p>你可能是用 <code>docker run</code> 或 <code>docker-compose</code> 启动的，需要确认数据是否保存在容器内部还是挂载到本地卷中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;你的容器名或ID&gt;</span><br></pre></td></tr></table></figure>

<p>查看 <code>Mounts</code> 部分，如果是本地挂载的目录（bind mount 或 volume），则需要把这些数据一起打包。</p>
<hr>
<h4 id="2-提取当前容器状态并打包为镜像"><a href="#2-提取当前容器状态并打包为镜像" class="headerlink" title="2. 提取当前容器状态并打包为镜像"></a>2. 提取当前容器状态并打包为镜像</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit &lt;正在运行的容器ID&gt; my-nocobase-image:v1</span><br></pre></td></tr></table></figure>

<p>这个命令会把当前容器的文件系统“快照”成一个新的镜像。</p>
<hr>
<h4 id="3-将镜像保存为文件（可传输）"><a href="#3-将镜像保存为文件（可传输）" class="headerlink" title="3. 将镜像保存为文件（可传输）"></a>3. 将镜像保存为文件（可传输）</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o my-nocobase-image.tar my-nocobase-image:v1</span><br></pre></td></tr></table></figure>

<p>把 <code>my-nocobase-image.tar</code> 拷贝（用 scp 或 rsync）到你的云服务器。</p>
<hr>
<h4 id="4-在云服务器导入并运行"><a href="#4-在云服务器导入并运行" class="headerlink" title="4. 在云服务器导入并运行"></a>4. 在云服务器导入并运行</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i my-nocobase-image.tar</span><br><span class="line">docker run -d -p 8000:80 my-nocobase-image:v1</span><br></pre></td></tr></table></figure>

<p>根据你的配置调整端口、挂载路径或环境变量。</p>
<hr>
<h2 id="✅-方法二：打包数据-配置，使用官方镜像重建（适合持续更新）"><a href="#✅-方法二：打包数据-配置，使用官方镜像重建（适合持续更新）" class="headerlink" title="✅ 方法二：打包数据+配置，使用官方镜像重建（适合持续更新）"></a>✅ 方法二：打包数据+配置，使用官方镜像重建（适合持续更新）</h2><h3 id="🧠-适合场景-1"><a href="#🧠-适合场景-1" class="headerlink" title="🧠 适合场景"></a>🧠 适合场景</h3><p>你使用的是官方 NocoBase 镜像，只是更改了配置（比如添加插件、修改数据等），不希望打包镜像，只想备份数据并迁移。</p>
<hr>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h4 id="前提："><a href="#前提：" class="headerlink" title="前提："></a>前提：</h4><ol>
<li><p>该项目有两个容器，镜像为：nocobase和mysql。故，项目迁移到云服务器时，需要同时迁移 <strong>应用镜像 + 数据库数据</strong>，推荐备份数据+docker compose部署。</p>
</li>
<li><p>执行docker inspect container-name后，发现Mounts中使用了bind 挂载。故，NocoBase 项目中有一部分关键数据（如上传文件、缓存、插件存储等）<strong>存放在本地挂载目录中</strong>，并不会包含在 <code>docker commit</code> 镜像中。</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bind&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Users/colinlee/Documents/software/xc_project/storage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/app/nocobase/storage&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Mode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rw&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;RW&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Propagation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;rprivate&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>本地目录：&#x2F;Users&#x2F;colinlee&#x2F;Documents&#x2F;software&#x2F;xc_project&#x2F;storage</p>
<p>容器内路径：&#x2F;app&#x2F;nocobase&#x2F;storage</p>
<h4 id="本地需要的文件"><a href="#本地需要的文件" class="headerlink" title="本地需要的文件"></a>本地需要的文件</h4><ol>
<li>docker-compose.yml</li>
<li>mysql_backup.sql</li>
<li>storage&#x2F;文件夹</li>
</ol>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><ol>
<li><strong>备份数据库</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i mysql-1 mysqldump -uroot -p<span class="string">&#x27;yourpassword&#x27;</span> --all-databases &gt; mysql_backup.sql</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>复制本地挂载目录</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /Users/colinlee/Documents/software/xc_project/storage .</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>上传所有文件到云服务器</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r docker-compose.yml mysql_backup.sql storage/ user@your-server-ip:/home/user/nocobase-deploy/</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>在云服务器运行容器</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/user/nocobase-deploy/</span><br><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>还原 MySQL 数据库</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i mysql-1 mysql -uroot -p<span class="string">&#x27;yourpassword&#x27;</span> &lt; mysql_backup.sql</span><br></pre></td></tr></table></figure>



<h4 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nocobase:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">XXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">XXXXXXXXXXXXXXXXX</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_KEY=XXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DIALECT=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DATABASE=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASSWORD=XXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_UNDERSCORED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NOCOBASE_PKG_USERNAME=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NOCOBASE_PKG_PASSWORD=</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./storage:/app/nocobase/storage</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;13000:80&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>








<hr>
<h2 id="✅-总结对比"><a href="#✅-总结对比" class="headerlink" title="✅ 总结对比"></a>✅ 总结对比</h2><table>
<thead>
<tr>
<th>方式</th>
<th>是否打镜像</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>方法一：打包镜像</td>
<td>✅</td>
<td>简单快速、完全保留现场</td>
<td>镜像大，不便频繁更新</td>
</tr>
<tr>
<td>方法二：迁移数据</td>
<td>❌</td>
<td>更灵活、便于版本管理</td>
<td>需要理解 NocoBase 的数据存储结构</td>
</tr>
</tbody></table>
<hr>
<p>你可以根据实际需要选择方式。如果你是初次部署，<strong>推荐用方法二（数据迁移+官方镜像）</strong>，更便于未来维护。如果你已经本地装了很多插件、改了很多文件，不方便复现，就选方法一。</p>
<hr>
<h2 id="CentOS上安装docker"><a href="#CentOS上安装docker" class="headerlink" title="CentOS上安装docker"></a>CentOS上安装docker</h2><h2 id="官方仓库安装"><a href="#官方仓库安装" class="headerlink" title="官方仓库安装"></a>官方仓库安装</h2><p>在 CentOS 上安装 Docker 的步骤如下：</p>
<ol>
<li><p><strong>更新系统</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update -y</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装必要的依赖</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加 Docker 仓库</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装 Docker</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动并启用 Docker 服务</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>验证安装</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>（可选）允许非 root 用户运行 Docker</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<p>注销并重新登录以应用权限。</p>
</li>
</ol>
<h3 id="2-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘appstream’"><a href="#2-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘appstream’" class="headerlink" title="2. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘appstream’"></a>2. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘appstream’</h3><p>表明无法解析 mirrorlist.centos.org，可能是网络问题或 CentOS 8 仓库已停止维护，可以使用<strong>阿里云镜像</strong></p>
<ul>
<li>备份仓库配置：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv /etc/yum.repos.d/CentOS-Linux-AppStream.repo /etc/yum.repos.d/CentOS-Linux-AppStream.repo.bak</span><br></pre></td></tr></table></figure>

<ul>
<li>创建新的 AppStream 仓库文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/yum.repos.d/CentOS-Linux-AppStream.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>添加：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[appstream] </span><br><span class="line">name=CentOS-8 - AppStream </span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos/8/AppStream/x86_64/os/ </span><br><span class="line">gpgcheck=1 </span><br><span class="line">enabled=1 </span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-8</span><br></pre></td></tr></table></figure>

<ul>
<li>清理并更新缓存：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum clean all </span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure>

<h3 id="2-1-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘baseos’"><a href="#2-1-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘baseos’" class="headerlink" title="2-1. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘baseos’:"></a>2-1. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘baseos’:</h3><p>报错显示 baseos 仓库仍然尝试访问已停止维护的 mirrorlist.centos.org，导致无法下载元数据。AppStream 仓库已成功切换，但 BaseOS 仓库仍需修复。可以使用<strong>阿里云镜像</strong>。</p>
<ul>
<li><p>备份现有 BaseOS 仓库配置：</p>
<p><code>sudo mv /etc/yum.repos.d/CentOS-Linux-BaseOS.repo /etc/yum.repos.d/CentOS-Linux-BaseOS.repo.bak</code></p>
</li>
<li><p>创建新的 BaseOS 仓库文件：</p>
<p><code>sudo vi /etc/yum.repos.d/CentOS-Linux-BaseOS.repo</code></p>
<p>添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[baseos]</span><br><span class="line">name=CentOS-8 - BaseOS</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos/8/BaseOS/x86_64/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理并更新缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum clean all </span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-2-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘extras’"><a href="#2-2-安装必要的依赖时可能遇到报错：Error-Failed-to-download-metadata-for-repo-‘extras’" class="headerlink" title="2-2. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘extras’:"></a>2-2. 安装必要的依赖时可能遇到报错：Error: Failed to download metadata for repo ‘extras’:</h3><p>报错表明 BaseOS 和 AppStream 仓库已成功切换到阿里云镜像，但 extras 仓库仍然指向已停止维护的 mirrorlist.centos.org，导致元数据下载失败。需要更新 extras 仓库的配置。可以使用<strong>阿里云镜像</strong>。</p>
<ul>
<li><p>备份现有 BaseOS 仓库配置：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo mv <span class="regexp">/etc/yum</span>.repos.d<span class="regexp">/CentOS-Linux-Extras.repo /</span>etc<span class="regexp">/yum.repos.d/</span>CentOS-Linux-Extras.repo.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的 BaseOS 仓库文件：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo vi <span class="regexp">/etc/yum</span>.repos.d/CentOS-Linux-Extras.repo</span><br></pre></td></tr></table></figure>

<p>添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[extras]</span><br><span class="line">name=CentOS-8 - Extras</span><br><span class="line">baseurl=http://mirrors.aliyun.com/centos/8/extras/x86_64/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/centos/RPM-GPG-KEY-CentOS-8</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理并更新缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum clean all </span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-重试安装命令"><a href="#3-重试安装命令" class="headerlink" title="3. 重试安装命令"></a>3. <strong>重试安装命令</strong></h3><p>修复仓库后，重新运行以下命令，也可以回到第二步骤：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h3 id="4-后续安装-Docker"><a href="#4-后续安装-Docker" class="headerlink" title="4. 后续安装 Docker"></a>4. <strong>后续安装 Docker</strong></h3><p>如果以上步骤成功，继续安装 Docker：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo systemctl start docker</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<h3 id="5-更换-Docker-镜像源"><a href="#5-更换-Docker-镜像源" class="headerlink" title="5. 更换 Docker 镜像源"></a>5. 更换 Docker 镜像源</h3><p>   如果 Docker Hub 访问受限（例如在中国大陆可能因网络限制导致），可以配置国内镜像源（如阿里云、华为云）加速拉取镜像。</p>
<ul>
<li>配置阿里云镜像源</li>
</ul>
<ul>
<li><p>编辑 Docker 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker sudo vi /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加以下内容（替换your-aliyun-id为你的阿里云账号 ID 或使用公共镜像地址）</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry.cn-hangzhou.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>保存后重启 Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证镜像源是否生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info --format <span class="string">&#x27;&#123;&#123;.RegistryConfig.Mirrors&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试镜像拉取,重新运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose down &amp;&amp; docker compose up -d</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-其他常见docker命令"><a href="#6-其他常见docker命令" class="headerlink" title="6. 其他常见docker命令"></a>6. 其他常见docker命令</h3><h4 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h4><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">docker ps - 列出 Docker 容器</span><br><span class="line">docker <span class="keyword">inspect</span> - 获取 Docker 对象（容器、镜像、卷、网络等）的详细信息。</span><br></pre></td></tr></table></figure>
<h4 id="本地镜像管理"><a href="#本地镜像管理" class="headerlink" title="本地镜像管理"></a>本地镜像管理</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">docker images - 列出本地的 Docker 镜像。</span><br><span class="line">docker build - 从 Dockerfile 构建 Docker 镜像。</span><br><span class="line">docker <span class="keyword">save</span> - 将一个或多个 Docker 镜像保存到一个 tar 归档文件中。</span><br><span class="line">docker <span class="keyword">load</span> - 从由 docker <span class="keyword">save</span> 命令生成的 tar 文件中加载 Docker 镜像。</span><br></pre></td></tr></table></figure>

<h4 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h4><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">docker compose build - 构建 docker compose 文件。</span><br><span class="line">docker compose <span class="keyword">up</span> - 运行 docker compose 文件。</span><br><span class="line">docker compose <span class="keyword">ls</span> - 列出 docker compose 服务。</span><br></pre></td></tr></table></figure>
<h4 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network <span class="built_in">ls</span>: 列出所有网络。</span><br></pre></td></tr></table></figure>
<h4 id="卷命令"><a href="#卷命令" class="headerlink" title="卷命令"></a>卷命令</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> <span class="built_in">ls</span>: 列出所有卷。</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nocobase</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>在无法联网的生产环境部署nocobase</title>
    <url>/2025/04/22/%E5%9C%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2nocobase/</url>
    <content><![CDATA[<p>由于生产环境不连接外网，您需要在联网的本地环境中提前准备好所有必要的Docker镜像、数据文件和配置文件，并通过U盘等方式传输到生产环境。根据服务器是否已安装Docker，部署步骤会有所不同。以下是完整的操作指南。</p>
<span id="more"></span>

<h4 id="前提说明："><a href="#前提说明：" class="headerlink" title="前提说明："></a>前提说明：</h4><blockquote>
<p>我用Docker运行了NocoBase，并配置了系统，现在想将该修改后的系统通过Docker部署到云服务器上。已知该项目有三个容器，镜像为：官方NocoBase、MySQL和运行了Flask的服务。</p>
<p>同时通过查看docker inspect，发现Mounts中使用了bind挂载，有一部分关键数据（如上传文件、缓存、插件存储等）存放在本地挂载目录中。我已经成功部署到测试用云服务器上，但现在需要将系统部署到不连接外网的生产环境，需要使用U盘拷贝等方式完成部署。请问如何按照“打包为镜像，部署到云服务器”的方法进行部署，要拷贝哪些东西，并分情况告诉我具体的部署实施步骤，情况1: Linux服务器已安装好了Docker；情况2: Linux服务器没有安装Docker。</p>
</blockquote>
<p>文件层级为：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">app</span></span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── flask_service</span><br><span class="line">      ├── <span class="keyword">app</span>.py</span><br><span class="line">      ├── Dockerfile</span><br><span class="line">      └── requirements.txt</span><br><span class="line">└──  storage</span><br><span class="line">       ├── apps</span><br><span class="line">       ├── <span class="keyword">db</span></span><br><span class="line">       ├── nocobase.<span class="keyword">conf</span></span><br><span class="line">       ├── plugins</span><br><span class="line">       └── uploads</span><br></pre></td></tr></table></figure>

<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>由于生产环境不连接外网，您需要在联网的本地环境中提前准备好所有必要的Docker镜像、数据文件和配置文件，并通过U盘等方式传输到生产环境。根据服务器是否已安装Docker，部署步骤会有所不同。以下是完整的操作指南。</p>
<hr>
<h4 id="准备工作（在本地联网环境）"><a href="#准备工作（在本地联网环境）" class="headerlink" title="准备工作（在本地联网环境）"></a>准备工作（在本地联网环境）</h4><p>为了确保生产环境能够完整运行NocoBase系统，您需要准备以下内容：</p>
<ol>
<li><p><strong>保存Docker镜像</strong></p>
<ul>
<li><p><strong>NocoBase镜像</strong>：假设使用的是官方镜像 <code>registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span><br><span class="line">docker save -o nocobase.tar registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MySQL镜像</strong>：假设使用的是 <code>mysql:8.0</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:8.0</span><br><span class="line">docker save -o mysql.tar mysql:8.0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Flask服务镜像</strong>：假设您已构建了一个自定义的Flask服务镜像 <code>flask-service</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> flask_service  <span class="comment"># 进入Flask服务的项目目录</span></span><br><span class="line">docker build -t flask-service .  <span class="comment"># 构建镜像</span></span><br><span class="line">docker save -o flask-service.tar flask-service  <span class="comment"># 保存镜像</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>备份MySQL数据库</strong></p>
<ul>
<li><p>进入运行中的MySQL容器，备份数据库（假设数据库名为 <code>nocobase</code>，用户为 <code>root</code>，密码为 <code>XXX</code>）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql mysqldump -u root -pXXX nocobase &gt; nocobase_backup.sql</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>打包本地挂载目录</strong></p>
<ul>
<li><p>根据<code>docker inspect</code>的结果，关键数据存储在本地挂载目录 <code>./storage</code> 中（包括上传文件、缓存、插件存储等）。将该目录压缩：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -czvf storage.tar.gz ./storage</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>准备docker-compose.yml</strong></p>
<ul>
<li>复制您当前使用的 <code>docker-compose.yml</code> 文件，确保其中定义了NocoBase、MySQL和Flask服务及其挂载卷配置。稍后在云服务器上需要调整路径。</li>
</ul>
</li>
<li><p><strong>（仅情况2）下载Docker和docker-compose安装包</strong></p>
<ul>
<li>如果生产服务器未安装Docker，需下载以下安装包：<ul>
<li><p>Docker安装包：例如 <code>docker-ce_xxx.deb</code>（适用于Debian&#x2F;Ubuntu系统，可从Docker官网下载）。</p>
<blockquote>
<p>针对rhel7.9，离线安装docker需要9个rpm文件(建议全装，更保险)</p>
<p><a href="https://tsn.miraclelinux.com/system/files/AXS7/x86_64/UPDATE/RPMS/container-selinux-2.119.2-1.911c772.el7.noarch.rpm">container-selinux-2.119.2-1.911c772.el7.noarch.rpm</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/containerd.io-1.6.21-3.1.el7.x86_64.rpm">containerd.io-1.6.21-3.1.el7.x86_64.rpm</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/docker-ce-20.10.24-3.el7.x86_64.rpm">docker-ce-20.10.24-3.el7.x86_64.rpm</a></p>
<p><a href="https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/stable/Packages/docker-ce-cli-20.10.24-3.el7.x86_64.rpm">docker-ce-cli-20.10.24-3.el7.x86_64.rpm</a></p>
<p><a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/docker-ce-rootless-extras-20.10.24-3.el7.x86_64.rpm">docker-ce-rootless-extras-20.10.24-3.el7.x86_64.rpm</a></p>
<p><a href="https://rpm.pbone.net/info_idpl_70031445_distro_centos_7_com_fuse-overlayfs-0.7.2-6.el7_8.x86_64.rpm.html">fuse-overlayfs-0.7.2-6.el7_8.x86_64.rpm</a></p>
<p><a href="https://rpm.pbone.net/info_idpl_74016102_distro_centos7_com_fuse3-libs-3.6.1-4.el7.x86_64.rpm.html">fuse3-libs-3.6.1-4.el7.x86_64.rpm</a></p>
<p><a href="https://rpm.pbone.net/info_idpl_73980784_distro_centos7_com_libcgroup-0.41-21.el7.x86_64.rpm.html">libcgroup-0.41-19.el8.x86_64.rpm</a></p>
<p><a href="https://rpm.pbone.net/info_idpl_74016281_distro_centos7_com_slirp4netns-0.4.3-4.el7_8.x86_64.rpm.html">slirp4netns-0.4.3-4.el7_8.x86_64.rpm</a></p>
</blockquote>
</li>
<li><p>docker-compose二进制文件：例如 <code>docker-compose-Linux-x86_64</code>（从GitHub Releases下载）。</p>
<blockquote>
<p>针对rhel7.9，离线安装docker-compose需要<a href="https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64">docker-compose-Linux-x86_64</a></p>
<blockquote>
<p><strong>下载后记得赋予执行权限：</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x docker-compose-Linux-x86_64</span><br><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="需要传输的文件"><a href="#需要传输的文件" class="headerlink" title="需要传输的文件"></a>需要传输的文件</h4><p>将以下文件拷贝到U盘，传输到生产环境：</p>
<ul>
<li><p><strong>所有情况</strong>：</p>
<ul>
<li><code>nocobase.tar</code>（NocoBase镜像）</li>
<li><code>mysql.tar</code>（MySQL镜像）</li>
<li><code>flask-service.tar</code>（Flask服务镜像）</li>
<li><code>nocobase_backup.sql</code>（MySQL数据库备份）</li>
<li><code>storage.tar.gz</code>（本地挂载目录压缩包）</li>
<li><code>app.py</code>（Flask服务挂载文件）</li>
<li><code>docker-compose.yml</code>（服务配置文件）</li>
</ul>
</li>
<li><p><strong>仅情况2（服务器未安装Docker）</strong>：</p>
<ul>
<li><code>docker-ce_xxx.deb</code>（Docker安装包）</li>
<li><code>docker-compose</code>（docker-compose二进制文件）</li>
</ul>
</li>
</ul>
<hr>
<h4 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h4><h5 id="情况1：Linux服务器已安装Docker"><a href="#情况1：Linux服务器已安装Docker" class="headerlink" title="情况1：Linux服务器已安装Docker"></a>情况1：Linux服务器已安装Docker</h5><ol>
<li><p><strong>传输文件</strong></p>
<ul>
<li>使用U盘将上述文件拷贝到云服务器，例如放置在 <code>/root/nocobase_deploy</code> 目录下。</li>
</ul>
</li>
<li><p><strong>加载Docker镜像</strong></p>
<ul>
<li><p>将保存的镜像加载到服务器的Docker环境中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i nocobase.tar</span><br><span class="line">docker load -i mysql.tar</span><br><span class="line">docker load -i flask-service.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p>1⃣️因flask-service是</p>
<ul>
<li><p><strong>开发环境</strong>（联网）：通过 build 配置从 flask_service 目录构建 flask-service 镜像，允许开发者修改代码并重新构建。</p>
</li>
<li><p><strong>生产环境</strong>（离线）：使用已导入的 flask-service.tar 镜像（通过 docker load），不依赖联网拉取基础镜像（python:3.11-slim）或重新构建。</p>
</li>
</ul>
</li>
<li><p>2⃣️所以在生产环境中，修改 docker-compose.yml</p>
</li>
<li><pre><code class="yml">build:
  context: ./flask_service
  dockerfile: Dockerfile
  
改为

image: flask-service:latest
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">3.</span> <span class="strong">**解压storage目录**</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">   -</span> 解压挂载目录到指定路径：</span><br><span class="line"></span><br><span class="line"><span class="code">     ```bash</span></span><br><span class="line"><span class="code">     tar -xzvf storage.tar.gz -C /root/nocobase_deploy/</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p><strong>调整docker-compose.yml</strong></p>
<ul>
<li><p>编辑 <code>docker-compose.yml</code>，确保挂载卷路径与云服务器上的实际路径一致（<strong>检查volumes</strong>）。例如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/nocobase_deploy/storage/uploads/python_statistic:/var/lib/mysql-files</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">XXXXXXXXXXXXX</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">nocobase</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/nocobase_deploy/storage:/app/nocobase/storage</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;13000:13000&quot;</span></span><br><span class="line">  <span class="attr">flask:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">flask-service</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/nocobase_deploy/storage/uploads/python_statistic:/app/uploads</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据实际需求调整端口映射和环境变量。</p>
</li>
</ul>
</li>
<li><p><strong>启动服务</strong></p>
<ul>
<li><p>在 <code>docker-compose.yml</code> 所在目录运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>恢复MySQL数据库</strong></p>
<ul>
<li><p>确保MySQL容器已启动，然后将备份数据导入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -i [mysql] mysql -u root -pXXXXXXXXXXXXXXXXXX nocobase &lt; nocobase_backup.sql</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h5 id="情况2：Linux服务器没有安装Docker"><a href="#情况2：Linux服务器没有安装Docker" class="headerlink" title="情况2：Linux服务器没有安装Docker"></a>情况2：Linux服务器没有安装Docker</h5><ol>
<li><p><strong>传输文件</strong></p>
<ul>
<li>使用U盘将情况1的所有文件以及 <code>docker-ce_xxx.rpm</code> 和 <code>docker-compose</code> 拷贝到云服务器，例如放置在 <code>/root/nocobase_deploy</code> 目录下。</li>
</ul>
</li>
<li><p><strong>安装Docker</strong></p>
<ul>
<li><p>安装Docker软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum localinstall -y *.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功后，继续启动 Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>安装docker-compose</strong></p>
<ul>
<li><p>安装docker-compose：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> docker-compose /usr/local/bin/</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose version</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>后续步骤</strong></p>
<ul>
<li>按照<strong>情况1的步骤2-6</strong>执行：<ul>
<li>加载Docker镜像</li>
<li>解压storage目录</li>
<li>调整docker-compose.yml</li>
<li>启动服务</li>
<li>恢复MySQL数据库</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>部署完成后，执行以下操作确认系统正常运行：</p>
<ul>
<li><p>检查容器状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问NocoBase服务（默认端口13000）和Flask服务（默认端口5000），确保功能正常。</p>
</li>
</ul>
<hr>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><strong>路径一致性</strong>：云服务器上的挂载路径必须与 <code>docker-compose.yml</code> 中的配置一致。</li>
<li><strong>数据库密码</strong>：备份和恢复数据库时使用的密码需与 <code>docker-compose.yml</code> 中的 <code>MYSQL_ROOT_PASSWORD</code> 保持一致。</li>
<li><strong>架构兼容性</strong>：确保本地和云服务器的CPU架构一致（如均为x86_64），否则需在对应架构下重新构建镜像。</li>
<li><strong>端口冲突</strong>：检查云服务器上的端口（13000、5000等）是否被占用，必要时修改端口映射。</li>
</ul>
<hr>
<h2 id="📦-推荐打包备份命令（可选）"><a href="#📦-推荐打包备份命令（可选）" class="headerlink" title="📦 推荐打包备份命令（可选）"></a>📦 推荐打包备份命令（可选）</h2><p>你也可以打一个压缩包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar czvf nocobase_full_backup_$(<span class="built_in">date</span> +%Y%m%d).tar.gz nocobase_backup.sql storage/</span><br></pre></td></tr></table></figure>

<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，您可以将修改后的NocoBase系统（包括NocoBase、MySQL和Flask服务）成功部署到不联网的生产环境。关键在于提前打包镜像、备份数据和挂载目录，并在目标服务器上正确恢复和配置。</p>
<h2 id="✅-总结部署流程图（简略版）"><a href="#✅-总结部署流程图（简略版）" class="headerlink" title="✅ 总结部署流程图（简略版）"></a>✅ 总结部署流程图（简略版）</h2><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">联网电脑 ——&gt; 打包镜像 + 数据 + 配置</span><br><span class="line">             <span class="string">|</span></span><br><span class="line">             ↓</span><br><span class="line">          拷贝到U盘</span><br><span class="line">             ↓</span><br><span class="line">        插入目标服务器</span><br><span class="line">     ┌──────────────────────┐</span><br><span class="line">     │ 情况一：已安装Docker │ → load镜像 → 启动compose → 导入DB</span><br><span class="line">     └──────────────────────┘</span><br><span class="line">     ┌──────────────────────┐</span><br><span class="line">     │ 情况二：无Docker环境 │ → 离线安装 → 同上</span><br><span class="line">     └──────────────────────┘</span><br></pre></td></tr></table></figure>



<h3 id="不重新打包镜像，直接修改-Docker-容器中的-app-py-代码"><a href="#不重新打包镜像，直接修改-Docker-容器中的-app-py-代码" class="headerlink" title="不重新打包镜像，直接修改 Docker 容器中的 app.py 代码"></a>不重新打包镜像，直接修改 Docker 容器中的 app.py 代码</h3><p>通过以下方式将本地修改后的 app.py 复制到容器，但不推荐直接修改容器文件：直接编辑容器内的 app.py 是临时的，容器重启后修改会丢失，因为容器是基于镜像的快照运行的。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">docker cp <span class="regexp">/path/</span>to<span class="regexp">/local/</span>app.py my_container:<span class="regexp">/path/</span>to<span class="regexp">/container/</span>app.py</span><br></pre></td></tr></table></figure>


<h3 id="附件一：docker-compose-yml文件"><a href="#附件一：docker-compose-yml文件" class="headerlink" title="附件一：docker-compose.yml文件"></a>附件一：docker-compose.yml文件</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nocobase:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/lee/nocobase/storage/uploads/python_statistic:/var/lib/mysql-files</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--secure-file-priv=/var/lib/mysql-files</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DIALECT=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DATABASE=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASSWORD=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_UNDERSCORED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NOCOBASE_PKG_USERNAME=</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">NOCOBASE_PKG_PASSWORD=</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./storage:/app/nocobase/storage</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;13000:80&quot;</span></span><br><span class="line">  <span class="attr">flask:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./flask_service</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">excel-importer</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=nocobase</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/lee/nocobase/storage/uploads/python_statistic:/app/uploads</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>

<h3 id="附件二：flask服务的Dockerfile"><a href="#附件二：flask服务的Dockerfile" class="headerlink" title="附件二：flask服务的Dockerfile"></a>附件二：flask服务的Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>-bullseye</span><br><span class="line"><span class="comment"># 使用清华源，加速 apt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s|http://deb.debian.org|https://mirrors.tuna.tsinghua.edu.cn|g&#x27;</span> /etc/apt/sources.list &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    gcc \</span></span><br><span class="line"><span class="language-bash">    libpq-dev \</span></span><br><span class="line"><span class="language-bash">    python3-dev \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --no-cache-dir -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>



<p>相关问答</p>
<ol>
<li><p>我使用root用户安装docker成功了，切换成普通用户执行 docker load -i时报错权限不足</p>
<blockquote>
<p>这是因为默认情况下，<strong>普通用户不能访问 Docker 守护进程（dockerd）</strong></p>
<p>方法：将普通用户加入 <code>docker</code> 用户组</p>
<ol>
<li><strong>创建 <code>docker</code> 组（如果不存在）</strong>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>将当前用户添加到 <code>docker</code> 组</strong>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>

<p>  请将 <code>your_username</code> 替换成你的普通用户名。</p>
<ol start="3">
<li><strong>重新登录当前用户</strong>（重要！必须重新登录或重启 shell 才能生效）：</li>
</ol>
<ul>
<li>可以使用 <code>su - your_username</code> 重新登录，或直接重新 SSH 登录。</li>
</ul>
<ol start="4">
<li><strong>测试是否能成功运行 docker 命令</strong>：</li>
</ol>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i your_image.tar</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>没有 <code>/usr/local/bin/</code> 的写权限，怎么安装docker-compose</p>
<blockquote>
<p>解决方法：安装到本地用户目录（无需 root 权限）<br>你可以将文件放在自己的用户目录下的 <code>bin/</code> 文件夹，并将其加入 PATH：</p>
   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/bin</span><br><span class="line"><span class="built_in">mv</span> docker-compose-Linux-x86_64 ~/bin/docker-compose</span><br><span class="line"><span class="built_in">chmod</span> +x ~/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>   然后在 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 中添加如下行（如果尚未添加）：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><br>   执行以下命令使其立即生效：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><br>   然后你就可以通过 <code>docker-compose</code> 命令使用它了（注意路径）：<br>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure></p>
</blockquote>
</li>
<li><p>root用户能否将某路径的文件权限向普通用户开放</p>
<blockquote>
<p>把某个路径（例如 <code>/opt/docker_images</code>）及其 <strong>所有子文件和子文件夹</strong> 的所有权转交给用户 <code>user1</code>，可以使用下面这个命令：一次性更改整个路径及其所有子项的所有者：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;<span class="built_in">chown</span> -R user1:user1 /opt/docker_images</span><br></pre></td></tr></table></figure>

</blockquote>
</li>
</ol>
<h6 id="-1"><a href="#-1" class="headerlink" title></a></h6>]]></content>
      <categories>
        <category>nocobase</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>将 NocoBase 从运行在 CentOS 8迁移到 RHEL 7.9 上的兼容性测试</title>
    <url>/2025/04/24/%E5%B0%86-NocoBase-%E4%BB%8E%E8%BF%90%E8%A1%8C%E5%9C%A8-CentOS-8%E8%BF%81%E7%A7%BB%E5%88%B0-RHEL-7-9-%E4%B8%8A%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>前情提要：</p>
<p><a href="https://likehui.fun/2025/04/17/nocobase%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/">nocobase部署笔记</a></p>
<p><a href="https://likehui.fun/2025/04/22/%E5%9C%A8%E6%97%A0%E6%B3%95%E8%81%94%E7%BD%91%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2nocobase/">在无法联网的生产环境部署nocobase</a></p>
<p>现在遇到一个问题，开发环境的操作系统&#x2F;Docker都用最新版本，但是生产环境的基础软件版本太低，你要怎么办？</p>
<span id="more"></span>

<blockquote>
<p>将 NocoBase 从运行在 CentOS 8（内核 4.18）迁移到 RHEL 7.9 上（默认内核通常是 3.10.x）<strong>理论上可行，但你需要注意几个兼容性问题</strong>，尤其是内核和系统库的版本差异对 Docker 和某些依赖的影响。</p>
</blockquote>
<p>最优解：直接上生产上部署试一试，如果没办法上生产，那么可以使用模拟环境做一下测试</p>
<h1 id="拉取-RHEL-7-9-容器模拟测试兼容性"><a href="#拉取-RHEL-7-9-容器模拟测试兼容性" class="headerlink" title="拉取 RHEL 7.9 容器模拟测试兼容性"></a>拉取 RHEL 7.9 容器模拟测试兼容性</h1><p>用 ubi7 镜像测试 NocoBase 镜像兼容性的 Dockerfile 和启动脚本，用以模拟目标环境里的构建行为</p>
<hr>
<h3 id="✅-功能列表"><a href="#✅-功能列表" class="headerlink" title="✅ 功能列表"></a>✅ 功能列表</h3><ol>
<li><strong>构建 UBI7 容器基础镜像</strong>；</li>
<li><strong>启动 NocoBase + MySQL + Flask 服务</strong>；</li>
<li><strong>输出容器状态与运行日志</strong>；</li>
<li><strong>验证端口监听情况（13000, 3306, 5000）</strong>；</li>
<li>**添加容器级别的 <code>healthcheck</code>**；</li>
<li><strong>检查 Flask 接口是否可用（curl 检测）</strong>；</li>
<li><strong>最终输出整体运行状态报告</strong>。</li>
</ol>
<hr>
<h3 id="📁-目录结构建议"><a href="#📁-目录结构建议" class="headerlink" title="📁 目录结构建议"></a>📁 目录结构建议</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">ubi_test/</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── <span class="keyword">run</span>.<span class="keyword">sh</span></span><br><span class="line">├── flask_service/</span><br><span class="line">│   ├── Dockerfile</span><br><span class="line">│   ├── <span class="keyword">app</span>.py</span><br><span class="line">│   └── requirements.txt</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-ubi-test-docker-compose-yml（增强版，含-Flask-healthcheck）"><a href="#✅-ubi-test-docker-compose-yml（增强版，含-Flask-healthcheck）" class="headerlink" title="✅ ubi_test/docker-compose.yml（增强版，含 Flask + healthcheck）"></a>✅ <code>ubi_test/docker-compose.yml</code>（增强版，含 Flask + healthcheck）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">nocobase:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">XXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">nocobase</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./uploads:/var/lib/mysql-files</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">--secure-file-priv=/var/lib/mysql-files</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;mysqladmin&quot;</span>, <span class="string">&quot;ping&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="string">&quot;localhost&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry.cn-shanghai.aliyuncs.com/nocobase/nocobase:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">APP_KEY=XXXXXXXXXXXXXXXXXXXXXXXXXX</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DIALECT=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_DATABASE=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASSWORD=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_UNDERSCORED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./storage:/app/nocobase/storage</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;13000:80&quot;</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">15s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">flask:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./flask_service</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">excel-importer</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nocobase</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_HOST=mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PORT=3306</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_USER=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_PASSWORD=nocobase</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=nocobase</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./uploads:/app/uploads</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5000:5000&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">mysql:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:5000/health&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-Flask-示例（路径：flask-service-app-py）"><a href="#✅-Flask-示例（路径：flask-service-app-py）" class="headerlink" title="✅ Flask 示例（路径：flask_service/app.py）"></a>✅ Flask 示例（路径：<code>flask_service/app.py</code>）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/health&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">health</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>, <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Flask is running.&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-Flask-requirements-txt"><a href="#✅-Flask-requirements-txt" class="headerlink" title="✅ Flask requirements.txt"></a>✅ Flask <code>requirements.txt</code></h2><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flask</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-Flask-Dockerfile（flask-service-Dockerfile）"><a href="#✅-Flask-Dockerfile（flask-service-Dockerfile）" class="headerlink" title="✅ Flask Dockerfile（flask_service/Dockerfile）"></a>✅ Flask <code>Dockerfile</code>（<code>flask_service/Dockerfile</code>）</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>-slim</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;--host=0.0.0.0&quot;</span>, <span class="string">&quot;--port=5000&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-run-sh-脚本增强版"><a href="#✅-run-sh-脚本增强版" class="headerlink" title="✅ run.sh 脚本增强版"></a>✅ <code>run.sh</code> 脚本增强版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[1] 构建基础 ubi7 环境镜像（可选）&quot;</span></span><br><span class="line">docker build -t ubi7-env ./ubi_test</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[2] 启动 docker-compose 环境...&quot;</span></span><br><span class="line"><span class="built_in">cd</span> ubi_test</span><br><span class="line">docker compose up -d --build</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[3] 等待服务启动中（最长等待 60 秒）...&quot;</span></span><br><span class="line"><span class="built_in">timeout</span>=60</span><br><span class="line">interval=5</span><br><span class="line">elapsed=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$elapsed</span> -lt <span class="variable">$timeout</span> ]; <span class="keyword">do</span></span><br><span class="line">  status=$(docker compose ps --services --filter <span class="string">&quot;status=running&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$status</span>&quot;</span> -ge 3 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;[✓] 所有服务已启动&quot;</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">sleep</span> <span class="variable">$interval</span></span><br><span class="line">  elapsed=$((elapsed + interval))</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[…] 正在等待服务启动（已等待 <span class="variable">$&#123;elapsed&#125;</span>s）&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$elapsed</span> -ge <span class="variable">$timeout</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;[✗] 启动超时，服务未全部运行&quot;</span></span><br><span class="line">  docker compose ps</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[4] 服务健康检查：&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> mysql app flask; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">&quot;  - <span class="variable">$service</span>: &quot;</span></span><br><span class="line">  health=$(docker inspect --format=<span class="string">&#x27;&#123;&#123;json .State.Health.Status&#125;&#125;&#x27;</span> <span class="string">&quot;ubi_test_<span class="variable">$service_1</span>&quot;</span>)</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$health</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[5] 检查端口监听：&quot;</span></span><br><span class="line"><span class="keyword">for</span> port <span class="keyword">in</span> 13000 3306 5000; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> lsof -i :<span class="string">&quot;<span class="variable">$port</span>&quot;</span> &gt; /dev/null 2&gt;&amp;1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - Port <span class="variable">$port</span> is listening ✅&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;  - Port <span class="variable">$port</span> is NOT listening ❌&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[6] 检查 Flask 服务接口响应：&quot;</span></span><br><span class="line"><span class="keyword">if</span> curl -fs http://localhost:5000/health &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;  - Flask /health OK ✅&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;  - Flask /health FAILED ❌&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[7] 输出 NocoBase 初始日志（前 30 行）：&quot;</span></span><br><span class="line">docker logs --<span class="built_in">tail</span>=30 ubi_test_app_1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[✓] 测试完毕，你可以访问：http://localhost:13000&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-使用方式："><a href="#✅-使用方式：" class="headerlink" title="✅ 使用方式："></a>✅ 使用方式：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 ubi_test 目录</span></span><br><span class="line"><span class="built_in">chmod</span> +x ubi_test/run.sh</span><br><span class="line">./ubi_test/run.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>nocobase</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>快速熟悉一个系统</title>
    <url>/2025/05/16/%E5%BF%AB%E9%80%9F%E7%86%9F%E6%82%89%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="监管报送系统"><a href="#监管报送系统" class="headerlink" title="监管报送系统"></a>监管报送系统</h1><p><strong>监管报送系统</strong>的特点：如流程规范性强、数据结构复杂、合规要求高、依赖跨系统数据、频繁对接监管机构等。</p>
<hr>
<h2 id="🧠-监管报送系统调研与熟悉模板"><a href="#🧠-监管报送系统调研与熟悉模板" class="headerlink" title="🧠 监管报送系统调研与熟悉模板"></a>🧠 <strong>监管报送系统调研与熟悉模板</strong></h2><h3 id="一、业务熟悉（目标清晰-上下游理解）"><a href="#一、业务熟悉（目标清晰-上下游理解）" class="headerlink" title="一、业务熟悉（目标清晰 + 上下游理解）"></a>一、业务熟悉（目标清晰 + 上下游理解）</h3><h4 id="1-监管背景与要求"><a href="#1-监管背景与要求" class="headerlink" title="1. 监管背景与要求"></a>1. 监管背景与要求</h4><ul>
<li>监管机构有哪些？银保监&#x2F;央行&#x2F;外管局等</li>
<li>报送制度依据？涉及哪些报文或制度文件？</li>
<li>报送频率（日报&#x2F;周报&#x2F;月报&#x2F;季报&#x2F;年报&#x2F;临时报）？</li>
<li>报送不合规后果？罚款？黑名单？限期整改？</li>
</ul>
<h4 id="2-报送内容梳理"><a href="#2-报送内容梳理" class="headerlink" title="2. 报送内容梳理"></a>2. 报送内容梳理</h4><ul>
<li>有哪些主要报送主题？如信贷类、支付类、跨境类、反洗钱类</li>
<li>每个主题下具体有哪些子项目&#x2F;报文？</li>
<li>报文字段来源？字段含义？</li>
</ul>
<h4 id="3-报送流程"><a href="#3-报送流程" class="headerlink" title="3. 报送流程"></a>3. 报送流程</h4><ul>
<li>报送流程如何？是否分为数据采集、清洗、审核、生成、上传、反馈？</li>
<li>是否涉及人行“金融数据采集平台”、外管局EDI系统、银保监会EAST平台等？</li>
</ul>
<h4 id="4-业务角色与职责"><a href="#4-业务角色与职责" class="headerlink" title="4. 业务角色与职责"></a>4. 业务角色与职责</h4><ul>
<li>报送部门角色（如合规部、财务部、IT部）？</li>
<li>系统使用者是业务人员还是IT人员？</li>
<li>哪些环节人工参与？哪些可自动化？</li>
</ul>
<h4 id="5-成功关键指标"><a href="#5-成功关键指标" class="headerlink" title="5. 成功关键指标"></a>5. 成功关键指标</h4><ul>
<li>报送成功率？失败率？</li>
<li>报送合规性？字段&#x2F;结构完整率？</li>
<li>是否有罚单或预警历史？</li>
</ul>
<hr>
<h3 id="二、数据熟悉（字段来源-血缘清晰）"><a href="#二、数据熟悉（字段来源-血缘清晰）" class="headerlink" title="二、数据熟悉（字段来源 + 血缘清晰）"></a>二、数据熟悉（字段来源 + 血缘清晰）</h3><h4 id="1-数据源梳理"><a href="#1-数据源梳理" class="headerlink" title="1. 数据源梳理"></a>1. 数据源梳理</h4><ul>
<li>报送所依赖的核心数据来源系统有哪些？<ul>
<li>如：核心系统、信贷系统、支付系统、反洗钱系统、CRM、会计系统</li>
</ul>
</li>
<li>各系统字段到报送字段的映射关系？</li>
</ul>
<h4 id="2-数据加工逻辑"><a href="#2-数据加工逻辑" class="headerlink" title="2. 数据加工逻辑"></a>2. 数据加工逻辑</h4><ul>
<li>有哪些清洗、加工规则？如金额转换、币种换算、日期标准化</li>
<li>哪些规则是硬性监管要求，哪些是自定义填补逻辑？</li>
</ul>
<h4 id="3-数据血缘图-x2F-字段流向"><a href="#3-数据血缘图-x2F-字段流向" class="headerlink" title="3. 数据血缘图&#x2F;字段流向"></a>3. 数据血缘图&#x2F;字段流向</h4><ul>
<li>字段从源头到报文生成的流向是？</li>
<li>字段是否在多个系统&#x2F;多个表中流转？</li>
<li>如何做字段级追溯？</li>
</ul>
<h4 id="4-数据质量管理"><a href="#4-数据质量管理" class="headerlink" title="4. 数据质量管理"></a>4. 数据质量管理</h4><ul>
<li>是否有数据校验机制？格式校验、逻辑校验、交叉校验？</li>
<li>数据稽核流程？是否有报送前人工或自动核查？</li>
<li>是否有质量评分或预警机制？</li>
</ul>
<hr>
<h3 id="三、技术熟悉（系统结构-开发模式）"><a href="#三、技术熟悉（系统结构-开发模式）" class="headerlink" title="三、技术熟悉（系统结构 + 开发模式）"></a>三、技术熟悉（系统结构 + 开发模式）</h3><h4 id="1-系统架构"><a href="#1-系统架构" class="headerlink" title="1. 系统架构"></a>1. 系统架构</h4><ul>
<li>报送系统是单体&#x2F;微服务&#x2F;ETL工具&#x2F;调度平台？</li>
<li>报文生成模块、审核模块、上传模块分别在哪？</li>
<li>是否接入报送平台API？文件通道？FTP？</li>
</ul>
<h4 id="2-开发与运维"><a href="#2-开发与运维" class="headerlink" title="2. 开发与运维"></a>2. 开发与运维</h4><ul>
<li>用的是什么语言&#x2F;框架？Java&#x2F;Spring Boot&#x2F;Python&#x2F;ETL工具？</li>
<li>报文模板怎么维护？是否可配置？</li>
<li>系统是否支持多租户&#x2F;多机构？</li>
</ul>
<h4 id="3-报送调度与自动化"><a href="#3-报送调度与自动化" class="headerlink" title="3. 报送调度与自动化"></a>3. 报送调度与自动化</h4><ul>
<li>是人工点击还是定时调度？调度用什么工具（如xxl-job&#x2F;Azkaban&#x2F;SchedulerX）？</li>
<li>是否支持失败重传？</li>
<li>是否支持补报、撤报？</li>
</ul>
<h4 id="4-日志与审计机制"><a href="#4-日志与审计机制" class="headerlink" title="4. 日志与审计机制"></a>4. 日志与审计机制</h4><ul>
<li>是否有详细的日志记录？哪些操作被记录？</li>
<li>报文生成、上传、反馈结果是否有链路可追溯？</li>
<li>是否有审计日志&#x2F;系统安全加固措施？</li>
</ul>
<hr>
<h3 id="四、合规性与安全性"><a href="#四、合规性与安全性" class="headerlink" title="四、合规性与安全性"></a>四、合规性与安全性</h3><h4 id="1-合规规则映射"><a href="#1-合规规则映射" class="headerlink" title="1. 合规规则映射"></a>1. 合规规则映射</h4><ul>
<li>系统逻辑是否完全匹配监管规则？</li>
<li>报送字段是否有最新监管要求变更？</li>
<li>报文格式&#x2F;校验规则是否定期更新？</li>
</ul>
<h4 id="2-权限与操作审计"><a href="#2-权限与操作审计" class="headerlink" title="2. 权限与操作审计"></a>2. 权限与操作审计</h4><ul>
<li>是否有角色权限控制？</li>
<li>哪些用户可以报送&#x2F;审核&#x2F;生成报文？</li>
<li>是否有操作审计功能？</li>
</ul>
<h4 id="3-报送安全机制"><a href="#3-报送安全机制" class="headerlink" title="3. 报送安全机制"></a>3. 报送安全机制</h4><ul>
<li>报送是否加密？使用何种证书？</li>
<li>是否需要上传签名？文件加签？</li>
<li>上传是否走公网？是否备案？</li>
</ul>
<hr>
<h3 id="五、部署与环境"><a href="#五、部署与环境" class="headerlink" title="五、部署与环境"></a>五、部署与环境</h3><h4 id="1-环境划分"><a href="#1-环境划分" class="headerlink" title="1. 环境划分"></a>1. 环境划分</h4><ul>
<li>系统分为哪些环境？开发&#x2F;测试&#x2F;UAT&#x2F;生产？</li>
<li>各环境是否连通监管测试系统？</li>
</ul>
<h4 id="2-部署方式"><a href="#2-部署方式" class="headerlink" title="2. 部署方式"></a>2. 部署方式</h4><ul>
<li>是容器化部署？还是传统服务器部署？</li>
<li>是否支持灾备切换？有无部署架构图？</li>
</ul>
<h4 id="3-系统稳定性"><a href="#3-系统稳定性" class="headerlink" title="3. 系统稳定性"></a>3. 系统稳定性</h4><ul>
<li>是否有服务可用性监控？</li>
<li>系统最大报文处理量是多少？</li>
<li>曾出现哪些严重故障？</li>
</ul>
<hr>
<h3 id="六、演练与应急预案"><a href="#六、演练与应急预案" class="headerlink" title="六、演练与应急预案"></a>六、演练与应急预案</h3><h4 id="1-灾难恢复演练"><a href="#1-灾难恢复演练" class="headerlink" title="1. 灾难恢复演练"></a>1. 灾难恢复演练</h4><ul>
<li>是否做过断网、失败重传等演练？</li>
<li>故障恢复流程规范化了吗？</li>
</ul>
<h4 id="2-应急联系人"><a href="#2-应急联系人" class="headerlink" title="2. 应急联系人"></a>2. 应急联系人</h4><ul>
<li>业务应急负责人是谁？技术应急负责人？</li>
<li>报送失败时响应时间多久？流程是怎样的？</li>
</ul>
<hr>
<h3 id="七、测试与上线控制"><a href="#七、测试与上线控制" class="headerlink" title="七、测试与上线控制"></a>七、测试与上线控制</h3><h4 id="1-报文测试用例"><a href="#1-报文测试用例" class="headerlink" title="1. 报文测试用例"></a>1. 报文测试用例</h4><ul>
<li>是否有覆盖主要报文的测试用例？</li>
<li>用例是否覆盖极端值、空值、边界情况？</li>
</ul>
<h4 id="2-上线流程"><a href="#2-上线流程" class="headerlink" title="2. 上线流程"></a>2. 上线流程</h4><ul>
<li>是否有上线审批？报送系统变更是否走变更管理？</li>
</ul>
<hr>
<h2 id="📌-用法建议："><a href="#📌-用法建议：" class="headerlink" title="📌 用法建议："></a>📌 用法建议：</h2><ul>
<li>初期熟悉时优先聚焦「业务熟悉」+「数据熟悉」</li>
<li>技术开发或系统维护人员建议重点看「技术熟悉」+「数据质量管理」</li>
<li>做报告&#x2F;汇报建议关注「合规性」+「成功率与问题演练」</li>
<li>可导入思维导图工具如 XMind、ProcessOn</li>
</ul>
<hr>
<h1 id="常规系统"><a href="#常规系统" class="headerlink" title="常规系统"></a>常规系统</h1><h2 id="业务熟悉"><a href="#业务熟悉" class="headerlink" title="业务熟悉"></a>业务熟悉</h2><ul>
<li>行业情况：系统所在的行业的情况是怎么样的</li>
<li>目标用户：系统的目标用户是谁？比如做给公司高管做决策用？给运营查数据用？互联网用户用？用户画像？</li>
<li>使用情况：平均有多少人在使用？高峰期有多少人在用？各端的活跃分布人群？</li>
<li>业务价值：系统有什么业务价值？有哪些指标可以衡量系统的价值？</li>
<li>功能模块：系统有哪些功能模块？关键业务流程有哪些？</li>
<li>系统指标：系统的非功能性能需求有哪些？如功能性、质量、扩展性、安全性？</li>
<li>未来规划：系统未来的发展规划是怎样？</li>
</ul>
<h3 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h3><ul>
<li>有哪些子系统或模块？系统之间是什么样的关系？</li>
<li>对外上下游接口有哪些？干系人是谁？</li>
<li>关键业务流程怎么实现的？用类图，时序图的方式表达出来</li>
</ul>
<h2 id="技术熟悉"><a href="#技术熟悉" class="headerlink" title="技术熟悉"></a>技术熟悉</h2><h3 id="开发架构"><a href="#开发架构" class="headerlink" title="开发架构"></a>开发架构</h3><ul>
<li>代码在哪里？怎么批量搞下来，后续方便搜代码</li>
<li>包怎么划分的？怎么分层？如项目目录结构</li>
<li>用了什么框架？如rpc、springcloud？</li>
<li>用了哪些工具包？如context</li>
<li>用了哪些中间件？如redis、kafka、mysql</li>
<li>依赖了哪些平台？如k8s、coding、蓝盾</li>
</ul>
<h3 id="运行架构"><a href="#运行架构" class="headerlink" title="运行架构"></a>运行架构</h3><ul>
<li>系统能支撑多少qps？峰值qps多少？</li>
<li>与上下游系统怎么交互的？rpc？http？异步同步？</li>
</ul>
<h3 id="物理架构"><a href="#物理架构" class="headerlink" title="物理架构"></a>物理架构</h3><ul>
<li>系统都有什么环境，如果发布部署，发布时间窗口？</li>
<li>系统有多少服务？</li>
<li>多少机房部署？</li>
<li>网站的cicd流程？</li>
</ul>
<h3 id="数据架构"><a href="#数据架构" class="headerlink" title="数据架构"></a>数据架构</h3><ul>
<li><p>数据用什么数据库存储？</p>
</li>
<li><p>关系型：梳理完整ER图？数据量有多少？归档逻辑怎么样？</p>
</li>
<li><p>非关系型：梳理表设计，数据量有多少？归档逻辑怎么样？</p>
</li>
<li><p>数据同步任务有啥量？具体怎么执行传的？</p>
</li>
<li><p>大数据框架如何使用的？数据流架构梳理？</p>
</li>
</ul>
<h3 id="系统运维"><a href="#系统运维" class="headerlink" title="系统运维"></a>系统运维</h3><ul>
<li><p>关键功能是否有监控？系统配置了哪些告警项？监控了哪些方面？</p>
</li>
<li><p>出了问题怎么解决？日志在哪里？是否有全链路追踪？是否有紧急操作，比如开关配置、降级、限流配置等</p>
</li>
<li><p>系统都有哪些坑？找开发人员回顾历史问题，以免踩坑</p>
</li>
<li><p>运维、客服反馈常见问题有哪些？</p>
</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li>需求开发</li>
<li>bugfix</li>
<li>系统重构</li>
</ul>
<h2 id="成熟度评估"><a href="#成熟度评估" class="headerlink" title="成熟度评估"></a>成熟度评估</h2><h3 id="研发流程"><a href="#研发流程" class="headerlink" title="研发流程"></a>研发流程</h3><ul>
<li>CI</li>
<li>CD</li>
<li>CO</li>
</ul>
<h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul>
<li>技术架构</li>
<li>数据架构</li>
</ul>
<h3 id="现网运维"><a href="#现网运维" class="headerlink" title="现网运维"></a>现网运维</h3><ul>
<li>日志标准化</li>
<li>监控告警</li>
<li>容量评估</li>
<li>应急预案</li>
<li>故障演练</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>API文档</li>
<li>性能指标</li>
<li>波测</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>python 在venv 环境下运行简单的jupyter notebook</title>
    <url>/2025/06/05/python-%E5%9C%A8venv-%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BF%90%E8%A1%8C%E7%AE%80%E5%8D%95%E7%9A%84jupyter-notebook/</url>
    <content><![CDATA[<p>在 Python 的 <code>venv</code> 虚拟环境中运行一个简单的 Jupyter Notebook，你可以按照以下步骤操作：</p>
<hr>
<h2 id="✅-一、创建并激活-venv-环境"><a href="#✅-一、创建并激活-venv-环境" class="headerlink" title="✅ 一、创建并激活 venv 环境"></a>✅ 一、创建并激活 venv 环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建虚拟环境（如：venv）</span></span><br><span class="line">python -m venv venv</span><br><span class="line"></span><br><span class="line"><span class="comment"># Windows 激活方式</span></span><br><span class="line">venv\Scripts\activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS/Linux 激活方式</span></span><br><span class="line"><span class="built_in">source</span> venv/bin/activate</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-二、安装-Jupyter-Notebook（或-JupyterLab）"><a href="#✅-二、安装-Jupyter-Notebook（或-JupyterLab）" class="headerlink" title="✅ 二、安装 Jupyter Notebook（或 JupyterLab）"></a>✅ 二、安装 Jupyter Notebook（或 JupyterLab）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install notebook  <span class="comment"># 经典 Notebook</span></span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">pip install jupyterlab  <span class="comment"># 更现代的界面</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✅-三、安装内核（可选，但推荐）"><a href="#✅-三、安装内核（可选，但推荐）" class="headerlink" title="✅ 三、安装内核（可选，但推荐）"></a>✅ 三、安装内核（可选，但推荐）</h2><p>安装 <code>ipykernel</code>，并将当前 venv 注册为一个内核：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ipykernel</span><br><span class="line">python -m ipykernel install --user --name=venv --display-name <span class="string">&quot;Python (venv)&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样你在 Jupyter 中就能看到 <code>Python (venv)</code> 内核选项。</p>
<hr>
<h2 id="✅-四、启动-Notebook-服务"><a href="#✅-四、启动-Notebook-服务" class="headerlink" title="✅ 四、启动 Notebook 服务"></a>✅ 四、启动 Notebook 服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>

<p>启动后会自动打开浏览器页面，你就可以新建 notebook 并运行 Python 代码了。</p>
<hr>
<h2 id="✅-五、验证环境是否正确"><a href="#✅-五、验证环境是否正确" class="headerlink" title="✅ 五、验证环境是否正确"></a>✅ 五、验证环境是否正确</h2><p>在 Notebook 新建一个 Cell，输入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">!which python  <span class="comment"># macOS/Linux</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">!where python  <span class="comment"># Windows</span></span><br></pre></td></tr></table></figure>

<p>输出路径应指向你的虚拟环境中的 Python，例如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/path/</span>to<span class="regexp">/venv/</span>bin/python</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安装-ipykernel-并注册当前虚拟环境为-Jupyter-内核的意义"><a href="#安装-ipykernel-并注册当前虚拟环境为-Jupyter-内核的意义" class="headerlink" title="安装 ipykernel 并注册当前虚拟环境为 Jupyter 内核的意义"></a>安装 ipykernel 并注册当前虚拟环境为 Jupyter 内核的意义</h2><blockquote>
<p>Jupyter 是独立于虚拟环境运行的；<br>虽然你在命令行激活了 venv，但 Jupyter 不知道你用了哪个环境；<br>安装 ipykernel 并注册后，Jupyter 就能识别你这个虚拟环境，才能在 notebook 里正确地运行、加载库，否则 notebook 会“用错解释器”。</p>
</blockquote>
<p>用<strong>更通俗直白</strong>的方式解释一下：</p>
<hr>
<h2 id="🌰-场景比喻：Jupyter-是饭店，venv-是你的家"><a href="#🌰-场景比喻：Jupyter-是饭店，venv-是你的家" class="headerlink" title="🌰 场景比喻：Jupyter 是饭店，venv 是你的家"></a>🌰 场景比喻：Jupyter 是饭店，venv 是你的家</h2><ul>
<li><strong>Jupyter Notebook</strong> 就像一个饭店，你进去可以点菜（写代码）。</li>
<li>但这个饭店默认只认识“官方菜单”（系统 Python 环境）。</li>
<li>你有一个特别定制的菜单（比如你家厨房安装了特殊库：<code>pandas==1.5.3</code>、<code>numpy==1.19</code>），这个菜单在 <strong>虚拟环境 venv 里</strong>。</li>
<li>如果你不告诉饭店你有这个菜单，Jupyter 是<strong>看不到你 venv 里的东西的</strong>，也就没法给你做这顿饭。</li>
</ul>
<hr>
<h2 id="💡-为什么要安装-ipykernel-并注册？"><a href="#💡-为什么要安装-ipykernel-并注册？" class="headerlink" title="💡 为什么要安装 ipykernel 并注册？"></a>💡 为什么要安装 <code>ipykernel</code> 并注册？</h2><blockquote>
<p>安装 <code>ipykernel</code> 就是 <strong>让你的厨房能与饭店通讯</strong>；</p>
<p>注册内核就是 <strong>告诉饭店“这是我家的菜单”，你以后可以选用它来做菜。</strong></p>
</blockquote>
<p>换句话说：</p>
<ul>
<li><strong>Jupyter 是独立于虚拟环境运行的</strong>；</li>
<li>虽然你在命令行激活了 venv，但 Jupyter 不知道你用了哪个环境；</li>
<li>安装 <code>ipykernel</code> 并注册后，Jupyter 就能识别你这个环境，才能在 notebook 里正确地运行、加载库。</li>
</ul>
<hr>
<h2 id="🎯-举个真实用例（最常见的情况）："><a href="#🎯-举个真实用例（最常见的情况）：" class="headerlink" title="🎯 举个真实用例（最常见的情况）："></a>🎯 举个真实用例（最常见的情况）：</h2><p>你有两个项目：</p>
<table>
<thead>
<tr>
<th>项目名</th>
<th>虚拟环境</th>
<th>依赖库</th>
</tr>
</thead>
<tbody><tr>
<td>项目 A</td>
<td><code>venv_a</code></td>
<td><code>pandas==1.5</code></td>
</tr>
<tr>
<td>项目 B</td>
<td><code>venv_b</code></td>
<td><code>pandas==2.2</code></td>
</tr>
</tbody></table>
<p>如果你不给这两个环境注册内核，打开 Jupyter 后，它只认识一个系统环境，运行 notebook 时：</p>
<ul>
<li>项目 A 的代码报错（因为系统里是 2.2，不兼容）</li>
<li>项目 B 的 notebook 运行错地方（因为 Jupyter 根本没用你的 venv）</li>
</ul>
<p>你就会很抓狂。</p>
<hr>
<h2 id="✅-安装并注册后："><a href="#✅-安装并注册后：" class="headerlink" title="✅ 安装并注册后："></a>✅ 安装并注册后：</h2><p>你打开 Jupyter，左上角就能选择内核，能看到这些选项：</p>
<ul>
<li>Python 3 (系统默认)</li>
<li>Python (venv_a)</li>
<li>Python (venv_b)</li>
</ul>
<p>这时你就能根据项目自由选择对应的环境，确保运行正确的依赖。</p>
<hr>
<h2 id="🔚-总结一句话："><a href="#🔚-总结一句话：" class="headerlink" title="🔚 总结一句话："></a>🔚 总结一句话：</h2><blockquote>
<p>安装 <code>ipykernel</code> 并注册内核，就是 <strong>让你的虚拟环境能被 Jupyter Notebook 正确识别和使用</strong>，否则 notebook 会“用错解释器”。</p>
</blockquote>
]]></content>
      <categories>
        <category>ML</category>
      </categories>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
</search>
